const __vite__fileDeps=["./Specs-CQNWz6Iy.js","./route-block-mFfs_uHM.js","./Runner-B9rX-Bu-.js","./Tooltip.vue_vue_type_style_index_0_lang-DT3RPtZJ.js","./Tooltip-CBLynKSI.css","./InlineCodeFragment.vue_vue_type_script_setup_true_lang-CkN-HAf_.js","./chevron-right-small_x16-HH4sWtDQ.js","./chevron-right-small_x16-DNJfVAuO.css","./box-open_x48-B7HU9nWf.js","./SpecPatterns.vue_vue_type_script_setup_true_lang-e76_DrGV.js","./document-text_x16-DcnRAkDu.js","./OpenFileInIDE.vue_vue_type_script_setup_true_lang-7uZqFf1Q.js","./InlineCodeFragment-Bk5iKsus.css","./Switch.vue_vue_type_script_setup_true_lang-D1Es5R1G.js","./cypress-dark-DoFp00-F.js","./refresh_x16-pYdSDjap.js","./status-errored-outline_x16-VWBm7BwN.js","./graphql-ziH_XwYY.js","./Runner-Cko9Pm9Z.css","./Index-C5YeVnOn.js","./TrackedBanner.vue_vue_type_script_setup_true_lang-4n-cYpDG.js","./index.es-C8yDP9FC.js","./SpecNameDisplay.vue_vue_type_script_setup_true_lang-CbljrrHW.js","./PromoHeader.vue_vue_type_script_setup_true_lang-DsxNIqRO.js","./settings_x16-DYf-I3qL.js","./useRelevantRun-CWgUAAGH.js","./Index-DViPD26H.css","./Settings-y4LfxyMT.js","./useMarkdown-DxXDLqZG.js","./CloudConnectButton.vue_vue_type_script_setup_true_lang-D0XTM9f0.js","./cypress-logo_x16-BCrguhIO.js","./isWindows-BWSfhoye.js","./Settings-UolMkq55.css","./Runs-0650BlSr.js","./locked-project_x48-BCBn9uVt.js","./day-CdOBjBrq.js","./Runs-s3eaBS_U.css","./Debug-CPwXVzhh.js","./chevron-right_x16-DY0xSPS4.js","./Debug-DPWbVlQz.css","./_...all_-DRL1mQ2q.js","./default-BIPJivEf.js","./default-Bx50TH87.css"],__vite__mapDeps=i=>i.map(i=>__vite__fileDeps[i]);
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link2);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link2) {
    const fetchOpts = {};
    if (link2.integrity)
      fetchOpts.integrity = link2.integrity;
    if (link2.referrerPolicy)
      fetchOpts.referrerPolicy = link2.referrerPolicy;
    if (link2.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link2.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link2) {
    if (link2.ep)
      return;
    link2.ep = true;
    const fetchOpts = getFetchOpts(link2);
    fetch(link2.href, fetchOpts);
  }
})();
function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
function normalizeStyle(value) {
  if (isArray$2(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$4(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$4(value)) {
    return value;
  } else if (isObject$7(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*.*?\*\//gs;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$4(value)) {
    res = value;
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$7(value)) {
    for (const name2 in value) {
      if (value[name2]) {
        res += name2 + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString$4(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a2.length; i++) {
    equal = looseEqual(a2[i], b2[i]);
  }
  return equal;
}
function looseEqual(a2, b2) {
  if (a2 === b2)
    return true;
  let aValidType = isDate$1(a2);
  let bValidType = isDate$1(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
  }
  aValidType = isSymbol(a2);
  bValidType = isSymbol(b2);
  if (aValidType || bValidType) {
    return a2 === b2;
  }
  aValidType = isArray$2(a2);
  bValidType = isArray$2(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
  }
  aValidType = isObject$7(a2);
  bValidType = isObject$7(b2);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a2).length;
    const bKeysCount = Object.keys(b2).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a2) {
      const aHasKey = a2.hasOwnProperty(key);
      const bHasKey = b2.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
        return false;
      }
    }
  }
  return String(a2) === String(b2);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString$1 = (val) => {
  return isString$4(val) ? val : val == null ? "" : isArray$2(val) || isObject$7(val) && (val.toString === objectToString$2 || !isFunction$3(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$7(val) && !isArray$2(val) && !isPlainObject$4(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$4 = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key) => hasOwnProperty$4.call(val, key);
const isArray$2 = Array.isArray;
const isMap = (val) => toTypeString$1(val) === "[object Map]";
const isSet = (val) => toTypeString$1(val) === "[object Set]";
const isDate$1 = (val) => toTypeString$1(val) === "[object Date]";
const isFunction$3 = (val) => typeof val === "function";
const isString$4 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$7 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return isObject$7(val) && isFunction$3(val.then) && isFunction$3(val.catch);
};
const objectToString$2 = Object.prototype.toString;
const toTypeString$1 = (value) => objectToString$2.call(value);
const toRawType = (value) => {
  return toTypeString$1(value).slice(8, -1);
};
const isPlainObject$4 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key) => isString$4(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn2) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn2(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize$1 = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize$1(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$4(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis$3;
const getGlobalThis$1 = () => {
  return _globalThis$3 || (_globalThis$3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn2) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn2();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l2;
      for (i = 0, l2 = this.effects.length; i < l2; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l2 = this.cleanups.length; i < l2; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l2 = this.scopes.length; i < l2; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn2) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn2);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect2) => {
  const { deps } = effect2;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect2);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn2, scheduler2 = null, scope) {
    this.fn = fn2;
    this.scheduler = scheduler2;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type2, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type2, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type2 === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$2(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type2) {
      case "add":
        if (!isArray$2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$2(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
function getDepFromReactive(object2, key) {
  var _a2;
  return (_a2 = targetMap.get(object2)) === null || _a2 === void 0 ? void 0 : _a2.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l2 = this.length; i < l2; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$3(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$2(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn$1(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$3;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$7(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn$1(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$2(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1$1,
  deleteProperty,
  has: has$1$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$2(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap2(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap2(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size$1(target, isReadonly2 = false) {
  target = target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$2(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ];
    const rawTarget = toRaw(target);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap2(value), wrap2(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type2) {
  return function(...args) {
    return type2 === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$2(this, key);
    },
    get size() {
      return size$1(this);
    },
    has,
    add,
    set: set$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$2(this, key, false, true);
    },
    get size() {
      return size$1(this);
    },
    has,
    add,
    set: set$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn$1(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value[
    "__v_skip"
    /* ReactiveFlags.SKIP */
  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$7(target)) {
    return target;
  }
  if (target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ] && !(isReadonly2 && target[
    "__v_isReactive"
    /* ReactiveFlags.IS_REACTIVE */
  ])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ]);
  }
  return !!(value && value[
    "__v_isReactive"
    /* ReactiveFlags.IS_REACTIVE */
  ]);
}
function isReadonly(value) {
  return !!(value && value[
    "__v_isReadonly"
    /* ReactiveFlags.IS_READONLY */
  ]);
}
function isShallow(value) {
  return !!(value && value[
    "__v_isShallow"
    /* ReactiveFlags.IS_SHALLOW */
  ]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$7(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$7(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object2) {
  const ret = isArray$2(object2) ? new Array(object2.length) : {};
  for (const key in object2) {
    ret[key] = toRef(object2, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
function toRef(object2, key, defaultValue) {
  const val = object2[key];
  return isRef(val) ? val : new ObjectRefImpl(object2, key, defaultValue);
}
var _a$1$2;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a$1$2] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this[
      "__v_isReadonly"
      /* ReactiveFlags.IS_READONLY */
    ] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
_a$1$2 = "__v_isReadonly";
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$3(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn$1(msg, ...args) {
  return;
}
function callWithErrorHandling(fn2, instance, type2, args) {
  let res;
  try {
    res = args ? fn2(...args) : fn2();
  } catch (err) {
    handleError(err, instance, type2);
  }
  return res;
}
function callWithAsyncErrorHandling(fn2, instance, type2, args) {
  if (isFunction$3(fn2)) {
    const res = callWithErrorHandling(fn2, instance, type2, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type2);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn2.length; i++) {
    values.push(callWithAsyncErrorHandling(fn2[i], instance, type2, args));
  }
  return values;
}
function handleError(err, instance, type2, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type2;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type2, contextVNode, throwInDev);
}
function logError(err, type2, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn2) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
}
function findInsertionIndex(id2) {
  let start2 = flushIndex + 1;
  let end2 = queue.length;
  while (start2 < end2) {
    const middle = start2 + end2 >>> 1;
    const middleJobId = getId$1(queue[middle]);
    middleJobId < id2 ? start2 = middle + 1 : end2 = middle;
  }
  return start2;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$2(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a2, b2) => getId$1(a2) - getId$1(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId$1 = (job) => job.id == null ? Infinity : job.id;
const comparator = (a2, b2) => {
  const diff = getId$1(a2) - getId$1(b2);
  if (diff === 0) {
    if (a2.pre && !b2.pre)
      return -1;
    if (b2.pre && !a2.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(
          job,
          null,
          14
          /* ErrorCodes.SCHEDULER */
        );
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number2, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a2) => isString$4(a2) ? a2.trim() : a2);
    }
    if (number2) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$3(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$7(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$2(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$7(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options2, key) {
  if (!options2 || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$1(options2, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options2, hyphenate(key)) || hasOwn$1(options2, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev2 = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev2;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn2;
  if (fn2._n) {
    return fn2;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn2(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit22, render: render2, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev2 = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render2.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false)
        ;
      result = normalizeVNode(render22.length > 1 ? render22(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit22
      } : { attrs, slots, emit: emit22 }) : render22(
        props,
        null
        /* we know it doesn't need it */
      ));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(
      err,
      instance,
      1
      /* ErrorCodes.RENDER_FUNCTION */
    );
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev2);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type2) => type2.__isSuspense;
function queueEffectWithSuspense(fn2, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$2(fn2)) {
      suspense.effects.push(...fn2);
    } else {
      suspense.effects.push(fn2);
    }
  } else {
    queuePostFlushCb(fn2);
  }
}
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$3(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
function watchEffect(effect2, options2) {
  return doWatch(effect2, null, options2);
}
function watchPostEffect(effect2, options2) {
  return doWatch(effect2, null, { flush: "post" });
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options2) {
  return doWatch(source, cb, options2);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = getCurrentScope() === (currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$2(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return traverse(s2);
      } else if (isFunction$3(s2)) {
        return callWithErrorHandling(
          s2,
          instance,
          2
          /* ErrorCodes.WATCH_GETTER */
        );
      } else
        ;
    });
  } else if (isFunction$3(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(
        source,
        instance,
        2
        /* ErrorCodes.WATCH_GETTER */
      );
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn2) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(
        fn2,
        instance,
        4
        /* ErrorCodes.WATCH_CLEANUP */
      );
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense);
  } else {
    effect2.run();
  }
  const unwatch = () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect2);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options2) {
  const publicThis = this.proxy;
  const getter = isString$4(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$3(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options2 = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options2);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen2) {
  if (!isObject$7(value) || value[
    "__v_skip"
    /* ReactiveFlags.SKIP */
  ]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse(value.value, seen2);
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen2);
    });
  } else if (isPlainObject$4(value)) {
    for (const key in value) {
      traverse(value[key], seen2);
    }
  }
  return value;
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c2 of children) {
          if (c2.type !== Comment) {
            child = c2;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$2(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options2) {
  return isFunction$3(options2) ? { setup: options2, name: options2.name } : options2;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type2, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type2, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type2, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
  const injected = injectHook(
    type2,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type2], injected);
  }, target);
}
function injectHook(type2, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type2] || (target[type2] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type2, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook(
  "bm"
  /* LifecycleHooks.BEFORE_MOUNT */
);
const onMounted = createHook(
  "m"
  /* LifecycleHooks.MOUNTED */
);
const onBeforeUpdate = createHook(
  "bu"
  /* LifecycleHooks.BEFORE_UPDATE */
);
const onUpdated = createHook(
  "u"
  /* LifecycleHooks.UPDATED */
);
const onBeforeUnmount = createHook(
  "bum"
  /* LifecycleHooks.BEFORE_UNMOUNT */
);
const onUnmounted = createHook(
  "um"
  /* LifecycleHooks.UNMOUNTED */
);
const onServerPrefetch = createHook(
  "sp"
  /* LifecycleHooks.SERVER_PREFETCH */
);
const onRenderTriggered = createHook(
  "rtg"
  /* LifecycleHooks.RENDER_TRIGGERED */
);
const onRenderTracked = createHook(
  "rtc"
  /* LifecycleHooks.RENDER_TRACKED */
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$3(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name2];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const COMPONENTS = "components";
function resolveComponent(name2, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString$4(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type2, name2, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type2 === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
        /* do not include inferred name to avoid breaking existing code */
      );
      if (selfName && (selfName === name2 || selfName === camelize(name2) || selfName === capitalize$1(camelize(name2)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type2] || Component[type2], name2) || // global registration
      resolve(instance.appContext[type2], name2)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name2) {
  return registry && (registry[name2] || registry[camelize(name2)] || registry[capitalize$1(camelize(name2))]);
}
function renderList(source, renderItem, cache2, index) {
  let ret;
  const cached = cache2 && cache2[index];
  if (isArray$2(source) || isString$4(source)) {
    ret = new Array(source.length);
    for (let i = 0, l2 = source.length; i < l2; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$7(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i = 0, l2 = keys2.length; i < l2; i++) {
        const key = keys2[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray$2(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res)
          res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name2, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name2 !== "default")
      props.name = name2;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name2];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name2}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
    /* PatchFlags.BAIL */
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$1(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type2.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn$1(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$1(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$1(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options2 = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options2.beforeCreate) {
    callHook$1(
      options2.beforeCreate,
      instance,
      "bc"
      /* LifecycleHooks.BEFORE_CREATE */
    );
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options2;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$3(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$7(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$3(opt) ? opt.bind(publicThis, publicThis) : isFunction$3(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$3(opt) && isFunction$3(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v) => c2.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$3(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(
      created,
      instance,
      "c"
      /* LifecycleHooks.CREATED */
    );
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$2(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$2(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$2(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$7(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type2) {
  callWithAsyncErrorHandling(isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type2);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$4(raw)) {
    const handler = ctx[raw];
    if (isFunction$3(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$3(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$7(raw)) {
    if (isArray$2(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction$3(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$3(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache2, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true));
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject$7(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m2) => mergeOptions$1(to, m2, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(isFunction$3(to) ? to.call(this, this) : to, isFunction$3(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$2(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(extend(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options2] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options2) {
          if (hasOwn$1(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options2,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
        if (options2) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options2,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$1(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options2, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options2 && hasOwn$1(options2, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options2, rawCurrentProps, key, castValues[key], instance, !hasOwn$1(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options2, props, key, value, instance, isAbsent) {
  const opt = options2[key];
  if (opt != null) {
    const hasDefault = hasOwn$1(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$3(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* BooleanFlags.shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* BooleanFlags.shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$3(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$7(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$2(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$3(opt) ? { type: opt } : Object.assign({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* BooleanFlags.shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* BooleanFlags.shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$1(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$7(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match2 = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match2 ? match2[2] : ctor === null ? "null" : "";
}
function isSameType(a2, b2) {
  return getType(a2) === getType(b2);
}
function getTypeIndex(type2, expectedTypes) {
  if (isArray$2(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type2));
  } else if (isFunction$3(expectedTypes)) {
    return isSameType(expectedTypes, type2) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$3(value)) {
      slots[key] = normalizeSlot$1(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type2 = children._;
    if (type2) {
      instance.slots = toRaw(children);
      def(children, "_", type2);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type2 = children._;
    if (type2) {
      if (optimized && type2 === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type2 === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$3(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject$7(rootProps)) {
      rootProps = null;
    }
    const context2 = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context2.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context2,
      _instance: null,
      version: version$9,
      get config() {
        return context2.config;
      },
      set config(v) {
      },
      use(plugin, ...options2) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$3(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options2);
        } else if (isFunction$3(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options2);
        } else
          ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context2.mixins.includes(mixin)) {
            context2.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name2, component) {
        if (!component) {
          return context2.components[name2];
        }
        context2.components[name2] = component;
        return app2;
      },
      directive(name2, directive) {
        if (!directive) {
          return context2.directives[name2];
        }
        context2.directives[name2] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context2;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context2.provides[key] = value;
        return app2;
      }
    };
    return app2;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$2(rawRef)) {
    rawRef.forEach((r2, i) => setRef(r2, oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref3) {
    if (isString$4(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$1(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$3(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString$4(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn$1(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$2(existing) && remove(existing, refValue);
          } else {
            if (!isArray$2(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (hasOwn$1(setupState, ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (hasOwn$1(setupState, ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options2) {
  return baseCreateRenderer(options2);
}
function baseCreateRenderer(options2, createHydrationFns) {
  const target = getGlobalThis$1();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options2;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type: type2, ref: ref3, shapeFlag } = n2;
    switch (type2) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type2.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type2.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type: type2, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type2 !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start2 = 0) => {
    for (let i = start2; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev2 = oldProps[key];
            const next = newProps[key];
            if (next !== prev2 || key === "value") {
              hostPatchProp(el, key, prev2, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev2 = oldProps[key];
        if (next !== prev2 && key !== "value") {
          hostPatchProp(el, key, prev2, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect2.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(
              nextChild,
              container,
              anchor,
              2
              /* MoveType.REORDER */
            );
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type: type2, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type2.move(vnode, container, anchor, internals);
      return;
    }
    if (type2 === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type2 === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type: type2, props, ref: ref3, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type: type2, el, anchor, transition } = vnode;
    if (type2 === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type2 === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end2) => {
    let next;
    while (cur !== end2) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end2);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
    for (let i = start2; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options2
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render2,
    hydrate,
    createApp: createAppAPI(render2, hydrate)
  };
}
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$2(ch1) && isArray$2(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u2, v, c2;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u2 = 0;
      v = result.length - 1;
      while (u2 < v) {
        c2 = u2 + v >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i] = result[u2 - 1];
        }
        result[u2] = i;
      }
    }
  }
  u2 = result.length;
  v = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type2) => type2.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$4(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert: insert2, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert2(placeholder, container, anchor);
      insert2(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert2(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
            /* TeleportMoveTypes.TOGGLE */
          );
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
              /* TeleportMoveTypes.TARGET_CHANGE */
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
            /* TeleportMoveTypes.TOGGLE */
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert: insert2 }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert2(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert2(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
          /* MoveType.REORDER */
        );
      }
    }
  }
  if (isReorder) {
    insert2(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(
    type2,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    true
    /* isBlock */
  ));
}
function createBlock(type2, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(
    type2,
    props,
    children,
    patchFlag,
    dynamicProps,
    true
    /* isBlock: prevent a block from tracking itself */
  ));
}
function isVNode$1(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref3, ref_key, ref_for }) => {
  return ref3 != null ? isString$4(ref3) || isRef(ref3) || isFunction$3(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type: type2,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type2.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$4(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
    type2 = Comment;
  }
  if (isVNode$1(type2)) {
    const cloned = cloneVNode(
      type2,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type2)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type2)) {
    type2 = type2.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$4(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$7(style)) {
      if (isProxy(style) && !isArray$2(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$4(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$7(type2) ? 4 : isFunction$3(type2) ? 2 : 0;
  return createBaseVNode(type2, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref3, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$2(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type2 = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$2(children)) {
    type2 = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type2 = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$3(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type2 = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type2 = 16;
      children = [createTextVNode(children)];
    } else {
      type2 = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type2;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type2 = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type: type2,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type2, appContext),
    emitsOptions: normalizeEmitsOptions(type2, appContext),
    // emit
    emit: null,
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type2.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup: setup9 } = Component;
  if (setup9) {
    const setupContext = instance.setupContext = setup9.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup9, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(
            e,
            instance,
            0
            /* ErrorCodes.SETUP_FUNCTION */
          );
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$3(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$7(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(extend({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction$3(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction$3(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function h$1(type2, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$7(propsOrChildren) && !isArray$2(propsOrChildren)) {
      if (isVNode$1(propsOrChildren)) {
        return createVNode(type2, null, [propsOrChildren]);
      }
      return createVNode(type2, propsOrChildren);
    } else {
      return createVNode(type2, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode$1(children)) {
      children = [children];
    }
    return createVNode(type2, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol(``);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
const version$9 = "3.2.47";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id2) {
    el.setAttribute(id2, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start2, end2) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start2 && (start2 === end2 || start2.nextSibling)) {
      while (true) {
        parent.insertBefore(start2.cloneNode(true), anchor);
        if (start2 === end2 || !(start2 = start2.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev2, next) {
  const style = el.style;
  const isCssString = isString$4(next);
  if (next && !isCssString) {
    if (prev2 && !isString$4(prev2)) {
      for (const key in prev2) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev2 !== next) {
        style.cssText = next;
      }
    } else if (prev2) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name2, val) {
  if (isArray$2(val)) {
    val.forEach((v) => setStyle(style, name2, v));
  } else {
    if (val == null)
      val = "";
    if (name2.startsWith("--")) {
      style.setProperty(name2, val);
    } else {
      const prefixed = autoPrefix(style, name2);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name2 = camelize(rawName);
  if (name2 !== "filter" && name2 in style) {
    return prefixCache[rawName] = name2;
  }
  name2 = capitalize$1(name2);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name2;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && // custom elements may use _value internally
  !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || // #4956: always set for OPTION elements because its value falls back to
    // textContent if no value attribute is present. And setting .value for
    // OPTION has no side effect
    el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type2 = typeof el[key];
    if (type2 === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type2 === "string") {
      value = "";
      needRemove = true;
    } else if (type2 === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener$1(el, event, handler, options2) {
  el.addEventListener(event, handler, options2);
}
function removeEventListener$1(el, event, handler, options2) {
  el.removeEventListener(event, handler, options2);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name2, options2] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener$1(el, name2, invoker, options2);
    } else if (existingInvoker) {
      removeEventListener$1(el, name2, existingInvoker, options2);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name2) {
  let options2;
  if (optionsModifierRE.test(name2)) {
    options2 = {};
    let m2;
    while (m2 = name2.match(optionsModifierRE)) {
      name2 = name2.slice(0, name2.length - m2[0].length);
      options2[m2[0].toLowerCase()] = true;
    }
  }
  const event = name2[2] === ":" ? name2.slice(3) : hyphenate(name2.slice(2));
  return [event, options2];
}
let cachedNow = 0;
const p$2 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$2.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$2(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn2) => (e2) => !e2._stopped && fn2 && fn2(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction$3(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$4(value)) {
    return false;
  }
  return key in el;
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  };
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c2) => setVarsOnVNode(c2, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
    }
  }
}
const TRANSITION$1 = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h$1(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray$2(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name: name2 = "v", type: type2, duration, enterFromClass = `${name2}-enter-from`, enterActiveClass = `${name2}-enter-active`, enterToClass = `${name2}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name2}-leave-from`, leaveActiveClass = `${name2}-leave-active`, leaveToClass = `${name2}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve3 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve3]);
      nextFrame$2(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type2, enterDuration, resolve3);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve3 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame$2(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type2, leaveDuration, resolve3);
        }
      });
      callHook(onLeave, [el, resolve3]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$7(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame$2(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve3) {
  const id2 = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id2 === el._endId) {
      resolve3();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type: type2, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type2) {
    return resolve3();
  }
  const endEvent = type2 + "end";
  let ended = 0;
  const end2 = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end2();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end2();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION$1}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION$1}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type2 = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION$1) {
    if (transitionTimeout > 0) {
      type2 = TRANSITION$1;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type2 = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type2 = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION$1 : ANIMATION : null;
    propCount = type2 ? type2 === TRANSITION$1 ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type2 === TRANSITION$1 && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION$1}Property`).toString());
  return {
    type: type2,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i) => toMs(d2) + toMs(delays[i])));
}
function toMs(s2) {
  return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c2) => {
        const el = c2.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el._moveCb = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
        }
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = (props) => delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c2) {
  const el = c2.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c2) {
  newPositionMap.set(c2, c2.el.getBoundingClientRect());
}
function applyTranslation(c2) {
  const oldPos = positionMap.get(c2);
  const newPos = newPositionMap.get(c2);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s2 = c2.el.style;
    s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
    s2.transitionDuration = "0s";
    return c2;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone2 = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
    });
  }
  moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
  clone2.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn2 = vnode.props["onUpdate:modelValue"] || false;
  return isArray$2(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el, { modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number2 || vnode.props && vnode.props.type === "number";
    addEventListener$1(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el.value;
      if (trim2) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el._assign(domValue);
    });
    if (trim2) {
      addEventListener$1(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener$1(el, "compositionstart", onCompositionStart);
      addEventListener$1(el, "compositionend", onCompositionEnd);
      addEventListener$1(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number: number2 } }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim2 && el.value.trim() === value) {
        return;
      }
      if ((number2 || el.type === "number") && looseToNumber(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _2, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener$1(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign2 = el._assign;
      if (isArray$2(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign2(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign2(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray$2(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener$1(el, "change", () => {
      el._assign(getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number: number2 } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener$1(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o2) => o2.selected).map((o2) => number2 ? looseToNumber(getValue(o2)) : getValue(o2));
      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray$2(value) && !isSet(value)) {
    return;
  }
  for (let i = 0, l2 = el.options.length; i < l2; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray$2(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i)
          el.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type2) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type2) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
  const fn2 = modelToUse[hook];
  fn2 && fn2(el, binding, vnode, prevVNode);
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m2) => e[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn2, modifiers) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn2(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn2, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn2(event);
    }
  };
};
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el._vod : "none";
}
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction$3(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString$4(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var nodejsCustomInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0;
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (_typeof$2(value)) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? "[function ".concat(value.name, "]") : "[function]";
    case "object":
      if (value === null) {
        return "null";
      }
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value) !== -1) {
    return "[Circular]";
  }
  var seenValues = [].concat(previouslySeenValues, [value]);
  var customInspectFn = getCustomFn(value);
  if (customInspectFn !== void 0) {
    var customValue = customInspectFn.call(value);
    if (customValue !== value) {
      return typeof customValue === "string" ? customValue : formatValue(customValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function formatObject(object2, seenValues) {
  var keys2 = Object.keys(object2);
  if (keys2.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object2) + "]";
  }
  var properties = keys2.map(function(key) {
    var value = formatValue(object2[key], seenValues);
    return key + ": " + value;
  });
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  var len = Math.min(MAX_ARRAY_LENGTH, array.length);
  var remaining = array.length - len;
  var items = [];
  for (var i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }
  return "[" + items.join(", ") + "]";
}
function getCustomFn(object2) {
  var customInspectFn = object2[String(nodejsCustomInspectSymbol)];
  if (typeof customInspectFn === "function") {
    return customInspectFn;
  }
  if (typeof object2.inspect === "function") {
    return object2.inspect;
  }
}
function getObjectTag(object2) {
  var tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object2.constructor === "function") {
    var name2 = object2.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag;
}
function invariant$2(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}
function defineInspect(classObject) {
  var fn2 = classObject.prototype.toJSON;
  typeof fn2 === "function" || invariant$2(0);
  classObject.prototype.inspect = fn2;
  if (nodejsCustomInspectSymbol) {
    classObject.prototype[nodejsCustomInspectSymbol] = fn2;
  }
}
var Location = /* @__PURE__ */ function() {
  function Location2(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  var _proto = Location2.prototype;
  _proto.toJSON = function toJSON2() {
    return {
      start: this.start,
      end: this.end
    };
  };
  return Location2;
}();
defineInspect(Location);
var Token = /* @__PURE__ */ function() {
  function Token2(kind, start2, end2, line, column, prev2, value) {
    this.kind = kind;
    this.start = start2;
    this.end = end2;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = prev2;
    this.next = null;
  }
  var _proto2 = Token2.prototype;
  _proto2.toJSON = function toJSON2() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  };
  return Token2;
}();
defineInspect(Token);
function isNode$1(maybeNode) {
  return maybeNode != null && typeof maybeNode.kind === "string";
}
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are experimental and may be changed
    // or removed in the future.
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
  InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var BREAK = Object.freeze({});
function visit$1(root, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : QueryDocumentKeys;
  var stack = void 0;
  var inArray = Array.isArray(root);
  var keys2 = [root];
  var index = -1;
  var edits = [];
  var node = void 0;
  var key = void 0;
  var parent = void 0;
  var path = [];
  var ancestors = [];
  var newRoot = root;
  do {
    index++;
    var isLeaving = index === keys2.length;
    var isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone2 = {};
          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
            var k = _Object$keys2[_i2];
            clone2[k] = node[k];
          }
          node = clone2;
        }
        var editOffset = 0;
        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];
          if (inArray) {
            editKey -= editOffset;
          }
          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys2 = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent ? inArray ? index : keys2[index] : void 0;
      node = parent ? parent[key] : newRoot;
      if (node === null || node === void 0) {
        continue;
      }
      if (parent) {
        path.push(key);
      }
    }
    var result = void 0;
    if (!Array.isArray(node)) {
      if (!isNode$1(node)) {
        throw new Error("Invalid AST Node: ".concat(inspect(node), "."));
      }
      var visitFn = getVisitFn(visitor, node.kind, isLeaving);
      if (visitFn) {
        result = visitFn.call(visitor, node, key, parent, path, ancestors);
        if (result === BREAK) {
          break;
        }
        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== void 0) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (isNode$1(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _visitorKeys$node$kin;
      stack = {
        inArray,
        index,
        keys: keys2,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys2 = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }
  return newRoot;
}
function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];
  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === "function") {
      return kindVisitor;
    }
    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;
    if (typeof kindSpecificVisitor === "function") {
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
    if (specificVisitor) {
      if (typeof specificVisitor === "function") {
        return specificVisitor;
      }
      var specificKindVisitor = specificVisitor[kind];
      if (typeof specificKindVisitor === "function") {
        return specificKindVisitor;
      }
    }
  }
}
var Kind = Object.freeze({
  // Name
  NAME: "Name",
  // Document
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  // Fragments
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  // Values
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  // Directives
  DIRECTIVE: "Directive",
  // Types
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType",
  // Type System Definitions
  SCHEMA_DEFINITION: "SchemaDefinition",
  OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
  // Type Definitions
  SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
  OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
  FIELD_DEFINITION: "FieldDefinition",
  INPUT_VALUE_DEFINITION: "InputValueDefinition",
  INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
  UNION_TYPE_DEFINITION: "UnionTypeDefinition",
  ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
  ENUM_VALUE_DEFINITION: "EnumValueDefinition",
  INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
  // Directive Definitions
  DIRECTIVE_DEFINITION: "DirectiveDefinition",
  // Type System Extensions
  SCHEMA_EXTENSION: "SchemaExtension",
  // Type Extensions
  SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
  OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
  INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
  UNION_TYPE_EXTENSION: "UnionTypeExtension",
  ENUM_TYPE_EXTENSION: "EnumTypeExtension",
  INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
});
function dedentBlockStringValue(rawString) {
  var lines = rawString.split(/\r\n|[\n\r]/g);
  var commonIndent = getBlockStringIndentation(rawString);
  if (commonIndent !== 0) {
    for (var i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  }
  var startLine = 0;
  while (startLine < lines.length && isBlank(lines[startLine])) {
    ++startLine;
  }
  var endLine = lines.length;
  while (endLine > startLine && isBlank(lines[endLine - 1])) {
    --endLine;
  }
  return lines.slice(startLine, endLine).join("\n");
}
function isBlank(str) {
  for (var i = 0; i < str.length; ++i) {
    if (str[i] !== " " && str[i] !== "	") {
      return false;
    }
  }
  return true;
}
function getBlockStringIndentation(value) {
  var _commonIndent;
  var isFirstLine = true;
  var isEmptyLine = true;
  var indent2 = 0;
  var commonIndent = null;
  for (var i = 0; i < value.length; ++i) {
    switch (value.charCodeAt(i)) {
      case 13:
        if (value.charCodeAt(i + 1) === 10) {
          ++i;
        }
      case 10:
        isFirstLine = false;
        isEmptyLine = true;
        indent2 = 0;
        break;
      case 9:
      case 32:
        ++indent2;
        break;
      default:
        if (isEmptyLine && !isFirstLine && (commonIndent === null || indent2 < commonIndent)) {
          commonIndent = indent2;
        }
        isEmptyLine = false;
    }
  }
  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;
}
function printBlockString(value) {
  var indentation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var preferMultipleLines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isSingleLine = value.indexOf("\n") === -1;
  var hasLeadingSpace = value[0] === " " || value[0] === "	";
  var hasTrailingQuote = value[value.length - 1] === '"';
  var hasTrailingSlash = value[value.length - 1] === "\\";
  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;
  var result = "";
  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
    result += "\n" + indentation;
  }
  result += indentation ? value.replace(/\n/g, "\n" + indentation) : value;
  if (printAsMultipleLines) {
    result += "\n";
  }
  return '"""' + result.replace(/"""/g, '\\"""') + '"""';
}
function print$1(ast) {
  return visit$1(ast, {
    leave: printDocASTReducer
  });
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: function Name(node) {
    return node.value;
  },
  Variable: function Variable(node) {
    return "$" + node.name;
  },
  // Document
  Document: function Document(node) {
    return join$3(node.definitions, "\n\n") + "\n";
  },
  OperationDefinition: function OperationDefinition(node) {
    var op = node.operation;
    var name2 = node.name;
    var varDefs = wrap("(", join$3(node.variableDefinitions, ", "), ")");
    var directives = join$3(node.directives, " ");
    var selectionSet = node.selectionSet;
    return !name2 && !directives && !varDefs && op === "query" ? selectionSet : join$3([op, join$3([name2, varDefs]), directives, selectionSet], " ");
  },
  VariableDefinition: function VariableDefinition(_ref) {
    var variable = _ref.variable, type2 = _ref.type, defaultValue = _ref.defaultValue, directives = _ref.directives;
    return variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join$3(directives, " "));
  },
  SelectionSet: function SelectionSet(_ref2) {
    var selections = _ref2.selections;
    return block(selections);
  },
  Field: function Field(_ref3) {
    var alias = _ref3.alias, name2 = _ref3.name, args = _ref3.arguments, directives = _ref3.directives, selectionSet = _ref3.selectionSet;
    var prefix = wrap("", alias, ": ") + name2;
    var argsLine = prefix + wrap("(", join$3(args, ", "), ")");
    if (argsLine.length > MAX_LINE_LENGTH) {
      argsLine = prefix + wrap("(\n", indent(join$3(args, "\n")), "\n)");
    }
    return join$3([argsLine, join$3(directives, " "), selectionSet], " ");
  },
  Argument: function Argument(_ref4) {
    var name2 = _ref4.name, value = _ref4.value;
    return name2 + ": " + value;
  },
  // Fragments
  FragmentSpread: function FragmentSpread(_ref5) {
    var name2 = _ref5.name, directives = _ref5.directives;
    return "..." + name2 + wrap(" ", join$3(directives, " "));
  },
  InlineFragment: function InlineFragment(_ref6) {
    var typeCondition = _ref6.typeCondition, directives = _ref6.directives, selectionSet = _ref6.selectionSet;
    return join$3(["...", wrap("on ", typeCondition), join$3(directives, " "), selectionSet], " ");
  },
  FragmentDefinition: function FragmentDefinition(_ref7) {
    var name2 = _ref7.name, typeCondition = _ref7.typeCondition, variableDefinitions = _ref7.variableDefinitions, directives = _ref7.directives, selectionSet = _ref7.selectionSet;
    return (
      // Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      "fragment ".concat(name2).concat(wrap("(", join$3(variableDefinitions, ", "), ")"), " ") + "on ".concat(typeCondition, " ").concat(wrap("", join$3(directives, " "), " ")) + selectionSet
    );
  },
  // Value
  IntValue: function IntValue(_ref8) {
    var value = _ref8.value;
    return value;
  },
  FloatValue: function FloatValue(_ref9) {
    var value = _ref9.value;
    return value;
  },
  StringValue: function StringValue(_ref10, key) {
    var value = _ref10.value, isBlockString = _ref10.block;
    return isBlockString ? printBlockString(value, key === "description" ? "" : "  ") : JSON.stringify(value);
  },
  BooleanValue: function BooleanValue(_ref11) {
    var value = _ref11.value;
    return value ? "true" : "false";
  },
  NullValue: function NullValue() {
    return "null";
  },
  EnumValue: function EnumValue(_ref12) {
    var value = _ref12.value;
    return value;
  },
  ListValue: function ListValue(_ref13) {
    var values = _ref13.values;
    return "[" + join$3(values, ", ") + "]";
  },
  ObjectValue: function ObjectValue(_ref14) {
    var fields = _ref14.fields;
    return "{" + join$3(fields, ", ") + "}";
  },
  ObjectField: function ObjectField(_ref15) {
    var name2 = _ref15.name, value = _ref15.value;
    return name2 + ": " + value;
  },
  // Directive
  Directive: function Directive(_ref16) {
    var name2 = _ref16.name, args = _ref16.arguments;
    return "@" + name2 + wrap("(", join$3(args, ", "), ")");
  },
  // Type
  NamedType: function NamedType(_ref17) {
    var name2 = _ref17.name;
    return name2;
  },
  ListType: function ListType(_ref18) {
    var type2 = _ref18.type;
    return "[" + type2 + "]";
  },
  NonNullType: function NonNullType(_ref19) {
    var type2 = _ref19.type;
    return type2 + "!";
  },
  // Type System Definitions
  SchemaDefinition: addDescription(function(_ref20) {
    var directives = _ref20.directives, operationTypes = _ref20.operationTypes;
    return join$3(["schema", join$3(directives, " "), block(operationTypes)], " ");
  }),
  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
    var operation = _ref21.operation, type2 = _ref21.type;
    return operation + ": " + type2;
  },
  ScalarTypeDefinition: addDescription(function(_ref22) {
    var name2 = _ref22.name, directives = _ref22.directives;
    return join$3(["scalar", name2, join$3(directives, " ")], " ");
  }),
  ObjectTypeDefinition: addDescription(function(_ref23) {
    var name2 = _ref23.name, interfaces = _ref23.interfaces, directives = _ref23.directives, fields = _ref23.fields;
    return join$3(["type", name2, wrap("implements ", join$3(interfaces, " & ")), join$3(directives, " "), block(fields)], " ");
  }),
  FieldDefinition: addDescription(function(_ref24) {
    var name2 = _ref24.name, args = _ref24.arguments, type2 = _ref24.type, directives = _ref24.directives;
    return name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join$3(args, "\n")), "\n)") : wrap("(", join$3(args, ", "), ")")) + ": " + type2 + wrap(" ", join$3(directives, " "));
  }),
  InputValueDefinition: addDescription(function(_ref25) {
    var name2 = _ref25.name, type2 = _ref25.type, defaultValue = _ref25.defaultValue, directives = _ref25.directives;
    return join$3([name2 + ": " + type2, wrap("= ", defaultValue), join$3(directives, " ")], " ");
  }),
  InterfaceTypeDefinition: addDescription(function(_ref26) {
    var name2 = _ref26.name, interfaces = _ref26.interfaces, directives = _ref26.directives, fields = _ref26.fields;
    return join$3(["interface", name2, wrap("implements ", join$3(interfaces, " & ")), join$3(directives, " "), block(fields)], " ");
  }),
  UnionTypeDefinition: addDescription(function(_ref27) {
    var name2 = _ref27.name, directives = _ref27.directives, types = _ref27.types;
    return join$3(["union", name2, join$3(directives, " "), types && types.length !== 0 ? "= " + join$3(types, " | ") : ""], " ");
  }),
  EnumTypeDefinition: addDescription(function(_ref28) {
    var name2 = _ref28.name, directives = _ref28.directives, values = _ref28.values;
    return join$3(["enum", name2, join$3(directives, " "), block(values)], " ");
  }),
  EnumValueDefinition: addDescription(function(_ref29) {
    var name2 = _ref29.name, directives = _ref29.directives;
    return join$3([name2, join$3(directives, " ")], " ");
  }),
  InputObjectTypeDefinition: addDescription(function(_ref30) {
    var name2 = _ref30.name, directives = _ref30.directives, fields = _ref30.fields;
    return join$3(["input", name2, join$3(directives, " "), block(fields)], " ");
  }),
  DirectiveDefinition: addDescription(function(_ref31) {
    var name2 = _ref31.name, args = _ref31.arguments, repeatable = _ref31.repeatable, locations = _ref31.locations;
    return "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join$3(args, "\n")), "\n)") : wrap("(", join$3(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join$3(locations, " | ");
  }),
  SchemaExtension: function SchemaExtension(_ref32) {
    var directives = _ref32.directives, operationTypes = _ref32.operationTypes;
    return join$3(["extend schema", join$3(directives, " "), block(operationTypes)], " ");
  },
  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
    var name2 = _ref33.name, directives = _ref33.directives;
    return join$3(["extend scalar", name2, join$3(directives, " ")], " ");
  },
  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
    var name2 = _ref34.name, interfaces = _ref34.interfaces, directives = _ref34.directives, fields = _ref34.fields;
    return join$3(["extend type", name2, wrap("implements ", join$3(interfaces, " & ")), join$3(directives, " "), block(fields)], " ");
  },
  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
    var name2 = _ref35.name, interfaces = _ref35.interfaces, directives = _ref35.directives, fields = _ref35.fields;
    return join$3(["extend interface", name2, wrap("implements ", join$3(interfaces, " & ")), join$3(directives, " "), block(fields)], " ");
  },
  UnionTypeExtension: function UnionTypeExtension(_ref36) {
    var name2 = _ref36.name, directives = _ref36.directives, types = _ref36.types;
    return join$3(["extend union", name2, join$3(directives, " "), types && types.length !== 0 ? "= " + join$3(types, " | ") : ""], " ");
  },
  EnumTypeExtension: function EnumTypeExtension(_ref37) {
    var name2 = _ref37.name, directives = _ref37.directives, values = _ref37.values;
    return join$3(["extend enum", name2, join$3(directives, " "), block(values)], " ");
  },
  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
    var name2 = _ref38.name, directives = _ref38.directives, fields = _ref38.fields;
    return join$3(["extend input", name2, join$3(directives, " "), block(fields)], " ");
  }
};
function addDescription(cb) {
  return function(node) {
    return join$3([node.description, cb(node)], "\n");
  };
}
function join$3(maybeArray) {
  var _maybeArray$filter$jo;
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(function(x2) {
    return x2;
  }).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join$3(array, "\n")), "\n}");
}
function wrap(start2, maybeString) {
  var end2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  return maybeString != null && maybeString !== "" ? start2 + maybeString + end2 : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function isMultiline(str) {
  return str.indexOf("\n") !== -1;
}
function hasMultilineItems(maybeArray) {
  return maybeArray != null && maybeArray.some(isMultiline);
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function isObjectLike$1(value) {
  return _typeof$1(value) == "object" && value !== null;
}
var SYMBOL_TO_STRING_TAG = typeof Symbol === "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";
function getLocation(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match2;
  while ((match2 = lineRegexp.exec(source.body)) && match2.index < position) {
    line += 1;
    column = position + 1 - (match2.index + match2[0].length);
  }
  return {
    line,
    column
  };
}
function printLocation(location2) {
  return printSourceLocation(location2.source, getLocation(location2.source, location2.start));
}
function printSourceLocation(source, sourceLocation) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = sourceLocation.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = sourceLocation.line + lineOffset;
  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = sourceLocation.column + columnOffset;
  var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
  var lines = body.split(/\r\n|[\n\r]/g);
  var locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    var subLineIndex = Math.floor(columnNum / 80);
    var subLineColumnNum = columnNum % 80;
    var subLines = [];
    for (var i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([["".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function(subLine) {
      return ["", subLine];
    }), [[" ", whitespace(subLineColumnNum - 1) + "^"], ["", subLines[subLineIndex + 1]]]));
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    ["".concat(lineNum - 1), lines[lineIndex - 1]],
    ["".concat(lineNum), locationLine],
    ["", whitespace(columnNum - 1) + "^"],
    ["".concat(lineNum + 1), lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  var existingLines = lines.filter(function(_ref) {
    _ref[0];
    var line = _ref[1];
    return line !== void 0;
  });
  var padLen = Math.max.apply(Math, existingLines.map(function(_ref2) {
    var prefix = _ref2[0];
    return prefix.length;
  }));
  return existingLines.map(function(_ref3) {
    var prefix = _ref3[0], line = _ref3[1];
    return leftPad(padLen, prefix) + (line ? " | " + line : " |");
  }).join("\n");
}
function whitespace(len) {
  return Array(len + 1).join(" ");
}
function leftPad(len, str) {
  return whitespace(len - str.length) + str;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
var GraphQLError = /* @__PURE__ */ function(_Error) {
  _inherits(GraphQLError2, _Error);
  var _super = _createSuper(GraphQLError2);
  function GraphQLError2(message, nodes, source, positions, path, originalError, extensions) {
    var _locations2, _source2, _positions2, _extensions2;
    var _this;
    _classCallCheck(this, GraphQLError2);
    _this = _super.call(this, message);
    var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : void 0 : nodes ? [nodes] : void 0;
    var _source = source;
    if (!_source && _nodes) {
      var _nodes$0$loc;
      _source = (_nodes$0$loc = _nodes[0].loc) === null || _nodes$0$loc === void 0 ? void 0 : _nodes$0$loc.source;
    }
    var _positions = positions;
    if (!_positions && _nodes) {
      _positions = _nodes.reduce(function(list, node) {
        if (node.loc) {
          list.push(node.loc.start);
        }
        return list;
      }, []);
    }
    if (_positions && _positions.length === 0) {
      _positions = void 0;
    }
    var _locations;
    if (positions && source) {
      _locations = positions.map(function(pos) {
        return getLocation(source, pos);
      });
    } else if (_nodes) {
      _locations = _nodes.reduce(function(list, node) {
        if (node.loc) {
          list.push(getLocation(node.loc.source, node.loc.start));
        }
        return list;
      }, []);
    }
    var _extensions = extensions;
    if (_extensions == null && originalError != null) {
      var originalExtensions = originalError.extensions;
      if (isObjectLike$1(originalExtensions)) {
        _extensions = originalExtensions;
      }
    }
    Object.defineProperties(_assertThisInitialized(_this), {
      name: {
        value: "GraphQLError"
      },
      message: {
        value: message,
        // By being enumerable, JSON.stringify will include `message` in the
        // resulting output. This ensures that the simplest possible GraphQL
        // service adheres to the spec.
        enumerable: true,
        writable: true
      },
      locations: {
        // Coercing falsy values to undefined ensures they will not be included
        // in JSON.stringify() when not provided.
        value: (_locations2 = _locations) !== null && _locations2 !== void 0 ? _locations2 : void 0,
        // By being enumerable, JSON.stringify will include `locations` in the
        // resulting output. This ensures that the simplest possible GraphQL
        // service adheres to the spec.
        enumerable: _locations != null
      },
      path: {
        // Coercing falsy values to undefined ensures they will not be included
        // in JSON.stringify() when not provided.
        value: path !== null && path !== void 0 ? path : void 0,
        // By being enumerable, JSON.stringify will include `path` in the
        // resulting output. This ensures that the simplest possible GraphQL
        // service adheres to the spec.
        enumerable: path != null
      },
      nodes: {
        value: _nodes !== null && _nodes !== void 0 ? _nodes : void 0
      },
      source: {
        value: (_source2 = _source) !== null && _source2 !== void 0 ? _source2 : void 0
      },
      positions: {
        value: (_positions2 = _positions) !== null && _positions2 !== void 0 ? _positions2 : void 0
      },
      originalError: {
        value: originalError
      },
      extensions: {
        // Coercing falsy values to undefined ensures they will not be included
        // in JSON.stringify() when not provided.
        value: (_extensions2 = _extensions) !== null && _extensions2 !== void 0 ? _extensions2 : void 0,
        // By being enumerable, JSON.stringify will include `path` in the
        // resulting output. This ensures that the simplest possible GraphQL
        // service adheres to the spec.
        enumerable: _extensions != null
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(_assertThisInitialized(_this), "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
      return _possibleConstructorReturn(_this);
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError2);
    } else {
      Object.defineProperty(_assertThisInitialized(_this), "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
    return _this;
  }
  _createClass$1(GraphQLError2, [{
    key: "toString",
    value: function toString2() {
      return printError(this);
    }
    // FIXME: workaround to not break chai comparisons, should be remove in v16
    // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet
  }, {
    key: SYMBOL_TO_STRING_TAG,
    get: function get2() {
      return "Object";
    }
  }]);
  return GraphQLError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function printError(error) {
  var output = error.message;
  if (error.nodes) {
    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {
      var node = _error$nodes2[_i2];
      if (node.loc) {
        output += "\n\n" + printLocation(node.loc);
      }
    }
  } else if (error.source && error.locations) {
    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {
      var location2 = _error$locations2[_i4];
      output += "\n\n" + printSourceLocation(error.source, location2);
    }
  }
  return output;
}
function syntaxError(source, position, description) {
  return new GraphQLError("Syntax Error: ".concat(description), void 0, source, [position]);
}
var TokenKind = Object.freeze({
  SOF: "<SOF>",
  EOF: "<EOF>",
  BANG: "!",
  DOLLAR: "$",
  AMP: "&",
  PAREN_L: "(",
  PAREN_R: ")",
  SPREAD: "...",
  COLON: ":",
  EQUALS: "=",
  AT: "@",
  BRACKET_L: "[",
  BRACKET_R: "]",
  BRACE_L: "{",
  PIPE: "|",
  BRACE_R: "}",
  NAME: "Name",
  INT: "Int",
  FLOAT: "Float",
  STRING: "String",
  BLOCK_STRING: "BlockString",
  COMMENT: "Comment"
});
function devAssert(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
const instanceOf = (
  // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')
  // eslint-disable-next-line no-shadow
  function instanceOf2(value, constructor) {
    return value instanceof constructor;
  }
);
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
var Source = /* @__PURE__ */ function() {
  function Source2(body) {
    var name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request";
    var locationOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      line: 1,
      column: 1
    };
    typeof body === "string" || devAssert(0, "Body must be a string. Received: ".concat(inspect(body), "."));
    this.body = body;
    this.name = name2;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(0, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(0, "column in locationOffset is 1-indexed and must be positive.");
  }
  _createClass(Source2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get2() {
      return "Source";
    }
  }]);
  return Source2;
}();
function isSource(source) {
  return instanceOf(source, Source);
}
var DirectiveLocation = Object.freeze({
  // Request Definitions
  QUERY: "QUERY",
  MUTATION: "MUTATION",
  SUBSCRIPTION: "SUBSCRIPTION",
  FIELD: "FIELD",
  FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
  FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
  INLINE_FRAGMENT: "INLINE_FRAGMENT",
  VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
  // Type System Definitions
  SCHEMA: "SCHEMA",
  SCALAR: "SCALAR",
  OBJECT: "OBJECT",
  FIELD_DEFINITION: "FIELD_DEFINITION",
  ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
  INTERFACE: "INTERFACE",
  UNION: "UNION",
  ENUM: "ENUM",
  ENUM_VALUE: "ENUM_VALUE",
  INPUT_OBJECT: "INPUT_OBJECT",
  INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
});
var Lexer = /* @__PURE__ */ function() {
  function Lexer2(source) {
    var startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0, null);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  var _proto = Lexer2.prototype;
  _proto.advance = function advance() {
    this.lastToken = this.token;
    var token = this.token = this.lookahead();
    return token;
  };
  _proto.lookahead = function lookahead() {
    var token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        var _token$next;
        token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  };
  return Lexer2;
}();
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function printCharCode(code2) {
  return (
    // NaN/undefined represents access beyond the end of the file.
    isNaN(code2) ? TokenKind.EOF : (
      // Trust JSON for ASCII.
      code2 < 127 ? JSON.stringify(String.fromCharCode(code2)) : (
        // Otherwise print the escaped form.
        '"\\u'.concat(("00" + code2.toString(16).toUpperCase()).slice(-4), '"')
      )
    )
  );
}
function readToken(lexer, prev2) {
  var source = lexer.source;
  var body = source.body;
  var bodyLength = body.length;
  var pos = prev2.end;
  while (pos < bodyLength) {
    var code2 = body.charCodeAt(pos);
    var _line = lexer.line;
    var _col = 1 + pos - lexer.lineStart;
    switch (code2) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++pos;
        continue;
      case 10:
        ++pos;
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 13:
        if (body.charCodeAt(pos + 1) === 10) {
          pos += 2;
        } else {
          ++pos;
        }
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 33:
        return new Token(TokenKind.BANG, pos, pos + 1, _line, _col, prev2);
      case 35:
        return readComment(source, pos, _line, _col, prev2);
      case 36:
        return new Token(TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev2);
      case 38:
        return new Token(TokenKind.AMP, pos, pos + 1, _line, _col, prev2);
      case 40:
        return new Token(TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev2);
      case 41:
        return new Token(TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev2);
      case 46:
        if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
          return new Token(TokenKind.SPREAD, pos, pos + 3, _line, _col, prev2);
        }
        break;
      case 58:
        return new Token(TokenKind.COLON, pos, pos + 1, _line, _col, prev2);
      case 61:
        return new Token(TokenKind.EQUALS, pos, pos + 1, _line, _col, prev2);
      case 64:
        return new Token(TokenKind.AT, pos, pos + 1, _line, _col, prev2);
      case 91:
        return new Token(TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev2);
      case 93:
        return new Token(TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev2);
      case 123:
        return new Token(TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev2);
      case 124:
        return new Token(TokenKind.PIPE, pos, pos + 1, _line, _col, prev2);
      case 125:
        return new Token(TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev2);
      case 34:
        if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
          return readBlockString(source, pos, _line, _col, prev2, lexer);
        }
        return readString(source, pos, _line, _col, prev2);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return readNumber(source, pos, code2, _line, _col, prev2);
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 95:
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
        return readName(source, pos, _line, _col, prev2);
    }
    throw syntaxError(source, pos, unexpectedCharacterMessage(code2));
  }
  var line = lexer.line;
  var col = 1 + pos - lexer.lineStart;
  return new Token(TokenKind.EOF, bodyLength, bodyLength, line, col, prev2);
}
function unexpectedCharacterMessage(code2) {
  if (code2 < 32 && code2 !== 9 && code2 !== 10 && code2 !== 13) {
    return "Cannot contain the invalid character ".concat(printCharCode(code2), ".");
  }
  if (code2 === 39) {
    return `Unexpected single quote character ('), did you mean to use a double quote (")?`;
  }
  return "Cannot parse the unexpected character ".concat(printCharCode(code2), ".");
}
function readComment(source, start2, line, col, prev2) {
  var body = source.body;
  var code2;
  var position = start2;
  do {
    code2 = body.charCodeAt(++position);
  } while (!isNaN(code2) && // SourceCharacter but not LineTerminator
  (code2 > 31 || code2 === 9));
  return new Token(TokenKind.COMMENT, start2, position, line, col, prev2, body.slice(start2 + 1, position));
}
function readNumber(source, start2, firstCode, line, col, prev2) {
  var body = source.body;
  var code2 = firstCode;
  var position = start2;
  var isFloat = false;
  if (code2 === 45) {
    code2 = body.charCodeAt(++position);
  }
  if (code2 === 48) {
    code2 = body.charCodeAt(++position);
    if (code2 >= 48 && code2 <= 57) {
      throw syntaxError(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code2), "."));
    }
  } else {
    position = readDigits(source, position, code2);
    code2 = body.charCodeAt(position);
  }
  if (code2 === 46) {
    isFloat = true;
    code2 = body.charCodeAt(++position);
    position = readDigits(source, position, code2);
    code2 = body.charCodeAt(position);
  }
  if (code2 === 69 || code2 === 101) {
    isFloat = true;
    code2 = body.charCodeAt(++position);
    if (code2 === 43 || code2 === 45) {
      code2 = body.charCodeAt(++position);
    }
    position = readDigits(source, position, code2);
    code2 = body.charCodeAt(position);
  }
  if (code2 === 46 || isNameStart(code2)) {
    throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code2), "."));
  }
  return new Token(isFloat ? TokenKind.FLOAT : TokenKind.INT, start2, position, line, col, prev2, body.slice(start2, position));
}
function readDigits(source, start2, firstCode) {
  var body = source.body;
  var position = start2;
  var code2 = firstCode;
  if (code2 >= 48 && code2 <= 57) {
    do {
      code2 = body.charCodeAt(++position);
    } while (code2 >= 48 && code2 <= 57);
    return position;
  }
  throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code2), "."));
}
function readString(source, start2, line, col, prev2) {
  var body = source.body;
  var position = start2 + 1;
  var chunkStart = position;
  var code2 = 0;
  var value = "";
  while (position < body.length && !isNaN(code2 = body.charCodeAt(position)) && // not LineTerminator
  code2 !== 10 && code2 !== 13) {
    if (code2 === 34) {
      value += body.slice(chunkStart, position);
      return new Token(TokenKind.STRING, start2, position + 1, line, col, prev2, value);
    }
    if (code2 < 32 && code2 !== 9) {
      throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code2), "."));
    }
    ++position;
    if (code2 === 92) {
      value += body.slice(chunkStart, position - 1);
      code2 = body.charCodeAt(position);
      switch (code2) {
        case 34:
          value += '"';
          break;
        case 47:
          value += "/";
          break;
        case 92:
          value += "\\";
          break;
        case 98:
          value += "\b";
          break;
        case 102:
          value += "\f";
          break;
        case 110:
          value += "\n";
          break;
        case 114:
          value += "\r";
          break;
        case 116:
          value += "	";
          break;
        case 117: {
          var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));
          if (charCode < 0) {
            var invalidSequence = body.slice(position + 1, position + 5);
            throw syntaxError(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
          }
          value += String.fromCharCode(charCode);
          position += 4;
          break;
        }
        default:
          throw syntaxError(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code2), "."));
      }
      ++position;
      chunkStart = position;
    }
  }
  throw syntaxError(source, position, "Unterminated string.");
}
function readBlockString(source, start2, line, col, prev2, lexer) {
  var body = source.body;
  var position = start2 + 3;
  var chunkStart = position;
  var code2 = 0;
  var rawValue = "";
  while (position < body.length && !isNaN(code2 = body.charCodeAt(position))) {
    if (code2 === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      rawValue += body.slice(chunkStart, position);
      return new Token(TokenKind.BLOCK_STRING, start2, position + 3, line, col, prev2, dedentBlockStringValue(rawValue));
    }
    if (code2 < 32 && code2 !== 9 && code2 !== 10 && code2 !== 13) {
      throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code2), "."));
    }
    if (code2 === 10) {
      ++position;
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code2 === 13) {
      if (body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      ++lexer.line;
      lexer.lineStart = position;
    } else if (
      // Escape Triple-Quote (\""")
      code2 === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34
    ) {
      rawValue += body.slice(chunkStart, position) + '"""';
      position += 4;
      chunkStart = position;
    } else {
      ++position;
    }
  }
  throw syntaxError(source, position, "Unterminated string.");
}
function uniCharCode(a2, b2, c2, d2) {
  return char2hex(a2) << 12 | char2hex(b2) << 8 | char2hex(c2) << 4 | char2hex(d2);
}
function char2hex(a2) {
  return a2 >= 48 && a2 <= 57 ? a2 - 48 : a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : -1;
}
function readName(source, start2, line, col, prev2) {
  var body = source.body;
  var bodyLength = body.length;
  var position = start2 + 1;
  var code2 = 0;
  while (position !== bodyLength && !isNaN(code2 = body.charCodeAt(position)) && (code2 === 95 || // _
  code2 >= 48 && code2 <= 57 || // 0-9
  code2 >= 65 && code2 <= 90 || // A-Z
  code2 >= 97 && code2 <= 122)) {
    ++position;
  }
  return new Token(TokenKind.NAME, start2, position, line, col, prev2, body.slice(start2, position));
}
function isNameStart(code2) {
  return code2 === 95 || code2 >= 65 && code2 <= 90 || code2 >= 97 && code2 <= 122;
}
function parse$4(source, options2) {
  var parser2 = new Parser(source, options2);
  return parser2.parseDocument();
}
var Parser = /* @__PURE__ */ function() {
  function Parser2(source, options2) {
    var sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options2;
  }
  var _proto = Parser2.prototype;
  _proto.parseName = function parseName2() {
    var token = this.expectToken(TokenKind.NAME);
    return {
      kind: Kind.NAME,
      value: token.value,
      loc: this.loc(token)
    };
  };
  _proto.parseDocument = function parseDocument() {
    var start2 = this._lexer.token;
    return {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),
      loc: this.loc(start2)
    };
  };
  _proto.parseDefinition = function parseDefinition() {
    if (this.peek(TokenKind.NAME)) {
      switch (this._lexer.token.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "schema":
        case "scalar":
        case "type":
        case "interface":
        case "union":
        case "enum":
        case "input":
        case "directive":
          return this.parseTypeSystemDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    } else if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    } else if (this.peekDescription()) {
      return this.parseTypeSystemDefinition();
    }
    throw this.unexpected();
  };
  _proto.parseOperationDefinition = function parseOperationDefinition() {
    var start2 = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return {
        kind: Kind.OPERATION_DEFINITION,
        operation: "query",
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start2)
      };
    }
    var operation = this.parseOperationType();
    var name2;
    if (this.peek(TokenKind.NAME)) {
      name2 = this.parseName();
    }
    return {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name: name2,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start2)
    };
  };
  _proto.parseOperationType = function parseOperationType() {
    var operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return "query";
      case "mutation":
        return "mutation";
      case "subscription":
        return "subscription";
    }
    throw this.unexpected(operationToken);
  };
  _proto.parseVariableDefinitions = function parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  };
  _proto.parseVariableDefinition = function parseVariableDefinition() {
    var start2 = this._lexer.token;
    return {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0,
      directives: this.parseDirectives(true),
      loc: this.loc(start2)
    };
  };
  _proto.parseVariable = function parseVariable() {
    var start2 = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return {
      kind: Kind.VARIABLE,
      name: this.parseName(),
      loc: this.loc(start2)
    };
  };
  _proto.parseSelectionSet = function parseSelectionSet() {
    var start2 = this._lexer.token;
    return {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),
      loc: this.loc(start2)
    };
  };
  _proto.parseSelection = function parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  };
  _proto.parseField = function parseField() {
    var start2 = this._lexer.token;
    var nameOrAlias = this.parseName();
    var alias;
    var name2;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name2 = this.parseName();
    } else {
      name2 = nameOrAlias;
    }
    return {
      kind: Kind.FIELD,
      alias,
      name: name2,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,
      loc: this.loc(start2)
    };
  };
  _proto.parseArguments = function parseArguments(isConst) {
    var item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  };
  _proto.parseArgument = function parseArgument() {
    var start2 = this._lexer.token;
    var name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    return {
      kind: Kind.ARGUMENT,
      name: name2,
      value: this.parseValueLiteral(false),
      loc: this.loc(start2)
    };
  };
  _proto.parseConstArgument = function parseConstArgument() {
    var start2 = this._lexer.token;
    return {
      kind: Kind.ARGUMENT,
      name: this.parseName(),
      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),
      loc: this.loc(start2)
    };
  };
  _proto.parseFragment = function parseFragment() {
    var start2 = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    var hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false),
        loc: this.loc(start2)
      };
    }
    return {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start2)
    };
  };
  _proto.parseFragmentDefinition = function parseFragmentDefinition() {
    var _this$_options;
    var start2 = this._lexer.token;
    this.expectKeyword("fragment");
    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {
      return {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start2)
      };
    }
    return {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start2)
    };
  };
  _proto.parseFragmentName = function parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  };
  _proto.parseValueLiteral = function parseValueLiteral(isConst) {
    var token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this._lexer.advance();
        return {
          kind: Kind.INT,
          value: token.value,
          loc: this.loc(token)
        };
      case TokenKind.FLOAT:
        this._lexer.advance();
        return {
          kind: Kind.FLOAT,
          value: token.value,
          loc: this.loc(token)
        };
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this._lexer.advance();
        switch (token.value) {
          case "true":
            return {
              kind: Kind.BOOLEAN,
              value: true,
              loc: this.loc(token)
            };
          case "false":
            return {
              kind: Kind.BOOLEAN,
              value: false,
              loc: this.loc(token)
            };
          case "null":
            return {
              kind: Kind.NULL,
              loc: this.loc(token)
            };
          default:
            return {
              kind: Kind.ENUM,
              value: token.value,
              loc: this.loc(token)
            };
        }
      case TokenKind.DOLLAR:
        if (!isConst) {
          return this.parseVariable();
        }
        break;
    }
    throw this.unexpected();
  };
  _proto.parseStringLiteral = function parseStringLiteral() {
    var token = this._lexer.token;
    this._lexer.advance();
    return {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING,
      loc: this.loc(token)
    };
  };
  _proto.parseList = function parseList(isConst) {
    var _this = this;
    var start2 = this._lexer.token;
    var item = function item2() {
      return _this.parseValueLiteral(isConst);
    };
    return {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),
      loc: this.loc(start2)
    };
  };
  _proto.parseObject = function parseObject(isConst) {
    var _this2 = this;
    var start2 = this._lexer.token;
    var item = function item2() {
      return _this2.parseObjectField(isConst);
    };
    return {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),
      loc: this.loc(start2)
    };
  };
  _proto.parseObjectField = function parseObjectField(isConst) {
    var start2 = this._lexer.token;
    var name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    return {
      kind: Kind.OBJECT_FIELD,
      name: name2,
      value: this.parseValueLiteral(isConst),
      loc: this.loc(start2)
    };
  };
  _proto.parseDirectives = function parseDirectives(isConst) {
    var directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  };
  _proto.parseDirective = function parseDirective(isConst) {
    var start2 = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst),
      loc: this.loc(start2)
    };
  };
  _proto.parseTypeReference = function parseTypeReference() {
    var start2 = this._lexer.token;
    var type2;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      type2 = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type2 = {
        kind: Kind.LIST_TYPE,
        type: type2,
        loc: this.loc(start2)
      };
    } else {
      type2 = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return {
        kind: Kind.NON_NULL_TYPE,
        type: type2,
        loc: this.loc(start2)
      };
    }
    return type2;
  };
  _proto.parseNamedType = function parseNamedType() {
    var start2 = this._lexer.token;
    return {
      kind: Kind.NAMED_TYPE,
      name: this.parseName(),
      loc: this.loc(start2)
    };
  };
  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
    }
    throw this.unexpected(keywordToken);
  };
  _proto.peekDescription = function peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  };
  _proto.parseDescription = function parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  };
  _proto.parseSchemaDefinition = function parseSchemaDefinition() {
    var start2 = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("schema");
    var directives = this.parseDirectives(true);
    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes,
      loc: this.loc(start2)
    };
  };
  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
    var start2 = this._lexer.token;
    var operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    var type2 = this.parseNamedType();
    return {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type: type2,
      loc: this.loc(start2)
    };
  };
  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
    var start2 = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("scalar");
    var name2 = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name: name2,
      directives,
      loc: this.loc(start2)
    };
  };
  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
    var start2 = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("type");
    var name2 = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name: name2,
      interfaces,
      directives,
      fields,
      loc: this.loc(start2)
    };
  };
  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
    var _this$_options2;
    if (!this.expectOptionalKeyword("implements")) {
      return [];
    }
    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {
      var types = [];
      this.expectOptionalToken(TokenKind.AMP);
      do {
        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));
      return types;
    }
    return this.delimitedMany(TokenKind.AMP, this.parseNamedType);
  };
  _proto.parseFieldsDefinition = function parseFieldsDefinition() {
    var _this$_options3;
    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {
      this._lexer.advance();
      this._lexer.advance();
      return [];
    }
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  };
  _proto.parseFieldDefinition = function parseFieldDefinition() {
    var start2 = this._lexer.token;
    var description = this.parseDescription();
    var name2 = this.parseName();
    var args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    var type2 = this.parseTypeReference();
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.FIELD_DEFINITION,
      description,
      name: name2,
      arguments: args,
      type: type2,
      directives,
      loc: this.loc(start2)
    };
  };
  _proto.parseArgumentDefs = function parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  };
  _proto.parseInputValueDef = function parseInputValueDef() {
    var start2 = this._lexer.token;
    var description = this.parseDescription();
    var name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    var type2 = this.parseTypeReference();
    var defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseValueLiteral(true);
    }
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name: name2,
      type: type2,
      defaultValue,
      directives,
      loc: this.loc(start2)
    };
  };
  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
    var start2 = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("interface");
    var name2 = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name: name2,
      interfaces,
      directives,
      fields,
      loc: this.loc(start2)
    };
  };
  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
    var start2 = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("union");
    var name2 = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    return {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name: name2,
      directives,
      types,
      loc: this.loc(start2)
    };
  };
  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  };
  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
    var start2 = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("enum");
    var name2 = this.parseName();
    var directives = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();
    return {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name: name2,
      directives,
      values,
      loc: this.loc(start2)
    };
  };
  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  };
  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
    var start2 = this._lexer.token;
    var description = this.parseDescription();
    var name2 = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name: name2,
      directives,
      loc: this.loc(start2)
    };
  };
  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
    var start2 = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("input");
    var name2 = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();
    return {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name: name2,
      directives,
      fields,
      loc: this.loc(start2)
    };
  };
  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  };
  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
    var keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  };
  _proto.parseSchemaExtension = function parseSchemaExtension() {
    var start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    var directives = this.parseDirectives(true);
    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes,
      loc: this.loc(start2)
    };
  };
  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
    var start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    var name2 = this.parseName();
    var directives = this.parseDirectives(true);
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name: name2,
      directives,
      loc: this.loc(start2)
    };
  };
  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
    var start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    var name2 = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name: name2,
      interfaces,
      directives,
      fields,
      loc: this.loc(start2)
    };
  };
  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
    var start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    var name2 = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name: name2,
      interfaces,
      directives,
      fields,
      loc: this.loc(start2)
    };
  };
  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
    var start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    var name2 = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.UNION_TYPE_EXTENSION,
      name: name2,
      directives,
      types,
      loc: this.loc(start2)
    };
  };
  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
    var start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    var name2 = this.parseName();
    var directives = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name: name2,
      directives,
      values,
      loc: this.loc(start2)
    };
  };
  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
    var start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    var name2 = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name: name2,
      directives,
      fields,
      loc: this.loc(start2)
    };
  };
  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
    var start2 = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    var name2 = this.parseName();
    var args = this.parseArgumentDefs();
    var repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    var locations = this.parseDirectiveLocations();
    return {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name: name2,
      arguments: args,
      repeatable,
      locations,
      loc: this.loc(start2)
    };
  };
  _proto.parseDirectiveLocations = function parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  };
  _proto.parseDirectiveLocation = function parseDirectiveLocation() {
    var start2 = this._lexer.token;
    var name2 = this.parseName();
    if (DirectiveLocation[name2.value] !== void 0) {
      return name2;
    }
    throw this.unexpected(start2);
  };
  _proto.loc = function loc(startToken) {
    var _this$_options4;
    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {
      return new Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
  };
  _proto.peek = function peek(kind) {
    return this._lexer.token.kind === kind;
  };
  _proto.expectToken = function expectToken(kind) {
    var token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    throw syntaxError(this._lexer.source, token.start, "Expected ".concat(getTokenKindDesc(kind), ", found ").concat(getTokenDesc(token), "."));
  };
  _proto.expectOptionalToken = function expectOptionalToken(kind) {
    var token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    return void 0;
  };
  _proto.expectKeyword = function expectKeyword(value) {
    var token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this._lexer.advance();
    } else {
      throw syntaxError(this._lexer.source, token.start, 'Expected "'.concat(value, '", found ').concat(getTokenDesc(token), "."));
    }
  };
  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
    var token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this._lexer.advance();
      return true;
    }
    return false;
  };
  _proto.unexpected = function unexpected(atToken) {
    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token), "."));
  };
  _proto.any = function any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  };
  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      var nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  };
  _proto.many = function many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  };
  _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    var nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  };
  return Parser2;
}();
function getTokenDesc(token) {
  var value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ' "'.concat(value, '"') : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? '"'.concat(kind, '"') : kind;
}
function l$1(a2, b2) {
  b2.tag = a2;
  return b2;
}
function m() {
}
function p$1(a2) {
  return function(b2) {
    var c2 = a2.length;
    let d2 = false, e = false, f2 = false, g = 0;
    b2(
      l$1(0, [
        function(h2) {
          if (h2) {
            d2 = true;
          } else if (e) {
            f2 = true;
          } else {
            for (e = f2 = true; f2 && !d2; ) {
              g < c2 ? (h2 = a2[g], g = g + 1 | 0, f2 = false, b2(l$1(1, [h2]))) : (d2 = true, b2(0));
            }
            e = false;
          }
        }
      ])
    );
  };
}
function r() {
}
function t(a2) {
  a2(0);
}
function u$1(a2) {
  let b2 = false;
  a2(
    l$1(0, [
      function(c2) {
        c2 ? b2 = true : b2 || a2(0);
      }
    ])
  );
}
function C(a2) {
  return a2(0);
}
function D$1(a2) {
  return function(b2) {
    return function(c2) {
      let e = m, f2 = false, g = [], h2 = false;
      b2(function(b3) {
        "number" == typeof b3 ? h2 || (h2 = true, 0 === g.length && c2(0)) : b3.tag ? h2 || (f2 = false, function(a3) {
          function b4(a4) {
            "number" == typeof a4 ? 0 !== g.length && (g = g.filter(d2), a4 = 0 === g.length, h2 && a4 ? c2(0) : !f2 && a4 && (f2 = true, e(0))) : a4.tag ? 0 !== g.length && (c2(l$1(1, [a4[0]])), k(0)) : (k = a4 = a4[0], g = g.concat(a4), a4(0));
          }
          function d2(a4) {
            return a4 !== k;
          }
          let k = m;
          1 === a3.length ? a3(b4) : a3.bind(null, b4);
        }(a2(b3[0])), f2 || (f2 = true, e(0))) : e = b3[0];
      });
      c2(
        l$1(0, [
          function(a3) {
            a3 ? (h2 || (h2 = true, e(a3)), g.forEach(function(c3) {
              return c3(a3);
            }), g = []) : (f2 || h2 ? f2 = false : (f2 = true, e(0)), g.forEach(C));
          }
        ])
      );
    };
  };
}
function E$1(a2) {
  return a2;
}
function H(a2) {
  return function(b2) {
    return function(c2) {
      let d2 = false;
      return b2(function(e) {
        if ("number" == typeof e) {
          d2 || (d2 = true, c2(e));
        } else if (e.tag) {
          d2 || (a2(e[0]), c2(e));
        } else {
          var g = e[0];
          c2(
            l$1(0, [
              function(a3) {
                if (!d2) {
                  return a3 && (d2 = true), g(a3);
                }
              }
            ])
          );
        }
      });
    };
  };
}
function J$1(a2) {
  a2(0);
}
function K(a2) {
  return function(b2) {
    return function(c2) {
      function d2(a3) {
        h2 && ("number" == typeof a3 ? (h2 = false, n ? c2(a3) : f2 || (f2 = true, e(0))) : a3.tag ? (c2(a3), k ? k = false : g(0)) : (g = a3 = a3[0], k = false, a3(0)));
      }
      let e = m, f2 = false, g = m, h2 = false, k = false, n = false;
      b2(function(b3) {
        "number" == typeof b3 ? n || (n = true, h2 || c2(0)) : b3.tag ? n || (h2 && (g(1), g = m), f2 ? f2 = false : (f2 = true, e(0)), b3 = a2(b3[0]), h2 = true, b3(d2)) : e = b3[0];
      });
      c2(
        l$1(0, [
          function(a3) {
            if (a3) {
              if (n || (n = true, e(1)), h2) {
                return h2 = false, g(1);
              }
            } else {
              n || f2 || (f2 = true, e(0)), h2 && !k && (k = true, g(0));
            }
          }
        ])
      );
    };
  };
}
function M(a2) {
  return function(b2) {
    return function(c2) {
      let d2 = [], e = m;
      return b2(function(b3) {
        "number" == typeof b3 ? p$1(d2)(c2) : b3.tag ? (d2.length >= a2 && 0 < a2 && d2.shift(), d2.push(b3[0]), e(0)) : (b3 = b3[0], 0 >= a2 ? (b3(1), u$1(c2)) : (e = b3, b3(0)));
      });
    };
  };
}
function N$1(a2) {
  return function(b2) {
    let c2 = m, d2 = false;
    b2(function(e) {
      "number" == typeof e ? d2 = true : e.tag ? d2 || (a2(e[0]), c2(0)) : (c2 = e = e[0], e(0));
    });
    return {
      unsubscribe: function() {
        if (!d2) {
          return d2 = true, c2(1);
        }
      }
    };
  };
}
function O() {
}
function buffer$1(a2) {
  return function(b2) {
    return function(c2) {
      function d2(a3) {
        "number" == typeof a3 ? k || (k = true, f2(1), 0 < e.length && c2(l$1(1, [e])), c2(0)) : a3.tag ? !k && 0 < e.length && (a3 = e, e = [], c2(l$1(1, [a3]))) : g = a3[0];
      }
      let e = [], f2 = m, g = m, h2 = false, k = false;
      b2(function(b3) {
        "number" == typeof b3 ? k || (k = true, g(1), 0 < e.length && c2(l$1(1, [e])), c2(0)) : b3.tag ? k || (e.push(b3[0]), h2 ? h2 = false : (h2 = true, f2(0), g(0))) : (f2 = b3[0], a2(d2));
      });
      c2(
        l$1(0, [
          function(a3) {
            if (!k) {
              if (a3) {
                return k = true, f2(1), g(1);
              }
              if (!h2) {
                return h2 = true, f2(0), g(0);
              }
            }
          }
        ])
      );
    };
  };
}
function filter$1(a2) {
  return function(b2) {
    return function(c2) {
      let d2 = m;
      return b2(function(b3) {
        "number" == typeof b3 ? c2(b3) : b3.tag ? a2(b3[0]) ? c2(b3) : d2(0) : (d2 = b3[0], c2(b3));
      });
    };
  };
}
function fromPromise$1(a2) {
  return function(b2) {
    let c2 = false;
    a2.then(function(a3) {
      c2 || (b2(l$1(1, [a3])), b2(0));
      return Promise.resolve(void 0);
    });
    b2(
      l$1(0, [
        function(a3) {
          a3 && (c2 = true);
        }
      ])
    );
  };
}
function fromValue$1(a2) {
  return function(b2) {
    let c2 = false;
    b2(
      l$1(0, [
        function(d2) {
          d2 ? c2 = true : c2 || (c2 = true, b2(l$1(1, [a2])), b2(0));
        }
      ])
    );
  };
}
function make$1(a2) {
  return function(b2) {
    let c2 = r, d2 = false;
    c2 = a2({
      next: function(a3) {
        d2 || b2(l$1(1, [a3]));
      },
      complete: function() {
        d2 || (d2 = true, b2(0));
      }
    });
    b2(
      l$1(0, [
        function(a3) {
          if (a3 && !d2) {
            return d2 = true, c2();
          }
        }
      ])
    );
  };
}
function makeSubject$1() {
  let a2 = [], b2 = false;
  return {
    source: function(c2) {
      function b3(a3) {
        return a3 !== c2;
      }
      a2 = a2.concat(c2);
      c2(
        l$1(0, [
          function(c3) {
            c3 && (a2 = a2.filter(b3));
          }
        ])
      );
    },
    next: function(c2) {
      b2 || a2.forEach(function(a3) {
        a3(l$1(1, [c2]));
      });
    },
    complete: function() {
      b2 || (b2 = true, a2.forEach(t));
    }
  };
}
function map$1(a2) {
  return function(b2) {
    return function(c2) {
      return b2(function(b3) {
        b3 = "number" == typeof b3 ? 0 : b3.tag ? l$1(1, [a2(b3[0])]) : l$1(0, [b3[0]]);
        c2(b3);
      });
    };
  };
}
function merge$1(a2) {
  return D$1(E$1)(p$1(a2));
}
function onEnd$1(a2) {
  return function(b2) {
    return function(c2) {
      let d2 = false;
      return b2(function(b3) {
        if ("number" == typeof b3) {
          if (d2) {
            return;
          }
          d2 = true;
          c2(b3);
          return a2();
        }
        if (b3.tag) {
          d2 || c2(b3);
        } else {
          var e = b3[0];
          c2(
            l$1(0, [
              function(c3) {
                if (!d2) {
                  return c3 ? (d2 = true, e(c3), a2()) : e(c3);
                }
              }
            ])
          );
        }
      });
    };
  };
}
function onStart$1(a2) {
  return function(b2) {
    return function(c2) {
      return b2(function(b3) {
        "number" == typeof b3 ? c2(b3) : b3.tag ? c2(b3) : (c2(b3), a2());
      });
    };
  };
}
function pipe() {
  for (var a2 = arguments, b2 = arguments[0], c2 = 1, d2 = arguments.length; c2 < d2; c2++) {
    b2 = a2[c2](b2);
  }
  return b2;
}
function publish$1(a2) {
  return N$1(O)(a2);
}
function share$1(a2) {
  function b2(a3) {
    "number" == typeof a3 ? (c2.forEach(J$1), c2 = []) : a3.tag ? (e = false, c2.forEach(function(b3) {
      b3(a3);
    })) : d2 = a3[0];
  }
  let c2 = [], d2 = m, e = false;
  return function(f2) {
    function g(a3) {
      return a3 !== f2;
    }
    c2 = c2.concat(f2);
    1 === c2.length && a2(b2);
    f2(
      l$1(0, [
        function(a3) {
          if (a3) {
            if (c2 = c2.filter(g), 0 === c2.length) {
              return d2(1);
            }
          } else {
            e || (e = true, d2(a3));
          }
        }
      ])
    );
  };
}
function skipUntil$1(a2) {
  return function(b2) {
    return function(c2) {
      function d2(a3) {
        "number" == typeof a3 ? g && (k = true, e(1)) : a3.tag ? (g = false, f2(1)) : (f2 = a3 = a3[0], a3(0));
      }
      let e = m, f2 = m, g = true, h2 = false, k = false;
      b2(function(b3) {
        "number" == typeof b3 ? (g && f2(1), k = true, c2(0)) : b3.tag ? g || k ? h2 ? h2 = false : (h2 = true, e(0), f2(0)) : (h2 = false, c2(b3)) : (e = b3[0], a2(d2));
      });
      c2(
        l$1(0, [
          function(a3) {
            if (!k) {
              if (a3) {
                if (k = true, e(1), g) {
                  return f2(1);
                }
              } else {
                h2 || (h2 = true, g && f2(0), e(0));
              }
            }
          }
        ])
      );
    };
  };
}
function take$1(a2) {
  return function(b2) {
    return function(c2) {
      let d2 = false, e = 0, f2 = m;
      b2(function(b3) {
        "number" == typeof b3 ? d2 || (d2 = true, c2(0)) : b3.tag ? e < a2 && !d2 && (e = e + 1 | 0, c2(b3), !d2 && e >= a2 && (d2 = true, c2(0), f2(1))) : (b3 = b3[0], 0 >= a2 ? (d2 = true, c2(0), b3(1)) : f2 = b3);
      });
      c2(
        l$1(0, [
          function(b3) {
            if (!d2) {
              if (b3) {
                return d2 = true, f2(1);
              }
              if (e < a2) {
                return f2(0);
              }
            }
          }
        ])
      );
    };
  };
}
function takeUntil$1(a2) {
  return function(b2) {
    return function(c2) {
      function d2(a3) {
        "number" != typeof a3 && (a3.tag ? (e = true, f2(1), c2(0)) : (g = a3 = a3[0], a3(0)));
      }
      let e = false, f2 = m, g = m;
      b2(function(b3) {
        "number" == typeof b3 ? e || (e = true, g(1), c2(0)) : b3.tag ? e || c2(b3) : (f2 = b3[0], a2(d2));
      });
      c2(
        l$1(0, [
          function(a3) {
            if (!e) {
              return a3 ? (e = true, f2(1), g(1)) : f2(0);
            }
          }
        ])
      );
    };
  };
}
function toPromise$1(a2) {
  return new Promise(function(b2) {
    M(1)(a2)(function(a3) {
      if ("number" != typeof a3) {
        if (a3.tag) {
          b2(a3[0]);
        } else {
          a3[0](0);
        }
      }
    });
  });
}
"function" == typeof Symbol ? Symbol.observable || (Symbol.observable = Symbol("observable")) : "@@observable";
function rehydrateGraphQlError(r2) {
  if ("string" == typeof r2) {
    return new GraphQLError(r2);
  } else if ("object" == typeof r2 && r2.message) {
    return new GraphQLError(r2.message, r2.nodes, r2.source, r2.positions, r2.path, r2, r2.extensions || {});
  } else {
    return r2;
  }
}
var o = function(e) {
  function CombinedError(r2) {
    var t2 = r2.networkError;
    var n = r2.response;
    var a2 = (r2.graphQLErrors || []).map(rehydrateGraphQlError);
    var o2 = function generateErrorMessage(e2, r3) {
      var t3 = "";
      if (void 0 !== e2) {
        return t3 = "[Network] " + e2.message;
      }
      if (void 0 !== r3) {
        r3.forEach(function(e3) {
          t3 += "[GraphQL] " + e3.message + "\n";
        });
      }
      return t3.trim();
    }(t2, a2);
    e.call(this, o2);
    this.name = "CombinedError";
    this.message = o2;
    this.graphQLErrors = a2;
    this.networkError = t2;
    this.response = n;
  }
  if (e) {
    CombinedError.__proto__ = e;
  }
  (CombinedError.prototype = Object.create(e && e.prototype)).constructor = CombinedError;
  CombinedError.prototype.toString = function toString2() {
    return this.message;
  };
  return CombinedError;
}(Error);
function phash(e, r2) {
  e |= 0;
  for (var t2 = 0, n = 0 | r2.length; t2 < n; t2++) {
    e = (e << 5) + e + r2.charCodeAt(t2);
  }
  return e;
}
function hash$3(e) {
  return phash(5381, e) >>> 0;
}
var i$2 = /* @__PURE__ */ new Set();
var s = /* @__PURE__ */ new WeakMap();
function stringify$2(e) {
  if (null === e || i$2.has(e)) {
    return "null";
  } else if ("object" != typeof e) {
    return JSON.stringify(e) || "";
  } else if (e.toJSON) {
    return stringify$2(e.toJSON());
  } else if (Array.isArray(e)) {
    var r2 = "[";
    for (var t2 = 0, n = e.length; t2 < n; t2++) {
      if (t2 > 0) {
        r2 += ",";
      }
      var a2 = stringify$2(e[t2]);
      r2 += a2.length > 0 ? a2 : "null";
    }
    return r2 += "]";
  }
  var o2 = Object.keys(e).sort();
  if (!o2.length && e.constructor && e.constructor !== Object) {
    var u2 = s.get(e) || Math.random().toString(36).slice(2);
    s.set(e, u2);
    return '{"__key":"' + u2 + '"}';
  }
  i$2.add(e);
  var f2 = "{";
  for (var c2 = 0, l2 = o2.length; c2 < l2; c2++) {
    var h2 = o2[c2];
    var p2 = stringify$2(e[h2]);
    if (p2) {
      if (f2.length > 1) {
        f2 += ",";
      }
      f2 += stringify$2(h2) + ":" + p2;
    }
  }
  i$2.delete(e);
  return f2 += "}";
}
function stringifyVariables(e) {
  i$2.clear();
  return stringify$2(e);
}
var u = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;
var f = /([\s,]|#[^\n\r]+)+/g;
function replaceOutsideStrings(e, r2) {
  return r2 % 2 == 0 ? e.replace(f, " ").trim() : e;
}
function stringifyDocument(e) {
  var r2 = ("string" != typeof e ? e.loc && e.loc.source.body || print$1(e) : e).split(u).map(replaceOutsideStrings).join("");
  if ("string" != typeof e) {
    var t2 = "definitions" in e && getOperationName$1(e);
    if (t2) {
      r2 = "# " + t2 + "\n" + r2;
    }
    if (!e.loc) {
      e.loc = {
        start: 0,
        end: r2.length,
        source: {
          body: r2,
          name: "gql",
          locationOffset: {
            line: 1,
            column: 1
          }
        }
      };
    }
  }
  return r2;
}
var c = /* @__PURE__ */ new Map();
function keyDocument(e) {
  var r2;
  var n;
  if ("string" == typeof e) {
    r2 = hash$3(stringifyDocument(e));
    n = c.get(r2) || parse$4(e, {
      noLocation: true
    });
  } else {
    r2 = e.__key || hash$3(stringifyDocument(e));
    n = c.get(r2) || e;
  }
  if (!n.loc) {
    stringifyDocument(n);
  }
  n.__key = r2;
  c.set(r2, n);
  return n;
}
function createRequest(e, r2) {
  if (!r2) {
    r2 = {};
  }
  var t2 = keyDocument(e);
  return {
    key: phash(t2.__key, stringifyVariables(r2)) >>> 0,
    query: t2,
    variables: r2
  };
}
function getOperationName$1(e) {
  for (var t2 = 0, n = e.definitions.length; t2 < n; t2++) {
    var a2 = e.definitions[t2];
    if (a2.kind === Kind.OPERATION_DEFINITION && a2.name) {
      return a2.name.value;
    }
  }
}
function getOperationType(e) {
  for (var t2 = 0, n = e.definitions.length; t2 < n; t2++) {
    var a2 = e.definitions[t2];
    if (a2.kind === Kind.OPERATION_DEFINITION) {
      return a2.operation;
    }
  }
}
function _extends$3() {
  return (_extends$3 = Object.assign || function(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = arguments[r2];
      for (var n in t2) {
        if (Object.prototype.hasOwnProperty.call(t2, n)) {
          e[n] = t2[n];
        }
      }
    }
    return e;
  }).apply(this, arguments);
}
function makeResult(e, r2, t2) {
  if (!("data" in r2) && !("errors" in r2) || "path" in r2) {
    throw new Error("No Content");
  }
  return {
    operation: e,
    data: r2.data,
    error: Array.isArray(r2.errors) ? new o({
      graphQLErrors: r2.errors,
      response: t2
    }) : void 0,
    extensions: "object" == typeof r2.extensions && r2.extensions || void 0,
    hasNext: !!r2.hasNext
  };
}
function mergeResultPatch(e, r2, t2) {
  var n = _extends$3({}, e);
  n.hasNext = !!r2.hasNext;
  if (!("path" in r2)) {
    if ("data" in r2) {
      n.data = r2.data;
    }
    return n;
  }
  if (Array.isArray(r2.errors)) {
    n.error = new o({
      graphQLErrors: n.error ? n.error.graphQLErrors.concat(r2.errors) : r2.errors,
      response: t2
    });
  }
  var a2 = n.data = _extends$3({}, n.data);
  var i = 0;
  var s2;
  while (i < r2.path.length) {
    a2 = a2[s2 = r2.path[i++]] = Array.isArray(a2[s2]) ? [].concat(a2[s2]) : _extends$3({}, a2[s2]);
  }
  _extends$3(a2, r2.data);
  return n;
}
function makeErrorResult(e, r2, t2) {
  return {
    operation: e,
    data: void 0,
    error: new o({
      networkError: r2,
      response: t2
    }),
    extensions: void 0
  };
}
function shouldUseGet(e) {
  return "query" === e.kind && !!e.context.preferGetMethod;
}
function makeFetchBody(e) {
  return {
    query: print$1(e.query),
    operationName: getOperationName$1(e.query),
    variables: e.variables || void 0,
    extensions: void 0
  };
}
function makeFetchURL(e, r2) {
  var t2 = shouldUseGet(e);
  var n = e.context.url;
  if (!t2 || !r2) {
    return n;
  }
  var a2 = [];
  if (r2.operationName) {
    a2.push("operationName=" + encodeURIComponent(r2.operationName));
  }
  if (r2.query) {
    a2.push("query=" + encodeURIComponent(r2.query.replace(/#[^\n\r]+/g, " ").trim()));
  }
  if (r2.variables) {
    a2.push("variables=" + encodeURIComponent(stringifyVariables(r2.variables)));
  }
  if (r2.extensions) {
    a2.push("extensions=" + encodeURIComponent(stringifyVariables(r2.extensions)));
  }
  var o2 = n + "?" + a2.join("&");
  if (o2.length > 2047) {
    e.context.preferGetMethod = false;
    return n;
  }
  return o2;
}
function makeFetchOptions(e, r2) {
  var t2 = shouldUseGet(e);
  var n = "function" == typeof e.context.fetchOptions ? e.context.fetchOptions() : e.context.fetchOptions || {};
  return _extends$3({}, n, {
    body: !t2 && r2 ? JSON.stringify(r2) : void 0,
    method: t2 ? "GET" : "POST",
    headers: t2 ? n.headers : _extends$3({}, {
      "content-type": "application/json"
    }, n.headers)
  });
}
var l = "undefined" != typeof Symbol ? Symbol.asyncIterator : null;
var h = "undefined" != typeof TextDecoder ? new TextDecoder() : null;
var p = /content-type:[^\r\n]*application\/json/i;
var d = /boundary="?([^=";]+)"?/i;
function makeFetchSource(e, r2, t2) {
  var n = "manual" === t2.redirect ? 400 : 300;
  var o2 = e.context.fetch;
  return make$1(function(a2) {
    var i = a2.next;
    var s2 = a2.complete;
    var u2 = "undefined" != typeof AbortController ? new AbortController() : null;
    if (u2) {
      t2.signal = u2.signal;
    }
    var f2 = false;
    function executeIncrementalFetch(e2, r3, t3) {
      var n2 = t3.headers && t3.headers.get("Content-Type") || "";
      if (!/multipart\/mixed/i.test(n2)) {
        return t3.json().then(function(n3) {
          var a4 = makeResult(r3, n3, t3);
          f2 = true;
          e2(a4);
        });
      }
      var a3 = "---";
      var o3 = n2.match(d);
      if (o3) {
        a3 = "--" + o3[1];
      }
      var i2;
      var cancel = function() {
      };
      if (l && t3[l]) {
        var s3 = t3[l]();
        i2 = s3.next.bind(s3);
      } else if ("body" in t3 && t3.body) {
        var u3 = t3.body.getReader();
        cancel = u3.cancel.bind(u3);
        i2 = u3.read.bind(u3);
      } else {
        throw new TypeError("Streaming requests unsupported");
      }
      var c3 = "";
      var v2 = true;
      var m3 = null;
      var g = null;
      return i2().then(function next(n3) {
        if (!n3.done) {
          var o4 = function toString2(e3) {
            return "Buffer" === e3.constructor.name ? e3.toString() : h.decode(e3);
          }(n3.value);
          var s4 = o4.indexOf(a3);
          if (s4 > -1) {
            s4 += c3.length;
          } else {
            s4 = c3.indexOf(a3);
          }
          c3 += o4;
          while (s4 > -1) {
            var u4 = c3.slice(0, s4);
            var l2 = c3.slice(s4 + a3.length);
            if (v2) {
              v2 = false;
            } else {
              var d2 = u4.indexOf("\r\n\r\n") + 4;
              var y2 = u4.slice(0, d2);
              var x2 = u4.slice(d2, u4.lastIndexOf("\r\n"));
              var b2 = void 0;
              if (p.test(y2)) {
                try {
                  b2 = JSON.parse(x2);
                  m3 = g = g ? mergeResultPatch(g, b2, t3) : makeResult(r3, b2, t3);
                } catch (e3) {
                }
              }
              if ("--" === l2.slice(0, 2) || b2 && !b2.hasNext) {
                if (!g) {
                  return e2(makeResult(r3, {}, t3));
                }
                break;
              }
            }
            s4 = (c3 = l2).indexOf(a3);
          }
        } else {
          f2 = true;
        }
        if (m3) {
          e2(m3);
          m3 = null;
        }
        if (!n3.done && (!g || g.hasNext)) {
          return i2().then(next);
        }
      }).finally(cancel);
    }
    var c2 = false;
    var v = false;
    var m2;
    Promise.resolve().then(function() {
      if (c2) {
        return;
      }
      return (o2 || fetch)(r2, t2);
    }).then(function(r3) {
      if (!r3) {
        return;
      }
      v = (m2 = r3).status < 200 || m2.status >= n;
      return executeIncrementalFetch(i, e, m2);
    }).then(s2).catch(function(r3) {
      if (f2) {
        throw r3;
      }
      if ("AbortError" !== r3.name) {
        var t3 = makeErrorResult(e, v ? new Error(m2.statusText) : r3, m2);
        i(t3);
        s2();
      }
    });
    return function() {
      c2 = true;
      if (u2) {
        u2.abort();
      }
    };
  });
}
function collectTypes(e2, n2) {
  if (Array.isArray(e2)) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      collectTypes(e2[r2], n2);
    }
  } else if ("object" == typeof e2 && null !== e2) {
    for (var t2 in e2) {
      if ("__typename" === t2 && "string" == typeof e2[t2]) {
        n2[e2[t2]] = 0;
      } else {
        collectTypes(e2[t2], n2);
      }
    }
  }
  return n2;
}
function collectTypesFromResponse(e2) {
  return Object.keys(collectTypes(e2, {}));
}
var formatNode = function(e2) {
  if (e2.selectionSet && !e2.selectionSet.selections.some(function(e3) {
    return e3.kind === Kind.FIELD && "__typename" === e3.name.value && !e3.alias;
  })) {
    return _extends$3({}, e2, {
      selectionSet: _extends$3({}, e2.selectionSet, {
        selections: e2.selectionSet.selections.concat([{
          kind: Kind.FIELD,
          name: {
            kind: Kind.NAME,
            value: "__typename"
          }
        }])
      })
    });
  }
};
var F$1 = /* @__PURE__ */ new Map();
function formatDocument(n2) {
  var r2 = keyDocument(n2);
  var a2 = F$1.get(r2.__key);
  if (!a2) {
    a2 = visit$1(r2, {
      Field: formatNode,
      InlineFragment: formatNode
    });
    Object.defineProperty(a2, "__key", {
      value: r2.__key,
      enumerable: false
    });
    F$1.set(r2.__key, a2);
  }
  return a2;
}
function maskTypename(e2) {
  if (!e2 || "object" != typeof e2) {
    return e2;
  }
  return Object.keys(e2).reduce(function(n2, r2) {
    var t2 = e2[r2];
    if ("__typename" === r2) {
      Object.defineProperty(n2, "__typename", {
        enumerable: false,
        value: t2
      });
    } else if (Array.isArray(t2)) {
      n2[r2] = t2.map(maskTypename);
    } else if (t2 && "object" == typeof t2 && "__typename" in t2) {
      n2[r2] = maskTypename(t2);
    } else {
      n2[r2] = t2;
    }
    return n2;
  }, Array.isArray(e2) ? [] : {});
}
function withPromise(e2) {
  e2.toPromise = function() {
    return new Promise(function(n2) {
      var r2 = N$1(function(e3) {
        if (!e3.stale && !e3.hasNext) {
          Promise.resolve().then(function() {
            r2.unsubscribe();
            n2(e3);
          });
        }
      })(e2);
    });
  };
  return e2;
}
function makeOperation(e2, n2, r2) {
  if (!r2) {
    r2 = n2.context;
  }
  return {
    key: n2.key,
    query: n2.query,
    variables: n2.variables,
    kind: e2,
    context: r2
  };
}
function addMetadata(e2, n2) {
  return makeOperation(e2.kind, e2, _extends$3({}, e2.context, {
    meta: _extends$3({}, e2.context.meta, n2)
  }));
}
function noop$6() {
}
function applyDefinitions(e2, r2, t2) {
  for (var a2 = 0; a2 < t2.length; a2++) {
    if (t2[a2].kind === Kind.FRAGMENT_DEFINITION) {
      var o2 = t2[a2].name.value;
      var i2 = stringifyDocument(t2[a2]);
      if (!e2.has(o2)) {
        e2.set(o2, i2);
        r2.push(t2[a2]);
      }
    } else {
      r2.push(t2[a2]);
    }
  }
}
function gql() {
  var e2 = arguments;
  var r2 = /* @__PURE__ */ new Map();
  var a2 = [];
  var o2 = [];
  var i2 = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || "";
  for (var u2 = 1; u2 < arguments.length; u2++) {
    var c2 = e2[u2];
    if (c2 && c2.definitions) {
      o2.push.apply(o2, c2.definitions);
    } else {
      i2 += c2;
    }
    i2 += e2[0][u2];
  }
  applyDefinitions(r2, a2, keyDocument(i2).definitions);
  applyDefinitions(r2, a2, o2);
  return keyDocument({
    kind: Kind.DOCUMENT,
    definitions: a2
  });
}
function shouldSkip(e2) {
  var n2 = e2.kind;
  return "mutation" !== n2 && "query" !== n2;
}
function cacheExchange$1(e2) {
  var n2 = e2.forward;
  var r2 = e2.client;
  e2.dispatchDebug;
  var a2 = /* @__PURE__ */ new Map();
  var i2 = /* @__PURE__ */ Object.create(null);
  function mapTypeNames(e3) {
    var n3 = makeOperation(e3.kind, e3);
    n3.query = formatDocument(e3.query);
    return n3;
  }
  function isOperationCached(e3) {
    var n3 = e3.context.requestPolicy;
    return "query" === e3.kind && "network-only" !== n3 && ("cache-only" === n3 || a2.has(e3.key));
  }
  return function(e3) {
    var u2 = share$1(e3);
    var c2 = map$1(function(e4) {
      var n3 = a2.get(e4.key);
      var i3 = _extends$3({}, n3, {
        operation: addMetadata(e4, {
          cacheOutcome: n3 ? "hit" : "miss"
        })
      });
      if ("cache-and-network" === e4.context.requestPolicy) {
        i3.stale = true;
        reexecuteOperation(r2, e4);
      }
      return i3;
    })(filter$1(function(e4) {
      return !shouldSkip(e4) && isOperationCached(e4);
    })(u2));
    var s2 = H(function(e4) {
      var n3 = e4.operation;
      if (!n3) {
        return;
      }
      var o2 = collectTypesFromResponse(e4.data).concat(n3.context.additionalTypenames || []);
      if ("mutation" === e4.operation.kind) {
        var u3 = /* @__PURE__ */ new Set();
        for (var c3 = 0; c3 < o2.length; c3++) {
          var s3 = o2[c3];
          var f2 = i2[s3] || (i2[s3] = /* @__PURE__ */ new Set());
          f2.forEach(function(e5) {
            u3.add(e5);
          });
          f2.clear();
        }
        u3.forEach(function(e5) {
          if (a2.has(e5)) {
            n3 = a2.get(e5).operation;
            a2.delete(e5);
            reexecuteOperation(r2, n3);
          }
        });
      } else if ("query" === n3.kind && e4.data) {
        a2.set(n3.key, e4);
        for (var p2 = 0; p2 < o2.length; p2++) {
          var l2 = o2[p2];
          (i2[l2] || (i2[l2] = /* @__PURE__ */ new Set())).add(n3.key);
        }
      }
    })(n2(filter$1(function(e4) {
      return "query" !== e4.kind || "cache-only" !== e4.context.requestPolicy;
    })(map$1(function(e4) {
      return addMetadata(e4, {
        cacheOutcome: "miss"
      });
    })(merge$1([map$1(mapTypeNames)(filter$1(function(e4) {
      return !shouldSkip(e4) && !isOperationCached(e4);
    })(u2)), filter$1(function(e4) {
      return shouldSkip(e4);
    })(u2)])))));
    return merge$1([c2, s2]);
  };
}
function reexecuteOperation(e2, n2) {
  return e2.reexecuteOperation(makeOperation(n2.kind, n2, _extends$3({}, n2.context, {
    requestPolicy: "network-only"
  })));
}
function subscriptionExchange(e2) {
  var n2 = e2.forwardSubscription;
  var t2 = e2.enableAllOperations;
  return function(e3) {
    var a2 = e3.client;
    var i2 = e3.forward;
    function isSubscriptionOperation(e4) {
      var n3 = e4.kind;
      return "subscription" === n3 || !!t2 && ("query" === n3 || "mutation" === n3);
    }
    return function(e4) {
      var t3 = share$1(e4);
      var u2 = D$1(function(e5) {
        var i3 = e5.key;
        var u3 = filter$1(function(e6) {
          return "teardown" === e6.kind && e6.key === i3;
        })(t3);
        return takeUntil$1(u3)(function createSubscriptionSource(e6) {
          var t4 = n2({
            key: e6.key.toString(36),
            query: print$1(e6.query),
            variables: e6.variables,
            context: _extends$3({}, e6.context)
          });
          return make$1(function(n3) {
            var r2 = n3.next;
            var o2 = n3.complete;
            var i4 = false;
            var u4;
            Promise.resolve().then(function() {
              if (i4) {
                return;
              }
              u4 = t4.subscribe({
                next: function(n4) {
                  return r2(makeResult(e6, n4));
                },
                error: function(n4) {
                  return r2(makeErrorResult(e6, n4));
                },
                complete: function() {
                  if (!i4) {
                    i4 = true;
                    if ("subscription" === e6.kind) {
                      a2.reexecuteOperation(makeOperation("teardown", e6, e6.context));
                    }
                    o2();
                  }
                }
              });
            });
            return function() {
              i4 = true;
              if (u4) {
                u4.unsubscribe();
              }
            };
          });
        }(e5));
      })(filter$1(isSubscriptionOperation)(t3));
      var c2 = i2(filter$1(function(e5) {
        return !isSubscriptionOperation(e5);
      })(t3));
      return merge$1([u2, c2]);
    };
  };
}
function dedupExchange(e2) {
  var n2 = e2.forward;
  e2.dispatchDebug;
  var t2 = /* @__PURE__ */ new Set();
  function filterIncomingOperation(e3) {
    var n3 = e3.key;
    var a2 = e3.kind;
    if ("teardown" === a2) {
      t2.delete(n3);
      return true;
    }
    if ("query" !== a2 && "subscription" !== a2) {
      return true;
    }
    var o2 = t2.has(n3);
    t2.add(n3);
    return !o2;
  }
  function afterOperationResult(e3) {
    if (!e3.hasNext) {
      t2.delete(e3.operation.key);
    }
  }
  return function(e3) {
    var r3 = filter$1(filterIncomingOperation)(e3);
    return H(afterOperationResult)(n2(r3));
  };
}
function fetchExchange(e2) {
  var n2 = e2.forward;
  e2.dispatchDebug;
  return function(e3) {
    var t2 = share$1(e3);
    var a2 = D$1(function(e4) {
      var n3 = e4.key;
      var a3 = filter$1(function(e5) {
        return "teardown" === e5.kind && e5.key === n3;
      })(t2);
      var o3 = makeFetchBody(e4);
      var i2 = makeFetchURL(e4, o3);
      var u2 = makeFetchOptions(e4, o3);
      return H(function(n4) {
        !n4.data ? n4.error : void 0;
      })(takeUntil$1(a3)(makeFetchSource(e4, i2, u2)));
    })(filter$1(function(e4) {
      return "query" === e4.kind || "mutation" === e4.kind;
    })(t2));
    var o2 = n2(filter$1(function(e4) {
      return "query" !== e4.kind && "mutation" !== e4.kind;
    })(t2));
    return merge$1([a2, o2]);
  };
}
function fallbackExchange(e2) {
  e2.dispatchDebug;
  return function(e3) {
    return filter$1(function() {
      return false;
    })(H(function(e4) {
      if ("teardown" !== e4.kind && false) {
        var r2 = 'No exchange has handled operations of kind "' + e4.kind + `". Check whether you've added an exchange responsible for these operations.`;
        console.warn(r2);
      }
    })(e3));
  };
}
fallbackExchange({
  dispatchDebug: noop$6
});
function composeExchanges(e2) {
  return function(n2) {
    var r2 = n2.client;
    n2.dispatchDebug;
    return e2.reduceRight(function(e3, n3) {
      return n3({
        client: r2,
        forward: e3,
        dispatchDebug: function dispatchDebug$1(e4) {
        }
      });
    }, n2.forward);
  };
}
function errorExchange(e2) {
  var n2 = e2.onError;
  return function(e3) {
    var r2 = e3.forward;
    return function(e4) {
      return H(function(e5) {
        var r3 = e5.error;
        if (r3) {
          n2(r3, e5.operation);
        }
      })(r2(e4));
    };
  };
}
var L$1 = [dedupExchange, cacheExchange$1, fetchExchange];
var J = function Client(e2) {
  var n2 = /* @__PURE__ */ new Map();
  var r2 = /* @__PURE__ */ new Map();
  var t2 = [];
  var a2 = makeSubject$1();
  var i2 = a2.source;
  var u2 = a2.next;
  var c2 = false;
  function dispatchOperation(e3) {
    c2 = true;
    if (e3) {
      u2(e3);
    }
    while (e3 = t2.shift()) {
      u2(e3);
    }
    c2 = false;
  }
  function makeResultSource(e3) {
    var a3 = filter$1(function(n3) {
      return n3.operation.kind === e3.kind && n3.operation.key === e3.key && (!n3.operation.context._instance || n3.operation.context._instance === e3.context._instance);
    })(y2);
    if (f2.maskTypename) {
      a3 = map$1(function(e4) {
        return _extends$3({}, e4, {
          data: maskTypename(e4.data)
        });
      })(a3);
    }
    if ("mutation" === e3.kind) {
      return take$1(1)(onStart$1(function() {
        return dispatchOperation(e3);
      })(a3));
    }
    return share$1(onEnd$1(function() {
      n2.delete(e3.key);
      r2.delete(e3.key);
      for (var a4 = t2.length - 1; a4 >= 0; a4--) {
        if (t2[a4].key === e3.key) {
          t2.splice(a4, 1);
        }
      }
      dispatchOperation(makeOperation("teardown", e3, e3.context));
    })(H(function(r3) {
      n2.set(e3.key, r3);
    })(K(function(n3) {
      if ("query" !== e3.kind || n3.stale) {
        return fromValue$1(n3);
      }
      return merge$1([fromValue$1(n3), map$1(function() {
        return _extends$3({}, n3, {
          stale: true
        });
      })(take$1(1)(filter$1(function(n4) {
        return "query" === n4.kind && n4.key === e3.key && "cache-only" !== n4.context.requestPolicy;
      })(i2)))]);
    })(takeUntil$1(filter$1(function(n3) {
      return "teardown" === n3.kind && n3.key === e3.key;
    })(i2))(a3)))));
  }
  var s2 = this instanceof Client ? this : Object.create(Client.prototype);
  var f2 = _extends$3(s2, {
    url: e2.url,
    fetchOptions: e2.fetchOptions,
    fetch: e2.fetch,
    suspense: !!e2.suspense,
    requestPolicy: e2.requestPolicy || "cache-first",
    preferGetMethod: !!e2.preferGetMethod,
    maskTypename: !!e2.maskTypename,
    operations$: i2,
    reexecuteOperation: function reexecuteOperation2(e3) {
      if ("mutation" === e3.kind || r2.has(e3.key)) {
        t2.push(e3);
        if (!c2) {
          Promise.resolve().then(dispatchOperation);
        }
      }
    },
    createOperationContext: function createOperationContext(e3) {
      if (!e3) {
        e3 = {};
      }
      return _extends$3({}, {
        _instance: void 0,
        url: f2.url,
        fetchOptions: f2.fetchOptions,
        fetch: f2.fetch,
        preferGetMethod: f2.preferGetMethod
      }, e3, {
        suspense: e3.suspense || false !== e3.suspense && f2.suspense,
        requestPolicy: e3.requestPolicy || f2.requestPolicy
      });
    },
    createRequestOperation: function createRequestOperation(e3, n3, r3) {
      getOperationType(n3.query);
      var a3 = f2.createOperationContext(r3);
      if ("mutation" === e3) {
        a3._instance = [];
      }
      return makeOperation(e3, n3, a3);
    },
    executeRequestOperation: function executeRequestOperation(e3) {
      if ("mutation" === e3.kind) {
        return makeResultSource(e3);
      }
      return make$1(function(t3) {
        var a3 = r2.get(e3.key);
        if (!a3) {
          r2.set(e3.key, a3 = makeResultSource(e3));
        }
        var i3 = "cache-and-network" === e3.context.requestPolicy || "network-only" === e3.context.requestPolicy;
        return N$1(t3.next)(onEnd$1(t3.complete)(onStart$1(function() {
          var r3 = n2.get(e3.key);
          if ("subscription" === e3.kind) {
            return dispatchOperation(e3);
          } else if (i3) {
            dispatchOperation(e3);
          }
          if (null != r3 && r3 === n2.get(e3.key)) {
            t3.next(i3 ? _extends$3({}, r3, {
              stale: true
            }) : r3);
          } else if (!i3) {
            dispatchOperation(e3);
          }
        })(a3))).unsubscribe;
      });
    },
    executeQuery: function executeQuery(e3, n3) {
      var r3 = f2.createRequestOperation("query", e3, n3);
      return f2.executeRequestOperation(r3);
    },
    executeSubscription: function executeSubscription(e3, n3) {
      var r3 = f2.createRequestOperation("subscription", e3, n3);
      return f2.executeRequestOperation(r3);
    },
    executeMutation: function executeMutation(e3, n3) {
      var r3 = f2.createRequestOperation("mutation", e3, n3);
      return f2.executeRequestOperation(r3);
    },
    query: function query2(e3, n3, r3) {
      if (!r3 || "boolean" != typeof r3.suspense) {
        r3 = _extends$3({}, r3, {
          suspense: false
        });
      }
      return withPromise(f2.executeQuery(createRequest(e3, n3), r3));
    },
    readQuery: function readQuery2(e3, n3, r3) {
      var t3 = null;
      N$1(function(e4) {
        t3 = e4;
      })(f2.query(e3, n3, r3)).unsubscribe();
      return t3;
    },
    subscription: function subscription(e3, n3, r3) {
      return f2.executeSubscription(createRequest(e3, n3), r3);
    },
    mutation: function mutation(e3, n3, r3) {
      return withPromise(f2.executeMutation(createRequest(e3, n3), r3));
    }
  });
  var p2 = noop$6;
  var h2 = composeExchanges(void 0 !== e2.exchanges ? e2.exchanges : L$1);
  var y2 = share$1(h2({
    client: f2,
    dispatchDebug: p2,
    forward: fallbackExchange({
      dispatchDebug: p2
    })
  })(i2));
  publish$1(y2);
  return f2;
};
var W = J;
function _extends$2() {
  return (_extends$2 = Object.assign || function(e2) {
    for (var u2 = 1; u2 < arguments.length; u2++) {
      var n2 = arguments[u2];
      for (var r2 in n2) {
        if (Object.prototype.hasOwnProperty.call(n2, r2)) {
          e2[r2] = n2[r2];
        }
      }
    }
    return e2;
  }).apply(this, arguments);
}
function install(u2, t2) {
  var a2;
  if (!isRef(t2)) {
    a2 = ref(t2 instanceof J ? t2 : new J(t2));
  } else {
    a2 = t2;
  }
  u2.provide("$urql", a2);
}
function useClient() {
  var e2 = inject("$urql");
  return e2;
}
function unwrapPossibleProxy(e2) {
  return e2 && isRef(e2) ? e2.value : e2;
}
var y = {
  flush: "pre"
};
function useQuery(e2) {
  return callUseQuery(e2);
}
function callUseQuery(e2, t2, a2) {
  if (void 0 === t2) {
    t2 = useClient();
  }
  if (void 0 === a2) {
    a2 = [];
  }
  var i2 = reactive(e2);
  var l2 = ref();
  var v2 = ref(false);
  var p2 = ref(false);
  var d2 = ref();
  var b2 = ref();
  var h2 = ref();
  var x2 = isRef(e2.pause) ? e2.pause : ref(!!e2.pause);
  var w2 = ref(createRequest(i2.query, unwrapPossibleProxy(i2.variables)));
  var P = ref();
  a2.push(watchEffect(function() {
    var e3 = createRequest(i2.query, unwrapPossibleProxy(i2.variables));
    if (w2.value.key !== e3.key) {
      w2.value = e3;
    }
  }, y));
  a2.push(watchEffect(function() {
    P.value = !x2.value ? t2.value.executeQuery(w2.value, _extends$2({}, {
      requestPolicy: i2.requestPolicy
    }, i2.context)) : void 0;
  }, y));
  var Q = {
    data: l2,
    stale: v2,
    error: d2,
    operation: b2,
    extensions: h2,
    fetching: p2,
    isPaused: x2,
    executeQuery: function executeQuery(e3) {
      var u2 = P.value = t2.value.executeQuery(w2.value, _extends$2({}, {
        requestPolicy: i2.requestPolicy
      }, i2.context, e3));
      return _extends$2({}, S2, {
        then: function then(e4, n2) {
          return new Promise(function(e5) {
            var n3 = false;
            var r2 = N$1(function() {
              if (!Q.fetching.value && !Q.stale.value) {
                if (r2) {
                  r2.unsubscribe();
                }
                n3 = true;
                e5(Q);
              }
            })(u2);
            if (n3) {
              r2.unsubscribe();
            }
          }).then(e4, n2);
        }
      });
    },
    pause: function pause() {
      x2.value = true;
    },
    resume: function resume() {
      x2.value = false;
    }
  };
  a2.push(watchEffect(function(e3) {
    if (P.value) {
      p2.value = true;
      v2.value = false;
      e3(N$1(function(e4) {
        l2.value = e4.data;
        v2.value = !!e4.stale;
        p2.value = false;
        d2.value = e4.error;
        b2.value = e4.operation;
        h2.value = e4.extensions;
      })(onEnd$1(function() {
        p2.value = false;
        v2.value = false;
      })(P.value)).unsubscribe);
    } else {
      p2.value = false;
      v2.value = false;
    }
  }, {
    flush: "sync"
  }));
  var S2 = _extends$2({}, Q, {
    then: function then(e3, u2) {
      return new Promise(function(e4) {
        if (!P.value) {
          return e4(Q);
        }
        var u3 = false;
        var n2 = N$1(function() {
          if (!Q.fetching.value && !Q.stale.value) {
            if (n2) {
              n2.unsubscribe();
            }
            u3 = true;
            e4(Q);
          }
        })(P.value);
        if (u3) {
          n2.unsubscribe();
        }
      }).then(e3, u2);
    }
  });
  return S2;
}
function useMutation(e2) {
  return callUseMutation(e2);
}
function callUseMutation(e2, n2) {
  if (void 0 === n2) {
    n2 = useClient();
  }
  var t2 = ref();
  var a2 = ref(false);
  var i2 = ref(false);
  var o2 = ref();
  var s2 = ref();
  var l2 = ref();
  return {
    data: t2,
    stale: a2,
    fetching: i2,
    error: o2,
    operation: s2,
    extensions: l2,
    executeMutation: function executeMutation(r2, v2) {
      i2.value = true;
      return toPromise$1(take$1(1)(n2.value.executeMutation(createRequest(e2, unwrapPossibleProxy(r2)), v2 || {}))).then(function(e3) {
        t2.value = e3.data;
        a2.value = !!e3.stale;
        i2.value = false;
        o2.value = e3.error;
        s2.value = e3.operation;
        l2.value = e3.extensions;
        return e3;
      });
    }
  };
}
var b$1 = {
  flush: "pre"
};
function useSubscription(e2, u2) {
  return callUseSubscription(e2, u2);
}
function callUseSubscription(e2, t2, a2, i2) {
  if (void 0 === a2) {
    a2 = useClient();
  }
  if (void 0 === i2) {
    i2 = [];
  }
  var l2 = reactive(e2);
  var v2 = ref();
  var p2 = ref(false);
  var d2 = ref(false);
  var y2 = ref();
  var h2 = ref();
  var x2 = ref();
  var w2 = ref(t2);
  var P = isRef(e2.pause) ? e2.pause : ref(!!e2.pause);
  var Q = ref(createRequest(l2.query, unwrapPossibleProxy(l2.variables)));
  var S2 = ref();
  i2.push(watchEffect(function() {
    var e3 = createRequest(l2.query, unwrapPossibleProxy(l2.variables));
    if (Q.value.key !== e3.key) {
      Q.value = e3;
    }
  }, b$1));
  i2.push(watchEffect(function() {
    S2.value = !P.value ? a2.value.executeSubscription(Q.value, _extends$2({}, l2.context)) : void 0;
  }, b$1));
  i2.push(watchEffect(function(e3) {
    if (S2.value) {
      d2.value = true;
      e3(N$1(function(e4) {
        d2.value = true;
        v2.value = void 0 !== e4.data ? "function" == typeof w2.value ? w2.value(v2.value, e4.data) : e4.data : e4.data, y2.value = e4.error;
        x2.value = e4.extensions;
        p2.value = !!e4.stale;
        h2.value = e4.operation;
      })(onEnd$1(function() {
        d2.value = false;
      })(S2.value)).unsubscribe);
    } else {
      d2.value = false;
    }
  }, b$1));
  var m2 = {
    data: v2,
    stale: p2,
    error: y2,
    operation: h2,
    extensions: x2,
    fetching: d2,
    isPaused: P,
    executeSubscription: function executeSubscription(e3) {
      S2.value = a2.value.executeSubscription(Q.value, _extends$2({}, l2.context, e3));
      return m2;
    },
    pause: function pause() {
      P.value = true;
    },
    resume: function resume() {
      P.value = false;
    }
  };
  return m2;
}
const RUN_ALL_SPECS_KEY = "__all";
const RUN_ALL_SPECS = {
  name: "All E2E Specs",
  absolute: RUN_ALL_SPECS_KEY,
  relative: RUN_ALL_SPECS_KEY,
  baseName: RUN_ALL_SPECS_KEY,
  fileName: RUN_ALL_SPECS_KEY
};
const CY_IN_CY_SIMULATE_RUN_MODE = "CY_IN_CY_SIMULATE_RUN_MODE";
const BannerIds = {
  ACI_082022_LOGIN: "aci_082022_login",
  ACI_082022_CREATE_ORG: "aci_082022_createOrganization",
  ACI_082022_CONNECT_PROJECT: "aci_082022_connectProject",
  ACI_082022_RECORD: "aci_082022_record",
  CT_052023_AVAILABLE: "ct_052023_available",
  ACI_052023_NO_RUNS_FOUND_FOR_BRANCH: "aci_052023_noRunsFoundForBranch",
  ACI_052023_GIT_NOT_DETECTED: "aci_052023_gitNotDetected"
};
const isRunMode = window.location.href.includes(CY_IN_CY_SIMULATE_RUN_MODE) || window.__CYPRESS_MODE__ === "run" && window.top === window;
const _hoisted_1$I = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$E = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M2 8C2 4.68629 4.68629 2 8 2C11.3137 2 14 4.68629 14 8C14 11.3137 11.3137 14 8 14C4.68629 14 2 11.3137 2 8ZM8 0C3.58172 0 0 3.58172 0 8C0 12.4183 3.58172 16 8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0ZM9 5C9 4.44772 8.55228 4 8 4C7.44772 4 7 4.44772 7 5V8C7 8.55228 7.44772 9 8 9C8.55228 9 9 8.55228 9 8V5ZM8 12C8.55228 12 9 11.5523 9 11C9 10.4477 8.55228 10 8 10C7.44772 10 7 10.4477 7 11C7 11.5523 7.44772 12 8 12Z",
  fill: "#DB7903",
  class: "icon-dark"
}, null, -1);
const _hoisted_3$x = [
  _hoisted_2$E
];
function render$t(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$I, _hoisted_3$x);
}
const __unplugin_components_1$2 = { name: "cy-errored-outline_x16", render: render$t };
/*!
  * shared v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const inBrowser = typeof window !== "undefined";
const makeSymbol = (name2, shareable = false) => !shareable ? Symbol(name2) : Symbol.for(name2);
const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber$1 = (val) => typeof val === "number" && isFinite(val);
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject$3(val) && Object.keys(val).length === 0;
const assign$3 = Object.assign;
let _globalThis$2;
const getGlobalThis = () => {
  return _globalThis$2 || (_globalThis$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function escapeHtml$1(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty$2.call(obj, key);
}
const isArray$1 = Array.isArray;
const isFunction$2 = (val) => typeof val === "function";
const isString$3 = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject$6 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$6(val) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const isPlainObject$3 = (val) => {
  if (!isObject$6(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
const toDisplayString = (val) => {
  return val == null ? "" : isArray$1(val) || isPlainObject$3(val) && val.toString === objectToString$1 ? JSON.stringify(val, null, 2) : String(val);
};
function join$2(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
function incrementer(code2) {
  let current = code2;
  return () => ++current;
}
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
const isNotObjectOrIsArray = (val) => !isObject$6(val) || isArray$1(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack = [{ src, des }];
  while (stack.length) {
    const { src: src2, des: des2 } = stack.pop();
    Object.keys(src2).forEach((key) => {
      if (isNotObjectOrIsArray(src2[key]) || isNotObjectOrIsArray(des2[key])) {
        des2[key] = src2[key];
      } else {
        stack.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}
/*!
  * message-compiler v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function createPosition(line, column, offset2) {
  return { line, column, offset: offset2 };
}
function createLocation(start2, end2, source) {
  const loc = { start: start2, end: end2 };
  if (source != null) {
    loc.source = source;
  }
  return loc;
}
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format$1(message, ...args) {
  if (args.length === 1 && isObject$5(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message.replace(RE_ARGS, (match2, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
const assign$2 = Object.assign;
const isString$2 = (val) => typeof val === "string";
const isObject$5 = (val) => val !== null && typeof val === "object";
function join$1(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
const CompileWarnCodes = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
};
const warnMessages = {
  [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code2, loc, ...args) {
  const msg = format$1(warnMessages[code2] || "", ...args || []);
  const message = { message: String(msg), code: code2 };
  if (loc) {
    message.location = loc;
  }
  return message;
}
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
const errorMessages = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  // generator error messages
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  // minimizer error messages
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code2, loc, options2 = {}) {
  const { domain, messages, args } = options2;
  const msg = format$1((messages || errorMessages)[code2] || "", ...args || []);
  const error = new SyntaxError(String(msg));
  error.code = code2;
  if (loc) {
    error.location = loc;
  }
  error.domain = domain;
  return error;
}
function defaultOnError(error) {
  throw error;
}
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner$1(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index2) => _buf[index2] === CHAR_CR && _buf[index2 + 1] === CHAR_LF;
  const isLF = (index2) => _buf[index2] === CHAR_LF;
  const isPS = (index2) => _buf[index2] === CHAR_PS;
  const isLS = (index2) => _buf[index2] === CHAR_LS;
  const isLineEnd = (index2) => isCRLF(index2) || isLF(index2) || isPS(index2) || isLS(index2);
  const index = () => _index;
  const line = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset2) => isCRLF(offset2) || isPS(offset2) || isLS(offset2) ? CHAR_LF : _buf[offset2];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset2 = 0) {
    _peekOffset = offset2;
  }
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next();
    }
    _peekOffset = 0;
  }
  return {
    index,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}
const EOF = void 0;
const DOT = ".";
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options2 = {}) {
  const location2 = options2.location !== false;
  const _scnr = createScanner$1(source);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context2 = () => _context;
  const { onError } = options2;
  function emitError(code2, pos, offset2, ...args) {
    const ctx = context2();
    pos.column += offset2;
    pos.offset += offset2;
    if (onError) {
      const loc = location2 ? createLocation(ctx.startLoc, pos) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err);
    }
  }
  function getToken(context3, type2, value) {
    context3.endLoc = currentPosition();
    context3.currentType = type2;
    const token = { type: type2 };
    if (location2) {
      token.loc = createLocation(context3.startLoc, context3.endLoc);
    }
    if (value != null) {
      token.value = value;
    }
    return token;
  }
  const getEndToken = (context3) => getToken(
    context3,
    14
    /* TokenTypes.EOF */
  );
  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc === 95;
  }
  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function isNamedIdentifierStart(scnr, context3) {
    const { currentType } = context3;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context3) {
    const { currentType } = context3;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context3) {
    const { currentType } = context3;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context3) {
    const { currentType } = context3;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context3) {
    const { currentType } = context3;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context3) {
    const { currentType } = context3;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context3) {
    const { currentType } = context3;
    if (currentType !== 10) {
      return false;
    }
    const fn2 = () => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn2();
      } else {
        return isTextStart(scnr, false);
      }
    };
    const ret = fn2();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  function isTextStart(scnr, reset = true) {
    const fn2 = (hasSpace = false, prev2 = "", detectModulo = false) => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return prev2 === "%" ? false : hasSpace;
      } else if (ch === "@" || !ch) {
        return prev2 === "%" ? true : hasSpace;
      } else if (ch === "%") {
        scnr.peek();
        return fn2(hasSpace, "%", true);
      } else if (ch === "|") {
        return prev2 === "%" || detectModulo ? true : !(prev2 === CHAR_SP || prev2 === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn2(true, CHAR_SP, detectModulo);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn2(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };
    const ret = fn2();
    reset && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn2) {
    const ch = scnr.currentChar();
    if (ch === EOF) {
      return EOF;
    }
    if (fn2(ch)) {
      scnr.next();
      return ch;
    }
    return null;
  }
  function isIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36;
  }
  function takeIdentifierChar(scnr) {
    return takeChar(scnr, isIdentifier);
  }
  function isNamedIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36 || // $
    cc === 45;
  }
  function takeNamedIdentifierChar(scnr) {
    return takeChar(scnr, isNamedIdentifier);
  }
  function isDigit2(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function takeDigit(scnr) {
    return takeChar(scnr, isDigit2);
  }
  function isHexDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57 || // 0-9
    cc >= 65 && cc <= 70 || // A-F
    cc >= 97 && cc <= 102;
  }
  function takeHexDigit(scnr) {
    return takeChar(scnr, isHexDigit);
  }
  function getDigits(scnr) {
    let ch = "";
    let num = "";
    while (ch = takeDigit(scnr)) {
      num += ch;
    }
    return num;
  }
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch = scnr.currentChar();
    if (ch !== "%") {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
    }
    scnr.next();
    return "%";
  }
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
        break;
      } else if (ch === "%") {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else {
          break;
        }
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }
    return buf;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let name2 = "";
    while (ch = takeNamedIdentifierChar(scnr)) {
      name2 += ch;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name2;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value += `-${getDigits(scnr)}`;
    } else {
      value += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value;
  }
  function isLiteral2(ch) {
    return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch = "";
    let literal = "";
    while (ch = takeChar(scnr, isLiteral2)) {
      if (ch === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();
    switch (ch) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i = 0; i < digits; i++) {
      const ch = takeHexDigit(scnr);
      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch;
    }
    return `\\${unicode}${sequence}`;
  }
  function isInvalidIdentifier(ch) {
    return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let identifiers = "";
    while (ch = takeChar(scnr, isInvalidIdentifier)) {
      identifiers += ch;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch = "";
    let name2 = "";
    while (ch = takeIdentifierChar(scnr)) {
      name2 += ch;
    }
    return name2;
  }
  function readLinkedRefer(scnr) {
    const fn2 = (buf) => {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF || ch === DOT) {
        buf += ch;
        scnr.next();
        return fn2(buf);
      } else {
        buf += ch;
        scnr.next();
        return fn2(buf);
      }
    };
    return fn2("");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context3) {
    let token = null;
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        if (context3.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context3,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context3.braceNest++;
        return token;
      case "}":
        if (context3.braceNest > 0 && context3.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context3,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context3.braceNest--;
        context3.braceNest > 0 && skipSpaces(scnr);
        if (context3.inLinked && context3.braceNest === 0) {
          context3.inLinked = false;
        }
        return token;
      case "@":
        if (context3.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token = readTokenInLinked(scnr, context3) || getEndToken(context3);
        context3.braceNest = 0;
        return token;
      default: {
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context3.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = getToken(context3, 1, readPlural(scnr));
          context3.braceNest = 0;
          context3.inLinked = false;
          return token;
        }
        if (context3.braceNest > 0 && (context3.currentType === 5 || context3.currentType === 6 || context3.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context3.braceNest = 0;
          return readToken2(scnr, context3);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context3)) {
          token = getToken(context3, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context3)) {
          token = getToken(context3, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validLiteral = isLiteralStart(scnr, context3)) {
          token = getToken(context3, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token = getToken(context3, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }
        break;
      }
    }
    return token;
  }
  function readTokenInLinked(scnr, context3) {
    const { currentType } = context3;
    let token = null;
    const ch = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch) {
      case "@":
        scnr.next();
        token = getToken(
          context3,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context3.inLinked = true;
        return token;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context3,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context3,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context3, 1, readPlural(scnr));
          context3.braceNest = 0;
          context3.inLinked = false;
          return token;
        }
        if (isLinkedDotStart(scnr, context3) || isLinkedDelimiterStart(scnr, context3)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context3);
        }
        if (isLinkedModifierStart(scnr, context3)) {
          skipSpaces(scnr);
          return getToken(context3, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context3)) {
          skipSpaces(scnr);
          if (ch === "{") {
            return readTokenInPlaceholder(scnr, context3) || token;
          } else {
            return getToken(context3, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context3.braceNest = 0;
        context3.inLinked = false;
        return readToken2(scnr, context3);
    }
  }
  function readToken2(scnr, context3) {
    let token = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (context3.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context3) || getEndToken(context3);
    }
    if (context3.inLinked) {
      return readTokenInLinked(scnr, context3) || getEndToken(context3);
    }
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        return readTokenInPlaceholder(scnr, context3) || getEndToken(context3);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context3,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context3) || getEndToken(context3);
      default: {
        if (isPluralStart(scnr)) {
          token = getToken(context3, 1, readPlural(scnr));
          context3.braceNest = 0;
          context3.inLinked = false;
          return token;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context3, 0, readText(scnr)) : getToken(context3, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context3, 0, readText(scnr));
        }
        break;
      }
    }
    return token;
  }
  function nextToken() {
    const { currentType, offset: offset2, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset2;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        14
        /* TokenTypes.EOF */
      );
    }
    return readToken2(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context: context2
  };
}
const ERROR_DOMAIN$2 = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match2, codePoint4, codePoint6) {
  switch (match2) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "";
    }
  }
}
function createParser(options2 = {}) {
  const location2 = options2.location !== false;
  const { onError, onWarn } = options2;
  function emitError(tokenzer, code2, start2, offset2, ...args) {
    const end2 = tokenzer.currentPosition();
    end2.offset += offset2;
    end2.column += offset2;
    if (onError) {
      const loc = location2 ? createLocation(start2, end2) : null;
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err);
    }
  }
  function emitWarn(tokenzer, code2, start2, offset2, ...args) {
    const end2 = tokenzer.currentPosition();
    end2.offset += offset2;
    end2.column += offset2;
    if (onWarn) {
      const loc = location2 ? createLocation(start2, end2) : null;
      onWarn(createCompileWarn(code2, loc, args));
    }
  }
  function startNode(type2, offset2, loc) {
    const node = { type: type2 };
    if (location2) {
      node.start = offset2;
      node.end = offset2;
      node.loc = { start: loc, end: loc };
    }
    return node;
  }
  function endNode(node, offset2, pos, type2) {
    if (type2) {
      node.type = type2;
    }
    if (location2) {
      node.end = offset2;
      if (node.loc) {
        node.loc.end = pos;
      }
    }
  }
  function parseText(tokenizer, value) {
    const context2 = tokenizer.context();
    const node = startNode(3, context2.offset, context2.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseList(tokenizer, index) {
    const context2 = tokenizer.context();
    const { lastOffset: offset2, lastStartLoc: loc } = context2;
    const node = startNode(5, offset2, loc);
    node.index = parseInt(index, 10);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseNamed(tokenizer, key, modulo) {
    const context2 = tokenizer.context();
    const { lastOffset: offset2, lastStartLoc: loc } = context2;
    const node = startNode(4, offset2, loc);
    node.key = key;
    if (modulo === true) {
      node.modulo = true;
    }
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLiteral(tokenizer, value) {
    const context2 = tokenizer.context();
    const { lastOffset: offset2, lastStartLoc: loc } = context2;
    const node = startNode(9, offset2, loc);
    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinkedModifier(tokenizer) {
    const token = tokenizer.nextToken();
    const context2 = tokenizer.context();
    const { lastOffset: offset2, lastStartLoc: loc } = context2;
    const node = startNode(8, offset2, loc);
    if (token.type !== 12) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context2.lastStartLoc, 0);
      node.value = "";
      endNode(node, offset2, loc);
      return {
        nextConsumeToken: token,
        node
      };
    }
    if (token.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context2.lastStartLoc, 0, getTokenCaption(token));
    }
    node.value = token.value || "";
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node
    };
  }
  function parseLinkedKey(tokenizer, value) {
    const context2 = tokenizer.context();
    const node = startNode(7, context2.offset, context2.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinked(tokenizer) {
    const context2 = tokenizer.context();
    const linkedNode = startNode(6, context2.offset, context2.startLoc);
    let token = tokenizer.nextToken();
    if (token.type === 9) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer.nextToken();
    }
    if (token.type !== 10) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context2.lastStartLoc, 0, getTokenCaption(token));
    }
    token = tokenizer.nextToken();
    if (token.type === 2) {
      token = tokenizer.nextToken();
    }
    switch (token.type) {
      case 11:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context2.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
        break;
      case 5:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context2.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseNamed(tokenizer, token.value || "");
        break;
      case 6:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context2.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseList(tokenizer, token.value || "");
        break;
      case 7:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context2.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLiteral(tokenizer, token.value || "");
        break;
      default: {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context2.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
      }
    }
    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage2(tokenizer) {
    const context2 = tokenizer.context();
    const startOffset = context2.currentType === 1 ? tokenizer.currentOffset() : context2.offset;
    const startLoc = context2.currentType === 1 ? context2.endLoc : context2.startLoc;
    const node = startNode(2, startOffset, startLoc);
    node.items = [];
    let nextToken = null;
    let modulo = null;
    do {
      const token = nextToken || tokenizer.nextToken();
      nextToken = null;
      switch (token.type) {
        case 0:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context2.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseText(tokenizer, token.value || ""));
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context2.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseList(tokenizer, token.value || ""));
          break;
        case 4:
          modulo = true;
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context2.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseNamed(tokenizer, token.value || "", !!modulo));
          if (modulo) {
            emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context2.lastStartLoc, 0, getTokenCaption(token));
            modulo = null;
          }
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context2.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseLiteral(tokenizer, token.value || ""));
          break;
        case 8: {
          const parsed = parseLinked(tokenizer);
          node.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
        }
      }
    } while (context2.currentType !== 14 && context2.currentType !== 1);
    const endOffset = context2.currentType === 1 ? context2.lastOffset : tokenizer.currentOffset();
    const endLoc = context2.currentType === 1 ? context2.lastEndLoc : tokenizer.currentPosition();
    endNode(node, endOffset, endLoc);
    return node;
  }
  function parsePlural(tokenizer, offset2, loc, msgNode) {
    const context2 = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node = startNode(1, offset2, loc);
    node.cases = [];
    node.cases.push(msgNode);
    do {
      const msg = parseMessage2(tokenizer);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node.cases.push(msg);
    } while (context2.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseResource(tokenizer) {
    const context2 = tokenizer.context();
    const { offset: offset2, startLoc } = context2;
    const msgNode = parseMessage2(tokenizer);
    if (context2.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset2, startLoc, msgNode);
    }
  }
  function parse2(source) {
    const tokenizer = createTokenizer(source, assign$2({}, options2));
    const context2 = tokenizer.context();
    const node = startNode(0, context2.offset, context2.startLoc);
    if (location2 && node.loc) {
      node.loc.source = source;
    }
    node.body = parseResource(tokenizer);
    if (options2.onCacheKey) {
      node.cacheKey = options2.onCacheKey(source);
    }
    if (context2.currentType !== 14) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context2.lastStartLoc, 0, source[context2.offset] || "");
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  return { parse: parse2 };
}
function getTokenCaption(token) {
  if (token.type === 14) {
    return "EOF";
  }
  const name2 = (token.value || "").replace(/\r?\n/gu, "\\n");
  return name2.length > 10 ? name2.slice(0, 9) + "" : name2;
}
function createTransformer(ast, options2 = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context2 = () => _context;
  const helper = (name2) => {
    _context.helpers.add(name2);
    return name2;
  };
  return { context: context2, helper };
}
function traverseNodes(nodes, transformer) {
  for (let i = 0; i < nodes.length; i++) {
    traverseNode(nodes[i], transformer);
  }
}
function traverseNode(node, transformer) {
  switch (node.type) {
    case 1:
      traverseNodes(node.cases, transformer);
      transformer.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node.items, transformer);
      break;
    case 6: {
      const linked = node;
      traverseNode(linked.key, transformer);
      transformer.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function transform(ast, options2 = {}) {
  const transformer = createTransformer(ast);
  transformer.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer);
  const context2 = transformer.context();
  ast.helpers = Array.from(context2.helpers);
}
function optimize(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c2) => optimizeMessageNode(c2));
  }
  return ast;
}
function optimizeMessageNode(message) {
  if (message.items.length === 1) {
    const item = message.items[0];
    if (item.type === 3 || item.type === 9) {
      message.static = item.value;
      delete item.value;
    }
  } else {
    const values = [];
    for (let i = 0; i < message.items.length; i++) {
      const item = message.items[i];
      if (!(item.type === 3 || item.type === 9)) {
        break;
      }
      if (item.value == null) {
        break;
      }
      values.push(item.value);
    }
    if (values.length === message.items.length) {
      message.static = join$1(values);
      for (let i = 0; i < message.items.length; i++) {
        const item = message.items[i];
        if (item.type === 3 || item.type === 9) {
          delete item.value;
        }
      }
    }
  }
}
const ERROR_DOMAIN$1 = "minifier";
function minify(node) {
  node.t = node.type;
  switch (node.type) {
    case 0: {
      const resource = node;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    }
    case 1: {
      const plural = node;
      const cases = plural.cases;
      for (let i = 0; i < cases.length; i++) {
        minify(cases[i]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    }
    case 2: {
      const message = node;
      const items = message.items;
      for (let i = 0; i < items.length; i++) {
        minify(items[i]);
      }
      message.i = items;
      delete message.items;
      if (message.static) {
        message.s = message.static;
        delete message.static;
      }
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const valueNode = node;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    }
    case 6: {
      const linked = node;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    }
    case 5: {
      const list = node;
      list.i = list.index;
      delete list.index;
      break;
    }
    case 4: {
      const named = node;
      named.k = named.key;
      delete named.key;
      break;
    }
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: ERROR_DOMAIN$1,
        args: [node.type]
      });
    }
  }
  delete node.type;
}
const ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options2) {
  const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options2;
  const location2 = options2.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location2 && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context2 = () => _context;
  function push2(code2, node) {
    _context.code += code2;
  }
  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push2(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }
  function indent2(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline() {
    _newline(_context.indentLevel);
  }
  const helper = (key) => `_${key}`;
  const needIndent = () => _context.needIndent;
  return {
    context: context2,
    push: push2,
    indent: indent2,
    deindent,
    newline,
    helper,
    needIndent
  };
}
function generateLinkedNode(generator, node) {
  const { helper } = generator;
  generator.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator, node.key);
  if (node.modifier) {
    generator.push(`, `);
    generateNode(generator, node.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
function generateMessageNode(generator, node) {
  const { helper, needIndent } = generator;
  generator.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length2 = node.items.length;
  for (let i = 0; i < length2; i++) {
    generateNode(generator, node.items[i]);
    if (i === length2 - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
function generatePluralNode(generator, node) {
  const { helper, needIndent } = generator;
  if (node.cases.length > 1) {
    generator.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length2 = node.cases.length;
    for (let i = 0; i < length2; i++) {
      generateNode(generator, node.cases[i]);
      if (i === length2 - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
function generateResource(generator, node) {
  if (node.body) {
    generateNode(generator, node.body);
  } else {
    generator.push("null");
  }
}
function generateNode(generator, node) {
  const { helper } = generator;
  switch (node.type) {
    case 0:
      generateResource(generator, node);
      break;
    case 1:
      generatePluralNode(generator, node);
      break;
    case 2:
      generateMessageNode(generator, node);
      break;
    case 6:
      generateLinkedNode(generator, node);
      break;
    case 8:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 7:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 5:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node.index}))`, node);
      break;
    case 4:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node.key)}))`, node);
      break;
    case 9:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 3:
      generator.push(JSON.stringify(node.value), node);
      break;
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: ERROR_DOMAIN,
        args: [node.type]
      });
    }
  }
}
const generate = (ast, options2 = {}) => {
  const mode = isString$2(options2.mode) ? options2.mode : "normal";
  const filename = isString$2(options2.filename) ? options2.filename : "message.intl";
  const sourceMap = !!options2.sourceMap;
  const breakLineCode = options2.breakLineCode != null ? options2.breakLineCode : mode === "arrow" ? ";" : "\n";
  const needIndent = options2.needIndent ? options2.needIndent : mode !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${join$1(helpers.map((s2) => `${s2}: _${s2}`), ", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  delete ast.helpers;
  const { code: code2, map: map2 } = generator.context();
  return {
    ast,
    code: code2,
    map: map2 ? map2.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function baseCompile$1(source, options2 = {}) {
  const assignedOptions = assign$2({}, options2);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser2 = createParser(assignedOptions);
  const ast = parser2.parse(source);
  if (!jit) {
    transform(ast, assignedOptions);
    return generate(ast, assignedOptions);
  } else {
    enambeOptimize && optimize(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}
/*!
  * core-base v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a2 = str.charCodeAt(0);
  const b2 = str.charCodeAt(str.length - 1);
  return a2 === b2 && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse$3(path) {
  const keys2 = [];
  let index = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c2;
  let key;
  let newChar;
  let type2;
  let transition;
  let action3;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys2.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index++;
    c2 = path[index];
    if (c2 === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type2 = getPathCharType(c2);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type2] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action3 = actions[transition[1]];
      if (action3) {
        newChar = c2;
        if (action3() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys2;
    }
  }
}
const cache$1 = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$6(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
  if (!isObject$6(obj)) {
    return null;
  }
  let hit = cache$1.get(path);
  if (!hit) {
    hit = parse$3(path);
    if (hit) {
      cache$1.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i = 0;
  while (i < len) {
    const val = last[hit[i]];
    if (val === void 0) {
      return null;
    }
    if (isFunction$2(last)) {
      return null;
    }
    last = val;
    i++;
  }
  return last;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join$2(values);
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options2) {
  const index = isNumber$1(options2.pluralIndex) ? options2.pluralIndex : -1;
  return options2.named && (isNumber$1(options2.named.count) || isNumber$1(options2.named.n)) ? isNumber$1(options2.named.count) ? options2.named.count : isNumber$1(options2.named.n) ? options2.named.n : index : index;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options2 = {}) {
  const locale = options2.locale;
  const pluralIndex = getPluralIndex(options2);
  const pluralRule = isObject$6(options2.pluralRules) && isString$3(locale) && isFunction$2(options2.pluralRules[locale]) ? options2.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject$6(options2.pluralRules) && isString$3(locale) && isFunction$2(options2.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages) => {
    return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  };
  const _list = options2.list || [];
  const list = (index) => _list[index];
  const _named = options2.named || {};
  isNumber$1(options2.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message(key) {
    const msg = isFunction$2(options2.messages) ? options2.messages(key) : isObject$6(options2.messages) ? options2.messages[key] : false;
    return !msg ? options2.parent ? options2.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name2) => options2.modifiers ? options2.modifiers[name2] : DEFAULT_MODIFIER;
  const normalize = isPlainObject$3(options2.processor) && isFunction$2(options2.processor.normalize) ? options2.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject$3(options2.processor) && isFunction$2(options2.processor.interpolate) ? options2.processor.interpolate : DEFAULT_INTERPOLATE;
  const type2 = isPlainObject$3(options2.processor) && isString$3(options2.processor.type) ? options2.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type22 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$6(arg1)) {
        modifier = arg1.modifier || modifier;
        type22 = arg1.type || type22;
      } else if (isString$3(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$3(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$3(arg2)) {
        type22 = arg2 || type22;
      }
    }
    const ret = message(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type22 === "vnode" && isArray$1(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type22) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type2,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign$3({}, _list, _named)
  };
  return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n, version2, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n,
    version: version2,
    meta
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
const inc$1$1 = incrementer(code$1$1);
const CoreWarnCodes = {
  NOT_FOUND_KEY: code$1$1,
  // 2
  FALLBACK_TO_TRANSLATE: inc$1$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
  // 8
  __EXTEND_POINT__: inc$1$1()
  // 9
};
const code$2 = CompileErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  // 17
  INVALID_DATE_ARGUMENT: inc$2(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc$2(),
  // 23
  __EXTEND_POINT__: inc$2()
  // 24
};
function createCoreError(code2) {
  return createCompileError(code2, null, void 0);
}
function getLocale(context2, options2) {
  return options2.locale != null ? resolveLocale(options2.locale) : resolveLocale(context2.locale);
}
let _resolveLocale;
function resolveLocale(locale) {
  if (isString$3(locale)) {
    return locale;
  } else {
    if (isFunction$2(locale)) {
      if (locale.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale.constructor.name === "Function") {
        const resolve3 = locale();
        if (isPromise(resolve3)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve3;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start2) {
  return [.../* @__PURE__ */ new Set([
    start2,
    ...isArray$1(fallback) ? fallback : isObject$6(fallback) ? Object.keys(fallback) : isString$3(fallback) ? [fallback] : [start2]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start2) {
  const startLocale = isString$3(start2) ? start2 : DEFAULT_LOCALE;
  const context2 = ctx;
  if (!context2.__localeChainCache) {
    context2.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context2.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block2 = [start2];
    while (isArray$1(block2)) {
      block2 = appendBlockToChain(chain, block2, fallback);
    }
    const defaults2 = isArray$1(fallback) || !isPlainObject$3(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block2 = isString$3(defaults2) ? [defaults2] : defaults2;
    if (isArray$1(block2)) {
      appendBlockToChain(chain, block2, false);
    }
    context2.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block2, blocks) {
  let follow = true;
  for (let i = 0; i < block2.length && isBoolean(follow); i++) {
    const locale = block2[i];
    if (isString$3(locale)) {
      follow = appendLocaleToChain(chain, block2[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale = target.replace(/!/g, "");
      chain.push(locale);
      if ((isArray$1(blocks) || isPlainObject$3(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
const VERSION$4 = "9.13.1";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type2) => {
      return type2 === "text" && isString$3(val) ? val.toUpperCase() : type2 === "vnode" && isObject$6(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type2) => {
      return type2 === "text" && isString$3(val) ? val.toLowerCase() : type2 === "vnode" && isObject$6(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type2) => {
      return type2 === "text" && isString$3(val) ? capitalize(val) : type2 === "vnode" && isObject$6(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
  _additionalMeta = meta;
};
const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context2) => {
  _fallbackContext = context2;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options2 = {}) {
  const onWarn = isFunction$2(options2.onWarn) ? options2.onWarn : warn;
  const version2 = isString$3(options2.version) ? options2.version : VERSION$4;
  const locale = isString$3(options2.locale) || isFunction$2(options2.locale) ? options2.locale : DEFAULT_LOCALE;
  const _locale = isFunction$2(locale) ? DEFAULT_LOCALE : locale;
  const fallbackLocale = isArray$1(options2.fallbackLocale) || isPlainObject$3(options2.fallbackLocale) || isString$3(options2.fallbackLocale) || options2.fallbackLocale === false ? options2.fallbackLocale : _locale;
  const messages = isPlainObject$3(options2.messages) ? options2.messages : { [_locale]: {} };
  const datetimeFormats = isPlainObject$3(options2.datetimeFormats) ? options2.datetimeFormats : { [_locale]: {} };
  const numberFormats = isPlainObject$3(options2.numberFormats) ? options2.numberFormats : { [_locale]: {} };
  const modifiers = assign$3({}, options2.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options2.pluralRules || {};
  const missing = isFunction$2(options2.missing) ? options2.missing : null;
  const missingWarn = isBoolean(options2.missingWarn) || isRegExp(options2.missingWarn) ? options2.missingWarn : true;
  const fallbackWarn = isBoolean(options2.fallbackWarn) || isRegExp(options2.fallbackWarn) ? options2.fallbackWarn : true;
  const fallbackFormat = !!options2.fallbackFormat;
  const unresolving = !!options2.unresolving;
  const postTranslation = isFunction$2(options2.postTranslation) ? options2.postTranslation : null;
  const processor = isPlainObject$3(options2.processor) ? options2.processor : null;
  const warnHtmlMessage = isBoolean(options2.warnHtmlMessage) ? options2.warnHtmlMessage : true;
  const escapeParameter = !!options2.escapeParameter;
  const messageCompiler = isFunction$2(options2.messageCompiler) ? options2.messageCompiler : _compiler;
  const messageResolver = isFunction$2(options2.messageResolver) ? options2.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction$2(options2.localeFallbacker) ? options2.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$6(options2.fallbackContext) ? options2.fallbackContext : void 0;
  const internalOptions = options2;
  const __datetimeFormatters = isObject$6(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$6(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$6(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context2 = {
    version: version2,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context2.datetimeFormats = datetimeFormats;
    context2.numberFormats = numberFormats;
    context2.__datetimeFormatters = __datetimeFormatters;
    context2.__numberFormatters = __numberFormatters;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context2, version2, __meta);
  }
  return context2;
}
function handleMissing(context2, key, locale, missingWarn, type2) {
  const { missing, onWarn } = context2;
  if (missing !== null) {
    const ret = missing(context2, locale, key, type2);
    return isString$3(ret) ? ret : key;
  } else {
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context2 = ctx;
  context2.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
function isAlmostSameLocale(locale, compareLocale) {
  if (locale === compareLocale)
    return false;
  return locale.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
  const index = locales.indexOf(targetLocale);
  if (index === -1) {
    return false;
  }
  for (let i = index + 1; i < locales.length; i++) {
    if (isAlmostSameLocale(targetLocale, locales[i])) {
      return true;
    }
  }
  return false;
}
function format(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = ast.b || ast.body;
  if ((body.t || body.type) === 1) {
    const plural = body;
    const cases = plural.c || plural.cases;
    return ctx.plural(cases.reduce((messages, c2) => [
      ...messages,
      formatMessageParts(ctx, c2)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
function formatMessageParts(ctx, node) {
  const _static = node.s || node.static;
  if (_static) {
    return ctx.type === "text" ? _static : ctx.normalize([_static]);
  } else {
    const messages = (node.i || node.items).reduce((acm, c2) => [...acm, formatMessagePart(ctx, c2)], []);
    return ctx.normalize(messages);
  }
}
function formatMessagePart(ctx, node) {
  const type2 = node.t || node.type;
  switch (type2) {
    case 3: {
      const text = node;
      return text.v || text.value;
    }
    case 9: {
      const literal = node;
      return literal.v || literal.value;
    }
    case 4: {
      const named = node;
      return ctx.interpolate(ctx.named(named.k || named.key));
    }
    case 5: {
      const list = node;
      return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
    }
    case 6: {
      const linked = node;
      const modifier = linked.m || linked.modifier;
      return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      const linkedKey = node;
      return linkedKey.v || linkedKey.value;
    }
    case 8: {
      const linkedModifier = node;
      return linkedModifier.v || linkedModifier.value;
    }
    default:
      throw new Error(`unhandled node type on format message part: ${type2}`);
  }
}
const defaultOnCacheKey = (message) => message;
let compileCache = /* @__PURE__ */ Object.create(null);
const isMessageAST = (val) => isObject$6(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
function baseCompile(message, options2 = {}) {
  let detectError = false;
  const onError = options2.onError || defaultOnError;
  options2.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile$1(message, options2), detectError };
}
function compile(message, context2) {
  if (isString$3(message)) {
    isBoolean(context2.warnHtmlMessage) ? context2.warnHtmlMessage : true;
    const onCacheKey = context2.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message, {
      ...context2,
      location: false,
      jit: true
    });
    const msg = format(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    const cacheKey = message.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format(message);
    } else {
      return format(message);
    }
  }
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction$2(val);
function translate(context2, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context2;
  const [key, options2] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options2.missingWarn) ? options2.missingWarn : context2.missingWarn;
  const fallbackWarn = isBoolean(options2.fallbackWarn) ? options2.fallbackWarn : context2.fallbackWarn;
  const escapeParameter = isBoolean(options2.escapeParameter) ? options2.escapeParameter : context2.escapeParameter;
  const resolvedMessage = !!options2.resolvedMessage;
  const defaultMsgOrKey = isString$3(options2.default) || isBoolean(options2.default) ? !isBoolean(options2.default) ? options2.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = getLocale(context2, options2);
  escapeParameter && escapeParams(options2);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context2, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages[locale] || {}
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$3(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$3(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$3(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context2, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context2, targetLocale, message, options2);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context2, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$3(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$3(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$3({}, context2.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options2) {
  if (isArray$1(options2.list)) {
    options2.list = options2.list.map((item) => isString$3(item) ? escapeHtml$1(item) : item);
  } else if (isObject$6(options2.named)) {
    Object.keys(options2.named).forEach((key) => {
      if (isString$3(options2.named[key])) {
        options2.named[key] = escapeHtml$1(options2.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context2, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context2;
  const locales = localeFallbacker(context2, fallbackLocale, locale);
  let message = {};
  let targetLocale;
  let format2 = null;
  const type2 = "translate";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    message = messages[targetLocale] || {};
    if ((format2 = resolveValue2(message, key)) === null) {
      format2 = message[key];
    }
    if (isString$3(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context2,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type2
      );
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
  }
  return [format2, targetLocale, message];
}
function compileMessageFormat(context2, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context2;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format2;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  const msg = messageCompiler(format2, getCompileContext(context2, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context2, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options2 = {};
  if (!isString$3(arg1) && !isNumber$1(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber$1(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber$1(arg2)) {
    options2.plural = arg2;
  } else if (isString$3(arg2)) {
    options2.default = arg2;
  } else if (isPlainObject$3(arg2) && !isEmptyObject(arg2)) {
    options2.named = arg2;
  } else if (isArray$1(arg2)) {
    options2.list = arg2;
  }
  if (isNumber$1(arg3)) {
    options2.plural = arg3;
  } else if (isString$3(arg3)) {
    options2.default = arg3;
  } else if (isPlainObject$3(arg3)) {
    assign$3(options2, arg3);
  }
  return [key, options2];
}
function getCompileContext(context2, locale, key, source, warnHtmlMessage, onError) {
  return {
    locale,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getMessageContextOptions(context2, locale, message, options2) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context2;
  const resolveMessage = (key) => {
    let val = resolveValue2(message, key);
    if (val == null && fallbackContext) {
      const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message2, key);
    }
    if (isString$3(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context2, key, locale, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context2.processor) {
    ctxOptions.processor = context2.processor;
  }
  if (options2.list) {
    ctxOptions.list = options2.list;
  }
  if (options2.named) {
    ctxOptions.named = options2.named;
  }
  if (isNumber$1(options2.plural)) {
    ctxOptions.pluralIndex = options2.plural;
  }
  return ctxOptions;
}
function datetime(context2, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context2;
  const { __datetimeFormatters } = context2;
  const [key, value, options2, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options2.missingWarn) ? options2.missingWarn : context2.missingWarn;
  isBoolean(options2.fallbackWarn) ? options2.fallbackWarn : context2.fallbackWarn;
  const part = !!options2.part;
  const locale = getLocale(context2, options2);
  const locales = localeFallbacker(
    context2,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$3(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  const type2 = "datetime format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject$3(format2))
      break;
    handleMissing(context2, key, targetLocale, missingWarn, type2);
  }
  if (!isPlainObject$3(format2) || !isString$3(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$3({}, format2, overrides));
    __datetimeFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options2 = {};
  let overrides = {};
  let value;
  if (isString$3(arg1)) {
    const matches2 = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches2) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches2[3] ? matches2[3].trim().startsWith("T") ? `${matches2[1].trim()}${matches2[3].trim()}` : `${matches2[1].trim()}T${matches2[3].trim()}` : matches2[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber$1(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$3(arg2)) {
    options2.key = arg2;
  } else if (isPlainObject$3(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options2[key] = arg2[key];
      }
    });
  }
  if (isString$3(arg3)) {
    options2.locale = arg3;
  } else if (isPlainObject$3(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject$3(arg4)) {
    overrides = arg4;
  }
  return [options2.key || "", value, options2, overrides];
}
function clearDateTimeFormat(ctx, locale, format2) {
  const context2 = ctx;
  for (const key in format2) {
    const id2 = `${locale}__${key}`;
    if (!context2.__datetimeFormatters.has(id2)) {
      continue;
    }
    context2.__datetimeFormatters.delete(id2);
  }
}
function number(context2, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context2;
  const { __numberFormatters } = context2;
  const [key, value, options2, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options2.missingWarn) ? options2.missingWarn : context2.missingWarn;
  isBoolean(options2.fallbackWarn) ? options2.fallbackWarn : context2.fallbackWarn;
  const part = !!options2.part;
  const locale = getLocale(context2, options2);
  const locales = localeFallbacker(
    context2,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$3(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  const type2 = "number format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject$3(format2))
      break;
    handleMissing(context2, key, targetLocale, missingWarn, type2);
  }
  if (!isPlainObject$3(format2) || !isString$3(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$3({}, format2, overrides));
    __numberFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options2 = {};
  let overrides = {};
  if (!isNumber$1(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString$3(arg2)) {
    options2.key = arg2;
  } else if (isPlainObject$3(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options2[key] = arg2[key];
      }
    });
  }
  if (isString$3(arg3)) {
    options2.locale = arg3;
  } else if (isPlainObject$3(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject$3(arg4)) {
    overrides = arg4;
  }
  return [options2.key || "", value, options2, overrides];
}
function clearNumberFormat(ctx, locale, format2) {
  const context2 = ctx;
  for (const key in format2) {
    const id2 = `${locale}__${key}`;
    if (!context2.__numberFormatters.has(id2)) {
      continue;
    }
    context2.__numberFormatters.delete(id2);
  }
}
{
  initFeatureFlags$1();
}
/*!
  * vue-i18n v9.13.1
  * (c) 2024 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION$3 = "9.13.1";
function initFeatureFlags() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
({
  FALLBACK_TO_ROOT: code$1,
  // 9
  NOT_SUPPORTED_PRESERVE: inc$1(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$1(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$1(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
  // 18
});
const code = CoreErrorCodes.__EXTEND_POINT__;
const inc = incrementer(code);
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  // 26
  NOT_INSTALLED: inc(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc(),
  // 29
  INVALID_VALUE: inc(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc()
  // 38
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, void 0);
}
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject$6(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$6(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i = 0; i < lastIndex; i++) {
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = {};
        }
        if (!isObject$6(currentObj[subKeys[i]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i]];
      }
      if (!hasStringValue) {
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
      }
      if (isObject$6(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options2) {
  const { messages, __i18n, messageResolver, flatJson } = options2;
  const ret = isPlainObject$3(messages) ? messages : isArray$1(__i18n) ? {} : { [locale]: {} };
  if (isArray$1(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || {};
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$3(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(gl, options2, componentOptions) {
  let messages = isObject$6(options2.messages) ? options2.messages : {};
  if ("__i18nGlobal" in componentOptions) {
    messages = getLocaleMessages(gl.locale.value, {
      messages,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages);
  if (locales.length) {
    locales.forEach((locale) => {
      gl.mergeLocaleMessage(locale, messages[locale]);
    });
  }
  {
    if (isObject$6(options2.datetimeFormats)) {
      const locales2 = Object.keys(options2.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeDateTimeFormat(locale, options2.datetimeFormats[locale]);
        });
      }
    }
    if (isObject$6(options2.numberFormats)) {
      const locales2 = Object.keys(options2.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeNumberFormat(locale, options2.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = () => [];
const NOOP_RETURN_FALSE = () => false;
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type2) => {
    return missing(locale, key, getCurrentInstance() || void 0, type2);
  };
}
const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options2 = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options2;
  const _isGlobal = __root === void 0;
  const flatJson = options2.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options2.translateExistCompatible;
  let _inheritLocale = isBoolean(options2.inheritLocale) ? options2.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$3(options2.locale) ? options2.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$3(options2.fallbackLocale) || isArray$1(options2.fallbackLocale) || isPlainObject$3(options2.fallbackLocale) || options2.fallbackLocale === false ? options2.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options2));
  const _datetimeFormats = _ref(isPlainObject$3(options2.datetimeFormats) ? options2.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject$3(options2.numberFormats) ? options2.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options2.missingWarn) || isRegExp(options2.missingWarn) ? options2.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options2.fallbackWarn) || isRegExp(options2.fallbackWarn) ? options2.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options2.fallbackRoot) ? options2.fallbackRoot : true;
  let _fallbackFormat = !!options2.fallbackFormat;
  let _missing = isFunction$2(options2.missing) ? options2.missing : null;
  let _runtimeMissing = isFunction$2(options2.missing) ? defineCoreMissingHandler(options2.missing) : null;
  let _postTranslation = isFunction$2(options2.postTranslation) ? options2.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options2.warnHtmlMessage) ? options2.warnHtmlMessage : true;
  let _escapeParameter = !!options2.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject$3(options2.modifiers) ? options2.modifiers : {};
  let _pluralRules = options2.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION$3,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options2.messageResolver,
      messageCompiler: options2.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject$3(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject$3(_context) ? _context.__numberFormatters : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction$2(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  const wrapWithDeps = (fn2, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        /* @__PURE__ */ setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn2(_context);
    } finally {
      if (__INTLIFY_PROD_DEVTOOLS__)
        ;
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber$1(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t2(...args) {
    return wrapWithDeps((context2) => Reflect.apply(translate, null, [context2, ...args]), () => parseTranslateArgs(...args), "translate", (root) => Reflect.apply(root.t, root, [...args]), (key) => key, (val) => isString$3(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$6(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t2(...[arg1, arg2, assign$3({ resolvedMessage: true }, arg3 || {})]);
  }
  function d2(...args) {
    return wrapWithDeps((context2) => Reflect.apply(datetime, null, [context2, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$3(val));
  }
  function n(...args) {
    return wrapWithDeps((context2) => Reflect.apply(number, null, [context2, ...args]), () => parseNumberArgs(...args), "number format", (root) => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$3(val));
  }
  function normalize(values) {
    return values.map((val) => isString$3(val) || isNumber$1(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context2) => {
        let ret;
        const _context2 = context2;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray$1(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context2) => Reflect.apply(number, null, [context2, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$3(val) || isArray$1(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context2) => Reflect.apply(datetime, null, [context2, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString$3(val) || isArray$1(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key, locale2) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString$3(locale2) ? locale2 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString$3(resolved) : resolved != null;
    }, () => [key], "translate exists", (root) => {
      return Reflect.apply(root.te, root, [key, locale2]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages2 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages2 = messageValue;
        break;
      }
    }
    return messages2;
  }
  function tm(key) {
    const messages2 = resolveMessages(key);
    return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    if (flatJson) {
      const _message = { [locale2]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale2];
    }
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    const _message = { [locale2]: message };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message = _message[locale2];
    deepCopy(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function mergeDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = assign$3(_datetimeFormats.value[locale2] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  function mergeNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = assign$3(_numberFormats.value[locale2] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t: t2,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm;
    composer.d = d2;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  return composer;
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys2) {
  if (keys2.length === 1 && keys2[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys2.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, {});
  }
}
function getFragmentableTag(tag) {
  return Fragment;
}
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign$3({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (val) => isNumber$1(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context2) {
    const { slots, attrs } = context2;
    const i18n = props.i18n || useI18n$1({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys2 = Object.keys(slots).filter((key) => key !== "_");
      const options2 = {};
      if (props.locale) {
        options2.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options2.plural = isString$3(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context2, keys2);
      const children = i18n[TranslateVNodeSymbol](props.keypath, arg, options2);
      const assignedAttrs = assign$3({}, attrs);
      const tag = isString$3(props.tag) || isObject$6(props.tag) ? props.tag : getFragmentableTag();
      return h$1(tag, assignedAttrs, children);
    };
  }
});
const Translation = TranslationImpl;
function isVNode(target) {
  return isArray$1(target) && !isString$3(target[0]);
}
function renderFormatter(props, context2, slotKeys, partFormatter) {
  const { slots, attrs } = context2;
  return () => {
    const options2 = { part: true };
    let overrides = {};
    if (props.locale) {
      options2.locale = props.locale;
    }
    if (isString$3(props.format)) {
      options2.key = props.format;
    } else if (isObject$6(props.format)) {
      if (isString$3(props.format.key)) {
        options2.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options22, prop) => {
        return slotKeys.includes(prop) ? assign$3({}, options22, { [prop]: props.format[prop] }) : options22;
      }, {});
    }
    const parts2 = partFormatter(...[props.value, options2, overrides]);
    let children = [options2.key];
    if (isArray$1(parts2)) {
      children = parts2.map((part, index) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index, parts: parts2 }) : [part.value];
        if (isVNode(node)) {
          node[0].key = `${part.type}-${index}`;
        }
        return node;
      });
    } else if (isString$3(parts2)) {
      children = [parts2];
    }
    const assignedAttrs = assign$3({}, attrs);
    const tag = isString$3(props.tag) || isObject$6(props.tag) ? props.tag : getFragmentableTag();
    return h$1(tag, assignedAttrs, children);
  };
}
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign$3({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context2) {
    const i18n = props.i18n || useI18n$1({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context2, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign$3({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context2) {
    const i18n = props.i18n || useI18n$1({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context2, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n, instance) {
  const i18nInternal = i18n;
  if (i18n.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n.global.__composer;
  }
}
function vTDirective(i18n) {
  const _process = (binding) => {
    const { instance, modifiers, value } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n, instance.$);
    const parsedValue = parseValue(value);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n.global === composer) {
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  };
  const unregister = (el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = void 0;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  };
  const update = (el, { value }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}
function parseValue(value) {
  if (isString$3(value)) {
    return { path: value };
  } else if (isPlainObject$3(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path, locale, args, choice, plural } = value;
  const options2 = {};
  const named = args || {};
  if (isString$3(locale)) {
    options2.locale = locale;
  }
  if (isNumber$1(choice)) {
    options2.plural = choice;
  }
  if (isNumber$1(plural)) {
    options2.plural = plural;
  }
  return [path, named, options2];
}
function apply(app2, i18n, ...options2) {
  const pluginOptions = isPlainObject$3(options2[0]) ? options2[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name2) => app2.component(name2, Translation));
    [NumberFormat.name, "I18nN"].forEach((name2) => app2.component(name2, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name2) => app2.component(name2, DatetimeFormat));
  }
  {
    app2.directive("t", vTDirective(i18n));
  }
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n$1(options2 = {}, VueI18nLegacy) {
  const __globalInjection = isBoolean(options2.globalInjection) ? options2.globalInjection : true;
  const __allowComposition = true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options2);
  const symbol = /* @__PURE__ */ makeSymbol("");
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  {
    const i18n = {
      // mode
      get mode() {
        return "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app2, ...options22) {
        app2.__VUE_I18N_SYMBOL__ = symbol;
        app2.provide(app2.__VUE_I18N_SYMBOL__, i18n);
        if (isPlainObject$3(options22[0])) {
          const opts = options22[0];
          i18n.__composerExtend = opts.__composerExtend;
          i18n.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (__globalInjection) {
          globalReleaseHandler = injectGlobalFields(app2, i18n.global);
        }
        {
          apply(app2, i18n, ...options22);
        }
        const unmountApp = app2.unmount;
        app2.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n.dispose();
          unmountApp();
        };
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n;
  }
}
function useI18n$1(options2 = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options2, componentOptions);
  if (scope === "global") {
    adjustI18nResources(gl, options2, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n, instance, options2.__useComponent);
    if (composer2 == null) {
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign$3({}, options2);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options2, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = scope.run(() => createComposer(options2));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance) {
  {
    const i18n = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n;
  }
}
function getScope(options2, componentOptions) {
  return isEmptyObject(options2) ? "__i18n" in componentOptions ? "local" : "global" : !options2.useScope ? "local" : options2.useScope;
}
function getGlobalComposer(i18n) {
  return i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
}
function getComposer(i18n, target, useComponent = false) {
  let composer = null;
  const root = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n;
    if (i18n.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    }
    if (composer != null) {
      break;
    }
    if (root === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
function setupLifeCycle(i18n, target, composer) {
  {
    onMounted(() => {
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      i18n.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app2, composer) {
  const i18n = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap2 = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n, prop, wrap2);
  });
  app2.config.globalProperties.$i18n = i18n;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app2.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app2.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags();
}
{
  registerMessageCompiler(compile);
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
const isObject$4 = (item) => item && typeof item === "object" && !Array.isArray(item);
const mergeDeep = (target, ...sources) => {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (isObject$4(target) && isObject$4(source)) {
    for (const key in source) {
      if (isObject$4(source[key])) {
        if (!target[key])
          Object.assign(target, { [key]: {} });
        mergeDeep(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return mergeDeep(target, ...sources);
};
const compiledMessages = mergeDeep(
  {},
  { "en-US": {
    "links": {
      "learnMore": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Learn more."]);
      },
      "learnMoreButton": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Learn more"]);
      },
      "needHelp": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Need help"]);
      }
    },
    "components": {
      "modal": {
        "dismiss": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Dismiss"]);
        }
      },
      "fileSearch": {
        "noMatchesForExtension": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["No files found when searching for the file extension"]);
        },
        "noMatchesForFileName": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize([]);
        },
        "byFilenameInput": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Search by filename..."]);
        },
        "byExtensionInput": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Extensions to include e.g. *.tsx, *.vue"]);
        },
        "matchesIndicatorEmptyFileSearch": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["No matches"]), _normalize(["1 match"]), _normalize([_interpolate(_named("denominator")), " matches"])]);
        },
        "matchesIndicator": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["No matches"]), _normalize([_interpolate(_named("numerator")), " of ", _interpolate(_named("denominator")), " matches"]), _normalize([_interpolate(_named("numerator")), " of ", _interpolate(_named("denominator")), " matches"])]);
        }
      },
      "button": {
        "cancel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cancel"]);
        },
        "back": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Back"]);
        }
      },
      "loading": {
        "config": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Initializing config..."]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Please wait while we load your project and find browsers installed on your system"]);
          }
        }
      },
      "select": {
        "placeholder": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Choose an option..."]);
        }
      },
      "alert": {
        "dismissAriaLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Dismiss"]);
        }
      },
      "specPattern": {
        "matches": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["No matches"]), _normalize([_interpolate(_named("n")), " match"]), _normalize([_interpolate(_named("n")), " matches"])]);
        }
      },
      "specPatternModal": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Spec pattern settings"]);
        }
      }
    },
    "clipboard": {
      "copy": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Copy"]);
      },
      "copied": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Copied!"]);
      }
    },
    "actions": {
      "close": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Close"]);
      }
    },
    "file": {
      "edit": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Edit"]);
      },
      "git": {
        "modified": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Modified"]);
        },
        "created": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Created"]);
        }
      }
    },
    "status": {
      "enabled": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Enabled"]);
      },
      "disabled": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Disabled"]);
      }
    },
    "createSpec": {
      "newSpec": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["New spec"]);
      },
      "createSpec": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Create spec"]);
      },
      "done": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Done!"]);
      },
      "noComponentsFound": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["No components found"]);
      },
      "unableToParseFile": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Unable to parse file"]);
      },
      "updateSpecPattern": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Update spec pattern"]);
      },
      "newSpecModalTitle": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Create new spec"]);
      },
      "successPage": {
        "header": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Great! The spec was successfully added"]);
        },
        "runSpecButton": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Okay, run the spec"]);
        },
        "createAnotherSpecButton": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Create another spec"]);
        }
      },
      "page": {
        "defaultPatternNoSpecs": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Create your first spec"]);
          },
          "component": {
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Since this project looks new, we recommend that you get started by creating a spec for one of your components."]);
            }
          },
          "e2e": {
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Since this project looks new, we recommend that you use the specs and tests that we've written for you to get started."]);
            }
          }
        },
        "customPatternNoSpecs": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["No specs found"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["We couldn't find any files matching the following spec patterns. You may need to move your specs or update your ", _interpolate(_list(0)), " to find them."]);
          }
        }
      },
      "noSpecsMessage": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["If you feel that you're seeing this screen in error, and there should be specs listed here, you likely need to update the spec pattern."]);
      },
      "viewSpecPatternButton": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["View spec pattern"]);
      },
      "e2e": {
        "importFromScaffold": {
          "header": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Scaffold example specs"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["We'll generate several example specs to help guide you on how to write tests in Cypress."]);
          },
          "specsAddedHeader": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Great! We added the following files to your project:"]);
          },
          "specsAddedButton": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Okay, I got it!"]);
          },
          "specsAddingHeader": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Adding specs..."]);
          }
        },
        "importTemplateSpec": {
          "header": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Create new spec"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["We'll generate a template spec file which can be used to start testing your application."]);
          },
          "chooseFilenameHeader": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Enter the path for your new spec"]);
          },
          "inputPlaceholder": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Enter a relative path..."]);
          },
          "invalidSpecWarning": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["This path is invalid because it doesn't match the following "]);
          },
          "specExtensionWarning": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["We recommend naming your spec to match the following pattern: "]);
          }
        }
      },
      "component": {
        "importFromComponent": {
          "header": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Create from component"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Generate a basic component test for any of the components in this project."]);
          },
          "chooseAComponentHeader": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Choose a component"]);
          }
        },
        "importTemplateSpec": {
          "header": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Create new spec"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["We'll generate a template spec file which can be used to start testing your components."]);
          },
          "invalidComponentWarning": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["We couldn't generate a valid path matching your custom "]);
          }
        }
      }
    },
    "specPage": {
      "pageTitle": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Specs"]);
      },
      "newSpecButton": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["New spec"]);
      },
      "searchPlaceholder": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Search specs"]);
      },
      "clearSearch": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Clear search field"]);
      },
      "componentSpecsHeader": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Component specs"]);
      },
      "e2eSpecsHeader": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["E2E specs"]);
      },
      "componentSpecsHeaderShort": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Component"]);
      },
      "e2eSpecsHeaderShort": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["E2E"]);
      },
      "lastUpdated": {
        "header": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Last updated"]);
        },
        "tooltip": {
          "gitStatus": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Git status"]);
          },
          "gitInfo": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["git info"]);
          },
          "gitInfoAvailable": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize([_interpolate(_list(0)), " of the spec files within this project"]);
          },
          "gitInfoUnavailable": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["Cypress is unable to detect ", _interpolate(_list(0)), " for this project and has defaulted to showing file system data instead"]);
          }
        }
      },
      "latestRuns": {
        "header": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Latest runs"]);
        },
        "headerShort": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Runs"]);
        },
        "tooltip": {
          "connected": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["The ", _interpolate(_list(0)), " in Cypress Cloud"]);
          },
          "notConnected": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["Connect to Cypress Cloud to see the ", _interpolate(_list(0))]);
          },
          "noAccess": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["Request access to this project in Cypress Cloud to view the ", _interpolate(_list(0))]);
          },
          "linkText": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["status of your latest runs"]);
          }
        }
      },
      "averageDuration": {
        "header": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Average duration"]);
        },
        "headerShort": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Duration"]);
        },
        "tooltip": {
          "connected": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["The ", _interpolate(_list(0)), " of your latest runs in Cypress Cloud"]);
          },
          "notConnected": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["Connect to Cypress Cloud to see the ", _interpolate(_list(0)), " of your latest runs"]);
          },
          "noAccess": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["Request access to this project in Cypress Cloud to view the ", _interpolate(_list(0)), " of your latest runs"]);
          },
          "linkText": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["average spec durations"]);
          }
        }
      },
      "flaky": {
        "badgeLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Flaky"]);
        },
        "severityLow": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Low"]);
        },
        "severityMedium": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Medium"]);
        },
        "severityHigh": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["High"]);
        },
        "flakyRate": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize([_interpolate(_list(0)), "% flaky rate"]);
        },
        "flakyRuns": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize([_interpolate(_named("flakyRuns")), " flaky runs / ", _interpolate(_named("totalRuns")), " total"]), _normalize([_interpolate(_named("flakyRuns")), " flaky run / ", _interpolate(_named("totalRuns")), " total"]), _normalize([_interpolate(_named("flakyRuns")), " flaky runs / ", _interpolate(_named("totalRuns")), " total"])]);
        },
        "lastFlaky": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["Last run flaky"]), _normalize(["Last flaky ", _interpolate(_named("runsSinceLastFlake")), " run ago"]), _normalize(["Last flaky ", _interpolate(_named("runsSinceLastFlake")), " runs ago"])]);
        }
      },
      "hoverButton": {
        "connect": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Connect"]);
        },
        "connectProject": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Connect project"]);
        },
        "connectProjectShort": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Connect"]);
        },
        "requestAccess": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Request access"]);
        },
        "requestAccessShort": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Request"]);
        },
        "requestSent": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Request sent"]);
        },
        "requestSentShort": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Sent"]);
        }
      },
      "connectProjectButton": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Connect your project"]);
      },
      "cloudLoginButton": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Log in to Cypress Cloud"]);
      },
      "reconnectProjectButton": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Reconnect your project"]);
      },
      "unauthorizedBannerTitle": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Request access to project"]);
      },
      "requestAccessButton": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Request access"]);
      },
      "requestSentButton": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Request sent"]);
      },
      "rows": {
        "gitTooltipSubtext": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize([_interpolate(_named("shortHash")), " by ", _interpolate(_named("author"))]);
        }
      },
      "noResultsMessage": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["No specs matched your search:"]);
      },
      "noSpecError": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Spec not found"]);
        },
        "intro": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["There is no spec matching the following location:"]);
        },
        "explainer": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["It is possible that the file has been moved or deleted. Please choose from the list of specs below."]);
        }
      },
      "offlineWarning": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["No internet connection"]);
        },
        "explainer": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Please check your internet connection to resolve this issue. When your internet connection is fixed, we will automatically attempt to fetch the run metrics from Cypress Cloud."]);
        }
      },
      "fetchFailedWarning": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Lost connection"]);
        },
        "explainer1": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["The request timed out or failed when trying to retrieve the recorded run metrics from Cypress Cloud. The information that you're seeing in the table below may be incomplete as a result."]);
        },
        "explainer2": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["Please refresh the page to try again and visit our ", _interpolate(_list(0)), " if this behavior continues."]);
        },
        "refreshButton": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Try again"]);
        }
      },
      "banners": {
        "login": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Optimize and record your CI test runs with Cypress Cloud"]);
          },
          "content": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["When you configure Cypress to record tests to Cypress Cloud, you'll see data from your latest recorded runs in the Cypress app. This increased visibility into your test history allows you to debug your tests faster and more effectively, all within your local workflow."]);
          },
          "buttonLabel": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Get started with Cypress Cloud"]);
          }
        },
        "createOrganization": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Finish setting up Cypress Cloud"]);
          },
          "content": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Join or create an organization in Cypress Cloud to access your projects and recorded test runs."]);
          },
          "buttonLabel": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Set up your organization"]);
          }
        },
        "connectProject": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Connect your project to Cypress Cloud"]);
          },
          "content": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Bring your recorded test results into your local development workflow to monitor, run, and fix tests all in the Cypress app."]);
          },
          "buttonLabel": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Connect your project"]);
          }
        },
        "record": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Record your first run"]);
          },
          "content": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Record a run to see your test results in Cypress Cloud. You can then optimize your test suite, debug failing and flaky tests, and integrate with your favorite tools."]);
          }
        },
        "ct": {
          "title": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize([_interpolate(_list(0)), " component testing is available for this project"]);
          },
          "content": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["You can now use Cypress to develop and test individual components without running your whole application. Generate the config in just a few clicks."]);
          },
          "primaryAction": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Quick setup"]);
          },
          "secondaryAction": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Read our guide"]);
          },
          "dismissAction": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Give feedback"]);
          }
        },
        "enableNotifications": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Start debugging as soon as your first tests fail"]);
          },
          "subtitle": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Cypress can notify you about Cloud test runs for your branch."]);
          },
          "enableDesktopNotifications": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Enable desktop notifications"]);
          },
          "remindMeLater": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Remind me later"]);
          },
          "notificationsEnabledTitle": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Notifications Enabled"]);
          },
          "notificationsEnabledBody": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Nice, notifications are enabled!"]);
          },
          "dismissBanner": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Dismiss banner"]);
          }
        }
      },
      "runSelectedSpecs": (ctx) => {
        const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
        return _plural([_normalize(["Run ", _interpolate(_named("n")), " spec"]), _normalize(["Run ", _interpolate(_named("n")), " specs"])]);
      },
      "testingTypePromo": {
        "e2e": {
          "header": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["End-to-end testing is not set up for this project"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
              return _normalize(["Try it out now, or ", _interpolate(_list(0)), " to learn more"]);
            },
            "link": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["read our guides"]);
            },
            "control": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Quick setup"]);
            }
          },
          "body": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["What is end-to-end testing?"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["End-to-end tests are perfect for testing your entire application from a user's perspective. Visit any URL and test full user journeys across pages and domains."]);
            },
            "listItem1": (ctx) => {
              const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
              return _normalize(["Test full user journeys across multiple pages using ", _interpolate(_list(0)), " to load up a web page for your test."]);
            },
            "listItem1Command": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["cy.visit()"]);
            },
            "listItem2": (ctx) => {
              const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
              return _normalize(["Work with live API calls or mock them with ", _interpolate(_list(0)), " to test all possible states of your app."]);
            },
            "listItem2Command": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["cy.intercept()"]);
            },
            "listItem3": (ctx) => {
              const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
              return _normalize(["Use ", _interpolate(_list(0)), " to maintain consistent browser sessions in your tests, and work with features like cookies and local storage, all while keeping your tests properly isolated."]);
            },
            "listItem3Command": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["cy.session()"]);
            }
          }
        },
        "ct": {
          "header": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Component testing is not set up for this project"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
              return _normalize(["Try it out now, or ", _interpolate(_list(0)), " to learn more"]);
            },
            "link": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["read our guides"]);
            },
            "control": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Quick setup"]);
            }
          },
          "body": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["What is Component Testing?"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Cypress Component Testing is a technique for developers to write, test, and debug components in isolation without ever leaving the browser - and without having to run your entire application."]);
            },
            "listItem1": (ctx) => {
              const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
              return _normalize(["Instead of visiting a page, use ", _interpolate(_list(0)), " to render your components directly in the browser."]);
            },
            "listItem1Command": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["cy.mount()"]);
            },
            "listItem2": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Test from a user's perspective with all the same Cypress commands that are available in end-to-end testing."]);
            },
            "listItem3": (ctx) => {
              const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
              return _normalize(["To get started, you can generate the config for ", _interpolate(_list(0)), ", ", _interpolate(_list(1)), ", and ", _interpolate(_list(2)), " (and ", _interpolate(_list(3)), "!)."]);
            },
            "listItem3Link": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["more"]);
            },
            "link": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Give feedback"]);
            }
          }
        }
      }
    },
    "noResults": {
      "defaultMessage": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["No results matched your search:"]);
      },
      "clearSearch": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Clear search"]);
      }
    },
    "sidebar": {
      "keyboardShortcuts": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Keyboard shortcuts"]);
        },
        "rerun": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Re-run tests"]);
        },
        "stop": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Stop tests"]);
        },
        "toggle": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Toggle specs list"]);
        }
      },
      "toggleLabel": {
        "expanded": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Collapse sidebar"]);
        },
        "collapsed": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Expand sidebar"]);
        }
      },
      "nav": {
        "ariaLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Pages"]);
        }
      },
      "debug": {
        "debugFeature": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["New Debug feature"]);
        },
        "passed": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Relevant run passed"]);
        },
        "failed": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["Relevant run had ", _interpolate(_named("n")), " test failure"]), _normalize(["Relevant run had ", _interpolate(_named("n")), " test failures"])]);
        },
        "errored": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Relevant run had an error"]);
        },
        "erroredWithFailures": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["Relevant run had an error with ", _interpolate(_named("n")), " test failure"]), _normalize(["Relevant run had an error with ", _interpolate(_named("n")), " test failures"])]);
        },
        "passing": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Relevant run is passing"]);
        },
        "failing": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["Relevant run is failing with ", _interpolate(_named("n")), " test failure"]), _normalize(["Relevant run is failing with ", _interpolate(_named("n")), " test failures"])]);
        }
      },
      "runs": {
        "running": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Latest run is in progress"]);
        },
        "failing": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["Latest run is failing with ", _interpolate(_named("n")), " test failure"]), _normalize(["Latest run is failing with ", _interpolate(_named("n")), " test failures"])]);
        },
        "passed": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Latest run passed"]);
        },
        "failed": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["Latest run had ", _interpolate(_named("n")), " test failure"]), _normalize(["Latest run had ", _interpolate(_named("n")), " test failures"])]);
        },
        "cancelled": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Latest run has been cancelled"]);
        },
        "errored": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Latest run had an error"]);
        },
        "erroredWithFailures": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["Latest run had an error with ", _interpolate(_named("n")), " test failure"]), _normalize(["Latest run had an error with ", _interpolate(_named("n")), " test failures"])]);
        }
      }
    },
    "topNav": {
      "released": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Released"]);
      },
      "version": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Version"]);
      },
      "versionUnsupported": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Unsupported"]);
      },
      "installed": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Installed"]);
      },
      "latest": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Latest"]);
      },
      "seeAllReleases": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["See all releases"]);
      },
      "runningOldVersion": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["You're currently running an old version of Cypress. Update to the latest version for the best experience."]);
      },
      "docsMenu": {
        "docsHeading": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Docs"]);
        },
        "gettingStartedTitle": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Getting started"]);
        },
        "firstTest": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Write your first test"]);
        },
        "testingApp": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Testing your app"]);
        },
        "organizingTests": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Organizing tests"]);
        },
        "referencesTitle": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["References"]);
        },
        "bestPractices": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Best practices"]);
        },
        "configuration": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Configuration"]);
        },
        "api": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["API"]);
        },
        "ciTitle": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Run in CI/CD"]);
        },
        "ciSetup": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Set up CI"]);
        },
        "fasterTests": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Run tests faster"]);
        },
        "prompts": {
          "ci1": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Configure CI"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Optimize your tests in CI by following these guides."]);
            },
            "seeOtherGuides": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["See other guides"]);
            },
            "intro": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Introduction to CI"]);
            },
            "learnTheBasics": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Learn the basics of running Cypress in CI."]);
            }
          },
          "orchestration1": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Run tests faster in CI"]);
            },
            "parallelTime": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["5 mins"]);
            },
            "noParallelTime": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["12 mins"]);
            },
            "withParallelization": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["with Parallelization"]);
            },
            "withoutParallelization": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["without Parallelization"]);
            },
            "intro": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["With Smart Orchestration, you'll be able to:"]);
            },
            "bullet1": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Run spec files in parallel"]);
            },
            "bullet2": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Prioritize failed specs to run first"]);
            },
            "bullet3": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Cancel CI runs on test failure"]);
            },
            "learnMore": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Learn more"]);
            }
          }
        }
      },
      "login": {
        "bodyInitial": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["Logging in gives you access to ", _interpolate(_list(0)), ". You can set up projects to be recorded and see test data from your project."]);
        },
        "bodySuccess": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["You are now logged in as ", _interpolate(_list(0)), "."]);
        },
        "bodyError": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["An error occurred while attempting to log in:"]);
        },
        "bodyBrowserError": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["The browser could not be opened."]);
        },
        "bodyBrowserErrorDetails": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress was unable to open your installed browser. To continue logging in, please paste this URL into your web browser:"]);
        },
        "cloud": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress Cloud"]);
        },
        "titleInitial": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Log in to Cypress"]);
        },
        "titleSuccess": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Login successful"]);
        },
        "titleFailed": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Login failed"]);
        },
        "titleBrowserError": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Browser error"]);
        },
        "actionLogin": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Log in"]);
        },
        "profileMenuLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Profile and logout"]);
        },
        "actionLogout": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Log out"]);
        },
        "actionContinue": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Continue"]);
        },
        "actionOpening": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Opening browser"]);
        },
        "actionWaiting": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Waiting for you to log in"]);
        },
        "actionTryAgain": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Try again"]);
        },
        "actionCancel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cancel"]);
        }
      },
      "updateCypress": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Upgrade to Cypress"]);
        },
        "currentlyRunning": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["You are currently running Version ", _interpolate(_list(0)), " of Cypress. "]);
        },
        "pasteToUpgradeProject": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["To upgrade to the latest version for your project, first ", _interpolate(_list(0)), ", then paste the command below into your terminal:"]);
        },
        "pasteToUpgradeGlobal": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["To upgrade to the latest version, first ", _interpolate(_list(0)), ", then paste the command below into your terminal:"]);
        },
        "rememberToCloseInsert": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["close this app"]);
        }
      },
      "upgradeText": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Upgrade"]);
      },
      "global": {
        "projects": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Projects"]);
        }
      }
    },
    "launchpadErrors": {
      "generic": {
        "configErrorTitle": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress configuration error"]);
        },
        "retryButton": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Try again"]);
        },
        "stackTraceLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Stack trace"]);
        },
        "docsButton": {
          "configGuide": {
            "text": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Configuration guide"]);
            },
            "link": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["https://on.cypress.io/configuration"]);
            }
          },
          "cloudGuide": {
            "text": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Cypress Cloud guide"]);
            },
            "link": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["https://on.cypress.io/features-dashboard"]);
            }
          },
          "docsHomepage": {
            "text": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Cypress docs"]);
            },
            "link": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["https://docs.cypress.io"]);
            }
          }
        }
      },
      "noInternet": {
        "header": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["You have no internet connection"]);
        },
        "message": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Check your internet connection to pull the latest data from Cypress Cloud."]);
        },
        "connectProject": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Please check your internet connection to resolve this issue. When your internet connection is fixed, we will automatically attempt to fetch your latest runs for this project."]);
        }
      }
    },
    "setupPage": {
      "projectSetup": {
        "frameworkLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Front-end framework"]);
        },
        "frameworkPlaceholder": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Pick a framework"]);
        },
        "bundlerLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Bundler"]);
        },
        "bundlerPlaceholder": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Pick a bundler"]);
        },
        "languageLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Language"]);
        },
        "configFileLanguageLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress config file"]);
        },
        "detected": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["(detected)"]);
        },
        "browseIntegrations": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Browse our list of third-party framework integrations"]);
        },
        "communityFrameworkDefinitionProblem": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Community framework definition problem"]);
        },
        "communityDependenciesCouldNotBeParsed": (ctx) => {
          const { normalize: _normalize, plural: _plural } = ctx;
          return _plural([_normalize(["This project has a community framework definition installed that could not be loaded. It is located at the following path:"]), _normalize(["This project has some community framework definitions installed that could not be loaded. They are located at the following paths:"])]);
        },
        "seeFrameworkDefinitionDocumentation": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["See the ", _interpolate(_list(0)), " for more information about creating, installing, and troubleshooting third party definitions."]);
        },
        "frameworkDefinitionDocumentation": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["framework definition documentation"]);
        }
      },
      "step": {
        "continue": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Continue"]);
        },
        "next": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Next step"]);
        },
        "back": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Back"]);
        },
        "skip": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Skip"]);
        }
      },
      "configFile": {
        "createManually": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Create file manually"]);
        },
        "skippedLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Skipped"]);
        },
        "changesRequiredLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Changes required"]);
        },
        "changesRequiredBadge": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Changes required"]);
        },
        "changesRequiredDescription": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["Please merge the code below with your existing ", _interpolate(_list(0))]);
        }
      },
      "testingCard": {
        "configured": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Configured"]);
        },
        "notConfigured": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Not Configured"]);
        },
        "running": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Running"]);
        },
        "chooseABrowser": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Choose a browser"]);
        },
        "reconfigure": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Reconfigure"]);
        },
        "disabled": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Disabled"]);
        }
      }
    },
    "globalPage": {
      "empty": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Add project"]);
        },
        "helper": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Get started by adding your first project below."]);
        },
        "dropText": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["Drag your project directory here or ", _interpolate(_list(0))]);
        },
        "browseManually": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["browse manually."]);
        }
      },
      "settings": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Settings"]);
      },
      "saveChanges": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Save changes"]);
      },
      "cancel": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Cancel"]);
      },
      "externalEditorPreferences": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["External editor preferences"]);
      },
      "externalEditorPreferencesDescription1": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Select your preference for opening files on your system."]);
      },
      "externalEditorPreferencesDescription2": (ctx) => {
        const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
        return _normalize(["You can change this later in the ", _interpolate(_list(0)), " page."]);
      },
      "recentProjectsHeader": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Recent projects"]);
      },
      "searchPlaceholder": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Search projects"]);
      },
      "addProjectButton": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Add project"]);
      },
      "projectActions": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Project actions"]);
      },
      "removeProject": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Remove project"]);
      },
      "openInIDE": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Open in IDE"]);
      },
      "openInFinder": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Open in Finder"]);
      },
      "noResultsMessage": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["No projects matched your search:"]);
      }
    },
    "welcomePage": {
      "review": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Review the differences between each testing type"]);
      },
      "codeExample": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Code example"]);
      },
      "compareTypes": {
        "content": {
          "e2eTitle": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["End-to-end tests"]);
          },
          "e2eBullet1": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Visit URLs via"]);
          },
          "e2eBullet2": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Test flows and functionality across multiple pages"]);
          },
          "e2eBullet3": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Ideal for testing integrated flows in CD workflows"]);
          },
          "componentTitle": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Component tests"]);
          },
          "ctBullet1": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Import components via"]);
          },
          "ctBullet2": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Test individual components of a design system in isolation"]);
          },
          "ctBullet3": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Ideal for testing isolated flows and components in CI"]);
          }
        },
        "modalTitle": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Key differences"]);
        }
      },
      "title": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Welcome to Cypress!"]);
      }
    },
    "settingsPage": {
      "config": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Resolved configuration"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["Since the options in the ", _interpolate(_list(0)), " can be set dynamically by your development environment, please refer to the legend below to understand how the configuration options are resolved."]);
        },
        "legend": {
          "env": {
            "label": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["env"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Set from environment variables"]);
            }
          },
          "default": {
            "label": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["default"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Default values"]);
            }
          },
          "dynamic": {
            "label": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["dynamic"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
              return _normalize(["Set by the ", _interpolate(_list(0)), " function"]);
            }
          },
          "cli": {
            "label": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["cli"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Set from CLI arguments"]);
            }
          },
          "config": {
            "label": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["config"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
              return _normalize(["Set from ", _interpolate(_list(0))]);
            }
          }
        }
      },
      "proxy": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Proxy settings"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress auto-detected the following proxy settings from your operating system."]);
        },
        "bypassList": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Proxy bypass list"]);
        },
        "proxyServer": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Proxy server"]);
        }
      },
      "editor": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["External editor"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["External editor to use for editing code opened when using Cypress."]);
        },
        "noEditorSelectedPlaceholder": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Choose your editor..."]);
        },
        "customPathPlaceholder": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["/path/to/editor"]);
        }
      },
      "notifications": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Desktop notifications"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress can notify you about Cloud test runs for your branch."]);
        },
        "notifyMeWhenRunStarts": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Notify me when a run starts"]);
        },
        "notifyMeWhenRunIsFailing": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Notify me when a run begins to fail"]);
        },
        "notifyMeWhenRunCompletes": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Notify me when a run completes"]);
        },
        "passed": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Passed"]);
        },
        "failed": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Failed"]);
        },
        "canceled": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Canceled"]);
        },
        "errored": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Errored"]);
        },
        "sendTestNotification": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Send a test notification"]);
        },
        "notReceivingNotifications": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["Not receiving notifications? You might need to allow notifications from Cypress in your computer's system preferences. ", _interpolate(_list(0))]);
        },
        "testNotificationTitle": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Hello From Cypress"]);
        },
        "testNotificationBody": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["This is a test notification"]);
        },
        "troubleshoot": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Troubleshoot"]);
        },
        "enableNotificationsLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["To modify notification settings, enable desktop notifications"]);
        }
      },
      "projectId": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Project ID"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["The Project ID configured for this project inside of Cypress Cloud. ", _interpolate(_list(0))]);
        }
      },
      "specPattern": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Spec patterns"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["The globs pointing Cypress to your spec files configured for this project. ", _interpolate(_list(0))]);
        }
      },
      "recordKey": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Record key"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["The Record Key configured for this project inside of Cypress Cloud. ", _interpolate(_list(0))]);
        },
        "manageKeys": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Manage keys"]);
        },
        "errorEmpty": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["You do not have permission to record on this project"]);
        },
        "errorEmptyButton": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Request record rights"]);
        },
        "errorAccess": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["You do not have permission to view this project"]);
        },
        "errorAccessPending": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Your request for access to this project is pending approval"]);
        },
        "errorAccessButton": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Request access"]);
        },
        "errorNotFound": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Project not found"]);
        },
        "errorNotFoundButton": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Connect it again"]);
        },
        "errorNotLoggedIn": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["You are not connected to Cypress Cloud"]);
        },
        "errorNotLoggedInButton": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Log in to Cypress Cloud"]);
        }
      },
      "project": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Project settings"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Review the configuration settings currently in use for this project."]);
        }
      },
      "cloud": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress Cloud settings"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Review the configuration settings for recording to Cypress Cloud."]);
        }
      },
      "experiments": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Experiments"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["If you'd like to try out new features that we're working on, you can enable beta features for your project by turning on the experimental features you'd like to try. ", _interpolate(_list(0))]);
        },
        "experimentalCspAllowList": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["CSP Allow List"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Enables Cypress to selectively permit Content-Security-Policy and Content-Security-Policy-Report-Only header directives, including those that might otherwise block Cypress from running."]);
          }
        },
        "experimentalFetchPolyfill": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Fetch polyfill"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Automatically replaces `window.fetch` with a polyfill that Cypress can spy on and stub. Note: `experimentalFetchPolyfill` has been deprecated in Cypress 6.0.0 and will be removed in a future release. Consider using [`cy.intercept()`](https://on.cypress.io/intercept) to intercept `fetch` requests instead."]);
          }
        },
        "experimentalInteractiveRunEvents": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Interactive run events"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Allows listening to the [`before:run`](https://on.cypress.io/before-run), [`after:run`](https://on.cypress.io/after-run), [`before:spec`](https://on.cypress.io/before-spec), and [`after:spec`](https://on.cypress.io/after-spec) events in plugins during interactive mode."]);
          }
        },
        "experimentalModifyObstructiveThirdPartyCode": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Modify obstructive third party code"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Applies `modifyObstructiveCode` to third party `.html` and `.js`, removes subresource integrity, and modifies the user agent in Electron."]);
          }
        },
        "retries": {
          "experimentalStrategy": {
            "name": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Retries Strategy"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(['Applies a strategy for test retries according to your "flake tolerance"; options are `detect-flake-but-always-fail` or `detect-flake-and-pass-on-threshold`.']);
            }
          },
          "experimentalOptions": {
            "name": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Retries Strategy Options"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Sets retries strategy-specific options like `maxRetries`, `passesRequired`, and `stopIfAnyPassed`."]);
            }
          }
        },
        "experimentalSingleTabRunMode": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Single tab run mode"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Runs all component specs in a single tab, trading spec isolation for faster run mode execution."]);
          }
        },
        "experimentalJustInTimeCompile": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Just-In-Time compiling"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Enables Just-In-Time (JIT) compiling for component testing, which will only compile assets related to the spec before the spec is run. Currently supported for Vite and Webpack."]);
          }
        },
        "experimentalSourceRewriting": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Source rewriting"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Enables AST-based JS/HTML rewriting. This may fix issues caused by the existing regex-based JS/HTML replacement algorithm. See [#5273](https://github.com/cypress-io/cypress/issues/5273) for details."]);
          }
        },
        "experimentalStudio": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Studio"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Generate and save commands directly to your test suite by interacting with your app as an end user would."]);
          }
        },
        "experimentalWebKitSupport": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["WebKit Support"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Adds support for testing in the WebKit browser engine used by Safari. See https://on.cypress.io/webkit-experiment for more information."]);
          }
        },
        "experimentalRunAllSpecs": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Run All Specs"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(['Enables the "Run All Specs" UI feature, allowing the execution of multiple specs sequentially.']);
          }
        },
        "experimentalOriginDependencies": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Origin Dependencies"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Enables support for `Cypress.require()` for including dependencies within the `cy.origin()` callback."]);
          }
        },
        "experimentalMemoryManagement": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Memory Management"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Enables support for improved memory management within Chromium-based browsers."]);
          }
        },
        "experimentalSkipDomainInjection": {
          "name": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Skip Domain Injection"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Disables setting `document.domain` to the application's super domain on injection."]);
          }
        }
      },
      "device": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Device settings"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Review the configuration settings currently in use for this device."]);
        }
      },
      "testingPreferences": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Testing preferences"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Configure your testing environment with these flags"]);
        },
        "autoScrollingEnabled": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Auto scrolling enabled"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Scroll behavior when running tests."]);
          }
        }
      },
      "footer": {
        "text": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["You can reconfigure the ", _interpolate(_named("testingType")), " testing settings for this project if you're experiencing issues with your Cypress configuration."]);
        },
        "button": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Configuration guide"]);
        },
        "buttonLink": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["https://on.cypress.io/configuration"]);
        }
      }
    },
    "runs": {
      "slideshow": {
        "tour": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Record your first test run to Cypress Cloud"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["You're almost there! Start recording your test runs to Cypress Cloud by running the command above in your local or CI terminal."]);
          }
        },
        "step1": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Monitor test failures in real time"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Uncover high-risk failed and flaky tests in CI before they become a problem in production."]);
          }
        },
        "step2": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Check if failed CI test runs also fail locally"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Use the Test Runner to run only the tests that failed in your last recorded run."]);
          }
        },
        "step3": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Build, test, and ship with confidence "]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["With Cypress Cloud, you can proactively identify, investigate, and resolve failures, and be a quality champion."]);
          }
        },
        "controls": {
          "step": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize([_interpolate(_list(0)), " of ", _interpolate(_list(1))]);
          },
          "next": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Next"]);
          },
          "reset": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Reset"]);
          },
          "view": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["View Tour"]);
          }
        }
      },
      "connect": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Connect to view your recorded runs"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress Cloud is built for teams who need to do testing at scale."]);
        },
        "buttonUser": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Connect to Cypress Cloud"]);
        },
        "buttonProject": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Connect a Cypress Cloud project"]);
        },
        "modal": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Connect project"]);
          },
          "cancel": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Cancel"]);
          },
          "createOrg": {
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["You need to create an organization in Cypress Cloud to continue."]);
            },
            "button": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Create organization"]);
            },
            "waitingButton": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Waiting for you to create an organization..."]);
            },
            "refreshButton": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Refresh organizations list"]);
            }
          },
          "selectProject": {
            "organization": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Organization"]);
            },
            "noOrganizationSelectedError": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["required when creating a new project"]);
            },
            "manageOrgs": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Manage organizations"]);
            },
            "project": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Project"]);
            },
            "projectName": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Project name"]);
            },
            "projectNameDisclaimer": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["(You can change this later)"]);
            },
            "createNewProject": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Create new"]);
            },
            "chooseExistingProject": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Choose an existing project"]);
            },
            "newProjectAccess": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Project access"]);
            },
            "privateLabel": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Private"]);
            },
            "privateDescription": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Only invited users can view recorded test results."]);
            },
            "publicLabel": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Public"]);
            },
            "publicDescription": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Anyone can view recorded test results."]);
            },
            "connectProject": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Connect project"]);
            },
            "createProject": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Create project"]);
            },
            "placeholderOrganizations": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Pick an organization"]);
            },
            "placeholderProjects": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Pick a project"]);
            },
            "placeholderProjectsPending": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Pick an organization first"]);
            }
          },
          "connectManually": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Connect project manually"]);
            },
            "warning": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["We couldn't add the projectId to your cypress.config.js file automatically."]);
            },
            "mainMessage": (ctx) => {
              const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
              return _normalize(["Manually add the ", _interpolate(_named("projectId")), " to the root of the config object in your ", _interpolate(_named("configFile")), " file."]);
            },
            "waitingButton": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Waiting for you to add the projectId..."]);
            }
          }
        },
        "errors": {
          "baseError": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Cypress Cloud error"]);
            }
          },
          "internalServerError": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Cannot connect to Cypress Cloud"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
              return _normalize(["The request times out when trying to retrieve the info from Cypress Cloud. Please refresh the page to try again and visit our ", _interpolate(_list(0)), " if this behavior continues."]);
            },
            "link": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Support Page"]);
            }
          }
        }
      },
      "connectSuccessAlert": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["This project is now connected to Cypress Cloud!"]);
        },
        "item1": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["We automatically added the ", _interpolate(_named("projectId")), " to your ", _interpolate(_named("configFile")), " file."]);
        },
        "item2": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["Please ensure that your ", _interpolate(_list(0)), " file is checked into source control."]);
        }
      },
      "empty": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Copy the command below to record your first run"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["Review the ", _interpolate(_list(0)), " to Cypress Cloud"]);
        },
        "link": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["guide on recording runs"]);
        },
        "gitRepositoryNotDetected": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Git repository not detected"]);
        },
        "ensureGitSetupCorrectly": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress uses Git to associate runs with your local state. As a fallback, all runs for your project are shown. Please ensure that version control is set up correctly."]);
        },
        "noRunsFoundForBranch": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["No runs found for your branch"]);
        },
        "noRunsForBranchMessage": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress uses Git to show runs for your branch. As a fallback, all runs for your project are shown. Ensure that version control is properly configured and that you are sending Git information to Cypress Cloud."]);
        }
      },
      "results": {
        "skipped": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["skipped"]);
        },
        "pending": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["pending"]);
        },
        "passed": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["passed"]);
        },
        "failed": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["failed"]);
        }
      },
      "errors": {
        "notFound": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Couldn't find your project"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["We were unable to find an existing project matching the ", _interpolate(_list(0)), " set in your Cypress config file. You can reconnect with an existing project or create a new project."]);
          },
          "button": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Reconnect your project"]);
          }
        },
        "unauthorized": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Request access to view the recorded runs"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["This is a private project that you do not currently have access to. Please request access from the project owner in order to view the list of runs."]);
          },
          "button": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Request access"]);
          }
        },
        "unauthorizedRequested": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Your access request for this project has been sent."]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["The owner of this project has been notified of your request. We'll notify you via email when your access request has been granted."]);
          },
          "button": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Request Sent"]);
          }
        },
        "connectionFailed": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Cannot connect to Cypress Cloud"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["The request times out when trying to retrieve the recorded runs from Cypress Cloud. Please refresh the page to try again and visit out ", _interpolate(_list(0)), " if this behavior continues."]);
          },
          "link": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Support page"]);
          },
          "button": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Try again"]);
          }
        }
      },
      "card": {
        "branchName": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Branch Name:"]);
        },
        "commitAuthor": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Commit Author:"]);
        },
        "totalDuration": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Run Total Duration:"]);
        },
        "debugLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Debug"]);
        },
        "debugDescription": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["View debug for run ", _interpolate(_named("runNumber"))]);
        },
        "noDebugAvailable": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["You can only debug runs for your most recent commits."]);
        }
      },
      "layout": {
        "viewCloudRuns": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["View runs in Cypress Cloud"]);
        },
        "checkedOut": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Checked out"]);
        }
      }
    },
    "debugPage": {
      "openFile": {
        "openInIDE": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Open in IDE"]);
        },
        "notFoundLocally": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Opening in IDE is disabled because the spec is not found in this project"]);
        }
      },
      "limit": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress renders up to 100 failed test results"]);
        },
        "message": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["This run has ", _interpolate(_named("n")), " failed tests"]), _normalize(["This run has ", _interpolate(_named("n")), " failed test"]), _normalize(["This run has ", _interpolate(_named("n")), " failed tests"])]);
        },
        "link": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["See all test results in Cypress Cloud"]);
        }
      },
      "runFailures": {
        "btn": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Run Failures"]);
        },
        "notFoundLocally": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Spec was not found locally"]);
        },
        "switchTestingTypeInfo": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["There is ", _interpolate(_named("n")), " ", _interpolate(_named("testingType")), " test failing in this spec. To run it locally switch to ", _interpolate(_named("testingType")), " testing."]), _normalize(["There are ", _interpolate(_named("n")), " ", _interpolate(_named("testingType")), " tests failing in this spec. To run them locally switch to ", _interpolate(_named("testingType")), " testing."])]);
        },
        "switchTestingTypeAction": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["Switch to ", _interpolate(_named("testingType")), " testing"]);
        }
      },
      "switchToRun": (ctx) => {
        const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
        return _normalize(["Switch to run number ", _interpolate(_named("runNumber"))]);
      },
      "overLimit": {
        "usageExceededTitle": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["You've reached your monthly test result limit"]);
        },
        "usageExceededUserMessage": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["Your Free Cypress Cloud plan includes ", _interpolate(_named("numberTests")), " monthly recorded test results. Contact your Cypress Cloud admin to upgrade your plan and view more test results."]);
        },
        "usageExceededAdminMessage": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["Your Free Cypress Cloud plan includes ", _interpolate(_named("numberTests")), " monthly recorded test results. Upgrade your plan now to view more test results."]);
        },
        "retentionExceededTitle": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Beyond data retention"]);
        },
        "retentionExceededMessage": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["Your data retention limit is ", _interpolate(_named("limitDays")), " days and these tests ran ", _interpolate(_named("runAgeDays")), " days ago. Upgrade your plan to increase your data retention limit."]);
        },
        "upgradePlan": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Upgrade plan"]);
        },
        "contactAdmin": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Contact admin"]);
        }
      },
      "wellDone": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Well Done!"]);
      },
      "allYourTestsPassed": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["All your tests passed."]);
      },
      "incomplete": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Incomplete"]);
      },
      "specsSkipped": (ctx) => {
        const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
        return _plural([_normalize([_interpolate(_named("totalSkippedSpecs")), " of ", _interpolate(_named("n")), " spec skipped"]), _normalize([_interpolate(_named("totalSkippedSpecs")), " of ", _interpolate(_named("n")), " specs skipped"])]);
      },
      "runHasNoTests": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Run has no tests"]);
      },
      "theRunStartedButNeverCompleted": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["The run started but never completed. This can happen when the run is cancelled from CI or when Cypress crashes while running tests."]);
      },
      "checkYourCiLogs": (ctx) => {
        const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
        return _normalize(["Check your ", _interpolate(_list(0)), " logs for more information."]);
      },
      "archiveThisRun": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Archive this run to remove it from the runs list and analytics."]);
      },
      "manuallyCancelled": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Manually cancelled"]);
      },
      "mostRecentRun": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["You are on the most recent run"]);
      },
      "switchToLatestRun": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Switch to latest run"]);
      },
      "switchRun": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Switch run"]);
      },
      "foundMoreThan100Runs": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["We found more than 100 runs."]);
      },
      "goToCypressCloud": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Go to Cypress Cloud to see all runs"]);
      },
      "emptyStates": {
        "debugDirectlyInCypress": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Debug failed CI runs directly in Cypress"]);
        },
        "reviewRerunAndDebug": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Review, rerun, and debug failed CI test runs that are recorded to Cypress Cloud  all from within your local Cypress app."]);
        },
        "connectToCypressCloud": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Connect to Cypress Cloud"]);
        },
        "connect": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Connect to debug your tests"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Cypress Cloud is built for teams who need to do testing at scale."]);
          }
        },
        "noProjectTestMessage": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Connect a Cypress Cloud project to locally debug failed CI test runs"]);
        },
        "noRuns": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Copy the command below to record your first run"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["Review the ", _interpolate(_list(0)), " to Cypress Cloud"]);
          },
          "link": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["guide on recording runs"]);
          }
        },
        "gitRepositoryNotDetected": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Git repository not detected"]);
        },
        "ensureGitSetupCorrectly": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress uses Git to associate runs with your local state. Please ensure that Git is properly configured for your project."]);
        },
        "learnAboutRecordingSrText": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["about recording a run to Cypress Cloud"]);
        },
        "learnAboutDebuggingSrText": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["about debugging CI failures in Cypress"]);
        },
        "learnAboutProjectSetupSrText": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["about project setup in Cypress"]);
        },
        "noRunsFoundForBranch": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["No runs found for your branch"]);
        },
        "noRunsForBranchMessage": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cypress uses Git to show runs for your branch. Ensure that version control is properly configured and that you are sending Git information to Cypress Cloud."]);
        },
        "slideshow": {
          "tour": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Record your first test run to Cypress Cloud"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["You're almost there! Start recording your test runs to Cypress Cloud by running the command below in your local or CI terminal."]);
            }
          },
          "step1": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Review how many tests failed during a CI test run"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["The Debug page shows the latest completed test run for your current checked out commit."]);
            }
          },
          "step2": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Check if failed CI test runs also fail locally"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Use the Test Runner to run only the tests that failed in your last recorded run."]);
            }
          },
          "step3": {
            "title": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Locally debug failed test runs with visual artifacts"]);
            },
            "description": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Easily review screenshots, videos and logs from your tests."]);
            }
          },
          "controls": {
            "step": (ctx) => {
              const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
              return _normalize([_interpolate(_list(0)), " of ", _interpolate(_list(1))]);
            },
            "next": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Next"]);
            },
            "reset": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["Reset"]);
            },
            "view": (ctx) => {
              const { normalize: _normalize } = ctx;
              return _normalize(["View Tour"]);
            }
          }
        }
      },
      "pending": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Testing in progress..."]);
        },
        "titleCompletionScheduled": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Scheduled to complete..."]);
        },
        "scheduledTime": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["Scheduled to complete in ", _interpolate(_named("time"))]);
        },
        "scheduledCompletionExpired": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Scheduled to complete soon"]);
        },
        "failuresHere": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Failures will be displayed here"]);
        }
      },
      "specCounts": {
        "whenRunning": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize([_interpolate(_named("completed")), " of ", _interpolate(_named("total")), " specs completed"]), _normalize([_interpolate(_named("completed")), " of ", _interpolate(_named("total")), " spec completed"]), _normalize([_interpolate(_named("completed")), " of ", _interpolate(_named("total")), " specs completed"])]);
        },
        "whenCompleted": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize([_interpolate(_named("n")), " specs"]), _normalize([_interpolate(_named("n")), " spec"]), _normalize([_interpolate(_named("n")), " specs"])]);
        }
      },
      "header": {
        "runUrl": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["View in Cypress Cloud"]);
        },
        "commitsAhead": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["You are ", _interpolate(_named("n")), " commit ahead"]), _normalize(["You are ", _interpolate(_named("n")), " commits ahead"])]);
        }
      },
      "stats": {
        "groups": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize([_interpolate(_named("n")), " group"]), _normalize([_interpolate(_named("n")), " groups"])]);
        },
        "operatingSystems": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize([_interpolate(_named("n")), " operating system"]), _normalize([_interpolate(_named("n")), " operating systems"])]);
        },
        "browsers": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize([_interpolate(_named("n")), " browser"]), _normalize([_interpolate(_named("n")), " browsers"])]);
        }
      },
      "artifacts": {
        "replay": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["View Test Replay"]);
        },
        "stdout": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["View Log"]);
        },
        "screenshots": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["View Screenshots"]);
        },
        "video": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["View Video"]);
        }
      }
    },
    "testingType": {
      "modalTitle": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Choose a testing type"]);
      },
      "e2e": {
        "name": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["E2E Testing"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Build and test the entire experience of your application from end-to-end to ensure each flow matches your expectations."]);
        }
      },
      "component": {
        "name": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Component Testing"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Build and test your components from your design system in isolation in order to ensure each state matches your expectations."]);
        }
      },
      "componentDisabled": {
        "description": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["To test your components you must ", _interpolate(_list(0)), " as an NPM dependency for this project."]);
        },
        "link": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["install Cypress"]);
        }
      }
    },
    "migration": {
      "before": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Before"]);
      },
      "after": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["After"]);
      },
      "heresWhy": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["here's why:"]);
      },
      "renameAuto": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["We recommend automatically renaming your specs in this step"]);
        },
        "changeButton": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["change"]);
        },
        "changedSpecFolder": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["We've changed the default spec folder from:"]);
        },
        "changedSpecExt": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["We've changed the default spec file extension from:"]);
        },
        "changedSpecPatternExplain": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["We've changed the default spec file extension to ", _interpolate(_list(0)), " in order to avoid conflicts with any existing testing frameworks."]);
        },
        "optedOutMessage": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["You've opted not to rename your spec file extension. You may need to change your specPattern later so we can still find your spec files."]);
        },
        "folderRenameMessage": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["You've opted not to rename your spec file extension, we'll only rename the folder"]);
        },
        "modal": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Change the existing spec file extension"]);
          },
          "warning": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["We recommend using the default extension to avoid inconsistencies, framework conflicts, and confusion with your team."]);
          },
          "line1": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Cypress now supports the ability to create new spec files from within the UI for both E2E and component specs."]);
          },
          "line2": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["All new spec files created within Cypress will use the default pattern of: "]);
          },
          "line3": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["We want to rename your existing specs so that they have a consistent filename pattern for both E2E and component testing."]);
          },
          "line4": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["All documentation and example code will be using: "]);
          },
          "line5": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["We've changed the placement of component specs to be next to their source files (e.g. src/Button.jsx and src/Button.cy.jsx)"]);
          },
          "line6": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["The new default pattern of ", _interpolate(_list(0)), " prevents targeting conflicts with other testing frameworks. (e.g. Jest)"]);
          },
          "label": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Choose from the following filename patterns:"]);
          },
          "option1": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize([_interpolate(_list(0)), " (recommended)"]);
          },
          "option2": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Don't rename anything  keep what I have."]);
          },
          "option3": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Rename folder only."]);
          },
          "optOutAdditional": (ctx) => {
            const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
            return _normalize(["I may need to change my ", _interpolate(_list(0)), " later if I don't use the recommended filename extension."]);
          },
          "buttonSave": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Save changes"]);
          },
          "buttonCancel": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Cancel"]);
          }
        }
      },
      "renameManual": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["We need you to move your component specs manually"]);
        },
        "componentFolderRemoved": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["We've removed the ", _interpolate(_list(0)), " options from the Cypress config."]);
        },
        "addedSpecPattern": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["We've added a new ", _interpolate(_list(0)), " option in the Cypress config that tells us where to find your component specs."]);
        },
        "cannotAuto": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["We can't automatically migrate your existing component spec files. We recommend that you move the following component spec files next to your source component files (e.g. ", _interpolate(_list(0)), ")"]);
        },
        "ifSkipNote": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["If you skip this step, Cypress will still be able to find them, but any new specs that you create will automatically be created next to your component files."]);
        }
      },
      "renameSupport": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["We'll automatically rename your existing E2E support file in this step"]);
        },
        "serveDifferentTypes": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["We now serve different support files for E2E and Component Testing."]);
        },
        "changedSupportFile": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["We've renamed the E2E support file from:"]);
        }
      },
      "configFile": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["We need to migrate to the new Cypress configuration file"]);
        },
        "changedDefault": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["We've changed the default Cypress config file from:"]);
        },
        "customOptions": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["We've set a custom ", _interpolate(_named("specPattern")), " option based on your ", _interpolate(_named("options")), "."]);
        },
        "willConvert": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["We'll automatically create a new ", _interpolate(_named("jsFile")), " file and seed it with your options from your existing ", _interpolate(_named("jsonFile")), "."]);
        }
      },
      "setupComponent": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["You need to reconfigure Cypress for component testing"]);
        },
        "line1": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["We've detected that you are currently using the experimental version of component testing."]);
        },
        "line2": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Your existing configuration is no longer compatible with new component testing configuration options."]);
        },
        "line3": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["In a previous step, we renamed your component specs, but can't automatically migrate your existing component testing configuration."]);
        },
        "line4": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["In the next screen, you'll be able to reconfigure component testing in a new guided configuration wizard."]);
        }
      },
      "wizard": {
        "title": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["Migrating to Cypress ", _interpolate(_named("version"))]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Your project requires updates to work with this version."]);
        },
        "typicalMigrationLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Typical migration:"]);
        },
        "typicalMigrationTime": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["5-10 minutes"]);
        },
        "step1": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Migrate existing specs"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["In this step, we'll automatically rename and/or move your existing spec files as needed."]);
          },
          "button": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Rename these specs for me"]);
          },
          "buttonSkip": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Skip renaming specs"]);
          },
          "buttonRenameFolder": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Rename the folder for me"]);
          }
        },
        "step2": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Move your existing component specs"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["In this step, you'll manually move your existing component specs to their new default location."]);
          },
          "buttonWait": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Waiting for you to move your component specs..."]);
          },
          "buttonDone": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Continue to next step"]);
          },
          "button": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["I'll do this later"]);
          }
        },
        "step3": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Rename the Cypress support file"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["In this step, we'll automatically rename your existing support file."]);
          },
          "button": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Rename the support file for me"]);
          }
        },
        "step4": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Migrate to the new Cypress configuration file"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["In this step, we'll automatically migrate your existing Cypress configuration to the new Cypress configuration file."]);
          },
          "button": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Migrate the configuration for me"]);
          }
        },
        "step5": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Reconfigure component testing"]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["In this step, we'll explain how you will reconfigure Cypress for component testing."]);
          },
          "button": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Finish migration and continue"]);
          }
        }
      }
    },
    "majorVersionWelcome": {
      "title": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["What's New in Cypress"]);
      },
      "actionContinue": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Continue"]);
      },
      "linkReleaseNotes": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["View full changelog"]);
      }
    },
    "setupWizard": {
      "selectFramework": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Project setup"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Confirm the front-end framework and bundler used in your project."]);
        }
      },
      "installDependencies": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Install dev dependencies"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Based on your previous selection, the following dependencies are required."]);
        },
        "pasteCommand": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Paste this command into your terminal to install the following packages:"]);
        },
        "waitForInstall": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Waiting for you to install the dependencies..."]);
        },
        "installed": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["installed"]);
        },
        "pendingInstall": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["pending installation"]);
        },
        "installationAlertSuccess": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["You've successfully installed all required dependencies."]);
        }
      },
      "configFiles": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Configuration files"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["We added the following files to your project:"]);
        }
      },
      "chooseBrowser": {
        "title": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Choose a browser"]);
        },
        "description": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["Choose your preferred browser for ", _interpolate(_named("testingType")), " testing."]);
        }
      }
    },
    "e2eProjectSetup": {
      "title": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Project setup"]);
      },
      "description": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Confirm your project's preferred language."]);
      }
    },
    "openBrowser": {
      "startComponent": (ctx) => {
        const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
        return _normalize(["Start Component Testing in ", _interpolate(_named("browser"))]);
      },
      "startE2E": (ctx) => {
        const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
        return _normalize(["Start E2E Testing in ", _interpolate(_named("browser"))]);
      },
      "openingComponent": (ctx) => {
        const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
        return _normalize(["Opening Component Testing in ", _interpolate(_named("browser"))]);
      },
      "openingE2E": (ctx) => {
        const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
        return _normalize(["Opening E2E Testing in ", _interpolate(_named("browser"))]);
      },
      "running": (ctx) => {
        const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
        return _normalize(["Running ", _interpolate(_named("browser"))]);
      },
      "focus": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Focus"]);
      },
      "close": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Close"]);
      },
      "switchTestingType": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Switch testing type"]);
      }
    },
    "runner": {
      "header": {
        "reviewDocs": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Review the docs"]);
        },
        "troubleRendering": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["if you're having trouble rendering your components properly."]);
        }
      },
      "snapshot": {
        "highlightsLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Highlights"]);
        },
        "testsRunningError": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cannot show snapshot while tests are running"]);
        },
        "snapshotMissingError": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["The snapshot is missing. Displaying current state of the DOM."]);
        },
        "defaultTitle": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["DOM snapshot"]);
        },
        "pinnedTitle": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Pinned"]);
        },
        "studioActiveError": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cannot show snapshot while creating commands in Studio"]);
        }
      },
      "selectorPlayground": {
        "matches": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
          return _plural([_normalize(["No matches"]), _normalize([_interpolate(_named("n")), " match"]), _normalize([_interpolate(_named("n")), " matches"])]);
        },
        "playgroundTooltip": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Click an element to see a suggested selector"]);
        },
        "copyTooltip": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Copy to clipboard"]);
        },
        "copyTooltipAction": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Copied!"]);
        },
        "printTooltip": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Print to console"]);
        },
        "printTooltipAction": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Printed!"]);
        },
        "invalidSelector": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Invalid"]);
        },
        "selectorMethodsLabel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Selector methods"]);
        },
        "toggle": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Toggle playground"]);
        }
      },
      "automation": {
        "disconnected": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["The Cypress extension has disconnected."]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Cypress cannot run tests without this extension."]);
          },
          "reload": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Reload the browser"]);
          }
        },
        "missing": {
          "title": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["The Cypress extension is missing."]);
          },
          "description": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Cypress cannot run tests without this extension. Please choose another browser."]);
          }
        },
        "shared": {
          "link": (ctx) => {
            const { normalize: _normalize } = ctx;
            return _normalize(["Read more about browser management"]);
          }
        }
      },
      "viewportTooltip": {
        "buttonText": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Review the guide on viewports"]);
        },
        "buttonHref": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["https://on.cypress.io/viewport"]);
        },
        "infoText": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["The viewport determines the width and height of your application under test. By default the viewport will be ", _interpolate(_list(0)), " by ", _interpolate(_list(1)), " for ", _interpolate(_list(2)), " testing."]);
        },
        "configText": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
          return _normalize(["Additionally, you can override this value in your ", _interpolate(_named("configFile")), " or via the ", _interpolate(_named("viewportCommand")), " command."]);
        }
      },
      "studio": {
        "studio": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Studio"]);
        },
        "studioDescription": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Generate Cypress commands by interacting with your site as an end user would. Then, save these commands directly to your test file."]);
        },
        "studioDetailedDescription": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Generate and save commands directly to your test suite by interacting with your app as an end user would. Right click on an element to add an assertion. Studio will track events that generate the following commands:"]);
        },
        "getStartedButton": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Get started"]);
        },
        "feedbackPrompt": (ctx) => {
          const { normalize: _normalize, interpolate: _interpolate, list: _list } = ctx;
          return _normalize(["Your ", _interpolate(_list(0)), " will be highly influential to our team."]);
        },
        "experimentalMessage": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["This feature is currently experimental and we will be adding more commands and abilities in the future."]);
        },
        "feedbackLink": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["feedback"]);
        },
        "saveTest": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Save test"]);
        },
        "testName": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Test name"]);
        },
        "saveTestButton": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Save"]);
        },
        "closeStudio": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Close Studio"]);
        },
        "restartStudio": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Restart Studio"]);
        },
        "copyCommands": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Copy commands to clipboard"]);
        },
        "commandsCopied": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Commands copied!"]);
        },
        "availableCommands": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Available commands"]);
        },
        "giveFeedback": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Give feedback"]);
        },
        "enterValidUrl": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Enter a valid URL to visit"]);
        },
        "continue": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Continue"]);
        },
        "actionCancel": (ctx) => {
          const { normalize: _normalize } = ctx;
          return _normalize(["Cancel"]);
        }
      }
    },
    "warnings": {
      "retry": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Try again"]);
      }
    },
    "versions": {
      "alpha": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Alpha"]);
      },
      "community": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Community"]);
      },
      "beta": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["Beta"]);
      },
      "new": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["New"]);
      },
      "communityNote": (ctx) => {
        const { normalize: _normalize } = ctx;
        return _normalize(["This is a community provided definition."]);
      }
    }
  } }
);
const rawJsonMessages = `{
  "links": {
    "learnMore": "Learn more.",
    "learnMoreButton": "Learn more",
    "needHelp": "Need help"
  },
  "components": {
    "modal": {
      "dismiss": "Dismiss"
    },
    "fileSearch": {
      "noMatchesForExtension": "No files found when searching for the file extension",
      "noMatchesForFileName": "",
      "byFilenameInput": "Search by filename...",
      "byExtensionInput": "Extensions to include e.g. *.tsx, *.vue",
      "matchesIndicatorEmptyFileSearch": "No matches | 1 match | { denominator } matches",
      "matchesIndicator": "No matches | {numerator} of {denominator} matches | {numerator} of {denominator} matches"
    },
    "button": {
      "cancel": "Cancel",
      "back": "Back"
    },
    "loading": {
      "config": {
        "title": "Initializing config...",
        "description": "Please wait while we load your project and find browsers installed on your system"
      }
    },
    "select": {
      "placeholder": "Choose an option..."
    },
    "alert": {
      "dismissAriaLabel": "Dismiss"
    },
    "specPattern": {
      "matches": "No matches | {n} match | {n} matches"
    },
    "specPatternModal": {
      "title": "Spec pattern settings"
    }
  },
  "clipboard": {
    "copy": "Copy",
    "copied": "Copied!"
  },
  "actions": {
    "close": "Close"
  },
  "file": {
    "edit": "Edit",
    "git": {
      "modified": "Modified",
      "created": "Created"
    }
  },
  "status": {
    "enabled": "Enabled",
    "disabled": "Disabled"
  },
  "createSpec": {
    "newSpec": "New spec",
    "createSpec": "Create spec",
    "done": "Done!",
    "noComponentsFound": "No components found",
    "unableToParseFile": "Unable to parse file",
    "updateSpecPattern": "Update spec pattern",
    "newSpecModalTitle": "Create new spec",
    "successPage": {
      "header": "Great! The spec was successfully added",
      "runSpecButton": "Okay, run the spec",
      "createAnotherSpecButton": "Create another spec"
    },
    "page": {
      "defaultPatternNoSpecs": {
        "title": "Create your first spec",
        "component": {
          "description": "Since this project looks new, we recommend that you get started by creating a spec for one of your components."
        },
        "e2e": {
          "description": "Since this project looks new, we recommend that you use the specs and tests that we've written for you to get started."
        }
      },
      "customPatternNoSpecs": {
        "title": "No specs found",
        "description": "We couldn't find any files matching the following spec patterns. You may need to move your specs or update your {0} to find them."
      }
    },
    "noSpecsMessage": "If you feel that you're seeing this screen in error, and there should be specs listed here, you likely need to update the spec pattern.",
    "viewSpecPatternButton": "View spec pattern",
    "e2e": {
      "importFromScaffold": {
        "header": "Scaffold example specs",
        "description": "We'll generate several example specs to help guide you on how to write tests in Cypress.",
        "specsAddedHeader": "Great! We added the following files to your project:",
        "specsAddedButton": "Okay, I got it!",
        "specsAddingHeader": "Adding specs..."
      },
      "importTemplateSpec": {
        "header": "Create new spec",
        "description": "We'll generate a template spec file which can be used to start testing your application.",
        "chooseFilenameHeader": "Enter the path for your new spec",
        "inputPlaceholder": "Enter a relative path...",
        "invalidSpecWarning": "This path is invalid because it doesn't match the following ",
        "specExtensionWarning": "We recommend naming your spec to match the following pattern: "
      }
    },
    "component": {
      "importFromComponent": {
        "header": "Create from component",
        "description": "Generate a basic component test for any of the components in this project.",
        "chooseAComponentHeader": "Choose a component"
      },
      "importTemplateSpec": {
        "header": "Create new spec",
        "description": "We'll generate a template spec file which can be used to start testing your components.",
        "invalidComponentWarning": "We couldn't generate a valid path matching your custom "
      }
    }
  },
  "specPage": {
    "pageTitle": "Specs",
    "newSpecButton": "New spec",
    "searchPlaceholder": "Search specs",
    "clearSearch": "Clear search field",
    "componentSpecsHeader": "Component specs",
    "e2eSpecsHeader": "E2E specs",
    "componentSpecsHeaderShort": "Component",
    "e2eSpecsHeaderShort": "E2E",
    "lastUpdated": {
      "header": "Last updated",
      "tooltip": {
        "gitStatus": "Git status",
        "gitInfo": "git info",
        "gitInfoAvailable": "{0} of the spec files within this project",
        "gitInfoUnavailable": "Cypress is unable to detect {0} for this project and has defaulted to showing file system data instead"
      }
    },
    "latestRuns": {
      "header": "Latest runs",
      "headerShort": "Runs",
      "tooltip": {
        "connected": "The {0} in Cypress Cloud",
        "notConnected": "Connect to Cypress Cloud to see the {0}",
        "noAccess": "Request access to this project in Cypress Cloud to view the {0}",
        "linkText": "status of your latest runs"
      }
    },
    "averageDuration": {
      "header": "Average duration",
      "headerShort": "Duration",
      "tooltip": {
        "connected": "The {0} of your latest runs in Cypress Cloud",
        "notConnected": "Connect to Cypress Cloud to see the {0} of your latest runs",
        "noAccess": "Request access to this project in Cypress Cloud to view the {0} of your latest runs",
        "linkText": "average spec durations"
      }
    },
    "flaky": {
      "badgeLabel": "Flaky",
      "severityLow": "Low",
      "severityMedium": "Medium",
      "severityHigh": "High",
      "flakyRate": "{0}% flaky rate",
      "flakyRuns": "{flakyRuns} flaky runs / {totalRuns} total | {flakyRuns} flaky run / {totalRuns} total | {flakyRuns} flaky runs / {totalRuns} total",
      "lastFlaky": "Last run flaky | Last flaky {runsSinceLastFlake} run ago | Last flaky {runsSinceLastFlake} runs ago"
    },
    "hoverButton": {
      "connect": "Connect",
      "connectProject": "Connect project",
      "connectProjectShort": "Connect",
      "requestAccess": "Request access",
      "requestAccessShort": "Request",
      "requestSent": "Request sent",
      "requestSentShort": "Sent"
    },
    "connectProjectButton": "Connect your project",
    "cloudLoginButton": "Log in to Cypress Cloud",
    "reconnectProjectButton": "Reconnect your project",
    "unauthorizedBannerTitle": "Request access to project",
    "requestAccessButton": "Request access",
    "requestSentButton": "Request sent",
    "rows": {
      "gitTooltipSubtext": "{shortHash} by {author}"
    },
    "noResultsMessage": "No specs matched your search:",
    "noSpecError": {
      "title": "Spec not found",
      "intro": "There is no spec matching the following location:",
      "explainer": "It is possible that the file has been moved or deleted. Please choose from the list of specs below."
    },
    "offlineWarning": {
      "title": "No internet connection",
      "explainer": "Please check your internet connection to resolve this issue. When your internet connection is fixed, we will automatically attempt to fetch the run metrics from Cypress Cloud."
    },
    "fetchFailedWarning": {
      "title": "Lost connection",
      "explainer1": "The request timed out or failed when trying to retrieve the recorded run metrics from Cypress Cloud. The information that you're seeing in the table below may be incomplete as a result.",
      "explainer2": "Please refresh the page to try again and visit our {0} if this behavior continues.",
      "refreshButton": "Try again"
    },
    "banners": {
      "login": {
        "title": "Optimize and record your CI test runs with Cypress Cloud",
        "content": "When you configure Cypress to record tests to Cypress Cloud, you'll see data from your latest recorded runs in the Cypress app. This increased visibility into your test history allows you to debug your tests faster and more effectively, all within your local workflow.",
        "buttonLabel": "Get started with Cypress Cloud"
      },
      "createOrganization": {
        "title": "Finish setting up Cypress Cloud",
        "content": "Join or create an organization in Cypress Cloud to access your projects and recorded test runs.",
        "buttonLabel": "Set up your organization"
      },
      "connectProject": {
        "title": "Connect your project to Cypress Cloud",
        "content": "Bring your recorded test results into your local development workflow to monitor, run, and fix tests all in the Cypress app.",
        "buttonLabel": "Connect your project"
      },
      "record": {
        "title": "Record your first run",
        "content": "Record a run to see your test results in Cypress Cloud. You can then optimize your test suite, debug failing and flaky tests, and integrate with your favorite tools."
      },
      "ct": {
        "title": "{0} component testing is available for this project",
        "content": "You can now use Cypress to develop and test individual components without running your whole application. Generate the config in just a few clicks.",
        "primaryAction": "Quick setup",
        "secondaryAction": "Read our guide",
        "dismissAction": "Give feedback"
      },
      "enableNotifications": {
        "title": "Start debugging as soon as your first tests fail",
        "subtitle": "Cypress can notify you about Cloud test runs for your branch.",
        "enableDesktopNotifications": "Enable desktop notifications",
        "remindMeLater": "Remind me later",
        "notificationsEnabledTitle": "Notifications Enabled",
        "notificationsEnabledBody": "Nice, notifications are enabled!",
        "dismissBanner": "Dismiss banner"
      }
    },
    "runSelectedSpecs": "Run {n} spec | Run {n} specs",
    "testingTypePromo": {
      "e2e": {
        "header": {
          "title": "End-to-end testing is not set up for this project",
          "description": "Try it out now, or {0} to learn more",
          "link": "read our guides",
          "control": "Quick setup"
        },
        "body": {
          "title": "What is end-to-end testing?",
          "description": "End-to-end tests are perfect for testing your entire application from a user's perspective. Visit any URL and test full user journeys across pages and domains.",
          "listItem1": "Test full user journeys across multiple pages using {0} to load up a web page for your test.",
          "listItem1Command": "cy.visit()",
          "listItem2": "Work with live API calls or mock them with {0} to test all possible states of your app.",
          "listItem2Command": "cy.intercept()",
          "listItem3": "Use {0} to maintain consistent browser sessions in your tests, and work with features like cookies and local storage, all while keeping your tests properly isolated.",
          "listItem3Command": "cy.session()"
        }
      },
      "ct": {
        "header": {
          "title": "Component testing is not set up for this project",
          "description": "Try it out now, or {0} to learn more",
          "link": "read our guides",
          "control": "Quick setup"
        },
        "body": {
          "title": "What is Component Testing?",
          "description": "Cypress Component Testing is a technique for developers to write, test, and debug components in isolation without ever leaving the browser - and without having to run your entire application.",
          "listItem1": "Instead of visiting a page, use {0} to render your components directly in the browser.",
          "listItem1Command": "cy.mount()",
          "listItem2": "Test from a user's perspective with all the same Cypress commands that are available in end-to-end testing.",
          "listItem3": "To get started, you can generate the config for {0}, {1}, and {2} (and {3}!).",
          "listItem3Link": "more",
          "link": "Give feedback"
        }
      }
    }
  },
  "noResults": {
    "defaultMessage": "No results matched your search:",
    "clearSearch": "Clear search"
  },
  "sidebar": {
    "keyboardShortcuts": {
      "title": "Keyboard shortcuts",
      "rerun": "Re-run tests",
      "stop": "Stop tests",
      "toggle": "Toggle specs list"
    },
    "toggleLabel": {
      "expanded": "Collapse sidebar",
      "collapsed": "Expand sidebar"
    },
    "nav": {
      "ariaLabel": "Pages"
    },
    "debug": {
      "debugFeature": "New Debug feature",
      "passed": "Relevant run passed",
      "failed": "Relevant run had {n} test failure | Relevant run had {n} test failures",
      "errored": "Relevant run had an error",
      "erroredWithFailures": "Relevant run had an error with {n} test failure | Relevant run had an error with {n} test failures",
      "passing": "Relevant run is passing",
      "failing": "Relevant run is failing with {n} test failure | Relevant run is failing with {n} test failures"
    },
    "runs": {
      "running": "Latest run is in progress",
      "failing": "Latest run is failing with {n} test failure | Latest run is failing with {n} test failures",
      "passed": "Latest run passed",
      "failed": "Latest run had {n} test failure | Latest run had {n} test failures",
      "cancelled": "Latest run has been cancelled",
      "errored": "Latest run had an error",
      "erroredWithFailures": "Latest run had an error with {n} test failure | Latest run had an error with {n} test failures"
    }
  },
  "topNav": {
    "released": "Released",
    "version": "Version",
    "versionUnsupported": "Unsupported",
    "installed": "Installed",
    "latest": "Latest",
    "seeAllReleases": "See all releases",
    "runningOldVersion": "You're currently running an old version of Cypress. Update to the latest version for the best experience.",
    "docsMenu": {
      "docsHeading": "Docs",
      "gettingStartedTitle": "Getting started",
      "firstTest": "Write your first test",
      "testingApp": "Testing your app",
      "organizingTests": "Organizing tests",
      "referencesTitle": "References",
      "bestPractices": "Best practices",
      "configuration": "Configuration",
      "api": "API",
      "ciTitle": "Run in CI/CD",
      "ciSetup": "Set up CI",
      "fasterTests": "Run tests faster",
      "prompts": {
        "ci1": {
          "title": "Configure CI",
          "description": "Optimize your tests in CI by following these guides.",
          "seeOtherGuides": "See other guides",
          "intro": "Introduction to CI",
          "learnTheBasics": "Learn the basics of running Cypress in CI."
        },
        "orchestration1": {
          "title": "Run tests faster in CI",
          "parallelTime": "5 mins",
          "noParallelTime": "12 mins",
          "withParallelization": "with Parallelization",
          "withoutParallelization": "without Parallelization",
          "intro": "With Smart Orchestration, you'll be able to:",
          "bullet1": "Run spec files in parallel",
          "bullet2": "Prioritize failed specs to run first",
          "bullet3": "Cancel CI runs on test failure",
          "learnMore": "Learn more"
        }
      }
    },
    "login": {
      "bodyInitial": "Logging in gives you access to {0}. You can set up projects to be recorded and see test data from your project.",
      "bodySuccess": "You are now logged in as {0}.",
      "bodyError": "An error occurred while attempting to log in:",
      "bodyBrowserError": "The browser could not be opened.",
      "bodyBrowserErrorDetails": "Cypress was unable to open your installed browser. To continue logging in, please paste this URL into your web browser:",
      "cloud": "Cypress Cloud",
      "titleInitial": "Log in to Cypress",
      "titleSuccess": "Login successful",
      "titleFailed": "Login failed",
      "titleBrowserError": "Browser error",
      "actionLogin": "Log in",
      "profileMenuLabel": "Profile and logout",
      "actionLogout": "Log out",
      "actionContinue": "Continue",
      "actionOpening": "Opening browser",
      "actionWaiting": "Waiting for you to log in",
      "actionTryAgain": "Try again",
      "actionCancel": "Cancel"
    },
    "updateCypress": {
      "title": "Upgrade to Cypress",
      "currentlyRunning": "You are currently running Version {0} of Cypress. ",
      "pasteToUpgradeProject": "To upgrade to the latest version for your project, first {0}, then paste the command below into your terminal:",
      "pasteToUpgradeGlobal": "To upgrade to the latest version, first {0}, then paste the command below into your terminal:",
      "rememberToCloseInsert": "close this app"
    },
    "upgradeText": "Upgrade",
    "global": {
      "projects": "Projects"
    }
  },
  "launchpadErrors": {
    "generic": {
      "configErrorTitle": "Cypress configuration error",
      "retryButton": "Try again",
      "stackTraceLabel": "Stack trace",
      "docsButton": {
        "configGuide": {
          "text": "Configuration guide",
          "link": "https://on.cypress.io/configuration"
        },
        "cloudGuide": {
          "text": "Cypress Cloud guide",
          "link": "https://on.cypress.io/features-dashboard"
        },
        "docsHomepage": {
          "text": "Cypress docs",
          "link": "https://docs.cypress.io"
        }
      }
    },
    "noInternet": {
      "header": "You have no internet connection",
      "message": "Check your internet connection to pull the latest data from Cypress Cloud.",
      "connectProject": "Please check your internet connection to resolve this issue. When your internet connection is fixed, we will automatically attempt to fetch your latest runs for this project."
    }
  },
  "setupPage": {
    "projectSetup": {
      "frameworkLabel": "Front-end framework",
      "frameworkPlaceholder": "Pick a framework",
      "bundlerLabel": "Bundler",
      "bundlerPlaceholder": "Pick a bundler",
      "languageLabel": "Language",
      "configFileLanguageLabel": "Cypress config file",
      "detected": "(detected)",
      "browseIntegrations": "Browse our list of third-party framework integrations",
      "communityFrameworkDefinitionProblem": "Community framework definition problem",
      "communityDependenciesCouldNotBeParsed": "This project has a community framework definition installed that could not be loaded. It is located at the following path: | This project has some community framework definitions installed that could not be loaded. They are located at the following paths:",
      "seeFrameworkDefinitionDocumentation": "See the {0} for more information about creating, installing, and troubleshooting third party definitions.",
      "frameworkDefinitionDocumentation": "framework definition documentation"
    },
    "step": {
      "continue": "Continue",
      "next": "Next step",
      "back": "Back",
      "skip": "Skip"
    },
    "configFile": {
      "createManually": "Create file manually",
      "skippedLabel": "Skipped",
      "changesRequiredLabel": "Changes required",
      "changesRequiredBadge": "Changes required",
      "changesRequiredDescription": "Please merge the code below with your existing {0}"
    },
    "testingCard": {
      "configured": "Configured",
      "notConfigured": "Not Configured",
      "running": "Running",
      "chooseABrowser": "Choose a browser",
      "reconfigure": "Reconfigure",
      "disabled": "Disabled"
    }
  },
  "globalPage": {
    "empty": {
      "title": "Add project",
      "helper": "Get started by adding your first project below.",
      "dropText": "Drag your project directory here or {0}",
      "browseManually": "browse manually."
    },
    "settings": "Settings",
    "saveChanges": "Save changes",
    "cancel": "Cancel",
    "externalEditorPreferences": "External editor preferences",
    "externalEditorPreferencesDescription1": "Select your preference for opening files on your system.",
    "externalEditorPreferencesDescription2": "You can change this later in the {0} page.",
    "recentProjectsHeader": "Recent projects",
    "searchPlaceholder": "Search projects",
    "addProjectButton": "Add project",
    "projectActions": "Project actions",
    "removeProject": "Remove project",
    "openInIDE": "Open in IDE",
    "openInFinder": "Open in Finder",
    "noResultsMessage": "No projects matched your search:"
  },
  "welcomePage": {
    "review": "Review the differences between each testing type",
    "codeExample": "Code example",
    "compareTypes": {
      "content": {
        "e2eTitle": "End-to-end tests",
        "e2eBullet1": "Visit URLs via",
        "e2eBullet2": "Test flows and functionality across multiple pages",
        "e2eBullet3": "Ideal for testing integrated flows in CD workflows",
        "componentTitle": "Component tests",
        "ctBullet1": "Import components via",
        "ctBullet2": "Test individual components of a design system in isolation",
        "ctBullet3": "Ideal for testing isolated flows and components in CI"
      },
      "modalTitle": "Key differences"
    },
    "title": "Welcome to Cypress!"
  },
  "settingsPage": {
    "config": {
      "title": "Resolved configuration",
      "description": "Since the options in the {0} can be set dynamically by your development environment, please refer to the legend below to understand how the configuration options are resolved.",
      "legend": {
        "env": {
          "label": "env",
          "description": "Set from environment variables"
        },
        "default": {
          "label": "default",
          "description": "Default values"
        },
        "dynamic": {
          "label": "dynamic",
          "description": "Set by the {0} function"
        },
        "cli": {
          "label": "cli",
          "description": "Set from CLI arguments"
        },
        "config": {
          "label": "config",
          "description": "Set from {0}"
        }
      }
    },
    "proxy": {
      "title": "Proxy settings",
      "description": "Cypress auto-detected the following proxy settings from your operating system.",
      "bypassList": "Proxy bypass list",
      "proxyServer": "Proxy server"
    },
    "editor": {
      "title": "External editor",
      "description": "External editor to use for editing code opened when using Cypress.",
      "noEditorSelectedPlaceholder": "Choose your editor...",
      "customPathPlaceholder": "/path/to/editor"
    },
    "notifications": {
      "title": "Desktop notifications",
      "description": "Cypress can notify you about Cloud test runs for your branch.",
      "notifyMeWhenRunStarts": "Notify me when a run starts",
      "notifyMeWhenRunIsFailing": "Notify me when a run begins to fail",
      "notifyMeWhenRunCompletes": "Notify me when a run completes",
      "passed": "Passed",
      "failed": "Failed",
      "canceled": "Canceled",
      "errored": "Errored",
      "sendTestNotification": "Send a test notification",
      "notReceivingNotifications": "Not receiving notifications? You might need to allow notifications from Cypress in your computer's system preferences. {0}",
      "testNotificationTitle": "Hello From Cypress",
      "testNotificationBody": "This is a test notification",
      "troubleshoot": "Troubleshoot",
      "enableNotificationsLabel": "To modify notification settings, enable desktop notifications"
    },
    "projectId": {
      "title": "Project ID",
      "description": "The Project ID configured for this project inside of Cypress Cloud. {0}"
    },
    "specPattern": {
      "title": "Spec patterns",
      "description": "The globs pointing Cypress to your spec files configured for this project. {0}"
    },
    "recordKey": {
      "title": "Record key",
      "description": "The Record Key configured for this project inside of Cypress Cloud. {0}",
      "manageKeys": "Manage keys",
      "errorEmpty": "You do not have permission to record on this project",
      "errorEmptyButton": "Request record rights",
      "errorAccess": "You do not have permission to view this project",
      "errorAccessPending": "Your request for access to this project is pending approval",
      "errorAccessButton": "Request access",
      "errorNotFound": "Project not found",
      "errorNotFoundButton": "Connect it again",
      "errorNotLoggedIn": "You are not connected to Cypress Cloud",
      "errorNotLoggedInButton": "Log in to Cypress Cloud"
    },
    "project": {
      "title": "Project settings",
      "description": "Review the configuration settings currently in use for this project."
    },
    "cloud": {
      "title": "Cypress Cloud settings",
      "description": "Review the configuration settings for recording to Cypress Cloud."
    },
    "experiments": {
      "title": "Experiments",
      "description": "If you'd like to try out new features that we're working on, you can enable beta features for your project by turning on the experimental features you'd like to try. {0}",
      "experimentalCspAllowList": {
        "name": "CSP Allow List",
        "description": "Enables Cypress to selectively permit Content-Security-Policy and Content-Security-Policy-Report-Only header directives, including those that might otherwise block Cypress from running."
      },
      "experimentalFetchPolyfill": {
        "name": "Fetch polyfill",
        "description": "Automatically replaces \`window.fetch\` with a polyfill that Cypress can spy on and stub. Note: \`experimentalFetchPolyfill\` has been deprecated in Cypress 6.0.0 and will be removed in a future release. Consider using [\`cy.intercept()\`](https://on.cypress.io/intercept) to intercept \`fetch\` requests instead."
      },
      "experimentalInteractiveRunEvents": {
        "name": "Interactive run events",
        "description": "Allows listening to the [\`before:run\`](https://on.cypress.io/before-run), [\`after:run\`](https://on.cypress.io/after-run), [\`before:spec\`](https://on.cypress.io/before-spec), and [\`after:spec\`](https://on.cypress.io/after-spec) events in plugins during interactive mode."
      },
      "experimentalModifyObstructiveThirdPartyCode": {
        "name": "Modify obstructive third party code",
        "description": "Applies \`modifyObstructiveCode\` to third party \`.html\` and \`.js\`, removes subresource integrity, and modifies the user agent in Electron."
      },
      "retries": {
        "experimentalStrategy": {
          "name": "Retries Strategy",
          "description": "Applies a strategy for test retries according to your \\"flake tolerance\\"; options are \`detect-flake-but-always-fail\` or \`detect-flake-and-pass-on-threshold\`."
        },
        "experimentalOptions": {
          "name": "Retries Strategy Options",
          "description": "Sets retries strategy-specific options like \`maxRetries\`, \`passesRequired\`, and \`stopIfAnyPassed\`."
        }
      },
      "experimentalSingleTabRunMode": {
        "name": "Single tab run mode",
        "description": "Runs all component specs in a single tab, trading spec isolation for faster run mode execution."
      },
      "experimentalJustInTimeCompile": {
        "name": "Just-In-Time compiling",
        "description": "Enables Just-In-Time (JIT) compiling for component testing, which will only compile assets related to the spec before the spec is run. Currently supported for Vite and Webpack."
      },
      "experimentalSourceRewriting": {
        "name": "Source rewriting",
        "description": "Enables AST-based JS/HTML rewriting. This may fix issues caused by the existing regex-based JS/HTML replacement algorithm. See [#5273](https://github.com/cypress-io/cypress/issues/5273) for details."
      },
      "experimentalStudio": {
        "name": "Studio",
        "description": "Generate and save commands directly to your test suite by interacting with your app as an end user would."
      },
      "experimentalWebKitSupport": {
        "name": "WebKit Support",
        "description": "Adds support for testing in the WebKit browser engine used by Safari. See https://on.cypress.io/webkit-experiment for more information."
      },
      "experimentalRunAllSpecs": {
        "name": "Run All Specs",
        "description": "Enables the \\"Run All Specs\\" UI feature, allowing the execution of multiple specs sequentially."
      },
      "experimentalOriginDependencies": {
        "name": "Origin Dependencies",
        "description": "Enables support for \`Cypress.require()\` for including dependencies within the \`cy.origin()\` callback."
      },
      "experimentalMemoryManagement": {
        "name": "Memory Management",
        "description": "Enables support for improved memory management within Chromium-based browsers."
      },
      "experimentalSkipDomainInjection": {
        "name": "Skip Domain Injection",
        "description": "Disables setting \`document.domain\` to the application's super domain on injection."
      }
    },
    "device": {
      "title": "Device settings",
      "description": "Review the configuration settings currently in use for this device."
    },
    "testingPreferences": {
      "title": "Testing preferences",
      "description": "Configure your testing environment with these flags",
      "autoScrollingEnabled": {
        "title": "Auto scrolling enabled",
        "description": "Scroll behavior when running tests."
      }
    },
    "footer": {
      "text": "You can reconfigure the {testingType} testing settings for this project if you're experiencing issues with your Cypress configuration.",
      "button": "Configuration guide",
      "buttonLink": "https://on.cypress.io/configuration"
    }
  },
  "runs": {
    "slideshow": {
      "tour": {
        "title": "Record your first test run to Cypress Cloud",
        "description": "You're almost there! Start recording your test runs to Cypress Cloud by running the command above in your local or CI terminal."
      },
      "step1": {
        "title": "Monitor test failures in real time",
        "description": "Uncover high-risk failed and flaky tests in CI before they become a problem in production."
      },
      "step2": {
        "title": "Check if failed CI test runs also fail locally",
        "description": "Use the Test Runner to run only the tests that failed in your last recorded run."
      },
      "step3": {
        "title": "Build, test, and ship with confidence ",
        "description": "With Cypress Cloud, you can proactively identify, investigate, and resolve failures, and be a quality champion."
      },
      "controls": {
        "step": "{0} of {1}",
        "next": "Next",
        "reset": "Reset",
        "view": "View Tour"
      }
    },
    "connect": {
      "title": "Connect to view your recorded runs",
      "description": "Cypress Cloud is built for teams who need to do testing at scale.",
      "buttonUser": "Connect to Cypress Cloud",
      "buttonProject": "Connect a Cypress Cloud project",
      "modal": {
        "title": "Connect project",
        "cancel": "Cancel",
        "createOrg": {
          "description": "You need to create an organization in Cypress Cloud to continue.",
          "button": "Create organization",
          "waitingButton": "Waiting for you to create an organization...",
          "refreshButton": "Refresh organizations list"
        },
        "selectProject": {
          "organization": "Organization",
          "noOrganizationSelectedError": "required when creating a new project",
          "manageOrgs": "Manage organizations",
          "project": "Project",
          "projectName": "Project name",
          "projectNameDisclaimer": "(You can change this later)",
          "createNewProject": "Create new",
          "chooseExistingProject": "Choose an existing project",
          "newProjectAccess": "Project access",
          "privateLabel": "Private",
          "privateDescription": "Only invited users can view recorded test results.",
          "publicLabel": "Public",
          "publicDescription": "Anyone can view recorded test results.",
          "connectProject": "Connect project",
          "createProject": "Create project",
          "placeholderOrganizations": "Pick an organization",
          "placeholderProjects": "Pick a project",
          "placeholderProjectsPending": "Pick an organization first"
        },
        "connectManually": {
          "title": "Connect project manually",
          "warning": "We couldn't add the projectId to your cypress.config.js file automatically.",
          "mainMessage": "Manually add the {projectId} to the root of the config object in your {configFile} file.",
          "waitingButton": "Waiting for you to add the projectId..."
        }
      },
      "errors": {
        "baseError": {
          "title": "Cypress Cloud error"
        },
        "internalServerError": {
          "title": "Cannot connect to Cypress Cloud",
          "description": "The request times out when trying to retrieve the info from Cypress Cloud. Please refresh the page to try again and visit our {0} if this behavior continues.",
          "link": "Support Page"
        }
      }
    },
    "connectSuccessAlert": {
      "title": "This project is now connected to Cypress Cloud!",
      "item1": "We automatically added the {projectId} to your {configFile} file.",
      "item2": "Please ensure that your {0} file is checked into source control."
    },
    "empty": {
      "title": "Copy the command below to record your first run",
      "description": "Review the {0} to Cypress Cloud",
      "link": "guide on recording runs",
      "gitRepositoryNotDetected": "Git repository not detected",
      "ensureGitSetupCorrectly": "Cypress uses Git to associate runs with your local state. As a fallback, all runs for your project are shown. Please ensure that version control is set up correctly.",
      "noRunsFoundForBranch": "No runs found for your branch",
      "noRunsForBranchMessage": "Cypress uses Git to show runs for your branch. As a fallback, all runs for your project are shown. Ensure that version control is properly configured and that you are sending Git information to Cypress Cloud."
    },
    "results": {
      "skipped": "skipped",
      "pending": "pending",
      "passed": "passed",
      "failed": "failed"
    },
    "errors": {
      "notFound": {
        "title": "Couldn't find your project",
        "description": "We were unable to find an existing project matching the {0} set in your Cypress config file. You can reconnect with an existing project or create a new project.",
        "button": "Reconnect your project"
      },
      "unauthorized": {
        "title": "Request access to view the recorded runs",
        "description": "This is a private project that you do not currently have access to. Please request access from the project owner in order to view the list of runs.",
        "button": "Request access"
      },
      "unauthorizedRequested": {
        "title": "Your access request for this project has been sent.",
        "description": "The owner of this project has been notified of your request. We'll notify you via email when your access request has been granted.",
        "button": "Request Sent"
      },
      "connectionFailed": {
        "title": "Cannot connect to Cypress Cloud",
        "description": "The request times out when trying to retrieve the recorded runs from Cypress Cloud. Please refresh the page to try again and visit out {0} if this behavior continues.",
        "link": "Support page",
        "button": "Try again"
      }
    },
    "card": {
      "branchName": "Branch Name:",
      "commitAuthor": "Commit Author:",
      "totalDuration": "Run Total Duration:",
      "debugLabel": "Debug",
      "debugDescription": "View debug for run {runNumber}",
      "noDebugAvailable": "You can only debug runs for your most recent commits."
    },
    "layout": {
      "viewCloudRuns": "View runs in Cypress Cloud",
      "checkedOut": "Checked out"
    }
  },
  "debugPage": {
    "openFile": {
      "openInIDE": "Open in IDE",
      "notFoundLocally": "Opening in IDE is disabled because the spec is not found in this project"
    },
    "limit": {
      "title": "Cypress renders up to 100 failed test results",
      "message": "This run has {n} failed tests | This run has {n} failed test | This run has {n} failed tests",
      "link": "See all test results in Cypress Cloud"
    },
    "runFailures": {
      "btn": "Run Failures",
      "notFoundLocally": "Spec was not found locally",
      "switchTestingTypeInfo": "There is {n} {testingType} test failing in this spec. To run it locally switch to {testingType} testing. | There are {n} {testingType} tests failing in this spec. To run them locally switch to {testingType} testing.",
      "switchTestingTypeAction": "Switch to {testingType} testing"
    },
    "switchToRun": "Switch to run number {runNumber}",
    "overLimit": {
      "usageExceededTitle": "You've reached your monthly test result limit",
      "usageExceededUserMessage": "Your Free Cypress Cloud plan includes {numberTests} monthly recorded test results. Contact your Cypress Cloud admin to upgrade your plan and view more test results.",
      "usageExceededAdminMessage": "Your Free Cypress Cloud plan includes {numberTests} monthly recorded test results. Upgrade your plan now to view more test results.",
      "retentionExceededTitle": "Beyond data retention",
      "retentionExceededMessage": "Your data retention limit is {limitDays} days and these tests ran {runAgeDays} days ago. Upgrade your plan to increase your data retention limit.",
      "upgradePlan": "Upgrade plan",
      "contactAdmin": "Contact admin"
    },
    "wellDone": "Well Done!",
    "allYourTestsPassed": "All your tests passed.",
    "incomplete": "Incomplete",
    "specsSkipped": "{totalSkippedSpecs} of {n} spec skipped | {totalSkippedSpecs} of {n} specs skipped",
    "runHasNoTests": "Run has no tests",
    "theRunStartedButNeverCompleted": "The run started but never completed. This can happen when the run is cancelled from CI or when Cypress crashes while running tests.",
    "checkYourCiLogs": "Check your {0} logs for more information.",
    "archiveThisRun": "Archive this run to remove it from the runs list and analytics.",
    "manuallyCancelled": "Manually cancelled",
    "mostRecentRun": "You are on the most recent run",
    "switchToLatestRun": "Switch to latest run",
    "switchRun": "Switch run",
    "foundMoreThan100Runs": "We found more than 100 runs.",
    "goToCypressCloud": "Go to Cypress Cloud to see all runs",
    "emptyStates": {
      "debugDirectlyInCypress": "Debug failed CI runs directly in Cypress",
      "reviewRerunAndDebug": "Review, rerun, and debug failed CI test runs that are recorded to Cypress Cloud  all from within your local Cypress app.",
      "connectToCypressCloud": "Connect to Cypress Cloud",
      "connect": {
        "title": "Connect to debug your tests",
        "description": "Cypress Cloud is built for teams who need to do testing at scale."
      },
      "noProjectTestMessage": "Connect a Cypress Cloud project to locally debug failed CI test runs",
      "noRuns": {
        "title": "Copy the command below to record your first run",
        "description": "Review the {0} to Cypress Cloud",
        "link": "guide on recording runs"
      },
      "gitRepositoryNotDetected": "Git repository not detected",
      "ensureGitSetupCorrectly": "Cypress uses Git to associate runs with your local state. Please ensure that Git is properly configured for your project.",
      "learnAboutRecordingSrText": "about recording a run to Cypress Cloud",
      "learnAboutDebuggingSrText": "about debugging CI failures in Cypress",
      "learnAboutProjectSetupSrText": "about project setup in Cypress",
      "noRunsFoundForBranch": "No runs found for your branch",
      "noRunsForBranchMessage": "Cypress uses Git to show runs for your branch. Ensure that version control is properly configured and that you are sending Git information to Cypress Cloud.",
      "slideshow": {
        "tour": {
          "title": "Record your first test run to Cypress Cloud",
          "description": "You're almost there! Start recording your test runs to Cypress Cloud by running the command below in your local or CI terminal."
        },
        "step1": {
          "title": "Review how many tests failed during a CI test run",
          "description": "The Debug page shows the latest completed test run for your current checked out commit."
        },
        "step2": {
          "title": "Check if failed CI test runs also fail locally",
          "description": "Use the Test Runner to run only the tests that failed in your last recorded run."
        },
        "step3": {
          "title": "Locally debug failed test runs with visual artifacts",
          "description": "Easily review screenshots, videos and logs from your tests."
        },
        "controls": {
          "step": "{0} of {1}",
          "next": "Next",
          "reset": "Reset",
          "view": "View Tour"
        }
      }
    },
    "pending": {
      "title": "Testing in progress...",
      "titleCompletionScheduled": "Scheduled to complete...",
      "scheduledTime": "Scheduled to complete in {time}",
      "scheduledCompletionExpired": "Scheduled to complete soon",
      "failuresHere": "Failures will be displayed here"
    },
    "specCounts": {
      "whenRunning": "{completed} of {total} specs completed | {completed} of {total} spec completed | {completed} of {total} specs completed",
      "whenCompleted": "{n} specs | {n} spec | {n} specs"
    },
    "header": {
      "runUrl": "View in Cypress Cloud",
      "commitsAhead": "You are {n} commit ahead | You are {n} commits ahead"
    },
    "stats": {
      "groups": "{n} group | {n} groups",
      "operatingSystems": "{n} operating system | {n} operating systems",
      "browsers": "{n} browser | {n} browsers"
    },
    "artifacts": {
      "replay": "View Test Replay",
      "stdout": "View Log",
      "screenshots": "View Screenshots",
      "video": "View Video"
    }
  },
  "testingType": {
    "modalTitle": "Choose a testing type",
    "e2e": {
      "name": "E2E Testing",
      "description": "Build and test the entire experience of your application from end-to-end to ensure each flow matches your expectations."
    },
    "component": {
      "name": "Component Testing",
      "description": "Build and test your components from your design system in isolation in order to ensure each state matches your expectations."
    },
    "componentDisabled": {
      "description": "To test your components you must {0} as an NPM dependency for this project.",
      "link": "install Cypress"
    }
  },
  "migration": {
    "before": "Before",
    "after": "After",
    "heresWhy": "here's why:",
    "renameAuto": {
      "title": "We recommend automatically renaming your specs in this step",
      "changeButton": "change",
      "changedSpecFolder": "We've changed the default spec folder from:",
      "changedSpecExt": "We've changed the default spec file extension from:",
      "changedSpecPatternExplain": "We've changed the default spec file extension to {0} in order to avoid conflicts with any existing testing frameworks.",
      "optedOutMessage": "You've opted not to rename your spec file extension. You may need to change your specPattern later so we can still find your spec files.",
      "folderRenameMessage": "You've opted not to rename your spec file extension, we'll only rename the folder",
      "modal": {
        "title": "Change the existing spec file extension",
        "warning": "We recommend using the default extension to avoid inconsistencies, framework conflicts, and confusion with your team.",
        "line1": "Cypress now supports the ability to create new spec files from within the UI for both E2E and component specs.",
        "line2": "All new spec files created within Cypress will use the default pattern of: ",
        "line3": "We want to rename your existing specs so that they have a consistent filename pattern for both E2E and component testing.",
        "line4": "All documentation and example code will be using: ",
        "line5": "We've changed the placement of component specs to be next to their source files (e.g. src/Button.jsx and src/Button.cy.jsx)",
        "line6": "The new default pattern of {0} prevents targeting conflicts with other testing frameworks. (e.g. Jest)",
        "label": "Choose from the following filename patterns:",
        "option1": "{0} (recommended)",
        "option2": "Don't rename anything  keep what I have.",
        "option3": "Rename folder only.",
        "optOutAdditional": "I may need to change my {0} later if I don't use the recommended filename extension.",
        "buttonSave": "Save changes",
        "buttonCancel": "Cancel"
      }
    },
    "renameManual": {
      "title": "We need you to move your component specs manually",
      "componentFolderRemoved": "We've removed the {0} options from the Cypress config.",
      "addedSpecPattern": "We've added a new {0} option in the Cypress config that tells us where to find your component specs.",
      "cannotAuto": "We can't automatically migrate your existing component spec files. We recommend that you move the following component spec files next to your source component files (e.g. {0})",
      "ifSkipNote": "If you skip this step, Cypress will still be able to find them, but any new specs that you create will automatically be created next to your component files."
    },
    "renameSupport": {
      "title": "We'll automatically rename your existing E2E support file in this step",
      "serveDifferentTypes": "We now serve different support files for E2E and Component Testing.",
      "changedSupportFile": "We've renamed the E2E support file from:"
    },
    "configFile": {
      "title": "We need to migrate to the new Cypress configuration file",
      "changedDefault": "We've changed the default Cypress config file from:",
      "customOptions": "We've set a custom {specPattern} option based on your {options}.",
      "willConvert": "We'll automatically create a new {jsFile} file and seed it with your options from your existing {jsonFile}."
    },
    "setupComponent": {
      "title": "You need to reconfigure Cypress for component testing",
      "line1": "We've detected that you are currently using the experimental version of component testing.",
      "line2": "Your existing configuration is no longer compatible with new component testing configuration options.",
      "line3": "In a previous step, we renamed your component specs, but can't automatically migrate your existing component testing configuration.",
      "line4": "In the next screen, you'll be able to reconfigure component testing in a new guided configuration wizard."
    },
    "wizard": {
      "title": "Migrating to Cypress {version}",
      "description": "Your project requires updates to work with this version.",
      "typicalMigrationLabel": "Typical migration:",
      "typicalMigrationTime": "5-10 minutes",
      "step1": {
        "title": "Migrate existing specs",
        "description": "In this step, we'll automatically rename and/or move your existing spec files as needed.",
        "button": "Rename these specs for me",
        "buttonSkip": "Skip renaming specs",
        "buttonRenameFolder": "Rename the folder for me"
      },
      "step2": {
        "title": "Move your existing component specs",
        "description": "In this step, you'll manually move your existing component specs to their new default location.",
        "buttonWait": "Waiting for you to move your component specs...",
        "buttonDone": "Continue to next step",
        "button": "I'll do this later"
      },
      "step3": {
        "title": "Rename the Cypress support file",
        "description": "In this step, we'll automatically rename your existing support file.",
        "button": "Rename the support file for me"
      },
      "step4": {
        "title": "Migrate to the new Cypress configuration file",
        "description": "In this step, we'll automatically migrate your existing Cypress configuration to the new Cypress configuration file.",
        "button": "Migrate the configuration for me"
      },
      "step5": {
        "title": "Reconfigure component testing",
        "description": "In this step, we'll explain how you will reconfigure Cypress for component testing.",
        "button": "Finish migration and continue"
      }
    }
  },
  "majorVersionWelcome": {
    "title": "What's New in Cypress",
    "actionContinue": "Continue",
    "linkReleaseNotes": "View full changelog"
  },
  "setupWizard": {
    "selectFramework": {
      "title": "Project setup",
      "description": "Confirm the front-end framework and bundler used in your project."
    },
    "installDependencies": {
      "title": "Install dev dependencies",
      "description": "Based on your previous selection, the following dependencies are required.",
      "pasteCommand": "Paste this command into your terminal to install the following packages:",
      "waitForInstall": "Waiting for you to install the dependencies...",
      "installed": "installed",
      "pendingInstall": "pending installation",
      "installationAlertSuccess": "You've successfully installed all required dependencies."
    },
    "configFiles": {
      "title": "Configuration files",
      "description": "We added the following files to your project:"
    },
    "chooseBrowser": {
      "title": "Choose a browser",
      "description": "Choose your preferred browser for {testingType} testing."
    }
  },
  "e2eProjectSetup": {
    "title": "Project setup",
    "description": "Confirm your project's preferred language."
  },
  "openBrowser": {
    "startComponent": "Start Component Testing in {browser}",
    "startE2E": "Start E2E Testing in {browser}",
    "openingComponent": "Opening Component Testing in {browser}",
    "openingE2E": "Opening E2E Testing in {browser}",
    "running": "Running {browser}",
    "focus": "Focus",
    "close": "Close",
    "switchTestingType": "Switch testing type"
  },
  "runner": {
    "header": {
      "reviewDocs": "Review the docs",
      "troubleRendering": "if you're having trouble rendering your components properly."
    },
    "snapshot": {
      "highlightsLabel": "Highlights",
      "testsRunningError": "Cannot show snapshot while tests are running",
      "snapshotMissingError": "The snapshot is missing. Displaying current state of the DOM.",
      "defaultTitle": "DOM snapshot",
      "pinnedTitle": "Pinned",
      "studioActiveError": "Cannot show snapshot while creating commands in Studio"
    },
    "selectorPlayground": {
      "matches": "No matches | {n} match | {n} matches",
      "playgroundTooltip": "Click an element to see a suggested selector",
      "copyTooltip": "Copy to clipboard",
      "copyTooltipAction": "Copied!",
      "printTooltip": "Print to console",
      "printTooltipAction": "Printed!",
      "invalidSelector": "Invalid",
      "selectorMethodsLabel": "Selector methods",
      "toggle": "Toggle playground"
    },
    "automation": {
      "disconnected": {
        "title": "The Cypress extension has disconnected.",
        "description": "Cypress cannot run tests without this extension.",
        "reload": "Reload the browser"
      },
      "missing": {
        "title": "The Cypress extension is missing.",
        "description": "Cypress cannot run tests without this extension. Please choose another browser."
      },
      "shared": {
        "link": "Read more about browser management"
      }
    },
    "viewportTooltip": {
      "buttonText": "Review the guide on viewports",
      "buttonHref": "https://on.cypress.io/viewport",
      "infoText": "The viewport determines the width and height of your application under test. By default the viewport will be {0} by {1} for {2} testing.",
      "configText": "Additionally, you can override this value in your {configFile} or via the {viewportCommand} command."
    },
    "studio": {
      "studio": "Studio",
      "studioDescription": "Generate Cypress commands by interacting with your site as an end user would. Then, save these commands directly to your test file.",
      "studioDetailedDescription": "Generate and save commands directly to your test suite by interacting with your app as an end user would. Right click on an element to add an assertion. Studio will track events that generate the following commands:",
      "getStartedButton": "Get started",
      "feedbackPrompt": "Your {0} will be highly influential to our team.",
      "experimentalMessage": "This feature is currently experimental and we will be adding more commands and abilities in the future.",
      "feedbackLink": "feedback",
      "saveTest": "Save test",
      "testName": "Test name",
      "saveTestButton": "Save",
      "closeStudio": "Close Studio",
      "restartStudio": "Restart Studio",
      "copyCommands": "Copy commands to clipboard",
      "commandsCopied": "Commands copied!",
      "availableCommands": "Available commands",
      "giveFeedback": "Give feedback",
      "enterValidUrl": "Enter a valid URL to visit",
      "continue": "Continue",
      "actionCancel": "Cancel"
    }
  },
  "warnings": {
    "retry": "Try again"
  },
  "versions": {
    "alpha": "Alpha",
    "community": "Community",
    "beta": "Beta",
    "new": "New",
    "communityNote": "This is a community provided definition."
  }
}
`;
const defaultMessages = JSON.parse(rawJsonMessages);
createI18n();
function createI18n(opts = {}) {
  return createI18n$1({
    locale: "en-US",
    /**
    * precompiled messages from unplugin-vue-i18n do not include explicit keys derived from
    * the filenames of the raw message sources, so it must be coerced.
    */
    messages: compiledMessages,
    ...opts
  });
}
function useI18n() {
  return useI18n$1({ useScope: "global" });
}
const _hoisted_1$H = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$D = /* @__PURE__ */ createBaseVNode("circle", {
  id: "Circle",
  cx: "8",
  cy: "8",
  r: "6",
  stroke: "#E1E3ED",
  class: "icon-light",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null, -1);
const _hoisted_3$w = /* @__PURE__ */ createBaseVNode("path", {
  id: "Progress",
  d: "M14 8C14 4.68629 11.3137 2 8 2",
  stroke: "#6470F3",
  class: "icon-dark",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null, -1);
const _hoisted_4$g = [
  _hoisted_2$D,
  _hoisted_3$w
];
function render$s(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$H, _hoisted_4$g);
}
const __unplugin_components_0$6 = { name: "cy-loading_x16", render: render$s };
const _hoisted_1$G = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$C = /* @__PURE__ */ createBaseVNode("path", {
  d: "M13 8C13 10.7614 10.7614 13 8 13C5.23858 13 3 10.7614 3 8C3 5.23858 5.23858 3 8 3H11M11 3L9 5M11 3L9 1",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  class: "icon-light"
}, null, -1);
const _hoisted_3$v = [
  _hoisted_2$C
];
function render$r(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$G, _hoisted_3$v);
}
const RefreshIcon = { name: "cy-action-restart_x16", render: render$r };
var isVue2 = false;
function tryOnScopeDispose(fn2) {
  if (getCurrentScope()) {
    onScopeDispose(fn2);
    return true;
  }
  return false;
}
const isClient = typeof window !== "undefined";
const isString$1 = (val) => typeof val === "string";
const noop$5 = () => {
};
function createFilterWrapper(filter, fn2) {
  function wrapper(...args) {
    filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms2, options2 = {}) {
  let timer;
  let maxTimer;
  const filter = (invoke) => {
    const duration = unref(ms2);
    const maxDuration = unref(options2.maxWait);
    if (timer)
      clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer)
          clearTimeout(timer);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter;
}
function promiseTimeout(ms2, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve3, reject) => {
    if (throwOnTimeout)
      setTimeout(() => reject(reason), ms2);
    else
      setTimeout(resolve3, ms2);
  });
}
function useDebounceFn(fn2, ms2 = 200, options2 = {}) {
  return createFilterWrapper(debounceFilter(ms2, options2), fn2);
}
function useDebounce(value, ms2 = 200, options2 = {}) {
  if (ms2 <= 0)
    return value;
  const debounced = ref(value.value);
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms2, options2);
  watch(value, () => updater());
  return debounced;
}
var __getOwnPropSymbols$9$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$9$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$9$1 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$9$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$9$1)
    for (var prop of __getOwnPropSymbols$9$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$9$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchWithFilter(source, cb, options2 = {}) {
  const _a2 = options2, {
    eventFilter = bypassFilter
  } = _a2, watchOptions = __objRest$5(_a2, [
    "eventFilter"
  ]);
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
var __defProp$7 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$7 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$8.call(b2, prop))
      __defNormalProp$7(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b2)) {
      if (__propIsEnum$8.call(b2, prop))
        __defNormalProp$7(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$4 = (a2, b2) => __defProps$4(a2, __getOwnPropDescs$4(b2));
var __objRest$4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function debouncedWatch(source, cb, options2 = {}) {
  const _a2 = options2, {
    debounce: debounce2 = 0
  } = _a2, watchOptions = __objRest$4(_a2, [
    "debounce"
  ]);
  return watchWithFilter(source, cb, __spreadProps$4(__spreadValues$7({}, watchOptions), {
    eventFilter: debounceFilter(debounce2)
  }));
}
function not(v) {
  return computed(() => !unref(v));
}
function tryOnMounted(fn2, sync = true) {
  if (getCurrentInstance())
    onMounted(fn2);
  else if (sync)
    fn2();
  else
    nextTick(fn2);
}
function useIntervalFn(cb, interval2 = 1e3, options2 = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options2;
  let timer = null;
  const isActive = ref(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    if (interval2 <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, interval2);
  }
  if (immediate && isClient)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useTimeoutFn(cb, interval2, options2 = {}) {
  const {
    immediate = true
  } = options2;
  const isPending = ref(false);
  let timer = null;
  function clear2() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear2();
  }
  function start2(...args) {
    clear2();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, unref(interval2));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start2();
  }
  tryOnScopeDispose(stop);
  return {
    isPending,
    start: start2,
    stop
  };
}
var __defProp$2 = Object.defineProperty;
var __getOwnPropSymbols$1$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1$1.call(b2, prop))
      __defNormalProp$2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1$1)
    for (var prop of __getOwnPropSymbols$1$1(b2)) {
      if (__propIsEnum$1$1.call(b2, prop))
        __defNormalProp$2(a2, prop, b2[prop]);
    }
  return a2;
};
function useTimeout(interval2 = 1e3, options2 = {}) {
  const {
    controls: exposeControls = false
  } = options2;
  const controls = useTimeoutFn(noop$5, interval2, options2);
  const ready = computed(() => !controls.isPending.value);
  if (exposeControls) {
    return __spreadValues$2({
      ready
    }, controls);
  } else {
    return ready;
  }
}
function useToggle(initialValue = false) {
  if (isRef(initialValue)) {
    return (value) => {
      initialValue.value = typeof value === "boolean" ? value : !initialValue.value;
    };
  } else {
    const boolean = ref(initialValue);
    const toggle = (value) => {
      boolean.value = typeof value === "boolean" ? value : !boolean.value;
    };
    return [boolean, toggle];
  }
}
function whenever(source, cb, options2) {
  return watch(source, (v, ov, onInvalidate) => {
    if (v)
      cb(v, ov, onInvalidate);
  }, options2);
}
function unrefElement(elRef) {
  var _a2;
  const plain = unref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options2;
  if (isString$1(args[0])) {
    [event, listener, options2] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options2] = args;
  }
  if (!target)
    return noop$5;
  let cleanup = noop$5;
  const stopWatch = watch(() => unref(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options2);
    cleanup = () => {
      el.removeEventListener(event, listener, options2);
      cleanup = noop$5;
    };
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function onClickOutside(target, handler, options2 = {}) {
  const { window: window2 = defaultWindow } = options2;
  if (!window2)
    return;
  const shouldListen = ref(true);
  const listener = (event) => {
    const el = unrefElement(target);
    if (!el || el === event.target || event.composedPath().includes(el) || !shouldListen.value)
      return;
    handler(event);
  };
  const cleanup = [
    useEventListener(window2, "click", listener, { passive: true, capture: true }),
    useEventListener(window2, "pointerdown", (e) => {
      const el = unrefElement(target);
      shouldListen.value = !!el && !e.composedPath().includes(el);
    }, { passive: true })
  ];
  const stop = () => cleanup.forEach((fn2) => fn2());
  return stop;
}
const createKeyPredicate = (keyFilter) => {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  else if (keyFilter)
    return () => true;
  else
    return () => false;
};
function onKeyStroke(key, handler, options2 = {}) {
  const { target = defaultWindow, eventName = "keydown", passive: passive2 = false } = options2;
  const predicate = createKeyPredicate(key);
  const listener = (e) => {
    if (predicate(e))
      handler(e);
  };
  return useEventListener(target, eventName, listener, passive2);
}
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$9.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useResizeObserver(target, callback, options2 = {}) {
  const _a2 = options2, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
  let observer;
  const isSupported = window2 && "ResizeObserver" in window2;
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (isSupported && window2 && el) {
      observer = new window2.ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  }, { immediate: true, flush: "post" });
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options2 = {}) {
  const width = ref(initialSize.width);
  const height = ref(initialSize.height);
  useResizeObserver(target, ([entry]) => {
    width.value = entry.contentRect.width;
    height.value = entry.contentRect.height;
  }, options2);
  return {
    width,
    height
  };
}
function useRafFn(fn2, options2 = {}) {
  const {
    immediate = true,
    window: window2 = defaultWindow
  } = options2;
  const isActive = ref(false);
  function loop() {
    if (!isActive.value)
      return;
    fn2();
    if (window2)
      window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value) {
      isActive.value = true;
      loop();
    }
  }
  function pause() {
    isActive.value = false;
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}
function useNetwork(options2 = {}) {
  const { window: window2 = defaultWindow } = options2;
  const navigator2 = window2 == null ? void 0 : window2.navigator;
  const isSupported = Boolean(navigator2 && "connection" in navigator2);
  const isOnline = ref(true);
  const saveData = ref(false);
  const offlineAt = ref(void 0);
  const downlink = ref(void 0);
  const downlinkMax = ref(void 0);
  const rtt = ref(void 0);
  const effectiveType = ref(void 0);
  const type2 = ref("unknown");
  const connection = isSupported && navigator2.connection;
  function updateNetworkInformation() {
    if (!navigator2)
      return;
    isOnline.value = navigator2.onLine;
    offlineAt.value = isOnline.value ? void 0 : Date.now();
    if (connection) {
      downlink.value = connection.downlink;
      downlinkMax.value = connection.downlinkMax;
      effectiveType.value = connection.effectiveType;
      rtt.value = connection.rtt;
      saveData.value = connection.saveData;
      type2.value = connection.type;
    }
  }
  if (window2) {
    useEventListener(window2, "offline", () => {
      isOnline.value = false;
      offlineAt.value = Date.now();
    });
    useEventListener(window2, "online", () => {
      isOnline.value = true;
    });
  }
  if (connection)
    useEventListener(connection, "change", updateNetworkInformation, false);
  updateNetworkInformation();
  return {
    isSupported,
    isOnline,
    saveData,
    offlineAt,
    downlink,
    downlinkMax,
    effectiveType,
    rtt,
    type: type2
  };
}
var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$5.call(b2, prop))
      __defNormalProp$5(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b2)) {
      if (__propIsEnum$5.call(b2, prop))
        __defNormalProp$5(a2, prop, b2[prop]);
    }
  return a2;
};
function useNow(options2 = {}) {
  const {
    controls: exposeControls = false,
    interval: interval2 = "requestAnimationFrame"
  } = options2;
  const now2 = ref(/* @__PURE__ */ new Date());
  const update = () => now2.value = /* @__PURE__ */ new Date();
  const controls = interval2 === "requestAnimationFrame" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval2, { immediate: true });
  if (exposeControls) {
    return __spreadValues$5({
      now: now2
    }, controls);
  } else {
    return now2;
  }
}
function useOnline(options2 = {}) {
  const { isOnline } = useNetwork(options2);
  return isOnline;
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var _a$2, _b;
isClient && (window == null ? void 0 : window.navigator) && ((_a$2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a$2.platform) && /iP(ad|hone|od)/.test((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.platform);
var __defProp$1$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1.call(b2, prop))
      __defNormalProp$1(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b2)) {
      if (__propIsEnum$1.call(b2, prop))
        __defNormalProp$1(a2, prop, b2[prop]);
    }
  return a2;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
const UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Infinity, value: 31536e6, name: "year" }
];
const DEFAULT_MESSAGES = {
  justNow: "just now",
  past: (n) => n.match(/\d/) ? `${n} ago` : n,
  future: (n) => n.match(/\d/) ? `in ${n}` : n,
  month: (n, past) => n === 1 ? past ? "last month" : "next month" : `${n} month${n > 1 ? "s" : ""}`,
  year: (n, past) => n === 1 ? past ? "last year" : "next year" : `${n} year${n > 1 ? "s" : ""}`,
  day: (n, past) => n === 1 ? past ? "yesterday" : "tomorrow" : `${n} day${n > 1 ? "s" : ""}`,
  week: (n, past) => n === 1 ? past ? "last week" : "next week" : `${n} week${n > 1 ? "s" : ""}`,
  hour: (n) => `${n} hour${n > 1 ? "s" : ""}`,
  minute: (n) => `${n} minute${n > 1 ? "s" : ""}`,
  second: (n) => `${n} second${n > 1 ? "s" : ""}`
};
const DEFAULT_FORMATTER = (date) => date.toISOString().slice(0, 10);
function useTimeAgo(time, options2 = {}) {
  const {
    controls: exposeControls = false,
    max: max2,
    updateInterval = 3e4,
    messages = DEFAULT_MESSAGES,
    fullDateFormatter = DEFAULT_FORMATTER
  } = options2;
  const { abs, round: round2 } = Math;
  const _a2 = useNow({ interval: updateInterval, controls: true }), { now: now2 } = _a2, controls = __objRest(_a2, ["now"]);
  function getTimeago(from, now22) {
    var _a22;
    const diff = +now22 - +from;
    const absDiff = abs(diff);
    if (absDiff < 6e4)
      return messages.justNow;
    if (typeof max2 === "number" && absDiff > max2)
      return fullDateFormatter(new Date(from));
    if (typeof max2 === "string") {
      const unitMax = (_a22 = UNITS.find((i) => i.name === max2)) == null ? void 0 : _a22.max;
      if (unitMax && absDiff > unitMax)
        return fullDateFormatter(new Date(from));
    }
    for (const unit of UNITS) {
      if (absDiff < unit.max)
        return format2(diff, unit);
    }
  }
  function applyFormat(name2, val, isPast) {
    const formatter = messages[name2];
    if (typeof formatter === "function")
      return formatter(val, isPast);
    return formatter.replace("{0}", val.toString());
  }
  function format2(diff, unit) {
    const val = round2(abs(diff) / unit.value);
    const past = diff > 0;
    const str = applyFormat(unit.name, val, past);
    return applyFormat(past ? "past" : "future", str, past);
  }
  const timeAgo = computed(() => getTimeago(new Date(unref(time)), unref(now2.value)));
  if (exposeControls) {
    return __spreadValues$1({
      timeAgo
    }, controls);
  } else {
    return timeAgo;
  }
}
function useVModel(props, key, emit3, options2 = {}) {
  var _a2;
  const {
    passive: passive2 = false,
    eventName,
    deep = false
  } = options2;
  const vm = getCurrentInstance();
  const _emit = emit3 || (vm == null ? void 0 : vm.emit) || ((_a2 = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a2.bind(vm));
  let event = eventName;
  if (!key) {
    {
      key = "modelValue";
    }
  }
  event = eventName || event || `update:${key}`;
  if (passive2) {
    const proxy = ref(props[key]);
    watch(() => props[key], (v) => proxy.value = v);
    watch(proxy, (v) => {
      if (v !== props[key] || deep)
        _emit(event, v);
    }, {
      deep
    });
    return proxy;
  } else {
    return computed({
      get() {
        return props[key];
      },
      set(value) {
        _emit(event, value);
      }
    });
  }
}
function useVModels(props, emit3, options2 = {}) {
  const ret = {};
  for (const key in props)
    ret[key] = useVModel(props, key, emit3, options2);
  return ret;
}
function useWindowSize({ window: window2 = defaultWindow, initialWidth = Infinity, initialHeight = Infinity } = {}) {
  const width = ref(initialWidth);
  const height = ref(initialHeight);
  const update = () => {
    if (window2) {
      width.value = window2.innerWidth;
      height.value = window2.innerHeight;
    }
  };
  update();
  tryOnMounted(update);
  useEventListener("resize", update, { passive: true });
  return { width, height };
}
function getUtmSource() {
  return window.__CYPRESS_MODE__ ? "Binary: App" : "Binary: Launchpad";
}
const _hoisted_1$F = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$B = /* @__PURE__ */ createBaseVNode("path", {
  d: "M10 3C9.44771 3 9 3.44772 9 4C9 4.55228 9.44771 5 10 5V3ZM10 11C9.44771 11 9 11.4477 9 12C9 12.5523 9.44771 13 10 13V11ZM6 5C6.55228 5 7 4.55228 7 4C7 3.44772 6.55228 3 6 3V5ZM6 13C6.55228 13 7 12.5523 7 12C7 11.4477 6.55228 11 6 11V13ZM5 7C4.44772 7 4 7.44772 4 8C4 8.55228 4.44772 9 5 9V7ZM11 9C11.5523 9 12 8.55228 12 8C12 7.44772 11.5523 7 11 7V9ZM10 5H11V3H10V5ZM11 11H10V13H11V11ZM5 5H6V3H5V5ZM6 11H5V13H6V11ZM5 9H11V7H5V9ZM2 8C2 6.34315 3.34315 5 5 5V3C2.23858 3 0 5.23858 0 8H2ZM0 8C0 10.7614 2.23858 13 5 13V11C3.34315 11 2 9.65685 2 8H0ZM14 8C14 9.65685 12.6569 11 11 11V13C13.7614 13 16 10.7614 16 8H14ZM16 8C16 5.23858 13.7614 3 11 3V5C12.6569 5 14 6.34315 14 8H16Z",
  fill: "currentColor",
  class: "icon-dark"
}, null, -1);
const _hoisted_3$u = [
  _hoisted_2$B
];
function render$q(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$F, _hoisted_3$u);
}
const ConnectIcon = { name: "cy-chain-link_x16", render: render$q };
const Auth_LogoutDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "Auth_Logout" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "logout" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "cloudViewer" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudOrganizationsUrl" } }, { "kind": "Field", "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projects" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "slug" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }] } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "email" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fullName" } }, { "kind": "Field", "alias": { "kind": "Name", "value": "firstOrganization" }, "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "1" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "title" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projectId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "CloudProject" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "authState" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "browserOpened" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "message" } }] } }] } }] } }] };
const Auth_LoginDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "Auth_Login" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "utmSource" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "utmMedium" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "utmContent" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "login" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "utmSource" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "utmSource" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "utmContent" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "utmContent" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "utmMedium" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "utmMedium" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "cloudViewer" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudOrganizationsUrl" } }, { "kind": "Field", "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projects" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "slug" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }] } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "email" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fullName" } }, { "kind": "Field", "alias": { "kind": "Name", "value": "firstOrganization" }, "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "1" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "title" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projectId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "CloudProject" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "authState" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "browserOpened" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "message" } }] } }] } }] } }] };
const Auth_ResetAuthStateDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "Auth_ResetAuthState" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "resetAuthState" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "cloudViewer" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudOrganizationsUrl" } }, { "kind": "Field", "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projects" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "slug" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }] } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "email" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fullName" } }, { "kind": "Field", "alias": { "kind": "Name", "value": "firstOrganization" }, "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "1" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "title" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projectId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "CloudProject" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "authState" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "browserOpened" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "message" } }] } }] } }] } }] };
const ChooseExternalEditorModal_SetPreferredEditorBinaryDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "ChooseExternalEditorModal_SetPreferredEditorBinary" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "value" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "setPreferences" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "value" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "value" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "type" }, "value": { "kind": "EnumValue", "value": "global" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "localSettings" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "preferences" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "preferredEditorBinary" } }] } }] } }] } }] } }] };
const CloudViewerAndProject_RequiredDataDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "CloudViewerAndProject_RequiredData" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "cloudViewer" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fullName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "email" } }, { "kind": "Field", "alias": { "kind": "Name", "value": "firstOrganization" }, "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "1" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "cachedUser" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fullName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "email" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "authState" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "name" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projectId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "config" } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentTestingType" } }, { "kind": "Field", "name": { "kind": "Name", "value": "isFullConfigReady" } }, { "kind": "Field", "name": { "kind": "Name", "value": "isCTConfigured" } }, { "kind": "Field", "name": { "kind": "Name", "value": "hasNonExampleSpec" } }, { "kind": "Field", "name": { "kind": "Name", "value": "savedState" } }, { "kind": "Field", "name": { "kind": "Name", "value": "branch" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "CloudProject" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "runs" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "10" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "status" } }, { "kind": "Field", "name": { "kind": "Name", "value": "url" } }] } }] } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "wizard" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "framework" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "icon" } }, { "kind": "Field", "name": { "kind": "Name", "value": "isDetected" } }] } }] } }] } }] };
const CloudViewerAndProject_CheckCloudOrgMembershipDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "subscription", "name": { "kind": "Name", "value": "CloudViewerAndProject_CheckCloudOrgMembership" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "cloudViewerChange" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "cloudViewer" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fullName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "email" } }, { "kind": "Field", "alias": { "kind": "Name", "value": "firstOrganization" }, "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "1" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "cachedUser" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fullName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "email" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "authState" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "name" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projectId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "config" } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentTestingType" } }, { "kind": "Field", "name": { "kind": "Name", "value": "isFullConfigReady" } }, { "kind": "Field", "name": { "kind": "Name", "value": "isCTConfigured" } }, { "kind": "Field", "name": { "kind": "Name", "value": "hasNonExampleSpec" } }, { "kind": "Field", "name": { "kind": "Name", "value": "savedState" } }, { "kind": "Field", "name": { "kind": "Name", "value": "branch" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "CloudProject" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "runs" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "10" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "status" } }, { "kind": "Field", "name": { "kind": "Name", "value": "url" } }] } }] } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "wizard" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "framework" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "icon" } }, { "kind": "Field", "name": { "kind": "Name", "value": "isDetected" } }] } }] } }] } }] } }] };
const CloudViewerAndProject_DetectCtFrameworksDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "CloudViewerAndProject_DetectCtFrameworks" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "initializeCtFrameworks" } }] } }] };
const HeaderBar_HeaderBarQueryDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "HeaderBar_HeaderBarQuery" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "title" } }, { "kind": "Field", "name": { "kind": "Name", "value": "config" } }, { "kind": "Field", "name": { "kind": "Name", "value": "savedState" } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentTestingType" } }, { "kind": "Field", "name": { "kind": "Name", "value": "branch" } }, { "kind": "Field", "name": { "kind": "Name", "value": "packageManager" } }, { "kind": "Field", "name": { "kind": "Name", "value": "activeBrowser" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "displayName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "majorVersion" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "browsers" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "isSelected" } }, { "kind": "Field", "name": { "kind": "Name", "value": "displayName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "version" } }, { "kind": "Field", "name": { "kind": "Name", "value": "majorVersion" } }, { "kind": "Field", "name": { "kind": "Name", "value": "isVersionSupported" } }, { "kind": "Field", "name": { "kind": "Name", "value": "warning" } }, { "kind": "Field", "name": { "kind": "Name", "value": "disabled" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "projectId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "CloudProject" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "isGlobalMode" } }, { "kind": "Field", "name": { "kind": "Name", "value": "versions" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "current" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "version" } }, { "kind": "Field", "name": { "kind": "Name", "value": "released" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "latest" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "version" } }, { "kind": "Field", "name": { "kind": "Name", "value": "released" } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudViewer" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudOrganizationsUrl" } }, { "kind": "Field", "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projects" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "slug" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }] } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "email" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fullName" } }, { "kind": "Field", "alias": { "kind": "Name", "value": "firstOrganization" }, "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "1" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "authState" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "browserOpened" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "message" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "cachedUser" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fullName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "email" } }] } }] } }] };
const HeaderBarContent_AuthChangeDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "subscription", "name": { "kind": "Name", "value": "HeaderBarContent_authChange" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "authChange" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "cloudViewer" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudOrganizationsUrl" } }, { "kind": "Field", "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projects" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "slug" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }] } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "email" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fullName" } }, { "kind": "Field", "alias": { "kind": "Name", "value": "firstOrganization" }, "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "1" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "title" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projectId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "CloudProject" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "authState" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "browserOpened" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "message" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "cachedUser" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fullName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "email" } }] } }] } }] } }] };
const GlobalPageHeader_ClearCurrentProjectDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "GlobalPageHeader_clearCurrentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "clearCurrentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "baseError" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "title" } }, { "kind": "Field", "name": { "kind": "Name", "value": "errorName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "errorStack" } }, { "kind": "Field", "name": { "kind": "Name", "value": "errorType" } }, { "kind": "Field", "name": { "kind": "Name", "value": "errorMessage" } }, { "kind": "Field", "name": { "kind": "Name", "value": "isUserCodeError" } }, { "kind": "Field", "name": { "kind": "Name", "value": "codeFrame" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "line" } }, { "kind": "Field", "name": { "kind": "Name", "value": "column" } }, { "kind": "Field", "name": { "kind": "Name", "value": "codeBlock" } }, { "kind": "Field", "name": { "kind": "Name", "value": "file" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "absolute" } }, { "kind": "Field", "name": { "kind": "Name", "value": "relative" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "warnings" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "migration" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "configFileNameBefore" } }] } }] } }] } }] };
const LoginConnectModals_LoginConnectModalsQueryDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "LoginConnectModals_LoginConnectModalsQuery" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "cloudViewer" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudOrganizationsUrl" } }, { "kind": "Field", "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projects" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "slug" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }] } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "email" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fullName" } }, { "kind": "Field", "alias": { "kind": "Name", "value": "firstOrganization" }, "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "1" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "createCloudOrganizationUrl" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "title" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projectId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "CloudProject" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentTestingType" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "authState" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "browserOpened" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "message" } }] } }] } }] };
const OpenFileInIdeDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "OpenFileInIDE" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "localSettings" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "preferences" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "preferredEditorBinary" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "availableEditors" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "binary" } }] } }] } }] } }] };
const OpenFileInIde_MutationDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "OpenFileInIDE_Mutation" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "input" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "FileDetailsInput" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "openFileInIDE" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "input" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "input" } } }] }] } }] };
const RecordPromptAdapterDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "RecordPromptAdapter" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "title" } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentTestingType" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "CloudProject" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "recordKeys" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "key" } }] } }] } }] } }] } }] } }] };
const UseCohorts_DetermineCohortDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "UseCohorts_DetermineCohort" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "name" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "cohorts" } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "determineCohort" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "cohortConfig" }, "value": { "kind": "ObjectValue", "fields": [{ "kind": "ObjectField", "name": { "kind": "Name", "value": "name" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "name" } } }, { "kind": "ObjectField", "name": { "kind": "Name", "value": "cohorts" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "cohorts" } } }] } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cohort" } }] } }] } }] };
const UsePromptManager_SetProjectPreferencesDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "UsePromptManager_SetProjectPreferences" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "value" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "setPreferences" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "type" }, "value": { "kind": "EnumValue", "value": "project" } }, { "kind": "Argument", "name": { "kind": "Name", "value": "value" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "value" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "savedState" } }] } }] } }] } }] };
const UsePromptManager_SetGlobalPreferencesDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "UsePromptManager_SetGlobalPreferences" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "value" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "setPreferences" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "type" }, "value": { "kind": "EnumValue", "value": "global" } }, { "kind": "Argument", "name": { "kind": "Name", "value": "value" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "value" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "localSettings" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "preferences" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "majorVersionWelcomeDismissed" } }] } }] } }] } }] } }] };
const CloudConnectModals_MonitorCloudViewerDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "subscription", "name": { "kind": "Name", "value": "CloudConnectModals_MonitorCloudViewer" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "cloudViewerChange" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "cloudViewer" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudOrganizationsUrl" } }, { "kind": "Field", "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projects" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "slug" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }] } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "createCloudOrganizationUrl" } }, { "kind": "Field", "alias": { "kind": "Name", "value": "firstOrganization" }, "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "1" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "title" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projectId" } }] } }] } }] } }] };
const CreateCloudOrgModal_CloudOrganizationsCheckDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "CreateCloudOrgModal_CloudOrganizationsCheck" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "refreshCloudViewer" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "cloudViewer" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudOrganizationsUrl" } }, { "kind": "Field", "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projects" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "100" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "slug" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }] } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "createCloudOrganizationUrl" } }, { "kind": "Field", "alias": { "kind": "Name", "value": "firstOrganization" }, "name": { "kind": "Name", "value": "organizations" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "1" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "title" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projectId" } }] } }] } }] } }] };
const SelectCloudProjectModal_SetProjectIdDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "SelectCloudProjectModal_SetProjectId" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "projectId" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "setProjectIdInConfigFile" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "projectId" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "projectId" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "currentProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "projectId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "cloudProject" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "CloudProject" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "runs" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "IntValue", "value": "10" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "nodes" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "createdAt" } }, { "kind": "Field", "name": { "kind": "Name", "value": "status" } }, { "kind": "Field", "name": { "kind": "Name", "value": "totalDuration" } }, { "kind": "Field", "name": { "kind": "Name", "value": "url" } }, { "kind": "Field", "name": { "kind": "Name", "value": "tags" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "totalPassed" } }, { "kind": "Field", "name": { "kind": "Name", "value": "totalFailed" } }, { "kind": "Field", "name": { "kind": "Name", "value": "totalPending" } }, { "kind": "Field", "name": { "kind": "Name", "value": "totalSkipped" } }, { "kind": "Field", "name": { "kind": "Name", "value": "totalFlakyTests" } }, { "kind": "Field", "name": { "kind": "Name", "value": "commitInfo" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "authorName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "authorEmail" } }, { "kind": "Field", "name": { "kind": "Name", "value": "summary" } }, { "kind": "Field", "name": { "kind": "Name", "value": "branch" } }] } }] } }] } }] } }] } }] } }] } }] } }] };
const SelectCloudProjectModal_CreateCloudProjectDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "SelectCloudProjectModal_CreateCloudProject" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "name" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "orgId" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "public" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "campaign" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "cohort" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "medium" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "source" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "cloudProjectCreate" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "name" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "name" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "orgId" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "orgId" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "public" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "public" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "campaign" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "campaign" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "cohort" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "cohort" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "medium" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "medium" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "source" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "source" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "slug" } }] } }] } }] };
const TopNav_SetPromptShownDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "TopNav_SetPromptShown" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "slug" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "setPromptShown" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "slug" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "slug" } } }] }] } }] };
const VerticalBrowserListItems_SetBrowserDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "VerticalBrowserListItems_SetBrowser" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "id" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ID" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "specPath" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "launchpadSetBrowser" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "id" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "id" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "browsers" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "isSelected" } }, { "kind": "Field", "name": { "kind": "Name", "value": "displayName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "version" } }, { "kind": "Field", "name": { "kind": "Name", "value": "majorVersion" } }, { "kind": "Field", "name": { "kind": "Name", "value": "isVersionSupported" } }, { "kind": "Field", "name": { "kind": "Name", "value": "warning" } }, { "kind": "Field", "name": { "kind": "Name", "value": "disabled" } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "launchOpenProject" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "specPath" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "specPath" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }] } }] } }] };
const Clipboard_CopyToClipboardDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "Clipboard_CopyToClipboard" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "text" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "copyTextToClipboard" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "text" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "text" } } }] }] } }] };
const ExternalLink_OpenExternalDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "ExternalLink_OpenExternal" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "url" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "includeGraphqlPort" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "openExternal" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "url" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "url" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "includeGraphqlPort" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "includeGraphqlPort" } } }] }] } }] };
const GlobalSubscriptions_PushFragmentDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "subscription", "name": { "kind": "Name", "value": "GlobalSubscriptions_PushFragment" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "pushFragment" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "target" } }, { "kind": "Field", "name": { "kind": "Name", "value": "fragment" } }, { "kind": "Field", "name": { "kind": "Name", "value": "data" } }, { "kind": "Field", "name": { "kind": "Name", "value": "errors" } }, { "kind": "Field", "name": { "kind": "Name", "value": "variables" } }, { "kind": "Field", "name": { "kind": "Name", "value": "invalidateCache" } }] } }] } }] };
const GlobalSubscriptions_ErrorWarningChangeDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "subscription", "name": { "kind": "Name", "value": "GlobalSubscriptions_ErrorWarningChange" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "errorWarningChange" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "baseError" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "title" } }, { "kind": "Field", "name": { "kind": "Name", "value": "errorName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "errorStack" } }, { "kind": "Field", "name": { "kind": "Name", "value": "errorType" } }, { "kind": "Field", "name": { "kind": "Name", "value": "errorMessage" } }, { "kind": "Field", "name": { "kind": "Name", "value": "isUserCodeError" } }, { "kind": "Field", "name": { "kind": "Name", "value": "codeFrame" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "line" } }, { "kind": "Field", "name": { "kind": "Name", "value": "column" } }, { "kind": "Field", "name": { "kind": "Name", "value": "codeBlock" } }, { "kind": "Field", "name": { "kind": "Name", "value": "file" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "absolute" } }, { "kind": "Field", "name": { "kind": "Name", "value": "relative" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "warnings" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "title" } }, { "kind": "Field", "name": { "kind": "Name", "value": "errorType" } }, { "kind": "Field", "name": { "kind": "Name", "value": "errorMessage" } }] } }] } }] } }] };
/*!
  * vue-router v4.0.11
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
const hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
const PolySymbol = (name2) => (
  // vr = vue router
  hasSymbol ? Symbol(name2) : "_vr_" + name2
);
const matchedRouteKey = /* @__PURE__ */ PolySymbol("rvlm");
const viewDepthKey = /* @__PURE__ */ PolySymbol("rvd");
const routerKey = /* @__PURE__ */ PolySymbol("r");
const routeLocationKey = /* @__PURE__ */ PolySymbol("rl");
const routerViewLocationKey = /* @__PURE__ */ PolySymbol("rvl");
const isBrowser$2 = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === "Module";
}
const assign$1 = Object.assign;
function applyToParams(fn2, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = Array.isArray(value) ? value.map(fn2) : fn2(value);
  }
  return newParams;
}
const noop$4 = () => {
};
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query2 = {}, searchString = "", hash2 = "";
  const searchPos = location2.indexOf("?");
  const hashPos = location2.indexOf("#", searchPos > -1 ? searchPos : 0);
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query2 = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash2 = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash2,
    path,
    query: query2,
    hash: hash2
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query2 = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query2 && "?") + query2 + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a2, b2) {
  const aLastIndex = a2.matched.length - 1;
  const bLastIndex = b2.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a2.matched[aLastIndex], b2.matched[bLastIndex]) && isSameRouteLocationParams(a2.params, b2.params) && stringifyQuery2(a2.query) === stringifyQuery2(b2.query) && a2.hash === b2.hash;
}
function isSameRouteRecord(a2, b2) {
  return (a2.aliasOf || a2) === (b2.aliasOf || b2);
}
function isSameRouteLocationParams(a2, b2) {
  if (Object.keys(a2).length !== Object.keys(b2).length)
    return false;
  for (const key in a2) {
    if (!isSameRouteLocationParamsValue(a2[key], b2[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a2, b2) {
  return Array.isArray(a2) ? isEquivalentArray(a2, b2) : Array.isArray(b2) ? isEquivalentArray(b2, a2) : a2 === b2;
}
function isEquivalentArray(a2, b2) {
  return Array.isArray(b2) ? a2.length === b2.length && a2.every((value, i) => value === b2[i]) : a2.length === 1 && a2[0] === b2;
}
function resolveRelativePath(to, from) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (position === 1 || segment === ".")
      continue;
    if (segment === "..")
      position--;
    else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser$2) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset2) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset2.behavior,
    left: elRect.left - docRect.left - (offset2.left || 0),
    top: elRect.top - docRect.top - (offset2.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path, delta) {
  const position = history.state ? history.state.position - delta : -1;
  return position + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash: hash2 } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash2.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash2.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash2;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners2 = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners2.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners2.push(callback);
    const teardown2 = () => {
      const index = listeners2.indexOf(callback);
      if (index > -1)
        listeners2.splice(index, 1);
    };
    teardowns.push(teardown2);
    return teardown2;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign$1({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown2 of teardowns)
      teardown2();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener);
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      // the length is off by one, we need to decrease it
      position: history2.length - 1,
      replaced: true,
      // don't add a scroll as the user may have an anchor and we want
      // scrollBehavior to be triggered without a saved position
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace2) {
    const hashIndex = base.indexOf("#");
    const url2 = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url2);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url2);
    }
  }
  function replace(to, data) {
    const state = assign$1({}, history2.state, buildState(
      historyState.value.back,
      // keep back and forward entries but override current position
      to,
      historyState.value.forward,
      true
    ), data, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push2(to, data) {
    const currentState = assign$1(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/vue-router-next/issues/366
      historyState.value,
      history2.state,
      {
        forward: to,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state = assign$1({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push: push2,
    replace
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign$1({
    // it's overridden right after
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base) {
  base = location.host ? base || location.pathname + location.search : "";
  if (!base.includes("#"))
    base += "#";
  return createWebHistory(base);
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name2) {
  return typeof name2 === "string" || typeof name2 === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = /* @__PURE__ */ PolySymbol("nf");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type2, params) {
  {
    return assign$1(new Error(), {
      type: type2,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type2) {
  return error instanceof Error && NavigationFailureSymbol in error && (type2 == null || !!(error.type & type2));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options2 = assign$1({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options2.start ? "^" : "";
  const keys2 = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [
      90
      /* Root */
    ];
    if (options2.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options2.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys2.push({
          name: value,
          repeatable,
          optional
        });
        const re22 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re22 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re22})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re22}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re22})(?:/(?:${re22}))*)` : `(${re22})`;
        if (!tokenIndex)
          subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
          // or /:p?-:p2
          optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re22 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options2.strict && options2.end) {
    const i = score.length - 1;
    score[i][score[i].length - 1] += 0.7000000000000001;
  }
  if (!options2.strict)
    pattern += "/?";
  if (options2.end)
    pattern += "$";
  else if (options2.strict)
    pattern += "(?:/|$)";
  const re2 = new RegExp(pattern, options2.sensitive ? "" : "i");
  function parse2(path) {
    const match2 = path.match(re2);
    const params = {};
    if (!match2)
      return null;
    for (let i = 1; i < match2.length; i++) {
      const value = match2[i] || "";
      const key = keys2[i - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify2(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (Array.isArray(param) && !repeatable)
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          const text = Array.isArray(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path;
  }
  return {
    re: re2,
    score,
    keys: keys2,
    parse: parse2,
    stringify: stringify2
  };
}
function compareScoreArray(a2, b2) {
  let i = 0;
  while (i < a2.length && i < b2.length) {
    const diff = b2[i] - a2[i];
    if (diff)
      return diff;
    i++;
  }
  if (a2.length < b2.length) {
    return a2.length === 1 && a2[0] === 40 + 40 ? -1 : 1;
  } else if (a2.length > b2.length) {
    return b2.length === 1 && b2[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a2, b2) {
  let i = 0;
  const aScore = a2.score;
  const bScore = b2.score;
  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i]);
    if (comp)
      return comp;
    i++;
  }
  return bScore.length - aScore.length;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i < path.length) {
    char = path[i++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options2) {
  const parser2 = tokensToParser(tokenizePath(record.path), options2);
  const matcher = assign$1(parser2, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes2, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name2) {
    return matcherMap.get(name2);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options2 = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign$1({}, mainNormalizedRecord, {
          // this allows us to hold a copy of the `components` option
          // so that async components cache is hold on the original record
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          // we might be the child of an alias
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
          // the aliases are always of the same kind as the original since they
          // are defined on the same record
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options2);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if ("children" in mainNormalizedRecord) {
        const children = mainNormalizedRecord.children;
        for (let i = 0; i < children.length; i++) {
          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
        }
      }
      originalRecord = originalRecord || matcher;
      insertMatcher(matcher);
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop$4;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i = 0;
    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0)
      i++;
    matchers.splice(i, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve3(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name2;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name2 = matcher.record.name;
      params = assign$1(
        // paramsFromLocation is a new object
        paramsFromLocation(
          currentLocation.params,
          // only keep params that exist in the resolved location
          // TODO: only keep optional params coming from a parent record
          matcher.keys.filter((k) => !k.optional).map((k) => k.name)
        ),
        location2.params
      );
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers.find((m2) => m2.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name2 = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m2) => m2.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name2 = matcher.record.name;
      params = assign$1({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name: name2,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes2.forEach((route) => addRoute(route));
  return { addRoute, resolve: resolve3, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys2) {
  const newParams = {};
  for (const key of keys2) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || {} : { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name2 in record.components)
      propsObject[name2] = typeof props === "boolean" ? props : props[name2];
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign$1(meta, record.meta), {});
}
function mergeOptions(defaults2, partialOptions) {
  const options2 = {};
  for (const key in defaults2) {
    options2[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
  }
  return options2;
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode$2(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
function parseQuery(search) {
  const query2 = {};
  if (search === "" || search === "?")
    return query2;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i = 0; i < searchParams.length; ++i) {
    const searchParam = searchParams[i].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode$2(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode$2(searchParam.slice(eqPos + 1));
    if (key in query2) {
      let currentValue = query2[key];
      if (!Array.isArray(currentValue)) {
        currentValue = query2[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query2[key] = value;
    }
  }
  return query2;
}
function stringifyQuery(query2) {
  let search = "";
  for (let key in query2) {
    const value = query2[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values = Array.isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query2) {
  const normalizedQuery = {};
  for (const key in query2) {
    const value = query2[key];
    if (value !== void 0) {
      normalizedQuery[key] = Array.isArray(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
function useCallbacks() {
  let handlers = [];
  function add2(handler) {
    handlers.push(handler);
    return () => {
      const i = handlers.indexOf(handler);
      if (i > -1)
        handlers.splice(i, 1);
    };
  }
  function reset() {
    handlers = [];
  }
  return {
    add: add2,
    list: () => handlers,
    reset
  };
}
function guardToPromiseFn(guard, to, from, record, name2) {
  const enterCallbackArray = record && // name is defined if record is because of the function overload
  (record.enterCallbacks[name2] = record.enterCallbacks[name2] || []);
  return () => new Promise((resolve3, reject) => {
    const next = (valid) => {
      if (valid === false)
        reject(createRouterError(4, {
          from,
          to
        }));
      else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
        record.enterCallbacks[name2] === enterCallbackArray && typeof valid === "function")
          enterCallbackArray.push(valid);
        resolve3();
      }
    };
    const guardReturn = guard.call(record && record.instances[name2], to, from, next);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from) {
  const guards = [];
  for (const record of matched) {
    for (const name2 in record.components) {
      let rawComponent = record.components[name2];
      if (guardType !== "beforeRouteEnter" && !record.instances[name2])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options2 = rawComponent.__vccOpts || rawComponent;
        const guard = options2[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name2));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name2}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name2] = resolvedComponent;
          const options2 = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options2[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name2)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => router.resolve(unref(props.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length: length2 } = matched;
    const routeMatched = matched[length2 - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length2 - 2]);
    return (
      // we are dealing with nested routes
      length2 > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length2 - 2])) : index
    );
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e = {}) {
    if (guardEvent(e)) {
      return router[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
        // avoid uncaught errors are they are logged anyway
      ).catch(noop$4);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props, { slots }) {
    const link2 = reactive(useLink(props));
    const { options: options2 } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options2.linkActiveClass, "router-link-active")]: link2.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(props.exactActiveClass, options2.linkExactActiveClass, "router-link-exact-active")]: link2.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link2);
      return props.custom ? children : h$1("a", {
        "aria-current": link2.isExactActive ? props.ariaCurrentValue : null,
        href: link2.href,
        // this would override user added attrs but Vue will still add
        // the listener so we end up triggering both
        onClick: link2.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
    return;
  if (e.defaultPrevented)
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e.preventDefault)
    e.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  setup(props, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const depth = inject(viewDepthKey, 0);
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);
    provide(viewDepthKey, depth + 1);
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name2], [oldInstance, from, oldName]) => {
      if (to) {
        to.instances[name2] = instance;
        if (from && from !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to && // if there is no instance but to and from are the same this might be
      // the first visit
      (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name2] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[props.name];
      const currentName = props.name;
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[props.name];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h$1(ViewComponent, assign$1({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, { Component: component, route }) || component
      );
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter$1(options2) {
  const matcher = createRouterMatcher(options2.routes, options2);
  const parseQuery$1 = options2.parseQuery || parseQuery;
  const stringifyQuery$1 = options2.stringifyQuery || stringifyQuery;
  const routerHistory = options2.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser$2 && options2.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = (
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode$2)
  );
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name2) {
    const recordMatcher = matcher.getRecordMatcher(name2);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name2) {
    return !!matcher.getRecordMatcher(name2);
  }
  function resolve3(rawLocation, currentLocation) {
    currentLocation = assign$1({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign$1(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode$2(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign$1({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign$1({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign$1({}, rawLocation, {
        params: encodeParams(rawLocation.params)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash2 = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign$1({}, rawLocation, {
      hash: encodeHash(hash2),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign$1({
      fullPath,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash: hash2,
      query: (
        // if the user is using a custom query lib like qs, we might have
        // nested objects, so we keep the query as is, meaning it can contain
        // numbers at `$route.query`, but at the point, the user will have to
        // use their own type anyway.
        // https://github.com/vuejs/vue-router-next/issues/328#issuecomment-649481567
        stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      )
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign$1({}, to);
  }
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to
      });
    }
  }
  function push2(to) {
    return pushWithRedirect(to);
  }
  function replace(to) {
    return push2(assign$1(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
          // force empty params
          { path: newTargetLocation }
        );
        newTargetLocation.params = {};
      }
      return assign$1({
        query: to.query,
        hash: to.hash,
        params: to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve3(to);
    const from = currentRoute.value;
    const data = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign$1(locationAsObject(shouldRedirect), {
          state: data,
          force,
          replace: replace2
        }),
        // keep original redirectedFrom if it exists
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(
        from,
        from,
        // this is a push, the only way for it to be triggered from a
        // history.listen is with a redirect, which makes it become a push
        true,
        // This cannot be the first navigation because the initial location
        // cannot be manually navigated to
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? error : (
      // reject any unknown error
      triggerError(error, toLocation, from)
    )).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(
          failure2,
          2
          /* NAVIGATION_GUARD_REDIRECT */
        )) {
          return pushWithRedirect(
            // keep options
            assign$1(locationAsObject(failure2.to), {
              state: data,
              force,
              replace: replace2
            }),
            // preserve the original redirectedFrom if any
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of to.matched) {
        if (record.beforeEnter && !from.matched.includes(record)) {
          if (Array.isArray(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(
      err,
      8
      /* NAVIGATION_CANCELLED */
    ) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from, failure) {
    for (const guard of afterGuards.list())
      guard(to, from, failure);
  }
  function finalizeNavigation(toLocation, from, isPush, replace2, data) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error)
      return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser$2 ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign$1({
          scroll: isFirstNavigation && state && state.scroll
        }, data));
      else
        routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      const toLocation = resolve3(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign$1(shouldRedirect, { replace: true }), toLocation).catch(noop$4);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser$2) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(
          error,
          4 | 8
          /* NAVIGATION_CANCELLED */
        )) {
          return error;
        }
        if (isNavigationFailure(
          error,
          2
          /* NAVIGATION_GUARD_REDIRECT */
        )) {
          pushWithRedirect(
            error.to,
            toLocation
            // avoid an uncaught rejection, let push call triggerError
          ).then((failure) => {
            if (isNavigationFailure(
              failure,
              4 | 16
              /* NAVIGATION_DUPLICATED */
            ) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop$4);
          return Promise.reject();
        }
        if (info.delta)
          routerHistory.go(-info.delta, false);
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          // after navigation, all matched components are resolved
          toLocation,
          from,
          false
        );
        if (failure) {
          if (info.delta) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(
            failure,
            4 | 16
            /* NAVIGATION_DUPLICATED */
          )) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop$4);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorHandlers.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve22, reject) => {
      readyHandlers.add([resolve22, reject]);
    });
  }
  function markAsReady(err) {
    if (ready)
      return;
    ready = true;
    setupListeners();
    readyHandlers.list().forEach(([resolve22, reject]) => err ? reject(err) : resolve22());
    readyHandlers.reset();
  }
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options2;
    if (!isBrowser$2 || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router = {
    currentRoute,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve3,
    options: options2,
    push: push2,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app2) {
      const router2 = this;
      app2.component("RouterLink", RouterLink);
      app2.component("RouterView", RouterView);
      app2.config.globalProperties.$router = router2;
      Object.defineProperty(app2.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser$2 && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push2(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        reactiveRoute[key] = computed(() => currentRoute.value[key]);
      }
      app2.provide(routerKey, router2);
      app2.provide(routeLocationKey, reactive(reactiveRoute));
      app2.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app2.unmount;
      installedApps.add(app2);
      app2.unmount = function() {
        installedApps.delete(app2);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  return router;
}
function runGuardQueue(guards) {
  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
function useRouter() {
  return inject(routerKey);
}
function useRoute() {
  return inject(routeLocationKey);
}
const _hoisted_1$E = {
  key: 0,
  class: "flex justify-self-start items-center"
};
const _hoisted_2$A = { class: "grow" };
const _hoisted_3$t = {
  key: 1,
  class: "flex justify-self-start items-center"
};
const __default__$3 = defineComponent({
  inheritAttrs: true
});
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  ...__default__$3,
  __name: "ButtonInternals",
  props: {
    prefixIcon: null,
    suffixIcon: null,
    prefixIconClass: null,
    suffixIconClass: null
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        __props.prefixIcon || _ctx.$slots.prefix ? (openBlock(), createElementBlock("span", _hoisted_1$E, [
          renderSlot(_ctx.$slots, "prefix", {}, () => [
            (openBlock(), createBlock(resolveDynamicComponent(__props.prefixIcon), {
              class: normalizeClass(__props.prefixIconClass)
            }, null, 8, ["class"]))
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("span", _hoisted_2$A, [
          renderSlot(_ctx.$slots, "default")
        ]),
        __props.suffixIcon || _ctx.$slots.suffix ? (openBlock(), createElementBlock("span", _hoisted_3$t, [
          renderSlot(_ctx.$slots, "suffix", {}, () => [
            (openBlock(), createBlock(resolveDynamicComponent(__props.suffixIcon), {
              class: normalizeClass(__props.suffixIconClass)
            }, null, 8, ["class"]))
          ])
        ])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const _hoisted_1$D = ["href"];
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "BaseLink",
  props: {
    href: { default: "" },
    useDefaultHocus: { type: Boolean, default: true }
  },
  setup(__props) {
    const props = __props;
    const attrs = useAttrs();
    const classes = computed(() => {
      const hocus = props.useDefaultHocus ? "hocus-link-default" : "";
      return `${attrs.class ?? "text-indigo-500"} ${hocus}`;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("a", {
        href: props.href,
        class: normalizeClass(unref(classes))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 10, _hoisted_1$D);
    };
  }
});
gql`
mutation ExternalLink_OpenExternal ($url: String!, $includeGraphqlPort: Boolean) {
  openExternal(url: $url, includeGraphqlPort: $includeGraphqlPort)
}
`;
const useExternalLink = ($href, includeGraphqlPort = false) => {
  const openExternalMutation = useMutation(ExternalLink_OpenExternalDocument);
  return (href) => {
    const resolvedHref = unref(typeof href === "string" ? href : $href);
    if (!resolvedHref) {
      return new Error(`Cannot open external link. Possible urls passed in were ${{ localHref: href, initialHref: unref($href) }}`);
    }
    return openExternalMutation.executeMutation({ url: resolvedHref, includeGraphqlPort });
  };
};
const __default__$2 = defineComponent({
  inheritAttrs: true
});
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  ...__default__$2,
  __name: "ExternalLink",
  props: {
    href: { default: "" },
    useDefaultHocus: { type: Boolean, default: true },
    includeGraphqlPort: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const open = useExternalLink(props.href, props.includeGraphqlPort);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$A, {
        "data-cy": "external",
        href: props.href,
        "use-default-hocus": props.useDefaultHocus,
        onClick: withModifiers(unref(open), ["prevent"]),
        onKeypress: withKeys(withModifiers(unref(open), ["prevent"]), ["enter"])
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["href", "use-default-hocus", "onClick", "onKeypress"]);
    };
  }
});
const _hoisted_1$C = ["disabled"];
const VariantClassesTable = {
  primary: "border-indigo-500 bg-indigo-500 focus:bg-indigo-600 text-white hocus-default",
  outline: "border-gray-100 text-indigo-600 hocus-default",
  tertiary: "text-indigo-500 bg-indigo-50 border-transparent hocus-default",
  pending: "bg-gray-500 text-white",
  link: "border-transparent text-indigo-600 hocus-default",
  linkBold: "border-transparent text-indigo-500 font-medium",
  text: "border-0",
  secondary: "bg-jade-500 text-white hocus-secondary",
  white: "bg-white text-indigo-500 font-medium hocus-default"
};
const SizeClassesTable = {
  sm: "px-[6px] py-[2px] text-[14px] h-[24px]",
  md: "px-[12px] py-[8px] text-[14px] h-[32px]",
  lg: "px-[16px] py-[11px] max-h-[40px]",
  "lg-wide": "px-[32px] py-[8px]"
};
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "Button",
  props: {
    prefixIcon: null,
    suffixIcon: null,
    size: null,
    variant: null,
    prefixIconClass: null,
    suffixIconClass: null,
    href: null,
    to: null,
    internalLink: { type: Boolean },
    disabled: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    const attrs = useAttrs();
    function filterHocus(classes2) {
      return classes2.split(" ").filter((css) => !(css.startsWith("hocus") && props.disabled)).join(" ");
    }
    const variantClasses = computed(() => {
      const variantClasses2 = VariantClassesTable[props.variant || "primary"];
      return props.disabled ? filterHocus(variantClasses2) : variantClasses2;
    });
    const sizeClasses = computed(() => SizeClassesTable[props.size || "md"]);
    const classes = computed(() => {
      return [
        variantClasses.value,
        sizeClasses.value,
        attrs.class,
        props.disabled && props.variant !== "pending" ? "opacity-50" : "",
        props.disabled ? "cursor-default" : ""
      ];
    });
    const linkVersion = computed(() => {
      if (!props.to) {
        return props.internalLink ? _sfc_main$A : _sfc_main$z;
      }
      if (props.disabled) {
        return _sfc_main$A;
      }
      return RouterLink;
    });
    const linkProps = computed(() => {
      if (props.disabled) {
        return {
          role: "link",
          ariaDisabled: "true",
          href: null
        };
      }
      if (props.to)
        return { to: props.to };
      if (props.href)
        return { href: props.href };
      return {};
    });
    return (_ctx, _cache) => {
      return !props.href && !props.to ? (openBlock(), createElementBlock("button", {
        key: 0,
        style: { "width": "fit-content" },
        class: normalizeClass(["border rounded flex outline-none leading-tight gap-[8px] items-center", unref(classes)]),
        disabled: __props.disabled
      }, [
        createVNode(_sfc_main$B, null, createSlots({
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 2
        }, [
          __props.prefixIcon || _ctx.$slots.prefix ? {
            name: "prefix",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "prefix", {}, () => [
                (openBlock(), createBlock(resolveDynamicComponent(__props.prefixIcon), {
                  class: normalizeClass(__props.prefixIconClass)
                }, null, 8, ["class"]))
              ])
            ]),
            key: "0"
          } : void 0,
          __props.suffixIcon || _ctx.$slots.suffix ? {
            name: "suffix",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "suffix", {}, () => [
                (openBlock(), createBlock(resolveDynamicComponent(__props.suffixIcon), {
                  class: normalizeClass(__props.suffixIconClass)
                }, null, 8, ["class"]))
              ])
            ]),
            key: "1"
          } : void 0
        ]), 1024)
      ], 10, _hoisted_1$C)) : (openBlock(), createBlock(resolveDynamicComponent(unref(linkVersion)), mergeProps({ key: 1 }, unref(linkProps), {
        style: { "width": "fit-content" },
        class: ["border rounded flex outline-none gap-[8px] items-center select-none", unref(classes)],
        "use-default-hocus": false
      }), {
        default: withCtx(() => [
          createVNode(_sfc_main$B, null, createSlots({
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 2
          }, [
            __props.prefixIcon || _ctx.$slots.prefix ? {
              name: "prefix",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "prefix", {}, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(__props.prefixIcon), {
                    class: normalizeClass(__props.prefixIconClass)
                  }, null, 8, ["class"]))
                ])
              ]),
              key: "0"
            } : void 0,
            __props.suffixIcon || _ctx.$slots.suffix ? {
              name: "suffix",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "suffix", {}, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(__props.suffixIcon), {
                    class: normalizeClass(__props.suffixIconClass)
                  }, null, 8, ["class"]))
                ])
              ]),
              key: "1"
            } : void 0
          ]), 1024)
        ]),
        _: 3
      }, 16, ["class"]));
    };
  }
});
/*!
  * pinia v2.0.0-rc.14
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
let activePinia;
const setActivePinia = (pinia) => activePinia = pinia;
const piniaSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject$2(o2) {
  return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia$1() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  const toBeInstalled = [];
  const pinia = markRaw({
    install(app2) {
      setActivePinia(pinia);
      {
        pinia._a = app2;
        app2.provide(piniaSymbol, pinia);
        app2.config.globalProperties.$pinia = pinia;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
      }
    },
    use(plugin) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia;
}
function addSubscription(subscriptions, callback, detached) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
    }
  };
  if (!detached && getCurrentInstance()) {
    onUnmounted(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.forEach((callback) => {
    callback(...args);
  });
}
function innerPatch(target, patchToApply) {
  for (const key in patchToApply) {
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$2(targetValue) && isPlainObject$2(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = innerPatch(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const { assign } = Object;
function isComputed$1(o2) {
  return !!(isRef(o2) && o2.effect);
}
function createOptionsStore(id2, options2, pinia, hot) {
  const { state, actions, getters } = options2;
  const initialState = pinia.state.value[id2];
  let store;
  function setup9() {
    if (!initialState && true) {
      {
        pinia.state.value[id2] = state ? state() : {};
      }
    }
    const localState = toRefs(pinia.state.value[id2]);
    return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name2) => {
      computedGetters[name2] = markRaw(computed(() => {
        setActivePinia(pinia);
        const store2 = pinia._s.get(id2);
        return getters[name2].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id2, setup9, options2, pinia);
  store.$reset = function $reset() {
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign($state, newState);
    });
  };
  return store;
}
const noop$3 = () => {
};
function createSetupStore($id, setup9, options2 = {}, pinia, hot) {
  let scope;
  const buildState2 = options2.state;
  const optionsForPlugin = {
    actions: {},
    ...options2
  };
  const $subscribeOptions = {
    deep: true
    // flush: 'post',
  };
  let isListening;
  let subscriptions = markRaw([]);
  let actionSubscriptions = markRaw([]);
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!buildState2 && !initialState && true) {
    {
      pinia.state.value[$id] = {};
    }
  }
  ref({});
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      innerPatch(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    isListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = noop$3;
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  function wrapAction(name2, action3) {
    return function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      let afterCallback = noop$3;
      let onErrorCallback = noop$3;
      function after(callback) {
        afterCallback = callback;
      }
      function onError(callback) {
        onErrorCallback = callback;
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name: name2,
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = action3.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        if (onErrorCallback(error) !== false) {
          throw error;
        }
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          const newRet2 = afterCallback(value);
          return newRet2 === void 0 ? value : newRet2;
        }).catch((error) => {
          if (onErrorCallback(error) !== false) {
            return Promise.reject(error);
          }
        });
      }
      const newRet = afterCallback(ret);
      return newRet === void 0 ? ret : newRet;
    };
  }
  const partialStore = {
    _p: pinia,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options22 = {}) {
      const _removeSubscription = addSubscription(
        subscriptions,
        callback,
        // @ts-expect-error: until the deprecation is removed
        options22.detached
      );
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state, oldState) => {
        if (isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign({}, $subscribeOptions, options22)));
      const removeSubscription = () => {
        stopWatcher();
        _removeSubscription();
      };
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(assign(
    {},
    partialStore
    // must be added later
    // setupStore
  ));
  pinia._s.set($id, store);
  const setupStore = pinia._e.run(() => {
    scope = effectScope();
    return scope.run(() => setup9());
  });
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed$1(prop) || isReactive(prop)) {
      if (!buildState2) {
        if (initialState) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            innerPatch(prop, initialState[key]);
          }
        }
        {
          pinia.state.value[$id][key] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = wrapAction(key, prop);
      {
        setupStore[key] = actionValue;
      }
      optionsForPlugin.actions[key] = prop;
    } else
      ;
  }
  {
    assign(store, setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign($state, state);
      });
    }
  });
  pinia._p.forEach((extender) => {
    {
      assign(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        // @ts-expect-error
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && buildState2) {
    (options2.hydrate || innerPatch)(store, initialState);
  }
  isListening = true;
  return store;
}
function defineStore(idOrOptions, setup9, setupOptions) {
  let id2;
  let options2;
  const isSetupStore = typeof setup9 === "function";
  if (typeof idOrOptions === "string") {
    id2 = idOrOptions;
    options2 = isSetupStore ? setupOptions : setup9;
  } else {
    options2 = idOrOptions;
    id2 = idOrOptions.id;
  }
  function useStore(pinia, hot) {
    const currentInstance2 = getCurrentInstance();
    pinia = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    pinia || currentInstance2 && inject(piniaSymbol);
    if (pinia)
      setActivePinia(pinia);
    pinia = activePinia;
    if (!pinia._s.has(id2)) {
      if (isSetupStore) {
        createSetupStore(id2, setup9, options2, pinia);
      } else {
        createOptionsStore(id2, options2, pinia);
      }
    }
    const store = pinia._s.get(id2);
    return store;
  }
  useStore.$id = id2;
  return useStore;
}
const useUserProjectStatusStore = defineStore({
  id: "userProjectStatus",
  state() {
    return {
      hasInitiallyLoaded: false,
      utmMedium: "",
      utmContent: void 0,
      isLoginConnectOpen: false,
      cypressFirstOpened: void 0,
      userData: void 0,
      testingType: void 0,
      projectId: void 0,
      user: {
        isLoggedIn: false,
        loginError: false,
        isOrganizationLoaded: false,
        isMemberOfOrganization: false
      },
      project: {
        isProjectConnected: false,
        isConfigLoaded: false,
        hasNoRecordedRuns: false,
        hasNonExampleSpec: false,
        isNotAuthorized: false,
        isNotFound: false,
        isCTConfigured: false,
        hasDetectedCtFramework: false,
        isUsingGit: false
      },
      promptsShown: {},
      bannersState: {},
      _latestBannerShownTimeForTesting: void 0
    };
  },
  actions: {
    setHasInitiallyLoaded() {
      this.hasInitiallyLoaded = true;
    },
    openLoginConnectModal({ utmMedium, utmContent }) {
      this.isLoginConnectOpen = true;
      this.utmMedium = utmMedium;
      this.utmContent = utmContent;
    },
    closeLoginConnectModal() {
      this.isLoginConnectOpen = false;
      this.utmMedium = "";
      this.utmContent = void 0;
    },
    setUserFlag(name2, newVal) {
      this.user[name2] = newVal;
    },
    setProjectFlag(name2, newVal) {
      this.project[name2] = newVal;
    },
    setLoginError(error) {
      this.user.loginError = error;
    },
    setUserData(userData) {
      this.userData = userData;
    },
    setPromptShown(slug, timestamp) {
      this.promptsShown[slug] = timestamp;
    },
    setCypressFirstOpened(timestamp) {
      this.cypressFirstOpened = timestamp;
    },
    setTestingType(testingType) {
      this.testingType = testingType;
    },
    setProjectId(projectId) {
      this.projectId = projectId;
    },
    setBannersState(banners) {
      this.bannersState = banners;
    },
    setLatestBannerShownTime(timestamp) {
      this._latestBannerShownTimeForTesting = timestamp;
    }
  },
  getters: {
    cloudStatus(state) {
      const { user, project } = state;
      switch (true) {
        case !user.isLoggedIn:
          return "isLoggedOut";
        case (user.isLoggedIn && user.isOrganizationLoaded && !user.isMemberOfOrganization):
          return "needsOrgConnect";
        case (user.isLoggedIn && user.isMemberOfOrganization && !project.isProjectConnected && project.isConfigLoaded):
          return "needsProjectConnect";
        case (user.isLoggedIn && user.isMemberOfOrganization && project.isProjectConnected && project.hasNoRecordedRuns && project.hasNonExampleSpec && project.isConfigLoaded):
          return "needsRecordedRun";
        default:
          return "allTasksCompleted";
      }
    },
    projectStatus(state) {
      const { project } = state;
      if (state.testingType === "e2e" && !project.isCTConfigured && project.hasDetectedCtFramework) {
        return "isComponentTestingCandidate";
      }
      return "allTasksCompleted";
    },
    cloudStatusMatches() {
      return (status) => this.cloudStatus === status;
    },
    projectStatusMatches() {
      return (status) => this.projectStatus === status;
    },
    latestBannerShownTime(state) {
      return state._latestBannerShownTimeForTesting;
    }
  }
});
const _hoisted_1$B = {
  key: 0,
  class: "flex gap-[16px]"
};
const _hoisted_2$z = { key: 1 };
const _hoisted_3$s = { key: 2 };
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "Auth",
  props: {
    gql: null,
    showRetry: { type: Boolean },
    showLogout: { type: Boolean },
    utmMedium: null,
    utmContent: null
  },
  emits: ["close", "cancel"],
  setup(__props, { emit: emit3 }) {
    const props = __props;
    const userProjectStatusStore = useUserProjectStatusStore();
    const { t: t2 } = useI18n();
    const isOnline = useOnline();
    gql`
fragment Auth on Query {
  ...SelectCloudProjectModal
  cloudViewer {
    id
    email
    fullName
    firstOrganization: organizations(first: 1) {
      nodes {
        id
      }
    }
  }
  authState {
    browserOpened
    name
    message
  }
  currentProject {
    id
    cloudProject {
      __typename
      ... on CloudProject {
        id
      }
    }
  }
}
`;
    gql`
mutation Auth_Logout {
  logout {
    ...Auth
  }
}
`;
    gql`
mutation Auth_Login ($utmSource: String!, $utmMedium: String!, $utmContent: String) {
  login (utmSource: $utmSource, utmContent: $utmContent, utmMedium: $utmMedium) {
    ...Auth
  }
}
`;
    gql`
mutation Auth_ResetAuthState {
  resetAuthState {
    ...Auth
  }
}
`;
    const login = useMutation(Auth_LoginDocument);
    const logout = useMutation(Auth_LogoutDocument);
    const reset = useMutation(Auth_ResetAuthStateDocument);
    const loginButtonRef = ref(_sfc_main$y);
    const loginInitiated = ref(false);
    onMounted(() => {
      var _a2, _b2;
      (_b2 = (_a2 = loginButtonRef == null ? void 0 : loginButtonRef.value) == null ? void 0 : _a2.$el) == null ? void 0 : _b2.focus();
    });
    onBeforeUnmount(() => {
      if (loginInitiated.value) {
        reset.executeMutation({});
      }
    });
    const showConnectButton = computed(() => {
      return userProjectStatusStore.project.isConfigLoaded && userProjectStatusStore.cloudStatusMatches("needsProjectConnect");
    });
    const cloudViewer = computed(() => {
      return props.gql.cloudViewer;
    });
    const browserOpened = computed(() => {
      return props.gql.authState.browserOpened;
    });
    const loginMutationIsPending = computed(() => {
      return !cloudViewer.value && (loginInitiated.value || browserOpened.value);
    });
    const handleLoginOrContinue = async () => {
      if (userProjectStatusStore.user.isLoggedIn) {
        emit3("close");
        return;
      }
      loginInitiated.value = true;
      login.executeMutation({ utmMedium: props.utmMedium, utmContent: props.utmContent || null, utmSource: getUtmSource() });
    };
    const handleCancel = () => {
      emit3("cancel");
    };
    const handleLogout = () => {
      logout.executeMutation({});
    };
    const handleTryAgain = async () => {
      await reset.executeMutation({});
      login.executeMutation({ utmMedium: props.utmMedium, utmContent: props.utmContent || null, utmSource: getUtmSource() });
    };
    const buttonText = computed(() => {
      const strings = {
        login: t2("topNav.login.actionLogin"),
        connectProject: t2("runs.connect.modal.selectProject.connectProject"),
        continue: t2("topNav.login.actionContinue")
      };
      if (showConnectButton.value) {
        return strings.connectProject;
      }
      if (userProjectStatusStore.user.isLoggedIn) {
        return strings.continue;
      }
      return strings.login;
    });
    const buttonPrefixIcon = computed(() => {
      return showConnectButton.value ? ConnectIcon : void 0;
    });
    return (_ctx, _cache) => {
      const _component_i_cy_action_restart_x16 = RefreshIcon;
      const _component_i_cy_loading_x16 = __unplugin_components_0$6;
      return props.showRetry ? (openBlock(), createElementBlock("div", _hoisted_1$B, [
        createVNode(_sfc_main$y, {
          size: "lg",
          onClick: handleTryAgain
        }, {
          prefix: withCtx(() => [
            createVNode(_component_i_cy_action_restart_x16, { class: "icon-light-white" })
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString$1(unref(t2)("topNav.login.actionTryAgain")), 1)
          ]),
          _: 1
        }),
        createVNode(_sfc_main$y, {
          variant: "outline",
          size: "lg",
          onClick: handleCancel
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString$1(unref(t2)("topNav.login.actionCancel")), 1)
          ]),
          _: 1
        })
      ])) : props.showLogout ? (openBlock(), createElementBlock("div", _hoisted_2$z, [
        createBaseVNode("button", {
          class: "bg-white border-rounded outline-transparent border-gray-100 border w-full py-[8px] text-[14px] text-indigo-500 block whitespace-nowrap hocus:border-gray-200 hover:no-underline",
          onClick: handleLogout
        }, toDisplayString$1(unref(t2)("topNav.login.actionLogout")), 1)
      ])) : (openBlock(), createElementBlock("div", _hoisted_3$s, [
        unref(loginMutationIsPending) ? (openBlock(), createBlock(_sfc_main$y, {
          key: 0,
          size: "lg",
          variant: "pending",
          "aria-live": "polite",
          disabled: true
        }, {
          prefix: withCtx(() => [
            createVNode(_component_i_cy_loading_x16, { class: "animate-spin icon-dark-white icon-light-gray-400" })
          ]),
          default: withCtx(() => [
            createTextVNode(" " + toDisplayString$1(unref(browserOpened) ? unref(t2)("topNav.login.actionWaiting") : unref(t2)("topNav.login.actionOpening")), 1)
          ]),
          _: 1
        })) : (openBlock(), createBlock(_sfc_main$y, {
          key: 1,
          ref_key: "loginButtonRef",
          ref: loginButtonRef,
          size: "lg",
          variant: "primary",
          "aria-live": "polite",
          disabled: !unref(cloudViewer) && !unref(isOnline),
          "prefix-icon": unref(buttonPrefixIcon),
          onClick: handleLoginOrContinue
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString$1(unref(buttonText)), 1)
          ]),
          _: 1
        }, 8, ["disabled", "prefix-icon"]))
      ]));
    };
  }
});
const _hoisted_1$A = {
  style: { "min-width": "48px", "min-height": "48px" },
  width: "48",
  height: "48",
  viewBox: "0 0 48 48",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$y = /* @__PURE__ */ createStaticVNode('<path d="M40 8H8C6.34315 8 5 9.34315 5 11V16H43V11C43 9.34315 41.6569 8 40 8Z" fill="#E1E3ED"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M8 8C6.34315 8 5 9.34315 5 11V16H43V11C43 9.34315 41.6569 8 40 8H8Z" fill="#E1E3ED"></path><path d="M19 30L14 28L9 31V36H38C38.5523 36 39 35.5523 39 35V23L34 24L29 27L24 25L19 30Z" fill="#E1E3ED"></path><path d="M5 16H4C4 16.5523 4.44772 17 5 17V16ZM43 16V17C43.5523 17 44 16.5523 44 16H43ZM19 11C18.4477 11 18 11.4477 18 12C18 12.5523 18.4477 13 19 13V11ZM39 13C39.5523 13 40 12.5523 40 12C40 11.4477 39.5523 11 39 11V13ZM14 28L14.3714 27.0715C14.0812 26.9555 13.7535 26.9817 13.4855 27.1425L14 28ZM19 30L18.6286 30.9285C19 31.077 19.4242 30.99 19.7071 30.7071L19 30ZM24 25L24.3714 24.0715C24 23.923 23.5758 24.01 23.2929 24.2929L24 25ZM29 27L28.6286 27.9285C28.9188 28.0445 29.2465 28.0183 29.5145 27.8575L29 27ZM9 31L8.4855 30.1425C8.1843 30.3232 8 30.6487 8 31H9ZM34 24L33.8039 23.0194C33.6915 23.0419 33.5838 23.0835 33.4855 23.1425L34 24ZM9 36H8C8 36.5523 8.44772 37 9 37V36ZM8 9H40V7H8V9ZM42 11V37H44V11H42ZM6 37V11H4V37H6ZM5 17H43V15H5V17ZM19 13H39V11H19V13ZM8 39C6.89543 39 6 38.1046 6 37H4C4 39.2091 5.79086 41 8 41V39ZM42 37C42 38.1046 41.1046 39 40 39V41C42.2091 41 44 39.2091 44 37H42ZM40 9C41.1046 9 42 9.89543 42 11H44C44 8.79086 42.2091 7 40 7V9ZM8 7C5.79086 7 4 8.79086 4 11H6C6 9.89543 6.89543 9 8 9V7ZM4 11V16H6V11H4ZM44 16V11H42V16H44ZM38 19H10V21H38V19ZM13.6286 28.9285L18.6286 30.9285L19.3714 29.0715L14.3714 27.0715L13.6286 28.9285ZM19.7071 30.7071L24.7071 25.7071L23.2929 24.2929L18.2929 29.2929L19.7071 30.7071ZM23.6286 25.9285L28.6286 27.9285L29.3714 26.0715L24.3714 24.0715L23.6286 25.9285ZM40 35V23H38V35H40ZM40 23V21H38V23H40ZM40 39H24V41H40V39ZM24 39H16V41H24V39ZM16 39H8V41H16V39ZM9.5145 31.8575L14.5145 28.8575L13.4855 27.1425L8.4855 30.1425L9.5145 31.8575ZM29.5145 27.8575L34.5145 24.8575L33.4855 23.1425L28.4855 26.1425L29.5145 27.8575ZM34.1961 24.9806L39.1961 23.9806L38.8039 22.0194L33.8039 23.0194L34.1961 24.9806ZM38 35H9V37H38V35ZM10 36V21H8V36H10ZM8 31V36H10V31H8ZM38 21H40C40 19.8954 39.1046 19 38 19V21ZM38 35V37C39.1046 37 40 36.1046 40 35H38ZM10 19C8.89543 19 8 19.8954 8 21H10H10V19Z" fill="#9095AD"></path><path d="M10 12C10 12.5523 9.55228 13 9 13C8.44772 13 8 12.5523 8 12C8 11.4477 8.44772 11 9 11C9.55228 11 10 11.4477 10 12Z" fill="#9095AD"></path><path d="M13 12C13 12.5523 12.5523 13 12 13C11.4477 13 11 12.5523 11 12C11 11.4477 11.4477 11 12 11C12.5523 11 13 11.4477 13 12Z" fill="#9095AD"></path><path d="M16 12C16 12.5523 15.5523 13 15 13C14.4477 13 14 12.5523 14 12C14 11.4477 14.4477 11 15 11C15.5523 11 16 11.4477 16 12Z" fill="#9095AD"></path><path d="M35.2426 41.2426C32.8995 43.5858 29.1005 43.5858 26.7574 41.2426C24.4142 38.8995 24.4142 35.1005 26.7574 32.7574C29.1005 30.4142 32.8995 30.4142 35.2426 32.7574C37.5858 35.1005 37.5858 38.8995 35.2426 41.2426Z" fill="#F59AA9"></path><path d="M32.5 35.5L29.5 38.5M32.5 38.5L29.5 35.5M35.2426 41.2426C32.8995 43.5858 29.1005 43.5858 26.7574 41.2426C24.4142 38.8995 24.4142 35.1005 26.7574 32.7574C29.1005 30.4142 32.8995 30.4142 35.2426 32.7574C37.5858 35.1005 37.5858 38.8995 35.2426 41.2426Z" stroke="#C62B49" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>', 9);
const _hoisted_11$1 = [
  _hoisted_2$y
];
function render$p(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$A, _hoisted_11$1);
}
const __unplugin_components_0$5 = { name: "cy-no-internet_x48", render: render$p };
const _hoisted_1$z = { class: "flex flex-col h-full text-center justify-center items-center" };
const _hoisted_2$x = { class: "mt-[24px] mb-[4px] text-gray-900 text-[18px] leading-[24px] w-[640px]" };
const _hoisted_3$r = { class: "font-normal mt-[8px] mb-[24px] text-gray-600 text-[16px] leading-[24px] w-[672px]" };
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "NoInternetConnection",
  setup(__props) {
    const { t: t2 } = useI18n();
    return (_ctx, _cache) => {
      const _component_i_cy_no_internet_x48 = __unplugin_components_0$5;
      return openBlock(), createElementBlock("div", _hoisted_1$z, [
        createVNode(_component_i_cy_no_internet_x48, {
          "data-cy": "no-connection-icon",
          "aria-hidden": "",
          class: "h-[48px] w-[48px] icon-dark-gray-500 icon-light-gray-100 icon-dark-secondary-jade-400 icon-light-secondary-jade-200"
        }),
        createBaseVNode("h2", _hoisted_2$x, toDisplayString$1(unref(t2)("launchpadErrors.noInternet.header")), 1),
        createBaseVNode("p", _hoisted_3$r, [
          renderSlot(_ctx.$slots, "default")
        ])
      ]);
    };
  }
});
const _hoisted_1$y = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$w = /* @__PURE__ */ createBaseVNode("path", {
  d: "M6.82489 6.84375C7.20878 7.37466 6.80705 7.64512 6.2982 7.98769C5.83364 8.30045 5.27979 8.67332 5.15302 9.35938C5.00805 10.1439 5.28125 10.9219 6.32812 11.4375C6.56597 11.5546 6.50949 12.7308 6.45832 13.7964C6.44049 14.1678 6.4233 14.5258 6.41944 14.8208C6.48106 14.835 6.54298 14.8484 6.60521 14.861C8.64877 14.0046 10.0688 12.7787 10.7969 11.1406C11.2188 9.98438 10.3906 8.64062 9.48438 8.1875C9.03125 6.25 11.1094 6.70312 11.6719 6.84375C11.8387 6.84375 11.7942 6.65067 11.7265 6.35632C11.6166 5.87867 11.4452 5.13434 12.0156 4.51562C12.4404 4.05487 13.0142 3.5235 13.2197 3.33573C11.9379 1.90225 10.0743 1 8 1C7.18411 1 6.40082 1.13959 5.67271 1.39618C4.4022 4.78576 5.05965 5.34405 6.57478 6.63067C6.65575 6.69944 6.73918 6.77028 6.82489 6.84375Z",
  fill: "#D0D2E0",
  class: "icon-light"
}, null, -1);
const _hoisted_3$q = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M6.60521 14.861C6.54298 14.8484 6.48106 14.835 6.41944 14.8208C6.4233 14.5258 6.44049 14.1678 6.45832 13.7964C6.50949 12.7308 6.56597 11.5546 6.32812 11.4375C5.28125 10.9219 5.00805 10.1439 5.15302 9.35938C5.27979 8.67332 5.83364 8.30045 6.2982 7.98769C6.80705 7.64512 7.20878 7.37466 6.82489 6.84375C6.73918 6.77028 6.65575 6.69944 6.57478 6.63067C5.05965 5.34405 4.4022 4.78576 5.67271 1.39618C6.40082 1.13959 7.18411 1 8 1C10.0743 1 11.9379 1.90225 13.2197 3.33573C13.0142 3.5235 12.4404 4.05487 12.0156 4.51562C11.4452 5.13434 11.6166 5.87867 11.7265 6.35632C11.7942 6.65067 11.8387 6.84375 11.6719 6.84375C11.1094 6.70312 9.03125 6.25 9.48438 8.1875C10.3906 8.64062 11.2188 9.98438 10.7969 11.1406C10.0688 12.7787 8.64877 14.0046 6.60521 14.861Z",
  fill: "#D0D2E0",
  class: "icon-light"
}, null, -1);
const _hoisted_4$f = /* @__PURE__ */ createBaseVNode("path", {
  d: "M5.67271 1.39618C2.95077 2.35543 1 4.9499 1 8C1 11.3224 3.31469 14.1043 6.41944 14.8208M5.67271 1.39618C6.40082 1.13959 7.18411 1 8 1C10.0743 1 11.9379 1.90225 13.2197 3.33573M5.67271 1.39618C4.4022 4.78576 5.05965 5.34405 6.57478 6.63067C6.65575 6.69944 6.73918 6.77028 6.82489 6.84375C7.20878 7.37466 6.80705 7.64512 6.2982 7.98769C5.83364 8.30045 5.27979 8.67332 5.15302 9.35938C5.00805 10.1439 5.28125 10.9219 6.32812 11.4375C6.56597 11.5546 6.50949 12.7308 6.45832 13.7964C6.44049 14.1678 6.4233 14.5258 6.41944 14.8208M13.2197 3.33573C13.0142 3.5235 12.4404 4.05487 12.0156 4.51562C11.4452 5.13434 11.6166 5.87867 11.7265 6.35632C11.7942 6.65067 11.8387 6.84375 11.6719 6.84375C11.1094 6.70312 9.03125 6.25 9.48438 8.1875C10.3906 8.64062 11.2188 9.98438 10.7969 11.1406C10.0688 12.7787 8.64877 14.0046 6.60521 14.861M13.2197 3.33573C14.3269 4.57387 15 6.20833 15 8C15 11.866 11.866 15 8 15C7.52239 15 7.05595 14.9522 6.60521 14.861M6.60521 14.861C6.54298 14.8484 6.48106 14.835 6.41944 14.8208",
  stroke: "#1B1E2E",
  "stroke-width": "2",
  class: "icon-dark"
}, null, -1);
const _hoisted_5$9 = [
  _hoisted_2$w,
  _hoisted_3$q,
  _hoisted_4$f
];
function render$o(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$y, _hoisted_5$9);
}
const __unplugin_components_0$4 = { name: "cy-globe_x16", render: render$o };
const _hoisted_1$x = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$v = /* @__PURE__ */ createBaseVNode("path", {
  class: "icon-dark",
  d: "M19.5 18.5854C18.9174 18.7913 18.5 19.3469 18.5 20V29.5C18.5 30.3284 19.1716 31 20 31H28C28.8284 31 29.5 30.3284 29.5 29.5V20C29.5 19.3469 29.0826 18.7913 28.5 18.5854M23 20H25C25.5523 20 26 19.5523 26 19V18C26 17.4477 25.5523 17 25 17H23C22.4477 17 22 17.4477 22 18V19C22 19.5523 22.4477 20 23 20Z",
  stroke: "#1B1E2E",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  style: { "transform": "translate(-16px, -16px)" }
}, null, -1);
const _hoisted_3$p = [
  _hoisted_2$v
];
function render$n(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$x, _hoisted_3$p);
}
const __unplugin_components_2$1 = { name: "cy-copy-clipboard_x16", render: render$n };
gql`
mutation Clipboard_CopyToClipboard($text: String!) {
  copyTextToClipboard(text: $text)
}
`;
function useClipboard(options2 = {}) {
  const copyMutation = useMutation(Clipboard_CopyToClipboardDocument);
  const copied = ref(false);
  let timer;
  const copy = async (text) => {
    const { data } = await copyMutation.executeMutation({ text });
    copied.value = (data == null ? void 0 : data.copyTextToClipboard) ?? false;
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      copied.value = false;
      timer = void 0;
    }, options2.copiedDuring || 2e3);
  };
  return { copy, copied };
}
const _export_sfc$1 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$v = {};
function _sfc_render$4(_ctx, _cache) {
  return openBlock(), createBlock(Transition, {
    "enter-active-class": "transition duration-200 ease-out",
    "enter-from-class": "translate-y-1 opacity-0",
    "enter-to-class": "translate-y-0 opacity-100",
    "leave-active-class": "transition duration-150 ease-in",
    "leave-from-class": "translate-y-0 opacity-100",
    "leave-to-class": "translate-y-1 opacity-0"
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  });
}
const TransitionQuickFade = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$4]]);
const _hoisted_1$w = { key: 0 };
const _hoisted_2$u = { key: 1 };
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "CopyButton",
  props: {
    text: null,
    noIcon: { type: Boolean, default: false },
    variant: { default: "tertiary" },
    size: { default: "md" }
  },
  setup(__props) {
    const props = __props;
    const { copy, copied } = useClipboard({ copiedDuring: 2e3 });
    const copyToClipboard = () => {
      if (props.text) {
        copy(props.text);
      }
    };
    const { t: t2 } = useI18n();
    return (_ctx, _cache) => {
      const _component_i_cy_copy_clipboard_x16 = __unplugin_components_2$1;
      return openBlock(), createBlock(_sfc_main$y, {
        size: __props.size,
        variant: __props.variant,
        "data-cy": "copy-button",
        onClick: copyToClipboard
      }, createSlots({
        default: withCtx(() => [
          createVNode(TransitionQuickFade, { mode: "out-in" }, {
            default: withCtx(() => [
              !unref(copied) ? (openBlock(), createElementBlock("span", _hoisted_1$w, toDisplayString$1(unref(t2)("clipboard.copy")), 1)) : (openBlock(), createElementBlock("span", _hoisted_2$u, toDisplayString$1(unref(t2)("clipboard.copied")), 1))
            ]),
            _: 1
          })
        ]),
        _: 2
      }, [
        !__props.noIcon ? {
          name: "prefix",
          fn: withCtx(() => [
            createVNode(_component_i_cy_copy_clipboard_x16, {
              class: normalizeClass(["h-[16px] w-[16px]", {
                "icon-dark-indigo-500": __props.variant === "tertiary",
                "icon-dark-gray-500": __props.variant === "outline"
              }])
            }, null, 8, ["class"])
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["size", "variant"]);
    };
  }
});
const _hoisted_1$v = { class: "border rounded flex font-light bg-gray-50 border-gray-100 px-[16px] text-gray-600 text-[14px] leading-[40px] relative items-center whitespace-nowrap overflow-hidden" };
const _hoisted_2$t = { class: "font-sans opacity-gradient p-[4px] pl-[32px] top-0 right-0 bottom-0 absolute" };
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "CopyText",
  props: {
    text: null
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      const _component_i_cy_globe_x16 = __unplugin_components_0$4;
      return openBlock(), createElementBlock("code", _hoisted_1$v, [
        createVNode(_component_i_cy_globe_x16, { class: "shrink-0 h-[16px] mr-[8px] w-[16px] icon-dark-gray-500 icon-light-gray-100" }),
        createTextVNode(" " + toDisplayString$1(props.text) + " ", 1),
        createBaseVNode("div", _hoisted_2$t, [
          createVNode(_sfc_main$u, {
            class: "bg-indigo-100",
            text: __props.text
          }, null, 8, ["text"])
        ])
      ]);
    };
  }
});
const CopyText = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["__scopeId", "data-v-18d56591"]]);
const _hoisted_1$u = {
  style: { "min-width": "12px", "min-height": "12px" },
  width: "12",
  height: "12",
  viewBox: "0 0 12 12",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$s = /* @__PURE__ */ createBaseVNode("path", {
  d: "M1 11L11 1M1 1L11 11",
  stroke: "#1B1E2E",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  class: "icon-dark"
}, null, -1);
const _hoisted_3$o = [
  _hoisted_2$s
];
function render$m(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$u, _hoisted_3$o);
}
const __unplugin_components_2 = { name: "cy-delete_x12", render: render$m };
const _hoisted_1$t = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$r = /* @__PURE__ */ createBaseVNode("path", {
  d: "M13.6569 13.6569C10.5327 16.781 5.46734 16.781 2.34315 13.6569C-0.781048 10.5327 -0.781048 5.46734 2.34315 2.34315C5.46734 -0.781048 10.5327 -0.781048 13.6569 2.34315C16.781 5.46734 16.781 10.5327 13.6569 13.6569Z",
  fill: "currentColor",
  class: "icon-light"
}, null, -1);
const _hoisted_3$n = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  style: { "transform": "translate(5px, 2.8px)" },
  "clip-rule": "evenodd",
  d: "M1.84477 2.53525L1.84393 2.53644C1.55247 2.99535 0.945841 3.13804 0.479622 2.85394C0.00800347 2.56655 -0.141341 1.95125 0.146051 1.47963L0.999992 2C0.146051 1.47963 0.146312 1.4792 0.146575 1.47877L0.147114 1.47789L0.148242 1.47605L0.150693 1.47208L0.15638 1.463L0.170928 1.44042C0.182042 1.42347 0.196048 1.40275 0.213011 1.37881C0.246877 1.33103 0.292902 1.2699 0.351663 1.20004C0.468602 1.06102 0.639738 0.88294 0.870176 0.706317C1.33799 0.347756 2.04656 0 2.99999 0C4.09902 0 4.91097 0.431523 5.41403 1.1133C5.87907 1.74355 5.99999 2.47764 5.99999 3C5.99999 3.62988 5.82686 4.14716 5.53741 4.57449C5.26535 4.97613 4.9179 5.25422 4.6658 5.44689C4.05784 5.9115 4.01123 5.9631 3.99314 6.11684C3.92861 6.66534 3.43165 7.05768 2.88315 6.99315C2.33465 6.92862 1.94231 6.43166 2.00684 5.88316C2.1317 4.8219 2.92228 4.24504 3.33392 3.94468C3.3778 3.91266 3.41737 3.88379 3.45138 3.8578C3.67974 3.68328 3.80299 3.56879 3.88152 3.45286C3.94266 3.3626 3.99999 3.23731 3.99999 3C3.99999 2.74111 3.93342 2.4752 3.8047 2.30076C3.71401 2.17785 3.52597 2 2.99999 2C2.5628 2 2.27137 2.15224 2.08684 2.29368C1.99111 2.36706 1.92298 2.43898 1.88221 2.48746C1.86211 2.51135 1.84967 2.52835 1.84477 2.53525ZM2.99999 10C3.55228 10 3.99999 9.55229 3.99999 9C3.99999 8.44771 3.55228 8 2.99999 8C2.44771 8 1.99999 8.44771 1.99999 9C1.99999 9.55229 2.44771 10 2.99999 10Z",
  fill: "white",
  class: "icon-dark"
}, null, -1);
const _hoisted_4$e = [
  _hoisted_2$r,
  _hoisted_3$n
];
function render$l(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$t, _hoisted_4$e);
}
const __unplugin_components_0$3 = { name: "cy-circle-bg-question-mark_x16", render: render$l };
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n = Object.prototype.toString.call(o2).slice(8, -1);
  if (n === "Object" && o2.constructor)
    n = o2.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o2);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i = 0;
      return function() {
        if (i >= o2.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o2[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o2[Symbol.iterator]();
  return it.next.bind(it);
}
function match(value, lookup) {
  if (value in lookup) {
    var returnValue = lookup[value];
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return typeof returnValue === "function" ? returnValue.apply(void 0, args) : returnValue;
  }
  var error = new Error('Tried to handle "' + value + '" but there is no handler defined. Only defined handlers are: ' + Object.keys(lookup).map(function(key) {
    return '"' + key + '"';
  }).join(", ") + ".");
  if (Error.captureStackTrace)
    Error.captureStackTrace(error, match);
  throw error;
}
var Features;
(function(Features2) {
  Features2[Features2["None"] = 0] = "None";
  Features2[Features2["RenderStrategy"] = 1] = "RenderStrategy";
  Features2[Features2["Static"] = 2] = "Static";
})(Features || (Features = {}));
var RenderStrategy;
(function(RenderStrategy2) {
  RenderStrategy2[RenderStrategy2["Unmount"] = 0] = "Unmount";
  RenderStrategy2[RenderStrategy2["Hidden"] = 1] = "Hidden";
})(RenderStrategy || (RenderStrategy = {}));
function render$k(_ref) {
  var _ref$visible = _ref.visible, visible = _ref$visible === void 0 ? true : _ref$visible, _ref$features = _ref.features, features = _ref$features === void 0 ? Features.None : _ref$features, main2 = _objectWithoutPropertiesLoose(_ref, ["visible", "features"]);
  if (visible)
    return _render(main2);
  if (features & Features.Static) {
    if (main2.props["static"])
      return _render(main2);
  }
  if (features & Features.RenderStrategy) {
    var _main$props$unmount, _match;
    var strategy = ((_main$props$unmount = main2.props.unmount) != null ? _main$props$unmount : true) ? RenderStrategy.Unmount : RenderStrategy.Hidden;
    return match(strategy, (_match = {}, _match[RenderStrategy.Unmount] = function() {
      return null;
    }, _match[RenderStrategy.Hidden] = function() {
      return _render(_extends$1({}, main2, {
        props: _extends$1({}, main2.props, {
          hidden: true,
          style: {
            display: "none"
          }
        })
      }));
    }, _match));
  }
  return _render(main2);
}
function _render(_ref2) {
  var props = _ref2.props, attrs = _ref2.attrs, slots = _ref2.slots, slot = _ref2.slot, name2 = _ref2.name;
  var _omit = omit(props, ["unmount", "static"]), as = _omit.as, passThroughProps = _objectWithoutPropertiesLoose(_omit, ["as"]);
  var children = slots["default"] == null ? void 0 : slots["default"](slot);
  if (as === "template") {
    if (Object.keys(passThroughProps).length > 0 || Object.keys(attrs).length > 0) {
      var _ref3 = children != null ? children : [], firstChild = _ref3[0], other = _ref3.slice(1);
      if (!isValidElement(firstChild) || other.length > 0) {
        throw new Error(['Passing props on "template"!', "", "The current component <" + name2 + ' /> is rendering a "template".', "However we need to passthrough the following props:", Object.keys(passThroughProps).concat(Object.keys(attrs)).map(function(line) {
          return "  - " + line;
        }).join("\n"), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map(function(line) {
          return "  - " + line;
        }).join("\n")].join("\n"));
      }
      return cloneVNode(firstChild, passThroughProps);
    }
    if (Array.isArray(children) && children.length === 1) {
      return children[0];
    }
    return children;
  }
  return h$1(as, passThroughProps, children);
}
function omit(object2, keysToOmit) {
  if (keysToOmit === void 0) {
    keysToOmit = [];
  }
  var clone2 = Object.assign({}, object2);
  for (var _iterator = _createForOfIteratorHelperLoose(keysToOmit), _step; !(_step = _iterator()).done; ) {
    var key = _step.value;
    if (key in clone2)
      delete clone2[key];
  }
  return clone2;
}
function isValidElement(input) {
  if (input == null)
    return false;
  if (typeof input.type === "string")
    return true;
  if (typeof input.type === "object")
    return true;
  if (typeof input.type === "function")
    return true;
  return false;
}
var Keys;
(function(Keys2) {
  Keys2["Space"] = " ";
  Keys2["Enter"] = "Enter";
  Keys2["Escape"] = "Escape";
  Keys2["Backspace"] = "Backspace";
  Keys2["ArrowLeft"] = "ArrowLeft";
  Keys2["ArrowUp"] = "ArrowUp";
  Keys2["ArrowRight"] = "ArrowRight";
  Keys2["ArrowDown"] = "ArrowDown";
  Keys2["Home"] = "Home";
  Keys2["End"] = "End";
  Keys2["PageUp"] = "PageUp";
  Keys2["PageDown"] = "PageDown";
  Keys2["Tab"] = "Tab";
})(Keys || (Keys = {}));
var id = 0;
function generateId() {
  return ++id;
}
function useId() {
  return generateId();
}
var focusableSelector = /* @__PURE__ */ ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(function(selector) {
  return selector + ":not([tabindex='-1'])";
}).join(",");
var Focus;
(function(Focus2) {
  Focus2[Focus2["First"] = 1] = "First";
  Focus2[Focus2["Previous"] = 2] = "Previous";
  Focus2[Focus2["Next"] = 4] = "Next";
  Focus2[Focus2["Last"] = 8] = "Last";
  Focus2[Focus2["WrapAround"] = 16] = "WrapAround";
  Focus2[Focus2["NoScroll"] = 32] = "NoScroll";
})(Focus || (Focus = {}));
var FocusResult;
(function(FocusResult2) {
  FocusResult2[FocusResult2["Error"] = 0] = "Error";
  FocusResult2[FocusResult2["Overflow"] = 1] = "Overflow";
  FocusResult2[FocusResult2["Success"] = 2] = "Success";
  FocusResult2[FocusResult2["Underflow"] = 3] = "Underflow";
})(FocusResult || (FocusResult = {}));
var Direction;
(function(Direction2) {
  Direction2[Direction2["Previous"] = -1] = "Previous";
  Direction2[Direction2["Next"] = 1] = "Next";
})(Direction || (Direction = {}));
function getFocusableElements(container) {
  if (container === void 0) {
    container = document.body;
  }
  if (container == null)
    return [];
  return Array.from(container.querySelectorAll(focusableSelector));
}
var FocusableMode;
(function(FocusableMode2) {
  FocusableMode2[FocusableMode2["Strict"] = 0] = "Strict";
  FocusableMode2[FocusableMode2["Loose"] = 1] = "Loose";
})(FocusableMode || (FocusableMode = {}));
function isFocusableElement(element, mode) {
  var _match;
  if (mode === void 0) {
    mode = FocusableMode.Strict;
  }
  if (element === document.body)
    return false;
  return match(mode, (_match = {}, _match[FocusableMode.Strict] = function() {
    return element.matches(focusableSelector);
  }, _match[FocusableMode.Loose] = function() {
    var next = element;
    while (next !== null) {
      if (next.matches(focusableSelector))
        return true;
      next = next.parentElement;
    }
    return false;
  }, _match));
}
function focusElement(element) {
  element == null ? void 0 : element.focus({
    preventScroll: true
  });
}
function focusIn(container, focus) {
  var elements = Array.isArray(container) ? container : getFocusableElements(container);
  var active = document.activeElement;
  var direction = function() {
    if (focus & (Focus.First | Focus.Next))
      return Direction.Next;
    if (focus & (Focus.Previous | Focus.Last))
      return Direction.Previous;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  }();
  var startIndex = function() {
    if (focus & Focus.First)
      return 0;
    if (focus & Focus.Previous)
      return Math.max(0, elements.indexOf(active)) - 1;
    if (focus & Focus.Next)
      return Math.max(0, elements.indexOf(active)) + 1;
    if (focus & Focus.Last)
      return elements.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  }();
  var focusOptions = focus & Focus.NoScroll ? {
    preventScroll: true
  } : {};
  var offset2 = 0;
  var total = elements.length;
  var next = void 0;
  do {
    var _next;
    if (offset2 >= total || offset2 + total <= 0)
      return FocusResult.Error;
    var nextIdx = startIndex + offset2;
    if (focus & Focus.WrapAround) {
      nextIdx = (nextIdx + total) % total;
    } else {
      if (nextIdx < 0)
        return FocusResult.Underflow;
      if (nextIdx >= total)
        return FocusResult.Overflow;
    }
    next = elements[nextIdx];
    (_next = next) == null ? void 0 : _next.focus(focusOptions);
    offset2 += direction;
  } while (next !== document.activeElement);
  if (!next.hasAttribute("tabindex"))
    next.setAttribute("tabindex", "0");
  return FocusResult.Success;
}
function useWindowEvent(type2, listener, options2) {
  window.addEventListener(type2, listener, options2);
  onUnmounted(function() {
    return window.removeEventListener(type2, listener, options2);
  });
}
function contains$2(containers, element) {
  for (var _iterator = _createForOfIteratorHelperLoose(containers), _step; !(_step = _iterator()).done; ) {
    var container = _step.value;
    if (container.contains(element))
      return true;
  }
  return false;
}
function useFocusTrap(containers, enabled, options2) {
  if (enabled === void 0) {
    enabled = ref(true);
  }
  if (options2 === void 0) {
    options2 = ref({});
  }
  var restoreElement = ref(typeof window !== "undefined" ? document.activeElement : null);
  var previousActiveElement = ref(null);
  function handleFocus() {
    if (!enabled.value)
      return;
    if (containers.value.size !== 1)
      return;
    var initialFocus = options2.value.initialFocus;
    var activeElement = document.activeElement;
    if (initialFocus) {
      if (initialFocus === activeElement) {
        return;
      }
    } else if (contains$2(containers.value, activeElement)) {
      return;
    }
    restoreElement.value = activeElement;
    if (initialFocus) {
      focusElement(initialFocus);
    } else {
      var couldFocus = false;
      for (var _iterator = _createForOfIteratorHelperLoose(containers.value), _step; !(_step = _iterator()).done; ) {
        var container = _step.value;
        var result = focusIn(container, Focus.First);
        if (result === FocusResult.Success) {
          couldFocus = true;
          break;
        }
      }
      if (!couldFocus)
        throw new Error("There are no focusable elements inside the <FocusTrap />");
    }
    previousActiveElement.value = document.activeElement;
  }
  function restore2() {
    focusElement(restoreElement.value);
    restoreElement.value = null;
    previousActiveElement.value = null;
  }
  watchEffect(handleFocus);
  onUpdated(function() {
    enabled.value ? handleFocus() : restore2();
  });
  onUnmounted(restore2);
  useWindowEvent("keydown", function(event) {
    if (!enabled.value)
      return;
    if (event.key !== Keys.Tab)
      return;
    if (!document.activeElement)
      return;
    if (containers.value.size !== 1)
      return;
    event.preventDefault();
    for (var _iterator2 = _createForOfIteratorHelperLoose(containers.value), _step2; !(_step2 = _iterator2()).done; ) {
      var element = _step2.value;
      var result = focusIn(element, (event.shiftKey ? Focus.Previous : Focus.Next) | Focus.WrapAround);
      if (result === FocusResult.Success) {
        previousActiveElement.value = document.activeElement;
        break;
      }
    }
  });
  useWindowEvent("focus", function(event) {
    if (!enabled.value)
      return;
    if (containers.value.size !== 1)
      return;
    var previous = previousActiveElement.value;
    if (!previous)
      return;
    var toElement = event.target;
    if (toElement && toElement instanceof HTMLElement) {
      if (!contains$2(containers.value, toElement)) {
        event.preventDefault();
        event.stopPropagation();
        focusElement(previous);
      } else {
        previousActiveElement.value = toElement;
        focusElement(toElement);
      }
    } else {
      focusElement(previousActiveElement.value);
    }
  }, true);
}
var CHILDREN_SELECTOR = "body > *";
var interactables = /* @__PURE__ */ new Set();
var originals = /* @__PURE__ */ new Map();
function inert(element) {
  element.setAttribute("aria-hidden", "true");
  element.inert = true;
}
function restore(element) {
  var original = originals.get(element);
  if (!original)
    return;
  if (original["aria-hidden"] === null)
    element.removeAttribute("aria-hidden");
  else
    element.setAttribute("aria-hidden", original["aria-hidden"]);
  element.inert = original.inert;
}
function useInertOthers(container, enabled) {
  if (enabled === void 0) {
    enabled = ref(true);
  }
  watchEffect(function(onInvalidate) {
    if (!enabled.value)
      return;
    if (!container.value)
      return;
    var element = container.value;
    interactables.add(element);
    for (var _iterator = _createForOfIteratorHelperLoose(originals.keys()), _step; !(_step = _iterator()).done; ) {
      var original = _step.value;
      if (original.contains(element)) {
        restore(original);
        originals["delete"](original);
      }
    }
    document.querySelectorAll(CHILDREN_SELECTOR).forEach(function(child) {
      if (!(child instanceof HTMLElement))
        return;
      for (var _iterator2 = _createForOfIteratorHelperLoose(interactables), _step2; !(_step2 = _iterator2()).done; ) {
        var interactable = _step2.value;
        if (child.contains(interactable))
          return;
      }
      if (interactables.size === 1) {
        originals.set(child, {
          "aria-hidden": child.getAttribute("aria-hidden"),
          // @ts-expect-error `inert` does not exist on HTMLElement (yet!)
          inert: child.inert
        });
        inert(child);
      }
    });
    onInvalidate(function() {
      interactables["delete"](element);
      if (interactables.size > 0) {
        document.querySelectorAll(CHILDREN_SELECTOR).forEach(function(child) {
          if (!(child instanceof HTMLElement))
            return;
          if (originals.has(child))
            return;
          for (var _iterator3 = _createForOfIteratorHelperLoose(interactables), _step3; !(_step3 = _iterator3()).done; ) {
            var interactable = _step3.value;
            if (child.contains(interactable))
              return;
          }
          originals.set(child, {
            "aria-hidden": child.getAttribute("aria-hidden"),
            // @ts-expect-error `inert` does not exist on HTMLElement (yet!)
            inert: child.inert
          });
          inert(child);
        });
      } else {
        for (var _iterator4 = _createForOfIteratorHelperLoose(originals.keys()), _step4; !(_step4 = _iterator4()).done; ) {
          var _element = _step4.value;
          restore(_element);
          originals["delete"](_element);
        }
      }
    });
  });
}
var StackContext = /* @__PURE__ */ Symbol("StackContext");
var StackMessage;
(function(StackMessage2) {
  StackMessage2[StackMessage2["AddElement"] = 0] = "AddElement";
  StackMessage2[StackMessage2["RemoveElement"] = 1] = "RemoveElement";
})(StackMessage || (StackMessage = {}));
function useStackContext() {
  return inject(StackContext, function() {
  });
}
function useElemenStack(element) {
  var notify = useStackContext();
  watchEffect(function(onInvalidate) {
    var domElement = element == null ? void 0 : element.value;
    if (!domElement)
      return;
    notify(StackMessage.AddElement, domElement);
    onInvalidate(function() {
      return notify(StackMessage.RemoveElement, domElement);
    });
  });
}
function useStackProvider(onUpdate) {
  var parentUpdate = useStackContext();
  function notify() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    onUpdate == null ? void 0 : onUpdate.apply(void 0, args);
    parentUpdate.apply(void 0, args);
  }
  provide(StackContext, notify);
}
var ForcePortalRootContext = /* @__PURE__ */ Symbol("ForcePortalRootContext");
function usePortalRoot() {
  return inject(ForcePortalRootContext, false);
}
var ForcePortalRoot = /* @__PURE__ */ defineComponent({
  name: "ForcePortalRoot",
  props: {
    as: {
      type: [Object, String],
      "default": "template"
    },
    force: {
      type: Boolean,
      "default": false
    }
  },
  setup: function setup(props, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    provide(ForcePortalRootContext, props.force);
    return function() {
      var passThroughProps = _objectWithoutPropertiesLoose(props, ["force"]);
      return render$k({
        props: passThroughProps,
        slot: {},
        slots,
        attrs,
        name: "ForcePortalRoot"
      });
    };
  }
});
function getPortalRoot() {
  var existingRoot = document.getElementById("headlessui-portal-root");
  if (existingRoot)
    return existingRoot;
  var root = document.createElement("div");
  root.setAttribute("id", "headlessui-portal-root");
  return document.body.appendChild(root);
}
var Portal = /* @__PURE__ */ defineComponent({
  name: "Portal",
  props: {
    as: {
      type: [Object, String],
      "default": "div"
    }
  },
  setup: function setup2(props, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var forcePortalRoot = usePortalRoot();
    var groupContext = inject(PortalGroupContext, null);
    var myTarget = ref(forcePortalRoot === true ? getPortalRoot() : groupContext === null ? getPortalRoot() : groupContext.resolveTarget());
    watchEffect(function() {
      if (forcePortalRoot)
        return;
      if (groupContext === null)
        return;
      myTarget.value = groupContext.resolveTarget();
    });
    var element = ref(null);
    useElemenStack(element);
    onUnmounted(function() {
      var root = document.getElementById("headlessui-portal-root");
      if (!root)
        return;
      if (myTarget.value !== root)
        return;
      if (myTarget.value.children.length <= 0) {
        var _myTarget$value$paren;
        (_myTarget$value$paren = myTarget.value.parentElement) == null ? void 0 : _myTarget$value$paren.removeChild(myTarget.value);
      }
    });
    useStackProvider();
    return function() {
      if (myTarget.value === null)
        return null;
      var propsWeControl = {
        ref: element
      };
      return h$1(
        // @ts-expect-error Children can be an object, but TypeScript is not happy
        // with it. Once this is fixed upstream we can remove this assertion.
        Teleport,
        {
          to: myTarget.value
        },
        render$k({
          props: _extends$1({}, props, propsWeControl),
          slot: {},
          attrs,
          slots,
          name: "Portal"
        })
      );
    };
  }
});
var PortalGroupContext = /* @__PURE__ */ Symbol("PortalGroupContext");
var PortalGroup = /* @__PURE__ */ defineComponent({
  name: "PortalGroup",
  props: {
    as: {
      type: [Object, String],
      "default": "template"
    },
    target: {
      type: Object,
      "default": null
    }
  },
  setup: function setup3(props, _ref2) {
    var attrs = _ref2.attrs, slots = _ref2.slots;
    var api = reactive({
      resolveTarget: function resolveTarget2() {
        return props.target;
      }
    });
    provide(PortalGroupContext, api);
    return function() {
      var passThroughProps = _objectWithoutPropertiesLoose(props, ["target"]);
      return render$k({
        props: passThroughProps,
        slot: {},
        attrs,
        slots,
        name: "PortalGroup"
      });
    };
  }
});
var DescriptionContext = /* @__PURE__ */ Symbol("DescriptionContext");
function useDescriptionContext() {
  var context2 = inject(DescriptionContext, null);
  if (context2 === null) {
    throw new Error("Missing parent");
  }
  return context2;
}
function useDescriptions(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$slot = _ref.slot, slot = _ref$slot === void 0 ? ref({}) : _ref$slot, _ref$name = _ref.name, name2 = _ref$name === void 0 ? "Description" : _ref$name, _ref$props = _ref.props, props = _ref$props === void 0 ? {} : _ref$props;
  var descriptionIds = ref([]);
  function register(value) {
    descriptionIds.value.push(value);
    return function() {
      var idx = descriptionIds.value.indexOf(value);
      if (idx === -1)
        return;
      descriptionIds.value.splice(idx, 1);
    };
  }
  provide(DescriptionContext, {
    register,
    slot,
    name: name2,
    props
  });
  return computed(function() {
    return descriptionIds.value.length > 0 ? descriptionIds.value.join(" ") : void 0;
  });
}
var Description = /* @__PURE__ */ defineComponent({
  name: "Description",
  props: {
    as: {
      type: [Object, String],
      "default": "p"
    }
  },
  render: function render$1() {
    var _this$context = this.context, _this$context$name = _this$context.name, name2 = _this$context$name === void 0 ? "Description" : _this$context$name, _this$context$slot = _this$context.slot, slot = _this$context$slot === void 0 ? ref({}) : _this$context$slot, _this$context$props = _this$context.props, props = _this$context$props === void 0 ? {} : _this$context$props;
    var passThroughProps = this.$props;
    var propsWeControl = _extends$1({}, Object.entries(props).reduce(function(acc, _ref2) {
      var _Object$assign;
      var key = _ref2[0], value = _ref2[1];
      return Object.assign(acc, (_Object$assign = {}, _Object$assign[key] = unref(value), _Object$assign));
    }, {}), {
      id: this.id
    });
    return render$k({
      props: _extends$1({}, passThroughProps, propsWeControl),
      slot: slot.value,
      attrs: this.$attrs,
      slots: this.$slots,
      name: name2
    });
  },
  setup: function setup4() {
    var context2 = useDescriptionContext();
    var id2 = "headlessui-description-" + useId();
    onMounted(function() {
      return onUnmounted(context2.register(id2));
    });
    return {
      id: id2,
      context: context2
    };
  }
});
function dom(ref2) {
  var _ref$value$$el;
  if (ref2 == null)
    return null;
  if (ref2.value == null)
    return null;
  return (_ref$value$$el = ref2.value.$el) != null ? _ref$value$$el : ref2.value;
}
var Context = /* @__PURE__ */ Symbol("Context");
var State;
(function(State2) {
  State2[State2["Open"] = 0] = "Open";
  State2[State2["Closed"] = 1] = "Closed";
})(State || (State = {}));
function useOpenClosed() {
  return inject(Context, null);
}
function useOpenClosedProvider(value) {
  provide(Context, value);
}
var DialogStates;
(function(DialogStates2) {
  DialogStates2[DialogStates2["Open"] = 0] = "Open";
  DialogStates2[DialogStates2["Closed"] = 1] = "Closed";
})(DialogStates || (DialogStates = {}));
var DialogContext = /* @__PURE__ */ Symbol("DialogContext");
function useDialogContext(component) {
  var context2 = inject(DialogContext, null);
  if (context2 === null) {
    var err = new Error("<" + component + " /> is missing a parent <Dialog /> component.");
    if (Error.captureStackTrace)
      Error.captureStackTrace(err, useDialogContext);
    throw err;
  }
  return context2;
}
var Missing = "DC8F892D-2EBD-447C-A4C8-A03058436FF4";
var Dialog = /* @__PURE__ */ defineComponent({
  name: "Dialog",
  inheritAttrs: false,
  props: {
    as: {
      type: [Object, String],
      "default": "div"
    },
    "static": {
      type: Boolean,
      "default": false
    },
    unmount: {
      type: Boolean,
      "default": true
    },
    open: {
      type: [Boolean, String],
      "default": Missing
    },
    initialFocus: {
      type: Object,
      "default": null
    }
  },
  emits: ["close"],
  render: function render$12() {
    var _this = this;
    var propsWeControl = _extends$1({}, this.$attrs, {
      ref: "el",
      id: this.id,
      role: "dialog",
      "aria-modal": this.dialogState === DialogStates.Open ? true : void 0,
      "aria-labelledby": this.titleId,
      "aria-describedby": this.describedby,
      onClick: this.handleClick,
      onKeydown: this.handleKeyDown
    });
    var _this$$props = this.$props, passThroughProps = _objectWithoutPropertiesLoose(_this$$props, ["open", "initialFocus"]);
    var slot = {
      open: this.dialogState === DialogStates.Open
    };
    return h$1(ForcePortalRoot, {
      force: true
    }, function() {
      return h$1(Portal, function() {
        return h$1(PortalGroup, {
          target: _this.dialogRef
        }, function() {
          return h$1(ForcePortalRoot, {
            force: false
          }, function() {
            return render$k({
              props: _extends$1({}, passThroughProps, propsWeControl),
              slot,
              attrs: _this.$attrs,
              slots: _this.$slots,
              visible: _this.visible,
              features: Features.RenderStrategy | Features.Static,
              name: "Dialog"
            });
          });
        });
      });
    });
  },
  setup: function setup5(props, _ref) {
    var emit3 = _ref.emit;
    var containers = ref(/* @__PURE__ */ new Set());
    var usesOpenClosedState = useOpenClosed();
    var open = computed(function() {
      if (props.open === Missing && usesOpenClosedState !== null) {
        var _match;
        return match(usesOpenClosedState.value, (_match = {}, _match[State.Open] = true, _match[State.Closed] = false, _match));
      }
      return props.open;
    });
    var hasOpen = props.open !== Missing || usesOpenClosedState !== null;
    if (!hasOpen) {
      throw new Error("You forgot to provide an `open` prop to the `Dialog`.");
    }
    if (typeof open.value !== "boolean") {
      throw new Error("You provided an `open` prop to the `Dialog`, but the value is not a boolean. Received: " + (open.value === Missing ? void 0 : props.open));
    }
    var dialogState = computed(function() {
      return props.open ? DialogStates.Open : DialogStates.Closed;
    });
    var visible = computed(function() {
      if (usesOpenClosedState !== null) {
        return usesOpenClosedState.value === State.Open;
      }
      return dialogState.value === DialogStates.Open;
    });
    var internalDialogRef = ref(null);
    var enabled = ref(dialogState.value === DialogStates.Open);
    onUpdated(function() {
      enabled.value = dialogState.value === DialogStates.Open;
    });
    var id2 = "headlessui-dialog-" + useId();
    var focusTrapOptions = computed(function() {
      return {
        initialFocus: props.initialFocus
      };
    });
    useFocusTrap(containers, enabled, focusTrapOptions);
    useInertOthers(internalDialogRef, enabled);
    useStackProvider(function(message, element) {
      var _match2;
      return match(message, (_match2 = {}, _match2[StackMessage.AddElement] = function() {
        containers.value.add(element);
      }, _match2[StackMessage.RemoveElement] = function() {
        containers.value["delete"](element);
      }, _match2));
    });
    var describedby = useDescriptions({
      name: "DialogDescription",
      slot: computed(function() {
        return {
          open: open.value
        };
      })
    });
    var titleId = ref(null);
    var api = {
      titleId,
      dialogState,
      setTitleId: function setTitleId(id3) {
        if (titleId.value === id3)
          return;
        titleId.value = id3;
      },
      close: function close() {
        emit3("close", false);
      }
    };
    provide(DialogContext, api);
    useWindowEvent("mousedown", function(event) {
      var target = event.target;
      if (dialogState.value !== DialogStates.Open)
        return;
      if (containers.value.size !== 1)
        return;
      if (contains$2(containers.value, target))
        return;
      api.close();
      nextTick(function() {
        return target == null ? void 0 : target.focus();
      });
    });
    watchEffect(function(onInvalidate) {
      if (dialogState.value !== DialogStates.Open)
        return;
      var overflow = document.documentElement.style.overflow;
      var paddingRight = document.documentElement.style.paddingRight;
      var scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
      document.documentElement.style.overflow = "hidden";
      document.documentElement.style.paddingRight = scrollbarWidth + "px";
      onInvalidate(function() {
        document.documentElement.style.overflow = overflow;
        document.documentElement.style.paddingRight = paddingRight;
      });
    });
    watchEffect(function(onInvalidate) {
      if (dialogState.value !== DialogStates.Open)
        return;
      var container = dom(internalDialogRef);
      if (!container)
        return;
      var observer = new IntersectionObserver(function(entries) {
        for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done; ) {
          var entry = _step.value;
          if (entry.boundingClientRect.x === 0 && entry.boundingClientRect.y === 0 && entry.boundingClientRect.width === 0 && entry.boundingClientRect.height === 0) {
            api.close();
          }
        }
      });
      observer.observe(container);
      onInvalidate(function() {
        return observer.disconnect();
      });
    });
    return {
      id: id2,
      el: internalDialogRef,
      dialogRef: internalDialogRef,
      containers,
      dialogState,
      titleId,
      describedby,
      visible,
      open,
      handleClick: function handleClick(event) {
        event.stopPropagation();
      },
      // Handle `Escape` to close
      handleKeyDown: function handleKeyDown(event) {
        if (event.key !== Keys.Escape)
          return;
        if (dialogState.value !== DialogStates.Open)
          return;
        if (containers.value.size > 1)
          return;
        event.preventDefault();
        event.stopPropagation();
        api.close();
      }
    };
  }
});
var DialogOverlay = /* @__PURE__ */ defineComponent({
  name: "DialogOverlay",
  props: {
    as: {
      type: [Object, String],
      "default": "div"
    }
  },
  render: function render$13() {
    var api = useDialogContext("DialogOverlay");
    var propsWeControl = {
      ref: "el",
      id: this.id,
      "aria-hidden": true,
      onClick: this.handleClick
    };
    var passThroughProps = this.$props;
    return render$k({
      props: _extends$1({}, passThroughProps, propsWeControl),
      slot: {
        open: api.dialogState.value === DialogStates.Open
      },
      attrs: this.$attrs,
      slots: this.$slots,
      name: "DialogOverlay"
    });
  },
  setup: function setup6() {
    var api = useDialogContext("DialogOverlay");
    var id2 = "headlessui-dialog-overlay-" + useId();
    return {
      id: id2,
      handleClick: function handleClick(event) {
        event.preventDefault();
        event.stopPropagation();
        api.close();
      }
    };
  }
});
var DialogTitle = /* @__PURE__ */ defineComponent({
  name: "DialogTitle",
  props: {
    as: {
      type: [Object, String],
      "default": "h2"
    }
  },
  render: function render$14() {
    var api = useDialogContext("DialogTitle");
    var propsWeControl = {
      id: this.id
    };
    var passThroughProps = this.$props;
    return render$k({
      props: _extends$1({}, passThroughProps, propsWeControl),
      slot: {
        open: api.dialogState.value === DialogStates.Open
      },
      attrs: this.$attrs,
      slots: this.$slots,
      name: "DialogTitle"
    });
  },
  setup: function setup7() {
    var api = useDialogContext("DialogTitle");
    var id2 = "headlessui-dialog-title-" + useId();
    onMounted(function() {
      api.setTitleId(id2);
      onUnmounted(function() {
        return api.setTitleId(null);
      });
    });
    return {
      id: id2
    };
  }
});
var DialogDescription = Description;
var DisclosureStates;
(function(DisclosureStates2) {
  DisclosureStates2[DisclosureStates2["Open"] = 0] = "Open";
  DisclosureStates2[DisclosureStates2["Closed"] = 1] = "Closed";
})(DisclosureStates || (DisclosureStates = {}));
function assertNever(x2) {
  throw new Error("Unexpected object: " + x2);
}
var Focus$1;
(function(Focus2) {
  Focus2[Focus2["First"] = 0] = "First";
  Focus2[Focus2["Previous"] = 1] = "Previous";
  Focus2[Focus2["Next"] = 2] = "Next";
  Focus2[Focus2["Last"] = 3] = "Last";
  Focus2[Focus2["Specific"] = 4] = "Specific";
  Focus2[Focus2["Nothing"] = 5] = "Nothing";
})(Focus$1 || (Focus$1 = {}));
function calculateActiveIndex(action3, resolvers) {
  var items = resolvers.resolveItems();
  if (items.length <= 0)
    return null;
  var currentActiveIndex = resolvers.resolveActiveIndex();
  var activeIndex = currentActiveIndex != null ? currentActiveIndex : -1;
  var nextActiveIndex = function() {
    switch (action3.focus) {
      case Focus$1.First:
        return items.findIndex(function(item) {
          return !resolvers.resolveDisabled(item);
        });
      case Focus$1.Previous: {
        var idx = items.slice().reverse().findIndex(function(item, idx2, all) {
          if (activeIndex !== -1 && all.length - idx2 - 1 >= activeIndex)
            return false;
          return !resolvers.resolveDisabled(item);
        });
        if (idx === -1)
          return idx;
        return items.length - 1 - idx;
      }
      case Focus$1.Next:
        return items.findIndex(function(item, idx2) {
          if (idx2 <= activeIndex)
            return false;
          return !resolvers.resolveDisabled(item);
        });
      case Focus$1.Last: {
        var _idx = items.slice().reverse().findIndex(function(item) {
          return !resolvers.resolveDisabled(item);
        });
        if (_idx === -1)
          return _idx;
        return items.length - 1 - _idx;
      }
      case Focus$1.Specific:
        return items.findIndex(function(item) {
          return resolvers.resolveId(item) === action3.id;
        });
      case Focus$1.Nothing:
        return null;
      default:
        assertNever(action3);
    }
  }();
  return nextActiveIndex === -1 ? currentActiveIndex : nextActiveIndex;
}
var ListboxStates;
(function(ListboxStates2) {
  ListboxStates2[ListboxStates2["Open"] = 0] = "Open";
  ListboxStates2[ListboxStates2["Closed"] = 1] = "Closed";
})(ListboxStates || (ListboxStates = {}));
function nextFrame$1(cb) {
  requestAnimationFrame(function() {
    return requestAnimationFrame(cb);
  });
}
var ListboxContext = /* @__PURE__ */ Symbol("ListboxContext");
function useListboxContext(component) {
  var context2 = inject(ListboxContext, null);
  if (context2 === null) {
    var err = new Error("<" + component + " /> is missing a parent <Listbox /> component.");
    if (Error.captureStackTrace)
      Error.captureStackTrace(err, useListboxContext);
    throw err;
  }
  return context2;
}
var Listbox = /* @__PURE__ */ defineComponent({
  name: "Listbox",
  emits: ["update:modelValue"],
  props: {
    as: {
      type: [Object, String],
      "default": "template"
    },
    disabled: {
      type: [Boolean],
      "default": false
    },
    horizontal: {
      type: [Boolean],
      "default": false
    },
    modelValue: {
      type: [Object, String, Number, Boolean]
    }
  },
  setup: function setup12(props, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs, emit3 = _ref.emit;
    var listboxState = ref(ListboxStates.Closed);
    var labelRef = ref(null);
    var buttonRef = ref(null);
    var optionsRef = ref(null);
    var options2 = ref([]);
    var searchQuery = ref("");
    var activeOptionIndex = ref(null);
    var value = computed(function() {
      return props.modelValue;
    });
    var api = {
      listboxState,
      value,
      orientation: computed(function() {
        return props.horizontal ? "horizontal" : "vertical";
      }),
      labelRef,
      buttonRef,
      optionsRef,
      disabled: computed(function() {
        return props.disabled;
      }),
      options: options2,
      searchQuery,
      activeOptionIndex,
      closeListbox: function closeListbox() {
        if (props.disabled)
          return;
        if (listboxState.value === ListboxStates.Closed)
          return;
        listboxState.value = ListboxStates.Closed;
        activeOptionIndex.value = null;
      },
      openListbox: function openListbox() {
        if (props.disabled)
          return;
        if (listboxState.value === ListboxStates.Open)
          return;
        listboxState.value = ListboxStates.Open;
      },
      goToOption: function goToOption(focus, id2) {
        if (props.disabled)
          return;
        if (listboxState.value === ListboxStates.Closed)
          return;
        var nextActiveOptionIndex = calculateActiveIndex(focus === Focus$1.Specific ? {
          focus: Focus$1.Specific,
          id: id2
        } : {
          focus
        }, {
          resolveItems: function resolveItems() {
            return options2.value;
          },
          resolveActiveIndex: function resolveActiveIndex() {
            return activeOptionIndex.value;
          },
          resolveId: function resolveId(option) {
            return option.id;
          },
          resolveDisabled: function resolveDisabled(option) {
            return option.dataRef.disabled;
          }
        });
        if (searchQuery.value === "" && activeOptionIndex.value === nextActiveOptionIndex)
          return;
        searchQuery.value = "";
        activeOptionIndex.value = nextActiveOptionIndex;
      },
      search: function search(value2) {
        if (props.disabled)
          return;
        if (listboxState.value === ListboxStates.Closed)
          return;
        searchQuery.value += value2.toLowerCase();
        var match2 = options2.value.findIndex(function(option) {
          return !option.dataRef.disabled && option.dataRef.textValue.startsWith(searchQuery.value);
        });
        if (match2 === -1 || match2 === activeOptionIndex.value)
          return;
        activeOptionIndex.value = match2;
      },
      clearSearch: function clearSearch() {
        if (props.disabled)
          return;
        if (listboxState.value === ListboxStates.Closed)
          return;
        if (searchQuery.value === "")
          return;
        searchQuery.value = "";
      },
      registerOption: function registerOption(id2, dataRef) {
        options2.value.push({
          id: id2,
          dataRef
        });
      },
      unregisterOption: function unregisterOption(id2) {
        var nextOptions = options2.value.slice();
        var currentActiveOption = activeOptionIndex.value !== null ? nextOptions[activeOptionIndex.value] : null;
        var idx = nextOptions.findIndex(function(a2) {
          return a2.id === id2;
        });
        if (idx !== -1)
          nextOptions.splice(idx, 1);
        options2.value = nextOptions;
        activeOptionIndex.value = function() {
          if (idx === activeOptionIndex.value)
            return null;
          if (currentActiveOption === null)
            return null;
          return nextOptions.indexOf(currentActiveOption);
        }();
      },
      select: function select(value2) {
        if (props.disabled)
          return;
        emit3("update:modelValue", value2);
      }
    };
    useWindowEvent("mousedown", function(event) {
      var _dom, _dom2, _dom3;
      var target = event.target;
      var active = document.activeElement;
      if (listboxState.value !== ListboxStates.Open)
        return;
      if ((_dom = dom(buttonRef)) == null ? void 0 : _dom.contains(target))
        return;
      if (!((_dom2 = dom(optionsRef)) == null ? void 0 : _dom2.contains(target)))
        api.closeListbox();
      if (active !== document.body && (active == null ? void 0 : active.contains(target)))
        return;
      if (!event.defaultPrevented)
        (_dom3 = dom(buttonRef)) == null ? void 0 : _dom3.focus({
          preventScroll: true
        });
    });
    provide(ListboxContext, api);
    useOpenClosedProvider(computed(function() {
      var _match;
      return match(listboxState.value, (_match = {}, _match[ListboxStates.Open] = State.Open, _match[ListboxStates.Closed] = State.Closed, _match));
    }));
    return function() {
      var slot = {
        open: listboxState.value === ListboxStates.Open,
        disabled: props.disabled
      };
      return render$k({
        props: omit(props, ["modelValue", "onUpdate:modelValue", "disabled", "horizontal"]),
        slot,
        slots,
        attrs,
        name: "Listbox"
      });
    };
  }
});
var ListboxLabel = /* @__PURE__ */ defineComponent({
  name: "ListboxLabel",
  props: {
    as: {
      type: [Object, String],
      "default": "label"
    }
  },
  render: function render$18() {
    var api = useListboxContext("ListboxLabel");
    var slot = {
      open: api.listboxState.value === ListboxStates.Open,
      disabled: api.disabled.value
    };
    var propsWeControl = {
      id: this.id,
      ref: "el",
      onClick: this.handleClick
    };
    return render$k({
      props: _extends$1({}, this.$props, propsWeControl),
      slot,
      attrs: this.$attrs,
      slots: this.$slots,
      name: "ListboxLabel"
    });
  },
  setup: function setup13() {
    var api = useListboxContext("ListboxLabel");
    var id2 = "headlessui-listbox-label-" + useId();
    return {
      id: id2,
      el: api.labelRef,
      handleClick: function handleClick() {
        var _dom4;
        (_dom4 = dom(api.buttonRef)) == null ? void 0 : _dom4.focus({
          preventScroll: true
        });
      }
    };
  }
});
var ListboxButton = /* @__PURE__ */ defineComponent({
  name: "ListboxButton",
  props: {
    as: {
      type: [Object, String],
      "default": "button"
    }
  },
  render: function render$19() {
    var _dom5, _dom6;
    var api = useListboxContext("ListboxButton");
    var slot = {
      open: api.listboxState.value === ListboxStates.Open,
      disabled: api.disabled.value
    };
    var propsWeControl = {
      ref: "el",
      id: this.id,
      type: "button",
      "aria-haspopup": true,
      "aria-controls": (_dom5 = dom(api.optionsRef)) == null ? void 0 : _dom5.id,
      "aria-expanded": api.disabled.value ? void 0 : api.listboxState.value === ListboxStates.Open,
      "aria-labelledby": api.labelRef.value ? [(_dom6 = dom(api.labelRef)) == null ? void 0 : _dom6.id, this.id].join(" ") : void 0,
      disabled: api.disabled.value === true ? true : void 0,
      onKeydown: this.handleKeyDown,
      onKeyup: this.handleKeyUp,
      onClick: this.handleClick
    };
    return render$k({
      props: _extends$1({}, this.$props, propsWeControl),
      slot,
      attrs: this.$attrs,
      slots: this.$slots,
      name: "ListboxButton"
    });
  },
  setup: function setup14() {
    var api = useListboxContext("ListboxButton");
    var id2 = "headlessui-listbox-button-" + useId();
    function handleKeyDown(event) {
      switch (event.key) {
        case Keys.Space:
        case Keys.Enter:
        case Keys.ArrowDown:
          event.preventDefault();
          api.openListbox();
          nextTick(function() {
            var _dom7;
            (_dom7 = dom(api.optionsRef)) == null ? void 0 : _dom7.focus({
              preventScroll: true
            });
            if (!api.value.value)
              api.goToOption(Focus$1.First);
          });
          break;
        case Keys.ArrowUp:
          event.preventDefault();
          api.openListbox();
          nextTick(function() {
            var _dom8;
            (_dom8 = dom(api.optionsRef)) == null ? void 0 : _dom8.focus({
              preventScroll: true
            });
            if (!api.value.value)
              api.goToOption(Focus$1.Last);
          });
          break;
      }
    }
    function handleKeyUp(event) {
      switch (event.key) {
        case Keys.Space:
          event.preventDefault();
          break;
      }
    }
    function handleClick(event) {
      if (api.disabled.value)
        return;
      if (api.listboxState.value === ListboxStates.Open) {
        api.closeListbox();
        nextTick(function() {
          var _dom9;
          return (_dom9 = dom(api.buttonRef)) == null ? void 0 : _dom9.focus({
            preventScroll: true
          });
        });
      } else {
        event.preventDefault();
        api.openListbox();
        nextFrame$1(function() {
          var _dom10;
          return (_dom10 = dom(api.optionsRef)) == null ? void 0 : _dom10.focus({
            preventScroll: true
          });
        });
      }
    }
    return {
      id: id2,
      el: api.buttonRef,
      handleKeyDown,
      handleKeyUp,
      handleClick
    };
  }
});
var ListboxOptions = /* @__PURE__ */ defineComponent({
  name: "ListboxOptions",
  props: {
    as: {
      type: [Object, String],
      "default": "ul"
    },
    "static": {
      type: Boolean,
      "default": false
    },
    unmount: {
      type: Boolean,
      "default": true
    }
  },
  render: function render$110() {
    var _api$options$value$ap, _dom$id, _dom11, _dom12;
    var api = useListboxContext("ListboxOptions");
    var slot = {
      open: api.listboxState.value === ListboxStates.Open
    };
    var propsWeControl = {
      "aria-activedescendant": api.activeOptionIndex.value === null ? void 0 : (_api$options$value$ap = api.options.value[api.activeOptionIndex.value]) == null ? void 0 : _api$options$value$ap.id,
      "aria-labelledby": (_dom$id = (_dom11 = dom(api.labelRef)) == null ? void 0 : _dom11.id) != null ? _dom$id : (_dom12 = dom(api.buttonRef)) == null ? void 0 : _dom12.id,
      "aria-orientation": api.orientation.value,
      id: this.id,
      onKeydown: this.handleKeyDown,
      role: "listbox",
      tabIndex: 0,
      ref: "el"
    };
    var passThroughProps = this.$props;
    return render$k({
      props: _extends$1({}, passThroughProps, propsWeControl),
      slot,
      attrs: this.$attrs,
      slots: this.$slots,
      features: Features.RenderStrategy | Features.Static,
      visible: this.visible,
      name: "ListboxOptions"
    });
  },
  setup: function setup15() {
    var api = useListboxContext("ListboxOptions");
    var id2 = "headlessui-listbox-options-" + useId();
    var searchDebounce = ref(null);
    function handleKeyDown(event) {
      if (searchDebounce.value)
        clearTimeout(searchDebounce.value);
      switch (event.key) {
        case Keys.Space:
          if (api.searchQuery.value !== "") {
            event.preventDefault();
            event.stopPropagation();
            return api.search(event.key);
          }
        case Keys.Enter:
          event.preventDefault();
          event.stopPropagation();
          if (api.activeOptionIndex.value !== null) {
            var dataRef = api.options.value[api.activeOptionIndex.value].dataRef;
            api.select(dataRef.value);
          }
          api.closeListbox();
          nextTick(function() {
            var _dom13;
            return (_dom13 = dom(api.buttonRef)) == null ? void 0 : _dom13.focus({
              preventScroll: true
            });
          });
          break;
        case match(api.orientation.value, {
          vertical: Keys.ArrowDown,
          horizontal: Keys.ArrowRight
        }):
          event.preventDefault();
          event.stopPropagation();
          return api.goToOption(Focus$1.Next);
        case match(api.orientation.value, {
          vertical: Keys.ArrowUp,
          horizontal: Keys.ArrowLeft
        }):
          event.preventDefault();
          event.stopPropagation();
          return api.goToOption(Focus$1.Previous);
        case Keys.Home:
        case Keys.PageUp:
          event.preventDefault();
          event.stopPropagation();
          return api.goToOption(Focus$1.First);
        case Keys.End:
        case Keys.PageDown:
          event.preventDefault();
          event.stopPropagation();
          return api.goToOption(Focus$1.Last);
        case Keys.Escape:
          event.preventDefault();
          event.stopPropagation();
          api.closeListbox();
          nextTick(function() {
            var _dom14;
            return (_dom14 = dom(api.buttonRef)) == null ? void 0 : _dom14.focus({
              preventScroll: true
            });
          });
          break;
        case Keys.Tab:
          event.preventDefault();
          event.stopPropagation();
          break;
        default:
          if (event.key.length === 1) {
            api.search(event.key);
            searchDebounce.value = setTimeout(function() {
              return api.clearSearch();
            }, 350);
          }
          break;
      }
    }
    var usesOpenClosedState = useOpenClosed();
    var visible = computed(function() {
      if (usesOpenClosedState !== null) {
        return usesOpenClosedState.value === State.Open;
      }
      return api.listboxState.value === ListboxStates.Open;
    });
    return {
      id: id2,
      el: api.optionsRef,
      handleKeyDown,
      visible
    };
  }
});
var ListboxOption = /* @__PURE__ */ defineComponent({
  name: "ListboxOption",
  props: {
    as: {
      type: [Object, String],
      "default": "li"
    },
    value: {
      type: [Object, String, Number, Boolean]
    },
    disabled: {
      type: Boolean,
      "default": false
    }
  },
  setup: function setup16(props, _ref2) {
    var slots = _ref2.slots, attrs = _ref2.attrs;
    var api = useListboxContext("ListboxOption");
    var id2 = "headlessui-listbox-option-" + useId();
    var active = computed(function() {
      return api.activeOptionIndex.value !== null ? api.options.value[api.activeOptionIndex.value].id === id2 : false;
    });
    var selected = computed(function() {
      return toRaw(api.value.value) === toRaw(props.value);
    });
    var dataRef = ref({
      disabled: props.disabled,
      value: props.value,
      textValue: ""
    });
    onMounted(function() {
      var _document$getElementB, _document$getElementB2;
      var textValue = (_document$getElementB = document.getElementById(id2)) == null ? void 0 : (_document$getElementB2 = _document$getElementB.textContent) == null ? void 0 : _document$getElementB2.toLowerCase().trim();
      if (textValue !== void 0)
        dataRef.value.textValue = textValue;
    });
    onMounted(function() {
      return api.registerOption(id2, dataRef);
    });
    onUnmounted(function() {
      return api.unregisterOption(id2);
    });
    onMounted(function() {
      watch([api.listboxState, selected], function() {
        var _document$getElementB3;
        if (api.listboxState.value !== ListboxStates.Open)
          return;
        if (!selected.value)
          return;
        api.goToOption(Focus$1.Specific, id2);
        (_document$getElementB3 = document.getElementById(id2)) == null ? void 0 : _document$getElementB3.focus == null ? void 0 : _document$getElementB3.focus();
      }, {
        immediate: true
      });
    });
    watchEffect(function() {
      if (api.listboxState.value !== ListboxStates.Open)
        return;
      if (!active.value)
        return;
      nextTick(function() {
        var _document$getElementB4;
        return (_document$getElementB4 = document.getElementById(id2)) == null ? void 0 : _document$getElementB4.scrollIntoView == null ? void 0 : _document$getElementB4.scrollIntoView({
          block: "nearest"
        });
      });
    });
    function handleClick(event) {
      if (props.disabled)
        return event.preventDefault();
      api.select(props.value);
      api.closeListbox();
      nextTick(function() {
        var _dom15;
        return (_dom15 = dom(api.buttonRef)) == null ? void 0 : _dom15.focus({
          preventScroll: true
        });
      });
    }
    function handleFocus() {
      if (props.disabled)
        return api.goToOption(Focus$1.Nothing);
      api.goToOption(Focus$1.Specific, id2);
    }
    function handleMove() {
      if (props.disabled)
        return;
      if (active.value)
        return;
      api.goToOption(Focus$1.Specific, id2);
    }
    function handleLeave() {
      if (props.disabled)
        return;
      if (!active.value)
        return;
      api.goToOption(Focus$1.Nothing);
    }
    return function() {
      var disabled = props.disabled;
      var slot = {
        active: active.value,
        selected: selected.value,
        disabled
      };
      var propsWeControl = {
        id: id2,
        role: "option",
        tabIndex: disabled === true ? void 0 : -1,
        "aria-disabled": disabled === true ? true : void 0,
        "aria-selected": selected.value === true ? selected.value : void 0,
        disabled: void 0,
        onClick: handleClick,
        onFocus: handleFocus,
        onPointermove: handleMove,
        onMousemove: handleMove,
        onPointerleave: handleLeave,
        onMouseleave: handleLeave
      };
      return render$k({
        props: _extends$1({}, props, propsWeControl),
        slot,
        attrs,
        slots,
        name: "ListboxOption"
      });
    };
  }
});
function useTreeWalker(_ref) {
  var container = _ref.container, accept = _ref.accept, walk = _ref.walk, enabled = _ref.enabled;
  watchEffect(function() {
    var root = container.value;
    if (!root)
      return;
    if (enabled !== void 0 && !enabled.value)
      return;
    var acceptNode = Object.assign(function(node) {
      return accept(node);
    }, {
      acceptNode: accept
    });
    var walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, acceptNode, false);
    while (walker.nextNode()) {
      walk(walker.currentNode);
    }
  });
}
var MenuStates;
(function(MenuStates2) {
  MenuStates2[MenuStates2["Open"] = 0] = "Open";
  MenuStates2[MenuStates2["Closed"] = 1] = "Closed";
})(MenuStates || (MenuStates = {}));
function nextFrame$1$1(cb) {
  requestAnimationFrame(function() {
    return requestAnimationFrame(cb);
  });
}
var MenuContext = /* @__PURE__ */ Symbol("MenuContext");
function useMenuContext(component) {
  var context2 = inject(MenuContext, null);
  if (context2 === null) {
    var err = new Error("<" + component + " /> is missing a parent <Menu /> component.");
    if (Error.captureStackTrace)
      Error.captureStackTrace(err, useMenuContext);
    throw err;
  }
  return context2;
}
var Menu$1 = /* @__PURE__ */ defineComponent({
  name: "Menu",
  props: {
    as: {
      type: [Object, String],
      "default": "template"
    }
  },
  setup: function setup17(props, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var menuState = ref(MenuStates.Closed);
    var buttonRef = ref(null);
    var itemsRef = ref(null);
    var items = ref([]);
    var searchQuery = ref("");
    var activeItemIndex = ref(null);
    var api = {
      menuState,
      buttonRef,
      itemsRef,
      items,
      searchQuery,
      activeItemIndex,
      closeMenu: function closeMenu() {
        menuState.value = MenuStates.Closed;
        activeItemIndex.value = null;
      },
      openMenu: function openMenu() {
        return menuState.value = MenuStates.Open;
      },
      goToItem: function goToItem(focus, id2) {
        var nextActiveItemIndex = calculateActiveIndex(focus === Focus$1.Specific ? {
          focus: Focus$1.Specific,
          id: id2
        } : {
          focus
        }, {
          resolveItems: function resolveItems() {
            return items.value;
          },
          resolveActiveIndex: function resolveActiveIndex() {
            return activeItemIndex.value;
          },
          resolveId: function resolveId(item) {
            return item.id;
          },
          resolveDisabled: function resolveDisabled(item) {
            return item.dataRef.disabled;
          }
        });
        if (searchQuery.value === "" && activeItemIndex.value === nextActiveItemIndex)
          return;
        searchQuery.value = "";
        activeItemIndex.value = nextActiveItemIndex;
      },
      search: function search(value) {
        searchQuery.value += value.toLowerCase();
        var match2 = items.value.findIndex(function(item) {
          return item.dataRef.textValue.startsWith(searchQuery.value) && !item.dataRef.disabled;
        });
        if (match2 === -1 || match2 === activeItemIndex.value)
          return;
        activeItemIndex.value = match2;
      },
      clearSearch: function clearSearch() {
        searchQuery.value = "";
      },
      registerItem: function registerItem(id2, dataRef) {
        items.value.push({
          id: id2,
          dataRef
        });
      },
      unregisterItem: function unregisterItem(id2) {
        var nextItems = items.value.slice();
        var currentActiveItem = activeItemIndex.value !== null ? nextItems[activeItemIndex.value] : null;
        var idx = nextItems.findIndex(function(a2) {
          return a2.id === id2;
        });
        if (idx !== -1)
          nextItems.splice(idx, 1);
        items.value = nextItems;
        activeItemIndex.value = function() {
          if (idx === activeItemIndex.value)
            return null;
          if (currentActiveItem === null)
            return null;
          return nextItems.indexOf(currentActiveItem);
        }();
      }
    };
    useWindowEvent("mousedown", function(event) {
      var _dom, _dom2, _dom3;
      var target = event.target;
      var active = document.activeElement;
      if (menuState.value !== MenuStates.Open)
        return;
      if ((_dom = dom(buttonRef)) == null ? void 0 : _dom.contains(target))
        return;
      if (!((_dom2 = dom(itemsRef)) == null ? void 0 : _dom2.contains(target)))
        api.closeMenu();
      if (active !== document.body && (active == null ? void 0 : active.contains(target)))
        return;
      if (!event.defaultPrevented)
        (_dom3 = dom(buttonRef)) == null ? void 0 : _dom3.focus({
          preventScroll: true
        });
    });
    provide(MenuContext, api);
    useOpenClosedProvider(computed(function() {
      var _match;
      return match(menuState.value, (_match = {}, _match[MenuStates.Open] = State.Open, _match[MenuStates.Closed] = State.Closed, _match));
    }));
    return function() {
      var slot = {
        open: menuState.value === MenuStates.Open
      };
      return render$k({
        props,
        slot,
        slots,
        attrs,
        name: "Menu"
      });
    };
  }
});
var MenuButton = /* @__PURE__ */ defineComponent({
  name: "MenuButton",
  props: {
    disabled: {
      type: Boolean,
      "default": false
    },
    as: {
      type: [Object, String],
      "default": "button"
    }
  },
  render: function render$111() {
    var _dom4;
    var api = useMenuContext("MenuButton");
    var slot = {
      open: api.menuState.value === MenuStates.Open
    };
    var propsWeControl = {
      ref: "el",
      id: this.id,
      type: "button",
      "aria-haspopup": true,
      "aria-controls": (_dom4 = dom(api.itemsRef)) == null ? void 0 : _dom4.id,
      "aria-expanded": this.$props.disabled ? void 0 : api.menuState.value === MenuStates.Open,
      onKeydown: this.handleKeyDown,
      onKeyup: this.handleKeyUp,
      onClick: this.handleClick
    };
    return render$k({
      props: _extends$1({}, this.$props, propsWeControl),
      slot,
      attrs: this.$attrs,
      slots: this.$slots,
      name: "MenuButton"
    });
  },
  setup: function setup18(props) {
    var api = useMenuContext("MenuButton");
    var id2 = "headlessui-menu-button-" + useId();
    function handleKeyDown(event) {
      switch (event.key) {
        case Keys.Space:
        case Keys.Enter:
        case Keys.ArrowDown:
          event.preventDefault();
          event.stopPropagation();
          api.openMenu();
          nextTick(function() {
            var _dom5;
            (_dom5 = dom(api.itemsRef)) == null ? void 0 : _dom5.focus({
              preventScroll: true
            });
            api.goToItem(Focus$1.First);
          });
          break;
        case Keys.ArrowUp:
          event.preventDefault();
          event.stopPropagation();
          api.openMenu();
          nextTick(function() {
            var _dom6;
            (_dom6 = dom(api.itemsRef)) == null ? void 0 : _dom6.focus({
              preventScroll: true
            });
            api.goToItem(Focus$1.Last);
          });
          break;
      }
    }
    function handleKeyUp(event) {
      switch (event.key) {
        case Keys.Space:
          event.preventDefault();
          break;
      }
    }
    function handleClick(event) {
      if (props.disabled)
        return;
      if (api.menuState.value === MenuStates.Open) {
        api.closeMenu();
        nextTick(function() {
          var _dom7;
          return (_dom7 = dom(api.buttonRef)) == null ? void 0 : _dom7.focus({
            preventScroll: true
          });
        });
      } else {
        event.preventDefault();
        event.stopPropagation();
        api.openMenu();
        nextFrame$1$1(function() {
          var _dom8;
          return (_dom8 = dom(api.itemsRef)) == null ? void 0 : _dom8.focus({
            preventScroll: true
          });
        });
      }
    }
    return {
      id: id2,
      el: api.buttonRef,
      handleKeyDown,
      handleKeyUp,
      handleClick
    };
  }
});
var MenuItems = /* @__PURE__ */ defineComponent({
  name: "MenuItems",
  props: {
    as: {
      type: [Object, String],
      "default": "div"
    },
    "static": {
      type: Boolean,
      "default": false
    },
    unmount: {
      type: Boolean,
      "default": true
    }
  },
  render: function render$112() {
    var _api$items$value$api$, _dom9;
    var api = useMenuContext("MenuItems");
    var slot = {
      open: api.menuState.value === MenuStates.Open
    };
    var propsWeControl = {
      "aria-activedescendant": api.activeItemIndex.value === null ? void 0 : (_api$items$value$api$ = api.items.value[api.activeItemIndex.value]) == null ? void 0 : _api$items$value$api$.id,
      "aria-labelledby": (_dom9 = dom(api.buttonRef)) == null ? void 0 : _dom9.id,
      id: this.id,
      onKeydown: this.handleKeyDown,
      onKeyup: this.handleKeyUp,
      role: "menu",
      tabIndex: 0,
      ref: "el"
    };
    var passThroughProps = this.$props;
    return render$k({
      props: _extends$1({}, passThroughProps, propsWeControl),
      slot,
      attrs: this.$attrs,
      slots: this.$slots,
      features: Features.RenderStrategy | Features.Static,
      visible: this.visible,
      name: "MenuItems"
    });
  },
  setup: function setup19() {
    var api = useMenuContext("MenuItems");
    var id2 = "headlessui-menu-items-" + useId();
    var searchDebounce = ref(null);
    useTreeWalker({
      container: computed(function() {
        return dom(api.itemsRef);
      }),
      enabled: computed(function() {
        return api.menuState.value === MenuStates.Open;
      }),
      accept: function accept(node) {
        if (node.getAttribute("role") === "menuitem")
          return NodeFilter.FILTER_REJECT;
        if (node.hasAttribute("role"))
          return NodeFilter.FILTER_SKIP;
        return NodeFilter.FILTER_ACCEPT;
      },
      walk: function walk(node) {
        node.setAttribute("role", "none");
      }
    });
    function handleKeyDown(event) {
      if (searchDebounce.value)
        clearTimeout(searchDebounce.value);
      switch (event.key) {
        case Keys.Space:
          if (api.searchQuery.value !== "") {
            event.preventDefault();
            event.stopPropagation();
            return api.search(event.key);
          }
        case Keys.Enter:
          event.preventDefault();
          event.stopPropagation();
          if (api.activeItemIndex.value !== null) {
            var _document$getElementB;
            var _id = api.items.value[api.activeItemIndex.value].id;
            (_document$getElementB = document.getElementById(_id)) == null ? void 0 : _document$getElementB.click();
          }
          api.closeMenu();
          nextTick(function() {
            var _dom10;
            return (_dom10 = dom(api.buttonRef)) == null ? void 0 : _dom10.focus({
              preventScroll: true
            });
          });
          break;
        case Keys.ArrowDown:
          event.preventDefault();
          event.stopPropagation();
          return api.goToItem(Focus$1.Next);
        case Keys.ArrowUp:
          event.preventDefault();
          event.stopPropagation();
          return api.goToItem(Focus$1.Previous);
        case Keys.Home:
        case Keys.PageUp:
          event.preventDefault();
          event.stopPropagation();
          return api.goToItem(Focus$1.First);
        case Keys.End:
        case Keys.PageDown:
          event.preventDefault();
          event.stopPropagation();
          return api.goToItem(Focus$1.Last);
        case Keys.Escape:
          event.preventDefault();
          event.stopPropagation();
          api.closeMenu();
          nextTick(function() {
            var _dom11;
            return (_dom11 = dom(api.buttonRef)) == null ? void 0 : _dom11.focus({
              preventScroll: true
            });
          });
          break;
        case Keys.Tab:
          event.preventDefault();
          event.stopPropagation();
          break;
        default:
          if (event.key.length === 1) {
            api.search(event.key);
            searchDebounce.value = setTimeout(function() {
              return api.clearSearch();
            }, 350);
          }
          break;
      }
    }
    function handleKeyUp(event) {
      switch (event.key) {
        case Keys.Space:
          event.preventDefault();
          break;
      }
    }
    var usesOpenClosedState = useOpenClosed();
    var visible = computed(function() {
      if (usesOpenClosedState !== null) {
        return usesOpenClosedState.value === State.Open;
      }
      return api.menuState.value === MenuStates.Open;
    });
    return {
      id: id2,
      el: api.itemsRef,
      handleKeyDown,
      handleKeyUp,
      visible
    };
  }
});
var MenuItem = /* @__PURE__ */ defineComponent({
  name: "MenuItem",
  props: {
    as: {
      type: [Object, String],
      "default": "template"
    },
    disabled: {
      type: Boolean,
      "default": false
    }
  },
  setup: function setup20(props, _ref2) {
    var slots = _ref2.slots, attrs = _ref2.attrs;
    var api = useMenuContext("MenuItem");
    var id2 = "headlessui-menu-item-" + useId();
    var active = computed(function() {
      return api.activeItemIndex.value !== null ? api.items.value[api.activeItemIndex.value].id === id2 : false;
    });
    var dataRef = ref({
      disabled: props.disabled,
      textValue: ""
    });
    onMounted(function() {
      var _document$getElementB2, _document$getElementB3;
      var textValue = (_document$getElementB2 = document.getElementById(id2)) == null ? void 0 : (_document$getElementB3 = _document$getElementB2.textContent) == null ? void 0 : _document$getElementB3.toLowerCase().trim();
      if (textValue !== void 0)
        dataRef.value.textValue = textValue;
    });
    onMounted(function() {
      return api.registerItem(id2, dataRef);
    });
    onUnmounted(function() {
      return api.unregisterItem(id2);
    });
    watchEffect(function() {
      if (api.menuState.value !== MenuStates.Open)
        return;
      if (!active.value)
        return;
      nextTick(function() {
        var _document$getElementB4;
        return (_document$getElementB4 = document.getElementById(id2)) == null ? void 0 : _document$getElementB4.scrollIntoView == null ? void 0 : _document$getElementB4.scrollIntoView({
          block: "nearest"
        });
      });
    });
    function handleClick(event) {
      if (props.disabled)
        return event.preventDefault();
      api.closeMenu();
      nextTick(function() {
        var _dom12;
        return (_dom12 = dom(api.buttonRef)) == null ? void 0 : _dom12.focus({
          preventScroll: true
        });
      });
    }
    function handleFocus() {
      if (props.disabled)
        return api.goToItem(Focus$1.Nothing);
      api.goToItem(Focus$1.Specific, id2);
    }
    function handleMove() {
      if (props.disabled)
        return;
      if (active.value)
        return;
      api.goToItem(Focus$1.Specific, id2);
    }
    function handleLeave() {
      if (props.disabled)
        return;
      if (!active.value)
        return;
      api.goToItem(Focus$1.Nothing);
    }
    return function() {
      var disabled = props.disabled;
      var slot = {
        active: active.value,
        disabled
      };
      var propsWeControl = {
        id: id2,
        role: "menuitem",
        tabIndex: disabled === true ? void 0 : -1,
        "aria-disabled": disabled === true ? true : void 0,
        onClick: handleClick,
        onFocus: handleFocus,
        onPointermove: handleMove,
        onMousemove: handleMove,
        onPointerleave: handleLeave,
        onMouseleave: handleLeave
      };
      return render$k({
        props: _extends$1({}, props, propsWeControl),
        slot,
        attrs,
        slots,
        name: "MenuItem"
      });
    };
  }
});
var PopoverStates;
(function(PopoverStates2) {
  PopoverStates2[PopoverStates2["Open"] = 0] = "Open";
  PopoverStates2[PopoverStates2["Closed"] = 1] = "Closed";
})(PopoverStates || (PopoverStates = {}));
var PopoverContext = /* @__PURE__ */ Symbol("PopoverContext");
function usePopoverContext(component) {
  var context2 = inject(PopoverContext, null);
  if (context2 === null) {
    var err = new Error("<" + component + " /> is missing a parent <" + Popover.name + " /> component.");
    if (Error.captureStackTrace)
      Error.captureStackTrace(err, usePopoverContext);
    throw err;
  }
  return context2;
}
var PopoverGroupContext = /* @__PURE__ */ Symbol("PopoverGroupContext");
function usePopoverGroupContext() {
  return inject(PopoverGroupContext, null);
}
var PopoverPanelContext = /* @__PURE__ */ Symbol("PopoverPanelContext");
function usePopoverPanelContext() {
  return inject(PopoverPanelContext, null);
}
var Popover = /* @__PURE__ */ defineComponent({
  name: "Popover",
  props: {
    as: {
      type: [Object, String],
      "default": "div"
    }
  },
  setup: function setup21(props, _ref) {
    var slots = _ref.slots, attrs = _ref.attrs;
    var buttonId = "headlessui-popover-button-" + useId();
    var panelId = "headlessui-popover-panel-" + useId();
    var popoverState = ref(PopoverStates.Closed);
    var button = ref(null);
    var panel = ref(null);
    var api = {
      popoverState,
      buttonId,
      panelId,
      panel,
      button,
      togglePopover: function togglePopover() {
        var _match;
        popoverState.value = match(popoverState.value, (_match = {}, _match[PopoverStates.Open] = PopoverStates.Closed, _match[PopoverStates.Closed] = PopoverStates.Open, _match));
      },
      closePopover: function closePopover() {
        if (popoverState.value === PopoverStates.Closed)
          return;
        popoverState.value = PopoverStates.Closed;
      },
      close: function close(focusableElement) {
        api.closePopover();
        var restoreElement = function() {
          if (!focusableElement)
            return dom(api.button);
          if (focusableElement instanceof HTMLElement)
            return focusableElement;
          if (focusableElement.value instanceof HTMLElement)
            return dom(focusableElement);
          return dom(api.button);
        }();
        restoreElement == null ? void 0 : restoreElement.focus();
      }
    };
    provide(PopoverContext, api);
    useOpenClosedProvider(computed(function() {
      var _match2;
      return match(popoverState.value, (_match2 = {}, _match2[PopoverStates.Open] = State.Open, _match2[PopoverStates.Closed] = State.Closed, _match2));
    }));
    var registerBag = {
      buttonId,
      panelId,
      close: function close() {
        api.closePopover();
      }
    };
    var groupContext = usePopoverGroupContext();
    var registerPopover = groupContext == null ? void 0 : groupContext.registerPopover;
    function isFocusWithinPopoverGroup() {
      var _groupContext$isFocus, _dom, _dom2;
      return (_groupContext$isFocus = groupContext == null ? void 0 : groupContext.isFocusWithinPopoverGroup()) != null ? _groupContext$isFocus : ((_dom = dom(button)) == null ? void 0 : _dom.contains(document.activeElement)) || ((_dom2 = dom(panel)) == null ? void 0 : _dom2.contains(document.activeElement));
    }
    watchEffect(function() {
      return registerPopover == null ? void 0 : registerPopover(registerBag);
    });
    useWindowEvent("focus", function() {
      if (popoverState.value !== PopoverStates.Open)
        return;
      if (isFocusWithinPopoverGroup())
        return;
      if (!button)
        return;
      if (!panel)
        return;
      api.closePopover();
    }, true);
    useWindowEvent("mousedown", function(event) {
      var _dom3, _dom4;
      var target = event.target;
      if (popoverState.value !== PopoverStates.Open)
        return;
      if ((_dom3 = dom(button)) == null ? void 0 : _dom3.contains(target))
        return;
      if ((_dom4 = dom(panel)) == null ? void 0 : _dom4.contains(target))
        return;
      api.closePopover();
      if (!isFocusableElement(target, FocusableMode.Loose)) {
        var _dom5;
        event.preventDefault();
        (_dom5 = dom(button)) == null ? void 0 : _dom5.focus();
      }
    });
    return function() {
      var slot = {
        open: popoverState.value === PopoverStates.Open,
        close: api.close
      };
      return render$k({
        props,
        slot,
        slots,
        attrs,
        name: "Popover"
      });
    };
  }
});
var PopoverButton = /* @__PURE__ */ defineComponent({
  name: "PopoverButton",
  props: {
    as: {
      type: [Object, String],
      "default": "button"
    },
    disabled: {
      type: [Boolean],
      "default": false
    }
  },
  render: function render$113() {
    var api = usePopoverContext("PopoverButton");
    var slot = {
      open: api.popoverState.value === PopoverStates.Open
    };
    var propsWeControl = this.isWithinPanel ? {
      type: "button",
      onKeydown: this.handleKeyDown,
      onClick: this.handleClick
    } : {
      ref: "el",
      id: api.buttonId,
      type: "button",
      "aria-expanded": this.$props.disabled ? void 0 : api.popoverState.value === PopoverStates.Open,
      "aria-controls": dom(api.panel) ? api.panelId : void 0,
      disabled: this.$props.disabled ? true : void 0,
      onKeydown: this.handleKeyDown,
      onKeyup: this.handleKeyUp,
      onClick: this.handleClick
    };
    return render$k({
      props: _extends$1({}, this.$props, propsWeControl),
      slot,
      attrs: this.$attrs,
      slots: this.$slots,
      name: "PopoverButton"
    });
  },
  setup: function setup22(props) {
    var api = usePopoverContext("PopoverButton");
    var groupContext = usePopoverGroupContext();
    var closeOthers = groupContext == null ? void 0 : groupContext.closeOthers;
    var panelContext = usePopoverPanelContext();
    var isWithinPanel = panelContext === null ? false : panelContext === api.panelId;
    var activeElementRef = ref(null);
    var previousActiveElementRef = ref(typeof window === "undefined" ? null : document.activeElement);
    useWindowEvent("focus", function() {
      previousActiveElementRef.value = activeElementRef.value;
      activeElementRef.value = document.activeElement;
    }, true);
    return {
      isWithinPanel,
      el: isWithinPanel ? null : api.button,
      handleKeyDown: function handleKeyDown(event) {
        var _dom6, _dom7;
        if (isWithinPanel) {
          if (api.popoverState.value === PopoverStates.Closed)
            return;
          switch (event.key) {
            case Keys.Space:
            case Keys.Enter:
              event.preventDefault();
              event.stopPropagation();
              api.closePopover();
              (_dom6 = dom(api.button)) == null ? void 0 : _dom6.focus();
              break;
          }
        } else {
          switch (event.key) {
            case Keys.Space:
            case Keys.Enter:
              event.preventDefault();
              event.stopPropagation();
              if (api.popoverState.value === PopoverStates.Closed)
                closeOthers == null ? void 0 : closeOthers(api.buttonId);
              api.togglePopover();
              break;
            case Keys.Escape:
              if (api.popoverState.value !== PopoverStates.Open)
                return closeOthers == null ? void 0 : closeOthers(api.buttonId);
              if (!dom(api.button))
                return;
              if (!((_dom7 = dom(api.button)) == null ? void 0 : _dom7.contains(document.activeElement)))
                return;
              api.closePopover();
              break;
            case Keys.Tab:
              if (api.popoverState.value !== PopoverStates.Open)
                return;
              if (!api.panel)
                return;
              if (!api.button)
                return;
              if (event.shiftKey) {
                var _dom8, _dom9;
                if (!previousActiveElementRef.value)
                  return;
                if ((_dom8 = dom(api.button)) == null ? void 0 : _dom8.contains(previousActiveElementRef.value))
                  return;
                if ((_dom9 = dom(api.panel)) == null ? void 0 : _dom9.contains(previousActiveElementRef.value))
                  return;
                var focusableElements = getFocusableElements();
                var previousIdx = focusableElements.indexOf(previousActiveElementRef.value);
                var buttonIdx = focusableElements.indexOf(dom(api.button));
                if (buttonIdx > previousIdx)
                  return;
                event.preventDefault();
                event.stopPropagation();
                focusIn(dom(api.panel), Focus.Last);
              } else {
                event.preventDefault();
                event.stopPropagation();
                focusIn(dom(api.panel), Focus.First);
              }
              break;
          }
        }
      },
      handleKeyUp: function handleKeyUp(event) {
        var _dom10, _dom11;
        if (isWithinPanel)
          return;
        if (event.key === Keys.Space) {
          event.preventDefault();
        }
        if (api.popoverState.value !== PopoverStates.Open)
          return;
        if (!api.panel)
          return;
        if (!api.button)
          return;
        switch (event.key) {
          case Keys.Tab:
            if (!previousActiveElementRef.value)
              return;
            if ((_dom10 = dom(api.button)) == null ? void 0 : _dom10.contains(previousActiveElementRef.value))
              return;
            if ((_dom11 = dom(api.panel)) == null ? void 0 : _dom11.contains(previousActiveElementRef.value))
              return;
            var focusableElements = getFocusableElements();
            var previousIdx = focusableElements.indexOf(previousActiveElementRef.value);
            var buttonIdx = focusableElements.indexOf(dom(api.button));
            if (buttonIdx > previousIdx)
              return;
            event.preventDefault();
            event.stopPropagation();
            focusIn(dom(api.panel), Focus.Last);
            break;
        }
      },
      handleClick: function handleClick() {
        if (props.disabled)
          return;
        if (isWithinPanel) {
          var _dom12;
          api.closePopover();
          (_dom12 = dom(api.button)) == null ? void 0 : _dom12.focus();
        } else {
          var _dom13;
          if (api.popoverState.value === PopoverStates.Closed)
            closeOthers == null ? void 0 : closeOthers(api.buttonId);
          (_dom13 = dom(api.button)) == null ? void 0 : _dom13.focus();
          api.togglePopover();
        }
      },
      handleFocus: function handleFocus() {
      }
    };
  }
});
var PopoverPanel = /* @__PURE__ */ defineComponent({
  name: "PopoverPanel",
  props: {
    as: {
      type: [Object, String],
      "default": "div"
    },
    "static": {
      type: Boolean,
      "default": false
    },
    unmount: {
      type: Boolean,
      "default": true
    },
    focus: {
      type: Boolean,
      "default": false
    }
  },
  render: function render$115() {
    var api = usePopoverContext("PopoverPanel");
    var slot = {
      open: api.popoverState.value === PopoverStates.Open,
      close: api.close
    };
    var propsWeControl = {
      ref: "el",
      id: this.id,
      onKeydown: this.handleKeyDown
    };
    return render$k({
      props: _extends$1({}, this.$props, propsWeControl),
      slot,
      attrs: this.$attrs,
      slots: this.$slots,
      features: Features.RenderStrategy | Features.Static,
      visible: this.visible,
      name: "PopoverPanel"
    });
  },
  setup: function setup24(props) {
    var focus = props.focus;
    var api = usePopoverContext("PopoverPanel");
    provide(PopoverPanelContext, api.panelId);
    onUnmounted(function() {
      api.panel.value = null;
    });
    watchEffect(function() {
      var _dom14;
      if (!focus)
        return;
      if (api.popoverState.value !== PopoverStates.Open)
        return;
      if (!api.panel)
        return;
      var activeElement = document.activeElement;
      if ((_dom14 = dom(api.panel)) == null ? void 0 : _dom14.contains(activeElement))
        return;
      focusIn(dom(api.panel), Focus.First);
    });
    useWindowEvent("keydown", function(event) {
      var _dom15;
      if (api.popoverState.value !== PopoverStates.Open)
        return;
      if (!dom(api.panel))
        return;
      if (event.key !== Keys.Tab)
        return;
      if (!document.activeElement)
        return;
      if (!((_dom15 = dom(api.panel)) == null ? void 0 : _dom15.contains(document.activeElement)))
        return;
      event.preventDefault();
      var result = focusIn(dom(api.panel), event.shiftKey ? Focus.Previous : Focus.Next);
      if (result === FocusResult.Underflow) {
        var _dom16;
        return (_dom16 = dom(api.button)) == null ? void 0 : _dom16.focus();
      } else if (result === FocusResult.Overflow) {
        if (!dom(api.button))
          return;
        var elements = getFocusableElements();
        var buttonIdx = elements.indexOf(dom(api.button));
        var nextElements = elements.splice(buttonIdx + 1).filter(function(element) {
          var _dom17;
          return !((_dom17 = dom(api.panel)) == null ? void 0 : _dom17.contains(element));
        });
        if (focusIn(nextElements, Focus.First) === FocusResult.Error) {
          focusIn(document.body, Focus.First);
        }
      }
    });
    useWindowEvent("focus", function() {
      var _dom18;
      if (!focus)
        return;
      if (api.popoverState.value !== PopoverStates.Open)
        return;
      if (!dom(api.panel))
        return;
      if ((_dom18 = dom(api.panel)) == null ? void 0 : _dom18.contains(document.activeElement))
        return;
      api.closePopover();
    }, true);
    var usesOpenClosedState = useOpenClosed();
    var visible = computed(function() {
      if (usesOpenClosedState !== null) {
        return usesOpenClosedState.value === State.Open;
      }
      return api.popoverState.value === PopoverStates.Open;
    });
    return {
      id: api.panelId,
      el: api.panel,
      handleKeyDown: function handleKeyDown(event) {
        var _dom19, _dom20;
        switch (event.key) {
          case Keys.Escape:
            if (api.popoverState.value !== PopoverStates.Open)
              return;
            if (!dom(api.panel))
              return;
            if (!((_dom19 = dom(api.panel)) == null ? void 0 : _dom19.contains(document.activeElement)))
              return;
            event.preventDefault();
            api.closePopover();
            (_dom20 = dom(api.button)) == null ? void 0 : _dom20.focus();
            break;
        }
      },
      visible
    };
  }
});
var OptionState;
(function(OptionState2) {
  OptionState2[OptionState2["Empty"] = 1] = "Empty";
  OptionState2[OptionState2["Active"] = 2] = "Active";
})(OptionState || (OptionState = {}));
var Reason;
(function(Reason2) {
  Reason2["Finished"] = "finished";
  Reason2["Cancelled"] = "cancelled";
})(Reason || (Reason = {}));
var TreeStates;
(function(TreeStates2) {
  TreeStates2["Visible"] = "visible";
  TreeStates2["Hidden"] = "hidden";
})(TreeStates || (TreeStates = {}));
Features.RenderStrategy;
const _hoisted_1$s = { class: "bg-white rounded-t flex border-b-[1px] border-b-gray-100 min-h-[56px] px-[24px] top-0 z-1 sticky items-center justify-between" };
const _hoisted_2$q = /* @__PURE__ */ createBaseVNode("span", { class: "border-t border-t-gray-100 h-[6px] mx-[8px] w-[32px] inline-block" }, null, -1);
const _hoisted_3$m = { class: "group-hocus:underline" };
const _hoisted_4$d = ["aria-label"];
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "StandardModalHeader",
  props: {
    helpLink: null,
    helpText: null,
    noHelp: { type: Boolean, default: false }
  },
  emits: ["close"],
  setup(__props) {
    const { t: t2 } = useI18n();
    return (_ctx, _cache) => {
      const _component_i_cy_circle_bg_question_mark_x16 = __unplugin_components_0$3;
      const _component_i_cy_delete_x12 = __unplugin_components_2;
      return openBlock(), createElementBlock("div", _hoisted_1$s, [
        createBaseVNode("div", null, [
          createVNode(unref(DialogTitle), { class: "text-gray-900 text-[18px] inline-block" }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }),
          !__props.noHelp ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            _hoisted_2$q,
            createVNode(_sfc_main$z, {
              href: __props.helpLink,
              class: "outline-transparent text-indigo-500 text-[16px] group"
            }, {
              default: withCtx(() => [
                createBaseVNode("span", _hoisted_3$m, toDisplayString$1(__props.helpText), 1)
              ]),
              _: 1
            }, 8, ["href"]),
            createVNode(_component_i_cy_circle_bg_question_mark_x16, { class: "ml-[8px] -top-[2px] relative inline-block icon-dark-indigo-500 icon-light-indigo-100" })
          ], 64)) : createCommentVNode("", true)
        ]),
        createBaseVNode("button", {
          "aria-label": unref(t2)(`actions.close`),
          class: "border-transparent rounded-full outline-none border group",
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
        }, [
          createVNode(_component_i_cy_delete_x12, { class: "h-[12px] w-[12px] icon-dark-gray-400 group-hocus:icon-dark-indigo-400 children:transition-all" })
        ], 8, _hoisted_4$d)
      ]);
    };
  }
});
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement$1(placement) {
  return ["top", "bottom"].includes(getBasePlacement$1(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref) {
  let {
    reference: reference2,
    floating,
    placement
  } = _ref;
  const commonX = reference2.x + reference2.width / 2 - floating.width / 2;
  const commonY = reference2.y + reference2.height / 2 - floating.height / 2;
  let coords;
  switch (getBasePlacement$1(placement)) {
    case "top":
      coords = {
        x: commonX,
        y: reference2.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case "right":
      coords = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference2.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference2.x,
        y: reference2.y
      };
  }
  const mainAxis = getMainAxisFromPlacement$1(placement);
  const length2 = getLengthFromAxis(mainAxis);
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] = coords[mainAxis] - (reference2[length2] / 2 - floating[length2] / 2);
      break;
    case "end":
      coords[mainAxis] = coords[mainAxis] + (reference2[length2] / 2 - floating[length2] / 2);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference2, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  let rects = await platform2.getElementRects({
    reference: reference2,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement({
    ...rects,
    placement
  });
  let statefulPlacement = placement;
  let middlewareData = {};
  for (let i = 0; i < middleware.length; i++) {
    const {
      name: name2,
      fn: fn2
    } = middleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference: reference2,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name2]: data != null ? data : {}
    };
    if (reset) {
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference: reference2,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement({
          ...rects,
          placement: statefulPlacement
        }));
      }
      i = -1;
      continue;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect$1(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
async function detectOverflow$1(middlewareArguments, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingParents",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options2;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = await platform2.getClippingClientRect({
    element: await platform2.isElement(element) ? element : element.contextElement || await platform2.getDocumentElement({
      element: elements.floating
    }),
    boundary,
    rootBoundary
  });
  const elementClientRect = rectToClientRect$1(await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? {
      ...rects.floating,
      x: x2,
      y: y2
    } : rects.reference,
    offsetParent: await platform2.getOffsetParent({
      element: elements.floating
    }),
    strategy
  }));
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
const min$2 = Math.min;
const max$2 = Math.max;
function within$1(min$12, value, max$12) {
  return max$2(min$12, min$2(value, max$12));
}
const arrow$2 = (options2) => ({
  name: "arrow",
  options: options2,
  async fn(middlewareArguments) {
    const {
      element,
      padding = 0
    } = options2 != null ? options2 : {};
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2
    } = middlewareArguments;
    if (element == null) {
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const basePlacement = getBasePlacement$1(placement);
    const axis = getMainAxisFromPlacement$1(basePlacement);
    const length2 = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions({
      element
    });
    const minProp = axis === "y" ? "top" : "left";
    const maxProp = axis === "y" ? "bottom" : "right";
    const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await platform2.getOffsetParent({
      element
    });
    const clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min2 = paddingObject[minProp];
    const max2 = clientSize - arrowDimensions[length2] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
    const offset2 = within$1(min2, center, max2);
    return {
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
const hash$1$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement$1(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1$1[matched]);
}
function getAlignmentSides(placement, rects) {
  const isStart = getAlignment(placement) === "start";
  const mainAxis = getMainAxisFromPlacement$1(placement);
  const length2 = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? isStart ? "right" : "left" : isStart ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement$1(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement$1(mainAlignmentSide)
  };
}
const hash$2 = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash$2[matched]);
}
const basePlacements$1 = ["top", "right", "bottom", "left"];
const allPlacements = /* @__PURE__ */ basePlacements$1.reduce((acc, basePlacement) => acc.concat(basePlacement, basePlacement + "-start", basePlacement + "-end"), []);
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getBasePlacement$1(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
const autoPlacement = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "autoPlacement",
    options: options2,
    async fn(middlewareArguments) {
      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _middlewareData$autoP5, _placementsSortedByLe;
      const {
        x: x2,
        y: y2,
        rects,
        middlewareData,
        placement
      } = middlewareArguments;
      const {
        alignment = null,
        allowedPlacements = allPlacements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = options2;
      if ((_middlewareData$autoP = middlewareData.autoPlacement) != null && _middlewareData$autoP.skip) {
        return {};
      }
      const placements2 = getPlacementList(alignment, autoAlignment, allowedPlacements);
      const overflow = await detectOverflow$1(middlewareArguments, detectOverflowOptions);
      const currentIndex = (_middlewareData$autoP2 = (_middlewareData$autoP3 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP3.index) != null ? _middlewareData$autoP2 : 0;
      const currentPlacement = placements2[currentIndex];
      const {
        main: main2,
        cross
      } = getAlignmentSides(currentPlacement, rects);
      if (placement !== currentPlacement) {
        return {
          x: x2,
          y: y2,
          reset: {
            placement: placements2[0]
          }
        };
      }
      const currentOverflows = [overflow[getBasePlacement$1(currentPlacement)], overflow[main2], overflow[cross]];
      const allOverflows = [...(_middlewareData$autoP4 = (_middlewareData$autoP5 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP5.overflows) != null ? _middlewareData$autoP4 : [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements2[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a2, b2) => a2.overflows[0] - b2.overflows[0]);
      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref) => {
        let {
          overflows
        } = _ref;
        return overflows.every((overflow2) => overflow2 <= 0);
      })) == null ? void 0 : _placementsSortedByLe.placement;
      return {
        data: {
          skip: true
        },
        reset: {
          placement: placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement
        }
      };
    }
  };
};
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement$1(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
const flip$2 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "flip",
    options: options2,
    async fn(middlewareArguments) {
      var _middlewareData$flip, _middlewareData$flip2;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement
      } = middlewareArguments;
      if ((_middlewareData$flip = middlewareData.flip) != null && _middlewareData$flip.skip) {
        return {};
      }
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true,
        ...detectOverflowOptions
      } = options2;
      const basePlacement = getBasePlacement$1(placement);
      const isBasePlacement = basePlacement === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement$1(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow$1(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[basePlacement]);
      }
      if (checkCrossAxis) {
        const {
          main: main2,
          cross
        } = getAlignmentSides(placement, rects);
        overflows.push(overflow[main2], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side) => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip3;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip3 = middlewareData.flip) == null ? void 0 : _middlewareData$flip3.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$slice$;
            const placement2 = (_overflowsData$slice$ = overflowsData.slice().sort((a2, b2) => a2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0) - b2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        return {
          data: {
            skip: true
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function convertValueToCoords(_ref) {
  let {
    placement,
    rects,
    value
  } = _ref;
  const basePlacement = getBasePlacement$1(placement);
  const multiplier = ["left", "top"].includes(basePlacement) ? -1 : 1;
  const rawValue = typeof value === "function" ? value({
    ...rects,
    placement
  }) : value;
  const {
    mainAxis,
    crossAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0
  } : {
    mainAxis: 0,
    crossAxis: 0,
    ...rawValue
  };
  return getMainAxisFromPlacement$1(basePlacement) === "x" ? {
    x: crossAxis,
    y: mainAxis * multiplier
  } : {
    x: mainAxis * multiplier,
    y: crossAxis
  };
}
const offset$2 = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement,
        rects
      } = middlewareArguments;
      const diffCoords = convertValueToCoords({
        placement,
        rects,
        value
      });
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
const shift = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "shift",
    options: options2,
    async fn(middlewareArguments) {
      const {
        x: x2,
        y: y2,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x22,
              y: y22
            } = _ref;
            return {
              x: x22,
              y: y22
            };
          }
        },
        ...detectOverflowOptions
      } = options2;
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow$1(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement$1(getBasePlacement$1(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
const size = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "size",
    options: options2,
    async fn(middlewareArguments) {
      var _middlewareData$size;
      const {
        placement,
        rects,
        middlewareData
      } = middlewareArguments;
      const {
        apply: apply2,
        ...detectOverflowOptions
      } = options2;
      if ((_middlewareData$size = middlewareData.size) != null && _middlewareData$size.skip) {
        return {};
      }
      const overflow = await detectOverflow$1(middlewareArguments, detectOverflowOptions);
      const basePlacement = getBasePlacement$1(placement);
      const isEnd = getAlignment(placement) === "end";
      let heightSide;
      let widthSide;
      if (basePlacement === "top" || basePlacement === "bottom") {
        heightSide = basePlacement;
        widthSide = isEnd ? "left" : "right";
      } else {
        widthSide = basePlacement;
        heightSide = isEnd ? "top" : "bottom";
      }
      const xMin = max$2(overflow.left, 0);
      const xMax = max$2(overflow.right, 0);
      const yMin = max$2(overflow.top, 0);
      const yMax = max$2(overflow.bottom, 0);
      const dimensions = {
        height: rects.floating.height - (["left", "right"].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max$2(overflow.top, overflow.bottom)) : overflow[heightSide]),
        width: rects.floating.width - (["top", "bottom"].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max$2(overflow.left, overflow.right)) : overflow[widthSide])
      };
      apply2 == null ? void 0 : apply2({
        ...dimensions,
        ...rects
      });
      return {
        data: {
          skip: true
        },
        reset: {
          rects: true
        }
      };
    }
  };
};
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getWindow$1(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function getNodeName$1(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function isHTMLElement$1(value) {
  return value instanceof getWindow$1(value).HTMLElement;
}
function isElement$1(value) {
  return value instanceof getWindow$1(value).Element;
}
function isNode(value) {
  return value instanceof getWindow$1(value).Node;
}
function isShadowRoot$1(node) {
  const OwnElement = getWindow$1(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isScrollParent$1(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement$1(element) {
  return ["table", "td", "th"].includes(getNodeName$1(element));
}
function isContainingBlock(element) {
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
  const css = getComputedStyle$1$1(element);
  return css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false);
}
const min$1 = Math.min;
const max$1 = Math.max;
const round$1 = Math.round;
function getBoundingClientRect$1(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  return {
    width: clientRect.width / scaleX,
    height: clientRect.height / scaleY,
    top: clientRect.top / scaleY,
    right: clientRect.right / scaleX,
    bottom: clientRect.bottom / scaleY,
    left: clientRect.left / scaleX,
    x: clientRect.left / scaleX,
    y: clientRect.top / scaleY
  };
}
function getDocumentElement$1(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll$1(element) {
  if (isWindow(element)) {
    return {
      scrollLeft: element.pageXOffset,
      scrollTop: element.pageYOffset
    };
  }
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getWindowScrollBarX$1(element) {
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getNodeScroll$1(element).scrollLeft;
}
function isScaled(element) {
  const rect = getBoundingClientRect$1(element);
  return round$1(rect.width) !== element.offsetWidth || round$1(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement$1(offsetParent);
  const rect = getBoundingClientRect$1(element, isOffsetParentAnElement && isScaled(offsetParent));
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName$1(offsetParent) !== "body" || isScrollParent$1(documentElement)) {
      scroll = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect$1(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX$1(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode$1(node) {
  if (getNodeName$1(node) === "html") {
    return node;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // @ts-ignore
    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    node.parentNode || // DOM Element detected
    (isShadowRoot$1(node) ? node.host : null) || // ShadowRoot detected
    getDocumentElement$1(node)
  );
}
function getTrueOffsetParent$1(element) {
  if (!isHTMLElement$1(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock$1(element) {
  let currentNode = getParentNode$1(element);
  while (isHTMLElement$1(currentNode) && !["html", "body"].includes(getNodeName$1(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent$1(element) {
  const window2 = getWindow$1(element);
  let offsetParent = getTrueOffsetParent$1(element);
  while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent$1(offsetParent);
  }
  if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock$1(element) || window2;
}
function getDimensions(element) {
  return {
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement$1(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName$1(offsetParent) !== "body" || isScrollParent$1(documentElement)) {
      scroll = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect$1(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    ...rect,
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  };
}
function getViewportRect$1(element) {
  const win = getWindow$1(element);
  const html = getDocumentElement$1(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getDocumentRect$1(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement$1(element);
  const scroll = getNodeScroll$1(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX$1(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1$1(body || html).direction === "rtl") {
    x2 += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getScrollParent$1(node) {
  if (["html", "body", "#document"].includes(getNodeName$1(node))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement$1(node) && isScrollParent$1(node)) {
    return node;
  }
  return getScrollParent$1(getParentNode$1(node));
}
function getScrollParents(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollParent = getScrollParent$1(node);
  const isBody = scrollParent === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow$1(scrollParent);
  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent$1(scrollParent) ? scrollParent : []) : scrollParent;
  const updatedList = list.concat(target);
  return isBody ? updatedList : (
    // @ts-ignore: isBody tells us target will be an HTMLElement here
    updatedList.concat(getScrollParents(getParentNode$1(target)))
  );
}
function contains$1(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot$1(rootNode)) {
    let next = child;
    do {
      if (next && parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect$1(element) {
  const clientRect = getBoundingClientRect$1(element);
  const top2 = clientRect.top + element.clientTop;
  const left2 = clientRect.left + element.clientLeft;
  return {
    top: top2,
    left: left2,
    x: left2,
    y: top2,
    right: left2 + element.clientWidth,
    bottom: top2 + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingParent(element, clippingParent) {
  if (clippingParent === "viewport") {
    return rectToClientRect$1(getViewportRect$1(element));
  }
  if (isElement$1(clippingParent)) {
    return getInnerBoundingClientRect$1(clippingParent);
  }
  return rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(element)));
}
function getClippingParents$1(element) {
  const clippingParents2 = getScrollParents(getParentNode$1(element));
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent$1(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter((clippingParent) => isElement$1(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== "body");
}
function getClippingClientRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary
  } = _ref;
  const mainClippingParents = boundary === "clippingParents" ? getClippingParents$1(element) : [].concat(boundary);
  const clippingParents2 = [...mainClippingParents, rootBoundary];
  const firstClippingParent = clippingParents2[0];
  const clippingRect = clippingParents2.reduce((accRect, clippingParent) => {
    const rect = getClientRectFromClippingParent(element, clippingParent);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingParent(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
const platform = {
  getElementRects: (_ref) => {
    let {
      reference: reference2,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference2, getOffsetParent$1(floating), strategy),
      floating: {
        ...getDimensions(floating),
        x: 0,
        y: 0
      }
    };
  },
  convertOffsetParentRelativeRectToViewportRelativeRect: (args) => convertOffsetParentRelativeRectToViewportRelativeRect(args),
  getOffsetParent: (_ref2) => {
    let {
      element
    } = _ref2;
    return getOffsetParent$1(element);
  },
  isElement: (value) => isElement$1(value),
  getDocumentElement: (_ref3) => {
    let {
      element
    } = _ref3;
    return getDocumentElement$1(element);
  },
  getClippingClientRect: (args) => getClippingClientRect(args),
  getDimensions: (_ref4) => {
    let {
      element
    } = _ref4;
    return getDimensions(element);
  },
  getClientRects: (_ref5) => {
    let {
      element
    } = _ref5;
    return element.getClientRects();
  }
};
const computePosition = (reference2, floating, options2) => computePosition$1(reference2, floating, {
  platform,
  ...options2
});
var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
const config$1 = {
  disabled: false,
  distance: 5,
  skidding: 0,
  container: "body",
  boundary: void 0,
  instantMove: false,
  disposeTimeout: 5e3,
  popperTriggers: [],
  strategy: "absolute",
  preventOverflow: true,
  flip: true,
  shift: true,
  overflowPadding: 0,
  arrowPadding: 0,
  arrowOverflow: true,
  themes: {
    tooltip: {
      placement: "top",
      triggers: ["hover", "focus", "touch"],
      hideTriggers: (events2) => [...events2, "click"],
      delay: {
        show: 200,
        hide: 0
      },
      handleResize: false,
      html: false,
      loadingContent: "..."
    },
    dropdown: {
      placement: "bottom",
      triggers: ["click"],
      delay: 0,
      handleResize: true,
      autoHide: true
    },
    menu: {
      $extend: "dropdown",
      triggers: ["hover", "focus"],
      popperTriggers: ["hover", "focus"],
      delay: {
        show: 0,
        hide: 400
      }
    }
  }
};
function getDefaultConfig(theme, key) {
  let themeConfig = config$1.themes[theme] || {};
  let value;
  do {
    value = themeConfig[key];
    if (typeof value === "undefined") {
      if (themeConfig.$extend) {
        themeConfig = config$1.themes[themeConfig.$extend] || {};
      } else {
        themeConfig = null;
        value = config$1[key];
      }
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return value;
}
function getThemeClasses(theme) {
  const result = [theme];
  let themeConfig = config$1.themes[theme] || {};
  do {
    if (themeConfig.$extend && !themeConfig.$resetCss) {
      result.push(themeConfig.$extend);
      themeConfig = config$1.themes[themeConfig.$extend] || {};
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return result.map((c2) => `v-popper--theme-${c2}`);
}
function getAllParentThemes(theme) {
  const result = [theme];
  let themeConfig = config$1.themes[theme] || {};
  do {
    if (themeConfig.$extend) {
      result.push(themeConfig.$extend);
      themeConfig = config$1.themes[themeConfig.$extend] || {};
    } else {
      themeConfig = null;
    }
  } while (themeConfig);
  return result;
}
let supportsPassive = false;
if (typeof window !== "undefined") {
  supportsPassive = false;
  try {
    const opts = Object.defineProperty({}, "passive", {
      get() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e) {
  }
}
let isIOS = false;
if (typeof window !== "undefined" && typeof navigator !== "undefined") {
  isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}
const placements$1 = ["auto", "top", "bottom", "left", "right"].reduce((acc, base) => acc.concat([
  base,
  `${base}-start`,
  `${base}-end`
]), []);
const SHOW_EVENT_MAP = {
  hover: "mouseenter",
  focus: "focus",
  click: "click",
  touch: "touchstart"
};
const HIDE_EVENT_MAP = {
  hover: "mouseleave",
  focus: "blur",
  click: "click",
  touch: "touchend"
};
function removeFromArray(array, item) {
  const index = array.indexOf(item);
  if (index !== -1) {
    array.splice(index, 1);
  }
}
function nextFrame() {
  return new Promise((resolve3) => requestAnimationFrame(() => {
    requestAnimationFrame(resolve3);
  }));
}
const shownPoppers = [];
let hidingPopper = null;
const shownPoppersByTheme = {};
function getShownPoppersByTheme(theme) {
  let list = shownPoppersByTheme[theme];
  if (!list) {
    list = shownPoppersByTheme[theme] = [];
  }
  return list;
}
let Element$1 = function() {
};
if (typeof window !== "undefined") {
  Element$1 = window.Element;
}
function defaultPropFactory(prop) {
  return function(props) {
    return getDefaultConfig(props.theme, prop);
  };
}
const PROVIDE_KEY = "__floating-vue__popper";
var PrivatePopper = () => defineComponent({
  name: "VPopper",
  provide() {
    return {
      [PROVIDE_KEY]: {
        parentPopper: this
      }
    };
  },
  inject: {
    [PROVIDE_KEY]: { default: null }
  },
  props: {
    theme: {
      type: String,
      required: true
    },
    targetNodes: {
      type: Function,
      required: true
    },
    referenceNode: {
      type: Function,
      required: true
    },
    popperNode: {
      type: Function,
      required: true
    },
    shown: {
      type: Boolean,
      default: false
    },
    showGroup: {
      type: String,
      default: null
    },
    ariaId: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: defaultPropFactory("disabled")
    },
    positioningDisabled: {
      type: Boolean,
      default: defaultPropFactory("positioningDisabled")
    },
    placement: {
      type: String,
      default: defaultPropFactory("placement"),
      validator: (value) => placements$1.includes(value)
    },
    delay: {
      type: [String, Number, Object],
      default: defaultPropFactory("delay")
    },
    distance: {
      type: [Number, String],
      default: defaultPropFactory("distance")
    },
    skidding: {
      type: [Number, String],
      default: defaultPropFactory("skidding")
    },
    triggers: {
      type: Array,
      default: defaultPropFactory("triggers")
    },
    showTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("showTriggers")
    },
    hideTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("hideTriggers")
    },
    popperTriggers: {
      type: Array,
      default: defaultPropFactory("popperTriggers")
    },
    popperShowTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("popperShowTriggers")
    },
    popperHideTriggers: {
      type: [Array, Function],
      default: defaultPropFactory("popperHideTriggers")
    },
    container: {
      type: [String, Object, Element$1, Boolean],
      default: defaultPropFactory("container")
    },
    boundary: {
      type: [String, Element$1],
      default: defaultPropFactory("boundary")
    },
    strategy: {
      type: String,
      validator: (value) => ["absolute", "fixed"].includes(value),
      default: defaultPropFactory("strategy")
    },
    autoHide: {
      type: [Boolean, Function],
      default: defaultPropFactory("autoHide")
    },
    handleResize: {
      type: Boolean,
      default: defaultPropFactory("handleResize")
    },
    instantMove: {
      type: Boolean,
      default: defaultPropFactory("instantMove")
    },
    eagerMount: {
      type: Boolean,
      default: defaultPropFactory("eagerMount")
    },
    popperClass: {
      type: [String, Array, Object],
      default: defaultPropFactory("popperClass")
    },
    computeTransformOrigin: {
      type: Boolean,
      default: defaultPropFactory("computeTransformOrigin")
    },
    autoMinSize: {
      type: Boolean,
      default: defaultPropFactory("autoMinSize")
    },
    autoSize: {
      type: [Boolean, String],
      default: defaultPropFactory("autoSize")
    },
    autoMaxSize: {
      type: Boolean,
      default: defaultPropFactory("autoMaxSize")
    },
    autoBoundaryMaxSize: {
      type: Boolean,
      default: defaultPropFactory("autoBoundaryMaxSize")
    },
    preventOverflow: {
      type: Boolean,
      default: defaultPropFactory("preventOverflow")
    },
    overflowPadding: {
      type: [Number, String],
      default: defaultPropFactory("overflowPadding")
    },
    arrowPadding: {
      type: [Number, String],
      default: defaultPropFactory("arrowPadding")
    },
    arrowOverflow: {
      type: Boolean,
      default: defaultPropFactory("arrowOverflow")
    },
    flip: {
      type: Boolean,
      default: defaultPropFactory("flip")
    },
    shift: {
      type: Boolean,
      default: defaultPropFactory("shift")
    },
    shiftCrossAxis: {
      type: Boolean,
      default: defaultPropFactory("shiftCrossAxis")
    }
  },
  emits: [
    "show",
    "hide",
    "update:shown",
    "apply-show",
    "apply-hide",
    "close-group",
    "close-directive",
    "auto-hide",
    "resize",
    "dispose"
  ],
  data() {
    return {
      isShown: false,
      isMounted: false,
      skipTransition: false,
      classes: {
        showFrom: false,
        showTo: false,
        hideFrom: false,
        hideTo: true
      },
      result: {
        x: 0,
        y: 0,
        placement: "",
        strategy: this.strategy,
        arrow: {
          x: 0,
          y: 0,
          centerOffset: 0
        },
        transformOrigin: null
      },
      shownChildren: /* @__PURE__ */ new Set(),
      lastAutoHide: true
    };
  },
  computed: {
    popperId() {
      return this.ariaId != null ? this.ariaId : this.randomId;
    },
    shouldMountContent() {
      return this.eagerMount || this.isMounted;
    },
    slotData() {
      return {
        popperId: this.popperId,
        isShown: this.isShown,
        shouldMountContent: this.shouldMountContent,
        skipTransition: this.skipTransition,
        autoHide: typeof this.autoHide === "function" ? this.lastAutoHide : this.autoHide,
        show: this.show,
        hide: this.hide,
        handleResize: this.handleResize,
        onResize: this.onResize,
        classes: __spreadProps(__spreadValues({}, this.classes), {
          popperClass: this.popperClass
        }),
        result: this.positioningDisabled ? null : this.result,
        attrs: this.$attrs
      };
    },
    parentPopper() {
      var _a2;
      return (_a2 = this[PROVIDE_KEY]) == null ? void 0 : _a2.parentPopper;
    },
    hasPopperShowTriggerHover() {
      var _a2, _b2;
      return ((_a2 = this.popperTriggers) == null ? void 0 : _a2.includes("hover")) || ((_b2 = this.popperShowTriggers) == null ? void 0 : _b2.includes("hover"));
    }
  },
  watch: __spreadValues(__spreadValues({
    shown: "$_autoShowHide",
    disabled(value) {
      if (value) {
        this.dispose();
      } else {
        this.init();
      }
    },
    async container() {
      if (this.isShown) {
        this.$_ensureTeleport();
        await this.$_computePosition();
      }
    }
  }, [
    "triggers",
    "positioningDisabled"
  ].reduce((acc, prop) => {
    acc[prop] = "$_refreshListeners";
    return acc;
  }, {})), [
    "placement",
    "distance",
    "skidding",
    "boundary",
    "strategy",
    "overflowPadding",
    "arrowPadding",
    "preventOverflow",
    "shift",
    "shiftCrossAxis",
    "flip"
  ].reduce((acc, prop) => {
    acc[prop] = "$_computePosition";
    return acc;
  }, {})),
  created() {
    this.$_isDisposed = true;
    this.randomId = `popper_${[Math.random(), Date.now()].map((n) => n.toString(36).substring(2, 10)).join("_")}`;
    if (this.autoMinSize) {
      console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.');
    }
    if (this.autoMaxSize) {
      console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
    }
  },
  mounted() {
    this.init();
    this.$_detachPopperNode();
  },
  activated() {
    this.$_autoShowHide();
  },
  deactivated() {
    this.hide();
  },
  beforeUnmount() {
    this.dispose();
  },
  methods: {
    show({ event = null, skipDelay = false, force = false } = {}) {
      var _a2, _b2;
      if (((_a2 = this.parentPopper) == null ? void 0 : _a2.lockedChild) && this.parentPopper.lockedChild !== this)
        return;
      this.$_pendingHide = false;
      if (force || !this.disabled) {
        if (((_b2 = this.parentPopper) == null ? void 0 : _b2.lockedChild) === this) {
          this.parentPopper.lockedChild = null;
        }
        this.$_scheduleShow(event, skipDelay);
        this.$emit("show");
        this.$_showFrameLocked = true;
        requestAnimationFrame(() => {
          this.$_showFrameLocked = false;
        });
      }
      this.$emit("update:shown", true);
    },
    hide({ event = null, skipDelay = false } = {}) {
      var _a2;
      if (this.$_hideInProgress)
        return;
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        return;
      }
      if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
        if (this.parentPopper) {
          this.parentPopper.lockedChild = this;
          clearTimeout(this.parentPopper.lockedChildTimer);
          this.parentPopper.lockedChildTimer = setTimeout(() => {
            if (this.parentPopper.lockedChild === this) {
              this.parentPopper.lockedChild.hide({ skipDelay });
              this.parentPopper.lockedChild = null;
            }
          }, 1e3);
        }
        return;
      }
      if (((_a2 = this.parentPopper) == null ? void 0 : _a2.lockedChild) === this) {
        this.parentPopper.lockedChild = null;
      }
      this.$_pendingHide = false;
      this.$_scheduleHide(event, skipDelay);
      this.$emit("hide");
      this.$emit("update:shown", false);
    },
    init() {
      if (!this.$_isDisposed)
        return;
      this.$_isDisposed = false;
      this.isMounted = false;
      this.$_events = [];
      this.$_preventShow = false;
      this.$_referenceNode = this.referenceNode();
      this.$_targetNodes = this.targetNodes().filter((e) => e.nodeType === e.ELEMENT_NODE);
      this.$_popperNode = this.popperNode();
      this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner");
      this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container");
      this.$_swapTargetAttrs("title", "data-original-title");
      this.$_detachPopperNode();
      if (this.triggers.length) {
        this.$_addEventListeners();
      }
      if (this.shown) {
        this.show();
      }
    },
    dispose() {
      if (this.$_isDisposed)
        return;
      this.$_isDisposed = true;
      this.$_removeEventListeners();
      this.hide({ skipDelay: true });
      this.$_detachPopperNode();
      this.isMounted = false;
      this.isShown = false;
      this.$_updateParentShownChildren(false);
      this.$_swapTargetAttrs("data-original-title", "title");
      this.$emit("dispose");
    },
    async onResize() {
      if (this.isShown) {
        await this.$_computePosition();
        this.$emit("resize");
      }
    },
    async $_computePosition() {
      var _a2;
      if (this.$_isDisposed || this.positioningDisabled)
        return;
      const options2 = {
        strategy: this.strategy,
        middleware: []
      };
      if (this.distance || this.skidding) {
        options2.middleware.push(offset$2({
          mainAxis: this.distance,
          crossAxis: this.skidding
        }));
      }
      const isPlacementAuto = this.placement.startsWith("auto");
      if (isPlacementAuto) {
        options2.middleware.push(autoPlacement({
          alignment: (_a2 = this.placement.split("-")[1]) != null ? _a2 : ""
        }));
      } else {
        options2.placement = this.placement;
      }
      if (this.preventOverflow) {
        if (this.shift) {
          options2.middleware.push(shift({
            padding: this.overflowPadding,
            boundary: this.boundary,
            crossAxis: this.shiftCrossAxis
          }));
        }
        if (!isPlacementAuto && this.flip) {
          options2.middleware.push(flip$2({
            padding: this.overflowPadding,
            boundary: this.boundary
          }));
        }
      }
      options2.middleware.push(arrow$2({
        element: this.$_arrowNode,
        padding: this.arrowPadding
      }));
      if (this.arrowOverflow) {
        options2.middleware.push({
          name: "arrowOverflow",
          fn: ({ placement, rects, middlewareData }) => {
            let overflow;
            const { centerOffset } = middlewareData.arrow;
            if (placement.startsWith("top") || placement.startsWith("bottom")) {
              overflow = Math.abs(centerOffset) > rects.reference.width / 2;
            } else {
              overflow = Math.abs(centerOffset) > rects.reference.height / 2;
            }
            return {
              data: {
                overflow
              }
            };
          }
        });
      }
      if (this.autoMinSize || this.autoSize) {
        const autoSize = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
        options2.middleware.push({
          name: "autoSize",
          fn: ({ rects, placement, middlewareData }) => {
            var _a22;
            if ((_a22 = middlewareData.autoSize) == null ? void 0 : _a22.skip) {
              return {};
            }
            let width;
            let height;
            if (placement.startsWith("top") || placement.startsWith("bottom")) {
              width = rects.reference.width;
            } else {
              height = rects.reference.height;
            }
            this.$_innerNode.style[autoSize === "min" ? "minWidth" : autoSize === "max" ? "maxWidth" : "width"] = width != null ? `${width}px` : null;
            this.$_innerNode.style[autoSize === "min" ? "minHeight" : autoSize === "max" ? "maxHeight" : "height"] = height != null ? `${height}px` : null;
            return {
              data: {
                skip: true
              },
              reset: {
                rects: true
              }
            };
          }
        });
      }
      if (this.autoMaxSize || this.autoBoundaryMaxSize) {
        this.$_innerNode.style.maxWidth = null;
        this.$_innerNode.style.maxHeight = null;
        options2.middleware.push(size({
          boundary: this.boundary,
          padding: this.overflowPadding,
          apply: ({ width, height }) => {
            this.$_innerNode.style.maxWidth = width != null ? `${width}px` : null;
            this.$_innerNode.style.maxHeight = height != null ? `${height}px` : null;
          }
        }));
      }
      const data = await computePosition(this.$_referenceNode, this.$_popperNode, options2);
      Object.assign(this.result, {
        x: data.x,
        y: data.y,
        placement: data.placement,
        strategy: data.strategy,
        arrow: __spreadValues(__spreadValues({}, data.middlewareData.arrow), data.middlewareData.arrowOverflow)
      });
    },
    $_scheduleShow(event = null, skipDelay = false) {
      this.$_updateParentShownChildren(true);
      this.$_hideInProgress = false;
      clearTimeout(this.$_scheduleTimer);
      if (hidingPopper && this.instantMove && hidingPopper.instantMove && hidingPopper !== this.parentPopper) {
        hidingPopper.$_applyHide(true);
        this.$_applyShow(true);
        return;
      }
      if (skipDelay) {
        this.$_applyShow();
      } else {
        this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
      }
    },
    $_scheduleHide(event = null, skipDelay = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        return;
      }
      this.$_updateParentShownChildren(false);
      this.$_hideInProgress = true;
      clearTimeout(this.$_scheduleTimer);
      if (this.isShown) {
        hidingPopper = this;
      }
      if (skipDelay) {
        this.$_applyHide();
      } else {
        this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
      }
    },
    $_computeDelay(type2) {
      const delay = this.delay;
      return parseInt(delay && delay[type2] || delay || 0);
    },
    async $_applyShow(skipTransition = false) {
      clearTimeout(this.$_disposeTimer);
      clearTimeout(this.$_scheduleTimer);
      this.skipTransition = skipTransition;
      if (this.isShown) {
        return;
      }
      this.$_ensureTeleport();
      await nextFrame();
      await this.$_computePosition();
      await this.$_applyShowEffect();
      if (!this.positioningDisabled) {
        this.$_registerEventListeners([
          ...getScrollParents(this.$_referenceNode),
          ...getScrollParents(this.$_popperNode)
        ], "scroll", () => {
          this.$_computePosition();
        });
      }
    },
    async $_applyShowEffect() {
      if (this.$_hideInProgress)
        return;
      if (this.computeTransformOrigin) {
        const bounds = this.$_referenceNode.getBoundingClientRect();
        const popperWrapper = this.$_popperNode.querySelector(".v-popper__wrapper");
        const parentBounds = popperWrapper.parentNode.getBoundingClientRect();
        const x2 = bounds.x + bounds.width / 2 - (parentBounds.left + popperWrapper.offsetLeft);
        const y2 = bounds.y + bounds.height / 2 - (parentBounds.top + popperWrapper.offsetTop);
        this.result.transformOrigin = `${x2}px ${y2}px`;
      }
      this.isShown = true;
      this.$_applyAttrsToTarget({
        "aria-describedby": this.popperId,
        "data-popper-shown": ""
      });
      const showGroup = this.showGroup;
      if (showGroup) {
        let popover;
        for (let i = 0; i < shownPoppers.length; i++) {
          popover = shownPoppers[i];
          if (popover.showGroup !== showGroup) {
            popover.hide();
            popover.$emit("close-group");
          }
        }
      }
      shownPoppers.push(this);
      document.body.classList.add("v-popper--some-open");
      for (const theme of getAllParentThemes(this.theme)) {
        getShownPoppersByTheme(theme).push(this);
        document.body.classList.add(`v-popper--some-open--${theme}`);
      }
      this.$emit("apply-show");
      this.classes.showFrom = true;
      this.classes.showTo = false;
      this.classes.hideFrom = false;
      this.classes.hideTo = false;
      await nextFrame();
      this.classes.showFrom = false;
      this.classes.showTo = true;
      this.$_popperNode.focus();
    },
    async $_applyHide(skipTransition = false) {
      if (this.shownChildren.size > 0) {
        this.$_pendingHide = true;
        this.$_hideInProgress = false;
        return;
      }
      clearTimeout(this.$_scheduleTimer);
      if (!this.isShown) {
        return;
      }
      this.skipTransition = skipTransition;
      removeFromArray(shownPoppers, this);
      if (shownPoppers.length === 0) {
        document.body.classList.remove("v-popper--some-open");
      }
      for (const theme of getAllParentThemes(this.theme)) {
        const list = getShownPoppersByTheme(theme);
        removeFromArray(list, this);
        if (list.length === 0) {
          document.body.classList.remove(`v-popper--some-open--${theme}`);
        }
      }
      if (hidingPopper === this) {
        hidingPopper = null;
      }
      this.isShown = false;
      this.$_applyAttrsToTarget({
        "aria-describedby": void 0,
        "data-popper-shown": void 0
      });
      clearTimeout(this.$_disposeTimer);
      const disposeTime = getDefaultConfig(this.theme, "disposeTimeout");
      if (disposeTime !== null) {
        this.$_disposeTimer = setTimeout(() => {
          if (this.$_popperNode) {
            this.$_detachPopperNode();
            this.isMounted = false;
          }
        }, disposeTime);
      }
      this.$_removeEventListeners("scroll");
      this.$emit("apply-hide");
      this.classes.showFrom = false;
      this.classes.showTo = false;
      this.classes.hideFrom = true;
      this.classes.hideTo = false;
      await nextFrame();
      this.classes.hideFrom = false;
      this.classes.hideTo = true;
    },
    $_autoShowHide() {
      if (this.shown) {
        this.show();
      } else {
        this.hide();
      }
    },
    $_ensureTeleport() {
      if (this.$_isDisposed)
        return;
      let container = this.container;
      if (typeof container === "string") {
        container = window.document.querySelector(container);
      } else if (container === false) {
        container = this.$_targetNodes[0].parentNode;
      }
      if (!container) {
        throw new Error("No container for popover: " + this.container);
      }
      container.appendChild(this.$_popperNode);
      this.isMounted = true;
    },
    $_addEventListeners() {
      const handleShow = (event) => {
        if (this.isShown && !this.$_hideInProgress) {
          return;
        }
        event.usedByTooltip = true;
        !this.$_preventShow && this.show({ event });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, SHOW_EVENT_MAP, this.triggers, this.showTriggers, handleShow);
      this.$_registerTriggerListeners([this.$_popperNode], SHOW_EVENT_MAP, this.popperTriggers, this.popperShowTriggers, handleShow);
      const handleHide = (event) => {
        if (event.usedByTooltip) {
          return;
        }
        this.hide({ event });
      };
      this.$_registerTriggerListeners(this.$_targetNodes, HIDE_EVENT_MAP, this.triggers, this.hideTriggers, handleHide);
      this.$_registerTriggerListeners([this.$_popperNode], HIDE_EVENT_MAP, this.popperTriggers, this.popperHideTriggers, handleHide);
    },
    $_registerEventListeners(targetNodes, eventType, handler) {
      this.$_events.push({ targetNodes, eventType, handler });
      targetNodes.forEach((node) => node.addEventListener(eventType, handler, supportsPassive ? {
        passive: true
      } : void 0));
    },
    $_registerTriggerListeners(targetNodes, eventMap, commonTriggers, customTrigger, handler) {
      let triggers = commonTriggers;
      if (customTrigger != null) {
        triggers = typeof customTrigger === "function" ? customTrigger(triggers) : customTrigger;
      }
      triggers.forEach((trigger2) => {
        const eventType = eventMap[trigger2];
        if (eventType) {
          this.$_registerEventListeners(targetNodes, eventType, handler);
        }
      });
    },
    $_removeEventListeners(filterEventType) {
      const newList = [];
      this.$_events.forEach((listener) => {
        const { targetNodes, eventType, handler } = listener;
        if (!filterEventType || filterEventType === eventType) {
          targetNodes.forEach((node) => node.removeEventListener(eventType, handler));
        } else {
          newList.push(listener);
        }
      });
      this.$_events = newList;
    },
    $_refreshListeners() {
      if (!this.$_isDisposed) {
        this.$_removeEventListeners();
        this.$_addEventListeners();
      }
    },
    $_handleGlobalClose(event, touch = false) {
      if (this.$_showFrameLocked)
        return;
      this.hide({ event });
      if (event.closePopover) {
        this.$emit("close-directive");
      } else {
        this.$emit("auto-hide");
      }
      if (touch) {
        this.$_preventShow = true;
        setTimeout(() => {
          this.$_preventShow = false;
        }, 300);
      }
    },
    $_detachPopperNode() {
      this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
    },
    $_swapTargetAttrs(attrFrom, attrTo) {
      for (const el of this.$_targetNodes) {
        const value = el.getAttribute(attrFrom);
        if (value) {
          el.removeAttribute(attrFrom);
          el.setAttribute(attrTo, value);
        }
      }
    },
    $_applyAttrsToTarget(attrs) {
      for (const el of this.$_targetNodes) {
        for (const n in attrs) {
          const value = attrs[n];
          if (value == null) {
            el.removeAttribute(n);
          } else {
            el.setAttribute(n, value);
          }
        }
      }
    },
    $_updateParentShownChildren(value) {
      let parent = this.parentPopper;
      while (parent) {
        if (value) {
          parent.shownChildren.add(this.randomId);
        } else {
          parent.shownChildren.delete(this.randomId);
          if (parent.$_pendingHide) {
            parent.hide();
          }
        }
        parent = parent.parentPopper;
      }
    },
    $_isAimingPopper() {
      const referenceBounds = this.$_referenceNode.getBoundingClientRect();
      if (mouseX >= referenceBounds.left && mouseX <= referenceBounds.right && mouseY >= referenceBounds.top && mouseY <= referenceBounds.bottom) {
        const popperBounds = this.$_popperNode.getBoundingClientRect();
        const vectorX = mouseX - mousePreviousX;
        const vectorY = mouseY - mousePreviousY;
        const distance = popperBounds.left + popperBounds.width / 2 - mousePreviousX + (popperBounds.top + popperBounds.height / 2) - mousePreviousY;
        const newVectorLength = distance + popperBounds.width + popperBounds.height;
        const edgeX = mousePreviousX + vectorX * newVectorLength;
        const edgeY = mousePreviousY + vectorY * newVectorLength;
        return lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.top, popperBounds.left, popperBounds.bottom) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.top, popperBounds.right, popperBounds.top) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.right, popperBounds.top, popperBounds.right, popperBounds.bottom) || lineIntersectsLine(mousePreviousX, mousePreviousY, edgeX, edgeY, popperBounds.left, popperBounds.bottom, popperBounds.right, popperBounds.bottom);
      }
      return false;
    }
  },
  render() {
    return this.$slots.default(this.slotData);
  }
});
if (typeof document !== "undefined" && typeof window !== "undefined") {
  if (isIOS) {
    document.addEventListener("touchstart", handleGlobalMousedown, supportsPassive ? {
      passive: true,
      capture: true
    } : true);
    document.addEventListener("touchend", handleGlobalTouchend, supportsPassive ? {
      passive: true,
      capture: true
    } : true);
  } else {
    window.addEventListener("mousedown", handleGlobalMousedown, true);
    window.addEventListener("click", handleGlobalClick, true);
  }
  window.addEventListener("resize", computePositionAllShownPoppers);
}
function handleGlobalMousedown(event) {
  for (let i = 0; i < shownPoppers.length; i++) {
    const popper2 = shownPoppers[i];
    try {
      const popperContent = popper2.popperNode();
      popper2.$_mouseDownContains = popperContent.contains(event.target);
    } catch (e) {
    }
  }
}
function handleGlobalClick(event) {
  handleGlobalClose(event);
}
function handleGlobalTouchend(event) {
  handleGlobalClose(event, true);
}
function handleGlobalClose(event, touch = false) {
  const preventClose = {};
  for (let i = shownPoppers.length - 1; i >= 0; i--) {
    const popper2 = shownPoppers[i];
    try {
      const contains2 = popper2.$_containsGlobalTarget = isContainingEventTarget(popper2, event);
      popper2.$_pendingHide = false;
      requestAnimationFrame(() => {
        popper2.$_pendingHide = false;
        if (preventClose[popper2.randomId])
          return;
        if (shouldAutoHide(popper2, contains2, event)) {
          popper2.$_handleGlobalClose(event, touch);
          if (!event.closeAllPopover && event.closePopover && contains2) {
            let parent2 = popper2.parentPopper;
            while (parent2) {
              preventClose[parent2.randomId] = true;
              parent2 = parent2.parentPopper;
            }
            return;
          }
          let parent = popper2.parentPopper;
          while (parent) {
            if (shouldAutoHide(parent, parent.$_containsGlobalTarget, event)) {
              parent.$_handleGlobalClose(event, touch);
            } else {
              break;
            }
            parent = parent.parentPopper;
          }
        }
      });
    } catch (e) {
    }
  }
}
function isContainingEventTarget(popper2, event) {
  const popperContent = popper2.popperNode();
  return popper2.$_mouseDownContains || popperContent.contains(event.target);
}
function shouldAutoHide(popper2, contains2, event) {
  return event.closeAllPopover || event.closePopover && contains2 || getAutoHideResult(popper2, event) && !contains2;
}
function getAutoHideResult(popper2, event) {
  if (typeof popper2.autoHide === "function") {
    const result = popper2.autoHide(event);
    popper2.lastAutoHide = result;
    return result;
  }
  return popper2.autoHide;
}
function computePositionAllShownPoppers(event) {
  for (let i = 0; i < shownPoppers.length; i++) {
    const popper2 = shownPoppers[i];
    popper2.$_computePosition(event);
  }
}
function hideAllPoppers() {
  for (let i = 0; i < shownPoppers.length; i++) {
    const popper2 = shownPoppers[i];
    popper2.hide();
  }
}
let mousePreviousX = 0;
let mousePreviousY = 0;
let mouseX = 0;
let mouseY = 0;
if (typeof window !== "undefined") {
  window.addEventListener("mousemove", (event) => {
    mousePreviousX = mouseX;
    mousePreviousY = mouseY;
    mouseX = event.clientX;
    mouseY = event.clientY;
  }, supportsPassive ? {
    passive: true
  } : void 0);
}
function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
  const uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  const uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
  return uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1;
}
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$6$1 = {
  extends: PrivatePopper()
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "reference",
    class: "v-popper"
  }, _ctx.$attrs, {
    class: {
      "v-popper--shown": _ctx.slotData.isShown
    }
  }), [
    renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.slotData)))
  ], 16);
}
var Popper$1 = /* @__PURE__ */ _export_sfc(_sfc_main$6$1, [["render", _sfc_render$3]]);
function getInternetExplorerVersion() {
  var ua = window.navigator.userAgent;
  var msie = ua.indexOf("MSIE ");
  if (msie > 0) {
    return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
  }
  var trident = ua.indexOf("Trident/");
  if (trident > 0) {
    var rv = ua.indexOf("rv:");
    return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
  }
  var edge = ua.indexOf("Edge/");
  if (edge > 0) {
    return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
  }
  return -1;
}
let isIE;
function initCompat() {
  if (!initCompat.init) {
    initCompat.init = true;
    isIE = getInternetExplorerVersion() !== -1;
  }
}
var script$a = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "notify"
  ],
  mounted() {
    initCompat();
    nextTick(() => {
      this._w = this.$el.offsetWidth;
      this._h = this.$el.offsetHeight;
      if (this.emitOnMount) {
        this.emitSize();
      }
    });
    const object2 = document.createElement("object");
    this._resizeObject = object2;
    object2.setAttribute("aria-hidden", "true");
    object2.setAttribute("tabindex", -1);
    object2.onload = this.addResizeHandlers;
    object2.type = "text/html";
    if (isIE) {
      this.$el.appendChild(object2);
    }
    object2.data = "about:blank";
    if (!isIE) {
      this.$el.appendChild(object2);
    }
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
        this._w = this.$el.offsetWidth;
        this._h = this.$el.offsetHeight;
        this.emitSize();
      }
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify);
      this.compareAndNotify();
    },
    removeResizeHandlers() {
      if (this._resizeObject && this._resizeObject.onload) {
        if (!isIE && this._resizeObject.contentDocument) {
          this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify);
        }
        this.$el.removeChild(this._resizeObject);
        this._resizeObject.onload = null;
        this._resizeObject = null;
      }
    }
  }
};
const _withId = /* @__PURE__ */ withScopeId();
pushScopeId("data-v-b329ee4c");
const _hoisted_1$2$2 = {
  class: "resize-observer",
  tabindex: "-1"
};
popScopeId();
const render$j = /* @__PURE__ */ _withId((_ctx, _cache, $props, $setup, $data, $options) => {
  return openBlock(), createBlock("div", _hoisted_1$2$2);
});
script$a.render = render$j;
script$a.__scopeId = "data-v-b329ee4c";
script$a.__file = "src/components/ResizeObserver.vue";
var PrivateThemeClass = (prop = "theme") => ({
  computed: {
    themeClass() {
      return getThemeClasses(this[prop]);
    }
  }
});
const _sfc_main$5$1 = defineComponent({
  name: "VPopperContent",
  components: {
    ResizeObserver: script$a
  },
  mixins: [
    PrivateThemeClass()
  ],
  props: {
    popperId: String,
    theme: String,
    shown: Boolean,
    mounted: Boolean,
    skipTransition: Boolean,
    autoHide: Boolean,
    handleResize: Boolean,
    classes: Object,
    result: Object
  },
  emits: [
    "hide",
    "resize"
  ],
  methods: {
    toPx(value) {
      if (value != null && !isNaN(value)) {
        return `${value}px`;
      }
      return null;
    }
  }
});
const _hoisted_1$1$2 = ["id", "aria-hidden", "tabindex", "data-popper-placement"];
const _hoisted_2$1$2 = {
  ref: "inner",
  class: "v-popper__inner"
};
const _hoisted_3$l = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-outer" }, null, -1);
const _hoisted_4$c = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-inner" }, null, -1);
const _hoisted_5$8 = [
  _hoisted_3$l,
  _hoisted_4$c
];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  return openBlock(), createElementBlock("div", {
    id: _ctx.popperId,
    ref: "popover",
    class: normalizeClass(["v-popper__popper", [
      _ctx.themeClass,
      _ctx.classes.popperClass,
      {
        "v-popper__popper--shown": _ctx.shown,
        "v-popper__popper--hidden": !_ctx.shown,
        "v-popper__popper--show-from": _ctx.classes.showFrom,
        "v-popper__popper--show-to": _ctx.classes.showTo,
        "v-popper__popper--hide-from": _ctx.classes.hideFrom,
        "v-popper__popper--hide-to": _ctx.classes.hideTo,
        "v-popper__popper--skip-transition": _ctx.skipTransition,
        "v-popper__popper--arrow-overflow": _ctx.result && _ctx.result.arrow.overflow,
        "v-popper__popper--no-positioning": !_ctx.result
      }
    ]]),
    style: normalizeStyle(_ctx.result ? {
      position: _ctx.result.strategy,
      transform: `translate3d(${Math.round(_ctx.result.x)}px,${Math.round(_ctx.result.y)}px,0)`
    } : void 0),
    "aria-hidden": _ctx.shown ? "false" : "true",
    tabindex: _ctx.autoHide ? 0 : void 0,
    "data-popper-placement": _ctx.result ? _ctx.result.placement : void 0,
    onKeyup: _cache[2] || (_cache[2] = withKeys(($event) => _ctx.autoHide && _ctx.$emit("hide"), ["esc"]))
  }, [
    createBaseVNode("div", {
      class: "v-popper__backdrop",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.autoHide && _ctx.$emit("hide"))
    }),
    createBaseVNode("div", {
      class: "v-popper__wrapper",
      style: normalizeStyle(_ctx.result ? {
        transformOrigin: _ctx.result.transformOrigin
      } : void 0)
    }, [
      createBaseVNode("div", _hoisted_2$1$2, [
        _ctx.mounted ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", null, [
            renderSlot(_ctx.$slots, "default")
          ]),
          _ctx.handleResize ? (openBlock(), createBlock(_component_ResizeObserver, {
            key: 0,
            onNotify: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("resize", $event))
          })) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true)
      ], 512),
      createBaseVNode("div", {
        ref: "arrow",
        class: "v-popper__arrow-container",
        style: normalizeStyle(_ctx.result ? {
          left: _ctx.toPx(_ctx.result.arrow.x),
          top: _ctx.toPx(_ctx.result.arrow.y)
        } : void 0)
      }, _hoisted_5$8, 4)
    ], 4)
  ], 46, _hoisted_1$1$2);
}
var PrivatePopperContent = /* @__PURE__ */ _export_sfc(_sfc_main$5$1, [["render", _sfc_render$2]]);
var PrivatePopperMethods = {
  methods: {
    show(...args) {
      return this.$refs.popper.show(...args);
    },
    hide(...args) {
      return this.$refs.popper.hide(...args);
    },
    dispose(...args) {
      return this.$refs.popper.dispose(...args);
    },
    onResize(...args) {
      return this.$refs.popper.onResize(...args);
    }
  }
};
const _sfc_main$4$1 = defineComponent({
  name: "VPopperWrapper",
  components: {
    Popper: Popper$1,
    PopperContent: PrivatePopperContent
  },
  mixins: [
    PrivatePopperMethods,
    PrivateThemeClass("finalTheme")
  ],
  props: {
    theme: {
      type: String,
      default: null
    }
  },
  computed: {
    finalTheme() {
      var _a2;
      return (_a2 = this.theme) != null ? _a2 : this.$options.vPopperTheme;
    }
  },
  methods: {
    getTargetNodes() {
      return Array.from(this.$refs.popper.$el.children).filter((node) => node !== this.$refs.popperContent.$el);
    }
  }
});
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PopperContent = resolveComponent("PopperContent");
  const _component_Popper = resolveComponent("Popper");
  return openBlock(), createBlock(_component_Popper, {
    ref: "popper",
    theme: _ctx.finalTheme,
    "target-nodes": _ctx.getTargetNodes,
    "reference-node": () => _ctx.$refs.popper.$el,
    "popper-node": () => _ctx.$refs.popperContent.$el,
    class: normalizeClass([
      _ctx.themeClass
    ])
  }, {
    default: withCtx(({
      popperId,
      isShown,
      shouldMountContent,
      skipTransition,
      autoHide,
      show,
      hide: hide2,
      handleResize,
      onResize,
      classes,
      result
    }) => [
      renderSlot(_ctx.$slots, "default", {
        shown: isShown,
        show,
        hide: hide2
      }),
      createVNode(_component_PopperContent, {
        ref: "popperContent",
        "popper-id": popperId,
        theme: _ctx.finalTheme,
        shown: isShown,
        mounted: shouldMountContent,
        "skip-transition": skipTransition,
        "auto-hide": autoHide,
        "handle-resize": handleResize,
        classes,
        result,
        onHide: hide2,
        onResize
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "popper", {
            shown: isShown,
            hide: hide2
          })
        ]),
        _: 2
      }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
    ]),
    _: 3
  }, 8, ["theme", "target-nodes", "reference-node", "popper-node", "class"]);
}
var PrivatePopperWrapper = /* @__PURE__ */ _export_sfc(_sfc_main$4$1, [["render", _sfc_render$1]]);
defineComponent(__spreadProps(__spreadValues({}, PrivatePopperWrapper), {
  name: "VDropdown",
  vPopperTheme: "dropdown"
}));
const _sfc_main$2$1 = defineComponent(__spreadProps(__spreadValues({}, PrivatePopperWrapper), {
  name: "VMenu",
  vPopperTheme: "menu"
}));
const _sfc_main$1$1 = defineComponent(__spreadProps(__spreadValues({}, PrivatePopperWrapper), {
  name: "VTooltip",
  vPopperTheme: "tooltip"
}));
defineComponent({
  name: "VTooltipDirective",
  components: {
    Popper: PrivatePopper(),
    PopperContent: PrivatePopperContent
  },
  mixins: [
    PrivatePopperMethods
  ],
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      default: "tooltip"
    },
    html: {
      type: Boolean,
      default: (props) => getDefaultConfig(props.theme, "html")
    },
    content: {
      type: [String, Number, Function],
      default: null
    },
    loadingContent: {
      type: String,
      default: (props) => getDefaultConfig(props.theme, "loadingContent")
    }
  },
  data() {
    return {
      asyncContent: null
    };
  },
  computed: {
    isContentAsync() {
      return typeof this.content === "function";
    },
    loading() {
      return this.isContentAsync && this.asyncContent == null;
    },
    finalContent() {
      if (this.isContentAsync) {
        return this.loading ? this.loadingContent : this.asyncContent;
      }
      return this.content;
    }
  },
  watch: {
    content: {
      handler() {
        this.fetchContent(true);
      },
      immediate: true
    },
    async finalContent() {
      await this.$nextTick();
      this.$refs.popper.onResize();
    }
  },
  created() {
    this.$_fetchId = 0;
  },
  methods: {
    fetchContent(force) {
      if (typeof this.content === "function" && this.$_isShown && (force || !this.$_loading && this.asyncContent == null)) {
        this.asyncContent = null;
        this.$_loading = true;
        const fetchId = ++this.$_fetchId;
        const result = this.content(this);
        if (result.then) {
          result.then((res) => this.onResult(fetchId, res));
        } else {
          this.onResult(fetchId, result);
        }
      }
    },
    onResult(fetchId, result) {
      if (fetchId !== this.$_fetchId)
        return;
      this.$_loading = false;
      this.asyncContent = result;
    },
    onShow() {
      this.$_isShown = true;
      this.fetchContent();
    },
    onHide() {
      this.$_isShown = false;
    }
  }
});
const options = config$1;
const Menu = _sfc_main$2$1;
const Tooltip = _sfc_main$1$1;
const _hoisted_1$r = { class: "flex min-h-screen items-center justify-center" };
const _hoisted_2$p = { class: "bg-white rounded mx-auto min-w-[480px] max-w-[600px] relative" };
const _hoisted_3$k = { key: 2 };
const _hoisted_4$b = { class: "rounded flex font-medium bg-red-100 mb-[20px] p-[16px] text-red-600 gap-[8px] items-center" };
const _hoisted_5$7 = { key: 3 };
const _hoisted_6$2 = { class: "rounded flex bg-red-100 mt-[16px] p-[16px] text-red-600 gap-[8px] items-center" };
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "LoginModal",
  props: {
    gql: null,
    utmMedium: null,
    utmContent: null
  },
  emits: ["close", "cancel"],
  setup(__props, { emit: emit3 }) {
    const props = __props;
    const online = useOnline();
    gql`
fragment LoginModal on Query {
  ...Auth
}
`;
    hideAllPoppers();
    const { t: t2 } = useI18n();
    const viewer = computed(() => {
      var _a2;
      return (_a2 = props.gql) == null ? void 0 : _a2.cloudViewer;
    });
    const error = computed(() => {
      const { name: name2 } = props.gql.authState;
      if (name2 !== "AUTH_BROWSER_LAUNCHED") {
        return name2;
      }
      return null;
    });
    const showFooter = computed(() => error.value !== "AUTH_COULD_NOT_LAUNCH_BROWSER");
    const title = computed(() => {
      if (viewer.value) {
        return t2("topNav.login.titleSuccess");
      }
      if (error.value === "AUTH_COULD_NOT_LAUNCH_BROWSER") {
        return t2("topNav.login.titleBrowserError");
      }
      if (error.value === "AUTH_ERROR_DURING_LOGIN") {
        return t2("topNav.login.titleFailed");
      }
      return t2("topNav.login.titleInitial");
    });
    const isOnline = computed(() => online.value);
    const cancelLogin = () => {
      emit3("cancel");
    };
    return (_ctx, _cache) => {
      const _component_i18n_t = resolveComponent("i18n-t");
      const _component_i_cy_errored_outline_x16 = __unplugin_components_1$2;
      return openBlock(), createBlock(unref(Dialog), {
        open: "",
        class: "inset-0 z-50 fixed overflow-y-auto",
        onClose: cancelLogin
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$r, [
            createVNode(unref(DialogOverlay), { class: "bg-gray-800 opacity-90 inset-0 fixed" }),
            createBaseVNode("div", _hoisted_2$p, [
              createVNode(_sfc_main$s, {
                "help-link": "https://on.cypress.io",
                "help-text": unref(t2)("links.needHelp"),
                onClose: cancelLogin
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(title)), 1)
                ]),
                _: 1
              }, 8, ["help-text"]),
              !unref(isOnline) ? (openBlock(), createBlock(_sfc_main$w, {
                key: 0,
                class: "mt-[24px]"
              })) : unref(isOnline) ? (openBlock(), createBlock(unref(DialogDescription), {
                key: 1,
                class: "font-normal p-[24px] text-gray-700"
              }, {
                default: withCtx(() => [
                  !unref(viewer) && !unref(error) ? (openBlock(), createBlock(_component_i18n_t, {
                    key: 0,
                    scope: "global",
                    keypath: "topNav.login.bodyInitial"
                  }, {
                    default: withCtx(() => [
                      createVNode(_sfc_main$z, { href: "https://on.cypress.io/dashboard-introduction" }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString$1(unref(t2)("topNav.login.cloud")), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })) : unref(viewer) ? (openBlock(), createBlock(_component_i18n_t, {
                    key: 1,
                    scope: "global",
                    keypath: "topNav.login.bodySuccess"
                  }, {
                    default: withCtx(() => [
                      createVNode(_sfc_main$z, {
                        href: "https://on.cypress.io/dashboard/profile",
                        class: "font-medium text-indigo-500"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString$1(unref(viewer).fullName || unref(viewer).email), 1)
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })) : unref(error) === "AUTH_COULD_NOT_LAUNCH_BROWSER" ? (openBlock(), createElementBlock("div", _hoisted_3$k, [
                    createBaseVNode("div", _hoisted_4$b, [
                      createVNode(_component_i_cy_errored_outline_x16, { class: "h-[16px] min-w-[16px] w-[16px] icon-dark-red-400" }),
                      createTextVNode(" " + toDisplayString$1(unref(t2)("topNav.login.bodyBrowserError")), 1)
                    ]),
                    createTextVNode(" " + toDisplayString$1(unref(t2)("topNav.login.bodyBrowserErrorDetails")) + " ", 1),
                    props.gql.authState.message ? (openBlock(), createBlock(CopyText, {
                      key: 0,
                      class: "mt-[12px]",
                      text: props.gql.authState.message
                    }, null, 8, ["text"])) : createCommentVNode("", true)
                  ])) : unref(error) === "AUTH_ERROR_DURING_LOGIN" ? (openBlock(), createElementBlock("div", _hoisted_5$7, [
                    createTextVNode(toDisplayString$1(unref(t2)("topNav.login.bodyError")) + " ", 1),
                    createBaseVNode("div", _hoisted_6$2, [
                      createVNode(_component_i_cy_errored_outline_x16, { class: "h-[16px] min-w-[16px] w-[16px] icon-dark-red-400" }),
                      createTextVNode(" " + toDisplayString$1(props.gql.authState.message), 1)
                    ])
                  ])) : createCommentVNode("", true)
                ]),
                _: 1
              })) : createCommentVNode("", true),
              createBaseVNode("div", {
                class: normalizeClass(["bg-gray-50 border-t-[1px] py-[16px] px-[24px]", { "hidden": !unref(showFooter) }])
              }, [
                createVNode(_sfc_main$x, {
                  gql: props.gql,
                  "show-retry": !!unref(error),
                  "utm-medium": props.utmMedium,
                  "utm-content": props.utmContent,
                  onClose: _cache[0] || (_cache[0] = ($event) => emit3("close")),
                  onCancel: _cache[1] || (_cache[1] = ($event) => emit3("cancel"))
                }, null, 8, ["gql", "show-retry", "utm-medium", "utm-content"])
              ], 2)
            ])
          ])
        ]),
        _: 1
      });
    };
  }
});
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "StandardModalBody",
  props: {
    variant: null
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(__props.variant === "bare" ? "p-0" : "p-[24px]")
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
const _sfc_main$p = {};
const _hoisted_1$q = { class: "rounded-b bg-gray-50 border-t-[1px] border-gray-100 h-[72px] py-[16px] px-[24px]" };
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_1$q, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
const StandardModalFooter = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render]]);
const _hoisted_1$p = { class: "flex min-h-screen items-center justify-center" };
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "StandardModal",
  props: {
    modelValue: { type: Boolean, default: false },
    helpLink: { default: "https://on.cypress.io" },
    helpText: { default: `${defaultMessages.links.needHelp}` },
    variant: { default: void 0 },
    noHelp: { type: Boolean, default: false },
    title: { default: "" },
    class: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: emit3 }) {
    const props = __props;
    const setIsOpen = (val) => {
      emit3("update:modelValue", val);
    };
    watch(
      () => props.modelValue,
      (value) => {
        if (value) {
          hideAllPoppers();
        }
      },
      { immediate: true }
    );
    const closeModal = () => {
      setIsOpen(false);
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Dialog), {
        open: __props.modelValue,
        class: "inset-0 z-10 fixed overflow-y-auto",
        onClose: _cache[0] || (_cache[0] = ($event) => closeModal())
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$p, [
            renderSlot(_ctx.$slots, "overlay", { classes: "fixed inset-0" }, () => [
              createVNode(unref(DialogOverlay), { class: "bg-gray-800 opacity-90 fixed sm:inset-0" })
            ]),
            createBaseVNode("div", {
              "data-cy": "standard-modal",
              class: normalizeClass(["bg-white rounded mx-auto ring-[#9095AD40] ring-4 relative", props.class || ""])
            }, [
              createVNode(_sfc_main$s, {
                "no-help": __props.noHelp,
                "help-link": __props.helpLink,
                "help-text": __props.helpText,
                onClose: closeModal
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "title", {}, () => [
                    createTextVNode(toDisplayString$1(__props.title), 1)
                  ])
                ]),
                _: 3
              }, 8, ["no-help", "help-link", "help-text"]),
              _ctx.$slots.description ? (openBlock(), createBlock(unref(DialogDescription), {
                key: 0,
                class: "font-normal p-[24px] text-gray-700"
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "description")
                ]),
                _: 3
              })) : createCommentVNode("", true),
              createVNode(_sfc_main$q, { variant: __props.variant }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["variant"]),
              _ctx.$slots.footer ? (openBlock(), createBlock(StandardModalFooter, { key: 1 }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "footer")
                ]),
                _: 3
              })) : createCommentVNode("", true)
            ], 2)
          ])
        ]),
        _: 3
      }, 8, ["open"]);
    };
  }
});
const _hoisted_1$o = {
  viewBox: "0 0 24 24",
  width: "1em",
  height: "1em"
};
const _hoisted_2$o = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M21 7L9 19l-5.5-5.5l1.41-1.41L9 16.17L19.59 5.59z"
}, null, -1);
const _hoisted_3$j = [
  _hoisted_2$o
];
function render$i(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$o, _hoisted_3$j);
}
const __unplugin_components_1$1 = { name: "mdi-check", render: render$i };
const _hoisted_1$n = {
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$n = /* @__PURE__ */ createBaseVNode("path", {
  d: "M2 5L8 11L14 5",
  stroke: "#1B1E2E",
  class: "icon-dark",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null, -1);
const _hoisted_3$i = [
  _hoisted_2$n
];
function render$h(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$n, _hoisted_3$i);
}
const __unplugin_components_0$2 = { name: "cy-chevron-down", render: render$h };
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f2 = n.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d2 = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a2, k, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a2;
}
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH2 = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH2 - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH2 >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag2] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag2] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      // Latin Extended-A block.
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "s"
    };
    var htmlEscapes2 = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply2(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length2 = array == null ? 0 : array.length;
      while (length2--) {
        if (iteratee(array[length2], length2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length2) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length2 = array == null ? 0 : array.length;
      return !!length2 && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator2) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        if (comparator2(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
      while (++index < length2) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length2 = values.length, offset2 = array.length;
      while (++index < length2) {
        array[offset2 + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length2 = array == null ? 0 : array.length;
      if (initAccum && length2) {
        accumulator = array[++index];
      }
      while (++index < length2) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length2 = array == null ? 0 : array.length;
      if (initAccum && length2) {
        accumulator = array[--length2];
      }
      while (length2--) {
        accumulator = iteratee(accumulator, array[length2], length2, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length2 = array == null ? 0 : array.length;
      while (++index < length2) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length2 = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length2) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator2) {
      var index = fromIndex - 1, length2 = array.length;
      while (++index < length2) {
        if (comparator2(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length2 = array == null ? 0 : array.length;
      return length2 ? baseSum(array, iteratee) / length2 : NAN;
    }
    function baseProperty(key) {
      return function(object2) {
        return object2 == null ? undefined$1 : object2[key];
      };
    }
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? undefined$1 : object2[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer2) {
      var length2 = array.length;
      array.sort(comparer2);
      while (length2--) {
        array[length2] = array[length2].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length2 = array.length;
      while (++index < length2) {
        var current = iteratee(array[index]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object2, props) {
      return arrayMap(props, function(key) {
        return [key, object2[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object2, props) {
      return arrayMap(props, function(key) {
        return object2[key];
      });
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length2 = strSymbols.length;
      while (++index < length2 && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length2 = array.length, result = 0;
      while (length2--) {
        if (array[length2] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes2);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object2, key) {
      return object2 == null ? undefined$1 : object2[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator2) {
      var data, result = [];
      while (!(data = iterator2.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg2(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length2 = array.length, resIndex = 0, result = [];
      while (++index < length2) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length2 = array.length;
      while (++index < length2) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context2) {
      context2 = context2 == null ? root : _2.defaults(root.Object(), context2, _2.pick(root, contextProps));
      var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
      var arrayProto = Array2.prototype, funcProto2 = Function2.prototype, objectProto2 = Object2.prototype;
      var coreJsData = context2["__core-js_shared__"];
      var funcToString2 = funcProto2.toString;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString2 = objectProto2.toString;
      var objectCtorString2 = funcToString2.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2(
        "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? context2.Buffer : undefined$1, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context2.clearTimeout !== root.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root.setTimeout && context2.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg2(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = /* @__PURE__ */ function() {
        function object2() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object2.prototype = proto;
          var result2 = new object2();
          object2.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH2;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end2 = view.end, length2 = end2 - start2, index = isRight ? end2 : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length2-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type2 = data.type, computed2 = iteratee2(value);
              if (type2 == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type2 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length2) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length2) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined$1 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length2) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size22 = data.size;
        data.set(key, value);
        this.size += data.size == size22 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length2 = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length2) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length2 = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length2)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length2 = array.length;
        return length2 ? array[baseRandom(0, length2 - 1)] : undefined$1;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object2, key, value) {
        if (value !== undefined$1 && !eq2(object2[key], value) || value === undefined$1 && !(key in object2)) {
          baseAssignValue(object2, key, value);
        }
      }
      function assignValue(object2, key, value) {
        var objValue = object2[key];
        if (!(hasOwnProperty2.call(object2, key) && eq2(objValue, value)) || value === undefined$1 && !(key in object2)) {
          baseAssignValue(object2, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length2 = array.length;
        while (length2--) {
          if (eq2(array[length2][0], key)) {
            return length2;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object2, source) {
        return object2 && copyObject(source, keys2(source), object2);
      }
      function baseAssignIn(object2, source) {
        return object2 && copyObject(source, keysIn(source), object2);
      }
      function baseAssignValue(object2, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object2, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object2[key] = value;
        }
      }
      function baseAt(object2, paths) {
        var index = -1, length2 = paths.length, result2 = Array2(length2), skip = object2 == null;
        while (++index < length2) {
          result2[index] = skip ? undefined$1 : get2(object2, paths[index]);
        }
        return result2;
      }
      function baseClamp(number2, lower, upper) {
        if (number2 === number2) {
          if (upper !== undefined$1) {
            number2 = number2 <= upper ? number2 : upper;
          }
          if (lower !== undefined$1) {
            number2 = number2 >= lower ? number2 : lower;
          }
        }
        return number2;
      }
      function baseClone(value, bitmask, customizer, key, object2, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object2 ? customizer(value, key, object2, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag2 || tag == argsTag || isFunc && !object2) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object2 ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet2(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys2(source);
        return function(object2) {
          return baseConformsTo(object2, source, props);
        };
      }
      function baseConformsTo(object2, source, props) {
        var length2 = props.length;
        if (object2 == null) {
          return !length2;
        }
        object2 = Object2(object2);
        while (length2--) {
          var key = props[length2], predicate = source[key], value = object2[key];
          if (value === undefined$1 && !(key in object2) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator2) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length2 = array.length, result2 = [], valuesLength = values2.length;
        if (!length2) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator2) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length2) {
            var value = array[index], computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator2 || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed2, comparator2)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator2) {
        var index = -1, length2 = array.length;
        while (++index < length2) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol2(current) : comparator2(current, computed2))) {
            var computed2 = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start2, end2) {
        var length2 = array.length;
        start2 = toInteger(start2);
        if (start2 < 0) {
          start2 = -start2 > length2 ? 0 : length2 + start2;
        }
        end2 = end2 === undefined$1 || end2 > length2 ? length2 : toInteger(end2);
        if (end2 < 0) {
          end2 += length2;
        }
        end2 = start2 > end2 ? 0 : toLength(end2);
        while (start2 < end2) {
          array[start2++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length2 = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length2) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object2, iteratee2) {
        return object2 && baseFor(object2, iteratee2, keys2);
      }
      function baseForOwnRight(object2, iteratee2) {
        return object2 && baseForRight(object2, iteratee2, keys2);
      }
      function baseFunctions(object2, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object2[key]);
        });
      }
      function baseGet(object2, path) {
        path = castPath(path, object2);
        var index = 0, length2 = path.length;
        while (object2 != null && index < length2) {
          object2 = object2[toKey(path[index++])];
        }
        return index && index == length2 ? object2 : undefined$1;
      }
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object2);
        return isArray2(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
      }
      function baseGetTag2(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag2 : nullTag2;
        }
        return symToStringTag2 && symToStringTag2 in Object2(value) ? getRawTag2(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object2, key) {
        return object2 != null && hasOwnProperty2.call(object2, key);
      }
      function baseHasIn(object2, key) {
        return object2 != null && key in Object2(object2);
      }
      function baseInRange(number2, start2, end2) {
        return number2 >= nativeMin(start2, end2) && number2 < nativeMax(start2, end2);
      }
      function baseIntersection(arrays, iteratee2, comparator2) {
        var includes2 = comparator2 ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator2 && (iteratee2 || length2 >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index = -1, seen2 = caches[0];
        outer:
          while (++index < length2 && result2.length < maxLength) {
            var value = array[index], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator2 || value !== 0 ? value : 0;
            if (!(seen2 ? cacheHas(seen2, computed2) : includes2(result2, computed2, comparator2))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed2) : includes2(arrays[othIndex], computed2, comparator2))) {
                  continue outer;
                }
              }
              if (seen2) {
                seen2.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object2, setter, iteratee2, accumulator) {
        baseForOwn(object2, function(value, key, object22) {
          setter(accumulator, iteratee2(value), key, object22);
        });
        return accumulator;
      }
      function baseInvoke(object2, path, args) {
        path = castPath(path, object2);
        object2 = parent(object2, path);
        var func = object2 == null ? object2 : object2[toKey(last(path))];
        return func == null ? undefined$1 : apply2(func, object2, args);
      }
      function baseIsArguments(value) {
        return isObjectLike2(value) && baseGetTag2(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike2(value) && baseGetTag2(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag2 : objTag;
        othTag = othTag == argsTag ? objectTag2 : othTag;
        var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object2)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike2(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object2, source, matchData, customizer) {
        var index = matchData.length, length2 = index, noCustomizer = !customizer;
        if (object2 == null) {
          return !length2;
        }
        object2 = Object2(object2);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
            return false;
          }
        }
        while (++index < length2) {
          data = matchData[index];
          var key = data[0], objValue = object2[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object2)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object2, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike2(value) && baseGetTag2(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike2(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag2(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys(object2);
        }
        var result2 = [];
        for (var key in Object2(object2)) {
          if (hasOwnProperty2.call(object2, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object2) {
        if (!isObject2(object2)) {
          return nativeKeysIn(object2);
        }
        var isProto = isPrototype(object2), result2 = [];
        for (var key in object2) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object2, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object2) {
          return object2 === source || baseIsMatch(object2, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object2) {
          var objValue = get2(object2, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object2, source, srcIndex, customizer, stack) {
        if (object2 === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object2, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object2, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object2, key, newValue);
      }
      function baseNth(array, n) {
        var length2 = array.length;
        if (!length2) {
          return;
        }
        n += n < 0 ? length2 : 0;
        return isIndex(n, length2) ? array[n] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index, "value": value };
        });
        return baseSortBy(result2, function(object2, other) {
          return compareMultiple(object2, other, orders);
        });
      }
      function basePick(object2, paths) {
        return basePickBy(object2, paths, function(value, path) {
          return hasIn(object2, path);
        });
      }
      function basePickBy(object2, paths, predicate) {
        var index = -1, length2 = paths.length, result2 = {};
        while (++index < length2) {
          var path = paths[index], value = baseGet(object2, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object2), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object2) {
          return baseGet(object2, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator2) {
        var indexOf2 = comparator2 ? baseIndexOfWith : baseIndexOf, index = -1, length2 = values2.length, seen2 = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen2 = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length2) {
          var fromIndex = 0, value = values2[index], computed2 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen2, computed2, fromIndex, comparator2)) > -1) {
            if (seen2 !== array) {
              splice.call(seen2, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length2 = array ? indexes.length : 0, lastIndex = length2 - 1;
        while (length2--) {
          var index = indexes[length2];
          if (length2 == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start2, end2, step, fromRight) {
        var index = -1, length2 = nativeMax(nativeCeil((end2 - start2) / (step || 1)), 0), result2 = Array2(length2);
        while (length2--) {
          result2[fromRight ? length2 : ++index] = start2;
          start2 += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object2, path, value, customizer) {
        if (!isObject2(object2)) {
          return object2;
        }
        path = castPath(path, object2);
        var index = -1, length2 = path.length, lastIndex = length2 - 1, nested = object2;
        while (nested != null && ++index < length2) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object2;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object2;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start2, end2) {
        var index = -1, length2 = array.length;
        if (start2 < 0) {
          start2 = -start2 > length2 ? 0 : length2 + start2;
        }
        end2 = end2 > length2 ? length2 : end2;
        if (end2 < 0) {
          end2 += length2;
        }
        length2 = start2 > end2 ? 0 : end2 - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length2);
        while (++index < length2) {
          result2[index] = array[index + start2];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array[mid];
            if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array[mid]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value : computed2 < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length2 = array.length, resIndex = 0, result2 = [];
        while (++index < length2) {
          var value = array[index], computed2 = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq2(computed2, seen2)) {
            var seen2 = computed2;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator2) {
        var index = -1, includes2 = arrayIncludes, length2 = array.length, isCommon = true, result2 = [], seen2 = result2;
        if (comparator2) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length2 >= LARGE_ARRAY_SIZE) {
          var set22 = iteratee2 ? null : createSet(array);
          if (set22) {
            return setToArray(set22);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen2 = new SetCache();
        } else {
          seen2 = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length2) {
            var value = array[index], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator2 || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen2.length;
              while (seenIndex--) {
                if (seen2[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen2.push(computed2);
              }
              result2.push(value);
            } else if (!includes2(seen2, computed2, comparator2)) {
              if (seen2 !== result2) {
                seen2.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object2, path) {
        path = castPath(path, object2);
        object2 = parent(object2, path);
        return object2 == null || delete object2[toKey(last(path))];
      }
      function baseUpdate(object2, path, updater, customizer) {
        return baseSet(object2, path, updater(baseGet(object2, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length2 = array.length, index = fromRight ? length2 : -1;
        while ((fromRight ? index-- : ++index < length2) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length2) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length2 : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action3) {
          return action3.func.apply(action3.thisArg, arrayPush([result3], action3.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator2) {
        var length2 = arrays.length;
        if (length2 < 2) {
          return length2 ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length2);
        while (++index < length2) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length2) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator2);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator2);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length2 = props.length, valsLength = values2.length, result2 = {};
        while (++index < length2) {
          var value = index < valsLength ? values2[index] : undefined$1;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object2) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object2) ? [value] : stringToPath(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array, start2, end2) {
        var length2 = array.length;
        end2 = end2 === undefined$1 ? length2 : end2;
        return !start2 && end2 >= length2 ? array : baseSlice(array, start2, end2);
      }
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root.clearTimeout(id2);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object2, other, orders) {
        var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
        while (++index < length2) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order2 = orders[index];
            return result2 * (order2 == "desc" ? -1 : 1);
          }
        }
        return object2.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length2 = source.length;
        array || (array = Array2(length2));
        while (++index < length2) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object2, customizer) {
        var isNew = !object2;
        object2 || (object2 = {});
        var index = -1, length2 = props.length;
        while (++index < length2) {
          var key = props[index];
          var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object2, key, newValue);
          } else {
            assignValue(object2, key, newValue);
          }
        }
        return object2;
      }
      function copySymbols(source, object2) {
        return copyObject(source, getSymbols(source), object2);
      }
      function copySymbolsIn(source, object2) {
        return copyObject(source, getSymbolsIn(source), object2);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object2, sources) {
          var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined$1, guard = length2 > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length2 < 3 ? undefined$1 : customizer;
            length2 = 1;
          }
          object2 = Object2(object2);
          while (++index < length2) {
            var source = sources[index];
            if (source) {
              assigner(object2, source, index, customizer);
            }
          }
          return object2;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length2) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object2, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object2), props = keysFunc(object2), length2 = props.length;
          while (length2--) {
            var key = props[fromRight ? length2 : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object2;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn2.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString2(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length2 = arguments.length, args = Array2(length2), index = length2, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length2 -= holders.length;
          if (length2 < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length2
            );
          }
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply2(fn2, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length2 = funcs.length, index = length2, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length2;
          while (++index < length2) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length2 ? funcs[index2].apply(this, args) : value;
            while (++index2 < length2) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length2 = arguments.length, args = Array2(length2), index = length2;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length2 -= holdersCount;
          if (isCurried && length2 < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length2
            );
          }
          var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
          length2 = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length2 > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length2) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn2 = Ctor || createCtor(fn2);
          }
          return fn2.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object2, iteratee2) {
          return baseInverter(object2, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply2(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length2, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length2) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply2(fn2, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start2, end2, step) {
          if (step && typeof step != "number" && isIterateeCall(start2, end2, step)) {
            end2 = step = undefined$1;
          }
          start2 = toFinite(start2);
          if (end2 === undefined$1) {
            end2 = start2;
            start2 = 0;
          } else {
            end2 = toFinite(end2);
          }
          step = step === undefined$1 ? start2 < end2 ? 1 : -1 : toFinite(step);
          return baseRange(start2, end2, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber2(value);
            other = toNumber2(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number2, precision) {
          number2 = toNumber2(number2);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number2)) {
            var pair = (toString2(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number2);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object2) {
          var tag = getTag(object2);
          if (tag == mapTag) {
            return mapToArray(object2);
          }
          if (tag == setTag) {
            return setToPairs(object2);
          }
          return baseToPairs(object2, keysFunc(object2));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length2 = partials ? partials.length : 0;
        if (!length2) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length2 -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object2) {
        if (objValue === undefined$1 || eq2(objValue, objectProto2[key]) && !hasOwnProperty2.call(object2, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen2) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen2.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq2(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object2, other);
            var result2 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object2);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object2;
        }
        var result2 = true;
        stack.set(object2, other);
        stack.set(other, object2);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object2);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys2, getSymbols);
      }
      function getAllKeysIn(object2) {
        return baseGetAllKeys(object2, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length2 = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length2--) {
          var data = array[length2], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object2 = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object2.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map22, key) {
        var data = map22.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object2) {
        var result2 = keys2(object2), length2 = result2.length;
        while (length2--) {
          var key = result2[length2], value = object2[key];
          result2[length2] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object2, key) {
        var value = getValue2(object2, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag2(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
        try {
          value[symToStringTag2] = undefined$1;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString2.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag2] = tag;
          } else {
            delete value[symToStringTag2];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object2(object2);
        return arrayFilter(nativeGetSymbols(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
        var result2 = [];
        while (object2) {
          arrayPush(result2, getSymbols(object2));
          object2 = getPrototype2(object2);
        }
        return result2;
      };
      var getTag = baseGetTag2;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag2(value), Ctor = result2 == objectTag2 ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start2, end2, transforms) {
        var index = -1, length2 = transforms.length;
        while (++index < length2) {
          var data = transforms[index], size22 = data.size;
          switch (data.type) {
            case "drop":
              start2 += size22;
              break;
            case "dropRight":
              end2 -= size22;
              break;
            case "take":
              end2 = nativeMin(end2, start2 + size22);
              break;
            case "takeRight":
              start2 = nativeMax(start2, end2 - size22);
              break;
          }
        }
        return { "start": start2, "end": end2 };
      }
      function getWrapDetails(source) {
        var match2 = source.match(reWrapDetails);
        return match2 ? match2[1].split(reSplitDetails) : [];
      }
      function hasPath(object2, path, hasFunc) {
        path = castPath(path, object2);
        var index = -1, length2 = path.length, result2 = false;
        while (++index < length2) {
          var key = toKey(path[index]);
          if (!(result2 = object2 != null && hasFunc(object2, key))) {
            break;
          }
          object2 = object2[key];
        }
        if (result2 || ++index != length2) {
          return result2;
        }
        length2 = object2 == null ? 0 : object2.length;
        return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray2(object2) || isArguments(object2));
      }
      function initCloneArray(array) {
        var length2 = array.length, result2 = new array.constructor(length2);
        if (length2 && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object2) {
        return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype2(object2)) : {};
      }
      function initCloneByTag(object2, tag, isDeep) {
        var Ctor = object2.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object2);
          case boolTag:
          case dateTag:
            return new Ctor(+object2);
          case dataViewTag:
            return cloneDataView(object2, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object2, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object2);
          case regexpTag:
            return cloneRegExp(object2);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object2);
        }
      }
      function insertWrapDetails(source, details) {
        var length2 = details.length;
        if (!length2) {
          return source;
        }
        var lastIndex = length2 - 1;
        details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length2 > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length2) {
        var type2 = typeof value;
        length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
        return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
      }
      function isIterateeCall(value, index, object2) {
        if (!isObject2(object2)) {
          return false;
        }
        var type2 = typeof index;
        if (type2 == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type2 == "string" && index in object2) {
          return eq2(object2[index], value);
        }
        return false;
      }
      function isKey(value, object2) {
        if (isArray2(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
      }
      function isKeyable(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object2) {
          if (object2 == null) {
            return false;
          }
          return object2[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object2));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object2) {
        var result2 = [];
        if (object2 != null) {
          for (var key in Object2(object2)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString2.call(value);
      }
      function overRest(func, start2, transform22) {
        start2 = nativeMax(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index = -1, length2 = nativeMax(args.length - start2, 0), array = Array2(length2);
          while (++index < length2) {
            array[index] = args[start2 + index];
          }
          index = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index < start2) {
            otherArgs[index] = args[index];
          }
          otherArgs[start2] = transform22(array);
          return apply2(func, this, otherArgs);
        };
      }
      function parent(object2, path) {
        return path.length < 2 ? object2 : baseGet(object2, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length2--) {
          var index = indexes[length2];
          array[length2] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
        }
        return array;
      }
      function safeGet(object2, key) {
        if (key === "constructor" && typeof object2[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object2[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference2, bitmask) {
        var source = reference2 + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size22) {
        var index = -1, length2 = array.length, lastIndex = length2 - 1;
        size22 = size22 === undefined$1 ? length2 : size22;
        while (++index < size22) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size22;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match2, number2, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString2.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size22, guard) {
        if (guard ? isIterateeCall(array, size22, guard) : size22 === undefined$1) {
          size22 = 1;
        } else {
          size22 = nativeMax(toInteger(size22), 0);
        }
        var length2 = array == null ? 0 : array.length;
        if (!length2 || size22 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size22));
        while (index < length2) {
          result2[resIndex++] = baseSlice(array, index, index += size22);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length2) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length2 = arguments.length;
        if (!length2) {
          return [];
        }
        var args = Array2(length2 - 1), array = arguments[0], index = length2;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator2 = last(values2);
        if (isArrayLikeObject(comparator2)) {
          comparator2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator2) : [];
      });
      function drop(array, n, guard) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length2);
      }
      function dropRight(array, n, guard) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length2 - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start2, end2) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
          start2 = 0;
          end2 = length2;
        }
        return baseFill(array, value, start2, end2);
      }
      function findIndex(array, predicate, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length2 + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index = length2 - 1;
        if (fromIndex !== undefined$1) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length2 + index, 0) : nativeMin(index, length2 - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length2) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length2 + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial2(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        if (comparator2) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator2) : [];
      });
      function join2(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? array[length2 - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return -1;
        }
        var index = length2;
        if (fromIndex !== undefined$1) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length2 + index, 0) : nativeMin(index, length2 - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator2) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length2 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length2) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove2(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length2 = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length2) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start2, end2) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        if (end2 && typeof end2 != "number" && isIterateeCall(array, start2, end2)) {
          start2 = 0;
          end2 = length2;
        } else {
          start2 = start2 == null ? 0 : toInteger(start2);
          end2 = end2 === undefined$1 ? length2 : toInteger(end2);
        }
        return baseSlice(array, start2, end2);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length2 = array == null ? 0 : array.length;
        if (length2) {
          var index = baseSortedIndex(array, value);
          if (index < length2 && eq2(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length2 = array == null ? 0 : array.length;
        if (length2) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq2(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length2 = array == null ? 0 : array.length;
        return length2 ? baseSlice(array, 1, length2) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length2 = array == null ? 0 : array.length;
        if (!length2) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length2 - n;
        return baseSlice(array, n < 0 ? 0 : n, length2);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator2 = last(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator2);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator2) {
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator2) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length2 = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length2 = nativeMax(group.length, length2);
            return true;
          }
        });
        return baseTimes(length2, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply2(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator2 = last(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator2);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length2 = paths.length, start2 = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
          return baseAt(object2, paths);
        };
        if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
          return this.thru(interceptor);
        }
        value = value.slice(start2, +start2 + (length2 ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length2 && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone22 = wrapperClone(parent2);
          clone22.__index__ = 0;
          clone22.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone22;
          } else {
            result2 = clone22;
          }
          var previous = clone22;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length2 = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length2 + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply2(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length2 = iteratees.length;
        if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object2, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object2, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options2) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber2(wait) || 0;
        if (isObject2(options2)) {
          leading = !!options2.leading;
          maxing = "maxWait" in options2;
          maxWait = maxing ? nativeMax(toNumber2(options2.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options2 ? !!options2.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache2.set(key, result2) || cache2;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once3(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length2 = nativeMin(args.length, funcsLength);
          while (++index < length2) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply2(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger(start2);
        return baseRest(func, start2);
      }
      function spread(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
        return baseRest(function(args) {
          var array = args[start2], otherArgs = castSlice(args, 0, start2);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply2(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options2) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options2)) {
          leading = "leading" in options2 ? !!options2.leading : leading;
          trailing = "trailing" in options2 ? !!options2.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap2(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object2, source) {
        return source == null || baseConformsTo(object2, source, keys2(source));
      }
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike2(value) && isArrayLike(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object2, source) {
        return object2 === source || baseIsMatch(object2, source, getMatchData(source));
      }
      function isMatchWith(object2, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object2, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike2(value) || baseGetTag2(value) != objectTag2) {
          return false;
        }
        var proto = getPrototype2(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
      }
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike2(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber2(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH2) : 0;
      }
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary2 = reIsBinary.test(value);
        return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign2 = createAssigner(function(object2, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys2(source), object2);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object2, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object2, source) {
        copyObject(source, keysIn(source), object2);
      });
      var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object2, customizer);
      });
      var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
        copyObject(source, keys2(source), object2, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults2 = baseRest(function(object2, sources) {
        object2 = Object2(object2);
        var index = -1;
        var length2 = sources.length;
        var guard = length2 > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length2 = 1;
        }
        while (++index < length2) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object2[key];
            if (value === undefined$1 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object2, key)) {
              object2[key] = source[key];
            }
          }
        }
        return object2;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply2(mergeWith, undefined$1, args);
      });
      function findKey(object2, predicate) {
        return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object2, predicate) {
        return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object2, iteratee2) {
        return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object2, iteratee2) {
        return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object2, iteratee2) {
        return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object2, iteratee2) {
        return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
      }
      function functions(object2) {
        return object2 == null ? [] : baseFunctions(object2, keys2(object2));
      }
      function functionsIn(object2) {
        return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
      }
      function get2(object2, path, defaultValue) {
        var result2 = object2 == null ? undefined$1 : baseGet(object2, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has2(object2, path) {
        return object2 != null && hasPath(object2, path, baseHas);
      }
      function hasIn(object2, path) {
        return object2 != null && hasPath(object2, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys2(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      function keysIn(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
      }
      function mapKeys(object2, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object2, function(value, key, object22) {
          baseAssignValue(result2, iteratee2(value, key, object22), value);
        });
        return result2;
      }
      function mapValues(object2, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object2, function(value, key, object22) {
          baseAssignValue(result2, key, iteratee2(value, key, object22));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object2, source, srcIndex) {
        baseMerge(object2, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
        baseMerge(object2, source, srcIndex, customizer);
      });
      var omit2 = flatRest(function(object2, paths) {
        var result2 = {};
        if (object2 == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object2);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object2, getAllKeysIn(object2), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length2 = paths.length;
        while (length2--) {
          baseUnset(result2, paths[length2]);
        }
        return result2;
      });
      function omitBy(object2, predicate) {
        return pickBy(object2, negate(getIteratee(predicate)));
      }
      var pick2 = flatRest(function(object2, paths) {
        return object2 == null ? {} : basePick(object2, paths);
      });
      function pickBy(object2, predicate) {
        if (object2 == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object2), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object2, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object2, path, defaultValue) {
        path = castPath(path, object2);
        var index = -1, length2 = path.length;
        if (!length2) {
          length2 = 1;
          object2 = undefined$1;
        }
        while (++index < length2) {
          var value = object2 == null ? undefined$1 : object2[toKey(path[index])];
          if (value === undefined$1) {
            index = length2;
            value = defaultValue;
          }
          object2 = isFunction2(value) ? value.call(object2) : value;
        }
        return object2;
      }
      function set2(object2, path, value) {
        return object2 == null ? object2 : baseSet(object2, path, value);
      }
      function setWith(object2, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object2 == null ? object2 : baseSet(object2, path, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn);
      function transform2(object2, iteratee2, accumulator) {
        var isArr = isArray2(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray(object2);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object2 && object2.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object2)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype2(object2)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index, object22) {
          return iteratee2(accumulator, value, index, object22);
        });
        return accumulator;
      }
      function unset(object2, path) {
        return object2 == null ? true : baseUnset(object2, path);
      }
      function update(object2, path, updater) {
        return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater));
      }
      function updateWith(object2, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater), customizer);
      }
      function values(object2) {
        return object2 == null ? [] : baseValues(object2, keys2(object2));
      }
      function valuesIn(object2) {
        return object2 == null ? [] : baseValues(object2, keysIn(object2));
      }
      function clamp(number2, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber2(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber2(number2), lower, upper);
      }
      function inRange(number2, start2, end2) {
        start2 = toFinite(start2);
        if (end2 === undefined$1) {
          end2 = start2;
          start2 = 0;
        } else {
          end2 = toFinite(end2);
        }
        number2 = toNumber2(number2);
        return baseInRange(number2, start2, end2);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize2(word) : word);
      });
      function capitalize2(string) {
        return upperFirst(toString2(string).toLowerCase());
      }
      function deburr(string) {
        string = toString2(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString2(string);
        target = baseToString(target);
        var length2 = string.length;
        position = position === undefined$1 ? length2 : baseClamp(toInteger(position), 0, length2);
        var end2 = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end2) == target;
      }
      function escape(string) {
        string = toString2(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString2(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length2, chars) {
        string = toString2(string);
        length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string) : 0;
        if (!length2 || strLength >= length2) {
          return string;
        }
        var mid = (length2 - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length2, chars) {
        string = toString2(string);
        length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string) : 0;
        return length2 && strLength < length2 ? string + createPadding(length2 - strLength, chars) : string;
      }
      function padStart(string, length2, chars) {
        string = toString2(string);
        length2 = toInteger(length2);
        var strLength = length2 ? stringSize(string) : 0;
        return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString2(string), n);
      }
      function replace() {
        var args = arguments, string = toString2(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH2 : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString2(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString2(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options2, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options2, guard)) {
          options2 = undefined$1;
        }
        string = toString2(string);
        options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset2 + match2.length;
          return match2;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options2, "variable") && options2.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim2(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start2, end2).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end2).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start2).join("");
      }
      function truncate(string, options2) {
        var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options2)) {
          var separator = "separator" in options2 ? options2.separator : separator;
          length2 = "length" in options2 ? toInteger(options2.length) : length2;
          omission = "omission" in options2 ? baseToString(options2.omission) : omission;
        }
        string = toString2(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length2 >= strLength) {
          return string;
        }
        var end2 = length2 - stringSize(omission);
        if (end2 < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string.slice(0, end2);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end2 += result2.length - end2;
        }
        if (isRegExp2(separator)) {
          if (string.slice(end2).search(separator)) {
            var match2, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match2 = separator.exec(substring)) {
              var newEnd = match2.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end2 : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end2) != end2) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape(string) {
        string = toString2(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString2(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply2(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object2, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object2, key, bind(object2[key], object2));
        });
        return object2;
      });
      function cond(pairs) {
        var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length2 ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length2) {
            var pair = pairs[index];
            if (apply2(pair[0], this, args)) {
              return apply2(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches2(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object2) {
          return baseInvoke(object2, path, args);
        };
      });
      var methodOf = baseRest(function(object2, args) {
        return function(path) {
          return baseInvoke(object2, path, args);
        };
      });
      function mixin(object2, source, options2) {
        var props = keys2(source), methodNames = baseFunctions(source, props);
        if (options2 == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options2 = source;
          source = object2;
          object2 = this;
          methodNames = baseFunctions(source, keys2(source));
        }
        var chain2 = !(isObject2(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction2(object2);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object2[methodName] = func;
          if (isFunc) {
            object2.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object2 });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object2, arrayPush([this.value()], arguments));
            };
          }
        });
        return object2;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object2) {
        return function(path) {
          return object2 == null ? undefined$1 : baseGet(object2, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH2, length2 = nativeMin(n, MAX_ARRAY_LENGTH2);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH2;
        var result2 = baseTimes(length2, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol2(value) ? [value] : copyArray(stringToPath(toString2(value)));
      }
      function uniqueId(prefix) {
        var id2 = ++idCounter;
        return toString2(prefix) + id2;
      }
      var add2 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max2(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min2(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial2;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches2;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit2;
      lodash2.omitBy = omitBy;
      lodash2.once = once3;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick2;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove2;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle;
      lodash2.thru = thru;
      lodash2.toArray = toArray;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform2;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap2;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add2;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize2;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq2;
      lodash2.escape = escape;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer2;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike2;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp2;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet2;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join2;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max2;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min2;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now2;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size2;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n, MAX_ARRAY_LENGTH2),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type2
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end2) {
        start2 = toInteger(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end2 < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end2 !== undefined$1) {
          end2 = toInteger(end2);
          result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH2);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
const _$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports);
const _hoisted_1$m = { class: "relative" };
const _hoisted_2$m = { class: "flex inset-y-0 absolute items-center" };
const _hoisted_3$h = { key: 0 };
const _hoisted_4$a = { class: "flex pr-3 inset-y-0 right-0 absolute items-center" };
const _hoisted_5$6 = ["data-cy"];
const _hoisted_6$1 = { class: "flex inset-y-0 absolute items-center" };
const _hoisted_7$1 = { class: "flex text-sm pr-3 inset-y-0 right-0 absolute items-center" };
const _hoisted_8$1 = {
  key: 0,
  class: "flex pr-3 right-0 text-jade-400 absolute items-center"
};
const _hoisted_9$1 = { role: "option" };
const __default__$1 = {
  inheritAttrs: true
};
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  ...__default__$1,
  __name: "Select",
  props: {
    options: null,
    modelValue: { default: void 0 },
    placeholder: { default: "" },
    label: { default: "" },
    itemValue: { default: "value" },
    itemKey: { default: "key" },
    error: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: emit3 }) {
    const props = __props;
    const { t: t2 } = useI18n();
    const isSelectedOption = (option) => {
      const optionKey = lodashExports.get(option, props.itemKey);
      return optionKey && optionKey === lodashExports.get(props.modelValue, props.itemKey);
    };
    const handleUpdate = (value) => {
      emit3("update:modelValue", value);
    };
    return (_ctx, _cache) => {
      const _component_i_cy_chevron_down = __unplugin_components_0$2;
      const _component_i_mdi_check = __unplugin_components_1$1;
      return openBlock(), createBlock(unref(Listbox), {
        value: props.modelValue,
        as: "div",
        "onUpdate:modelValue": handleUpdate
      }, {
        default: withCtx(({ open }) => [
          createVNode(unref(ListboxLabel), { class: "font-medium text-sm text-gray-800 block" }, {
            default: withCtx(() => [
              __props.label ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString$1(__props.label), 1)
              ], 64)) : renderSlot(_ctx.$slots, "label", {
                key: 1,
                open
              })
            ]),
            _: 2
          }, 1024),
          createBaseVNode("div", _hoisted_1$m, [
            createVNode(unref(ListboxButton), {
              class: normalizeClass(["bg-white border rounded text-left w-full py-2 px-4 text-gray-800 hocus-default group relative sm:text-sm", open ? "cursor-default default-ring" : "cursor-pointer border-gray-100"])
            }, {
              default: withCtx(() => [
                createBaseVNode("span", _hoisted_2$m, [
                  renderSlot(_ctx.$slots, "input-prefix", {
                    value: __props.modelValue,
                    open
                  })
                ]),
                createBaseVNode("span", {
                  class: normalizeClass([
                    "pr-[24px] text-[16px] leading-[24px]",
                    {
                      "pl-[24px]": _ctx.$slots["input-prefix"]
                    }
                  ])
                }, [
                  !__props.modelValue ? (openBlock(), createElementBlock("span", _hoisted_3$h, toDisplayString$1(__props.placeholder ? __props.placeholder : unref(t2)("components.select.placeholder")), 1)) : renderSlot(_ctx.$slots, "selected", { key: 1 }, () => [
                    createTextVNode(toDisplayString$1(unref(lodashExports.get)(__props.modelValue, __props.itemValue || "")), 1)
                  ])
                ], 2),
                createBaseVNode("span", _hoisted_4$a, [
                  renderSlot(_ctx.$slots, "input-suffix", {
                    value: __props.modelValue,
                    open
                  }, () => [
                    createVNode(_component_i_cy_chevron_down, {
                      "data-testid": "icon-caret",
                      class: normalizeClass([{
                        "rotate-180 icon-dark-indigo-600": open,
                        "rotate-0 icon-dark-gray-500": !open
                      }, "max-w-[16px] transform transition duration-250 group-hocus:icon-dark-indigo-600"])
                    }, null, 8, ["class"])
                  ])
                ])
              ]),
              _: 2
            }, 1032, ["class"]),
            createVNode(Transition, {
              "leave-active-class": "transition ease-in duration-100",
              "leave-from-class": "opacity-100",
              "leave-to-class": "opacity-0"
            }, {
              default: withCtx(() => [
                createVNode(unref(ListboxOptions), { class: "bg-white rounded shadow-lg ring-black mt-1 text-base w-full max-h-60 ring-1 ring-opacity-5 z-10 absolute overflow-auto sm:text-sm focus:outline-none" }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(props.options, (option) => {
                      return openBlock(), createBlock(unref(ListboxOption), {
                        key: unref(lodashExports.get)(option, __props.itemKey),
                        as: "li",
                        value: option,
                        disabled: option.disabled || false
                      }, {
                        default: withCtx(({ active, selected }) => [
                          createBaseVNode("div", {
                            class: normalizeClass(["border-transparent cursor-pointer border py-2 pr-8 pl-4 block truncate select-none relative", [{
                              "font-medium bg-jade-50": isSelectedOption(option),
                              "bg-gray-50": active,
                              "text-gray-800": !isSelectedOption(option) && !active,
                              "text-opacity-40": option.disabled || false
                            }]]),
                            "data-cy": unref(lodashExports.get)(option, __props.itemKey)
                          }, [
                            createBaseVNode("span", _hoisted_6$1, [
                              renderSlot(_ctx.$slots, "item-prefix", {
                                selected,
                                active,
                                value: option
                              })
                            ]),
                            createBaseVNode("span", {
                              class: normalizeClass(["inline-block", {
                                "pl-8": _ctx.$slots["item-prefix"],
                                "pr-6": _ctx.$slots["item-suffix"]
                              }])
                            }, [
                              renderSlot(_ctx.$slots, "item-body", {
                                selected: isSelectedOption(option),
                                active,
                                value: option
                              }, () => [
                                createTextVNode(toDisplayString$1(unref(lodashExports.get)(option, __props.itemValue || "")), 1)
                              ])
                            ], 2),
                            createBaseVNode("span", _hoisted_7$1, [
                              renderSlot(_ctx.$slots, "item-suffix", {
                                selected: isSelectedOption(option),
                                active,
                                value: option
                              }, () => [
                                isSelectedOption(option) ? (openBlock(), createElementBlock("span", _hoisted_8$1, [
                                  createVNode(_component_i_mdi_check, {
                                    class: "h-[16px] w-[16px]",
                                    "data-testid": "icon-check",
                                    "aria-hidden": "true"
                                  })
                                ])) : createCommentVNode("", true)
                              ])
                            ])
                          ], 10, _hoisted_5$6)
                        ]),
                        _: 2
                      }, 1032, ["value", "disabled"]);
                    }), 128)),
                    createBaseVNode("li", _hoisted_9$1, [
                      renderSlot(_ctx.$slots, "footer")
                    ])
                  ]),
                  _: 3
                })
              ]),
              _: 3
            })
          ])
        ]),
        _: 3
      }, 8, ["value"]);
    };
  }
});
const _hoisted_1$l = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$l = /* @__PURE__ */ createBaseVNode("path", {
  d: "M12 7C12 8.38071 11.4404 9.63071 10.5355 10.5355C9.63071 11.4404 8.38071 12 7 12C4.23858 12 2 9.76142 2 7C2 4.23858 4.23858 2 7 2C9.76142 2 12 4.23858 12 7Z",
  class: "icon-light",
  fill: "#D0D2E0"
}, null, -1);
const _hoisted_3$g = /* @__PURE__ */ createBaseVNode("path", {
  d: "M10.5355 10.5355C11.4404 9.63071 12 8.38071 12 7C12 4.23858 9.76142 2 7 2C4.23858 2 2 4.23858 2 7C2 9.76142 4.23858 12 7 12C8.38071 12 9.63071 11.4404 10.5355 10.5355ZM10.5355 10.5355L14 14",
  stroke: "#1B1E2E",
  class: "icon-dark",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null, -1);
const _hoisted_4$9 = [
  _hoisted_2$l,
  _hoisted_3$g
];
function render$g(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$l, _hoisted_4$9);
}
const IconMagnifyingGlass = { name: "cy-magnifying-glass_x16", render: render$g };
function useModelWrapper(props, emit3, name2 = "modelValue") {
  return computed({
    get: () => props[name2],
    set: (value) => {
      emit3(`update:${name2}`, value);
    }
  });
}
const _hoisted_1$k = {
  key: 0,
  class: "flex flex-none ml-[-1px] pl-4 items-center"
};
const _hoisted_2$k = { class: "flex items-center justify-center text-gray-500" };
const _hoisted_3$f = ["type"];
const _hoisted_4$8 = {
  key: 1,
  class: "flex flex-none mr-[-1px] pr-3 items-center"
};
const _hoisted_5$5 = { class: "flex items-center justify-center text-gray-500" };
const __default__ = {
  inheritAttrs: false
};
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  ...__default__,
  __name: "Input",
  props: {
    type: { default: "text" },
    inputClasses: { default: void 0 },
    prefixIcon: { default: void 0 },
    prefixIconClasses: { default: void 0 },
    suffixIcon: { default: void 0 },
    suffixIconClasses: { default: void 0 },
    modelValue: { default: "" },
    style: { default: "" },
    hasError: { type: Boolean, default: false },
    inputRef: { type: Function, default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: emits }) {
    const props = __props;
    const slots = useSlots();
    const attrs = useAttrs();
    const inputAttrs = _$1.omit(attrs, "class");
    const localValue = useModelWrapper(props, emits, "modelValue");
    const hasPrefix = computed(() => {
      return !!(slots.prefix || props.prefixIcon || props.type === "search");
    });
    const hasSuffix = computed(() => {
      return !!(slots.suffix || props.suffixIcon);
    });
    return (_ctx, _cache) => {
      var _a2;
      const _component_i_cy_magnifying_glass_x16 = IconMagnifyingGlass;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["p-0 m-0 border-0", _ctx.$attrs.class])
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["relative flex flex-row leading-tight border border-gray-100 rounded-md", [props.inputClasses, { "hocus-default focus-within-default": !__props.hasError, "border-error-300 ring-2 ring-error-100 hocus-error": __props.hasError }]])
        }, [
          unref(hasPrefix) ? (openBlock(), createElementBlock("div", _hoisted_1$k, [
            createBaseVNode("span", _hoisted_2$k, [
              renderSlot(_ctx.$slots, "prefix", {}, () => [
                __props.prefixIcon ? (openBlock(), createBlock(resolveDynamicComponent(__props.prefixIcon), {
                  key: 0,
                  class: normalizeClass(["pointer-events-none", __props.prefixIconClasses])
                }, null, 8, ["class"])) : __props.type === "search" ? (openBlock(), createBlock(_component_i_cy_magnifying_glass_x16, {
                  key: 1,
                  class: "icon-light-gray-50 icon-dark-gray-500"
                })) : createCommentVNode("", true)
              ], true)
            ])
          ])) : createCommentVNode("", true),
          withDirectives(createBaseVNode("input", mergeProps({
            ref: (_a2 = props.inputRef) == null ? void 0 : _a2.call(props),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(localValue) ? localValue.value = $event : null),
            style: __props.style,
            type: __props.type,
            spellcheck: false,
            class: [[{ "text-gray-800": !__props.hasError, "text-error-500": __props.hasError }], "border-0 flex-1 ml-[1px] min-w-[100px] py-[9px] pl-2 placeholder-gray-400 text-gray-800 block disabled:bg-gray-100 disabled:text-gray-400"],
            autocomplete: "off"
          }, unref(inputAttrs)), null, 16, _hoisted_3$f), [
            [vModelDynamic, unref(localValue)]
          ]),
          unref(hasSuffix) ? (openBlock(), createElementBlock("div", _hoisted_4$8, [
            createBaseVNode("span", _hoisted_5$5, [
              renderSlot(_ctx.$slots, "suffix", {}, () => [
                __props.suffixIcon ? (openBlock(), createBlock(resolveDynamicComponent(__props.suffixIcon), {
                  key: 0,
                  class: normalizeClass(["pointer-events-none", __props.suffixIconClasses])
                }, null, 8, ["class"])) : createCommentVNode("", true)
              ], true)
            ])
          ])) : createCommentVNode("", true)
        ], 2)
      ], 2);
    };
  }
});
const Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["__scopeId", "data-v-71ed09a1"]]);
const _hoisted_1$j = ["for"];
const _hoisted_2$j = { class: "flex text-[16px] leading-[24px] items-center" };
const _hoisted_3$e = ["name", "value", "checked", "onClick"];
const _hoisted_4$7 = { class: "text-gray-800" };
const _hoisted_5$4 = { class: "text-gray-500" };
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "Radio",
  props: {
    name: null,
    label: null,
    value: null,
    options: null
  },
  emits: ["update:value"],
  setup(__props, { emit: emits }) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("label", {
          class: "mt-[24px] text-gray-800 block font-bold",
          for: props.name
        }, toDisplayString$1(props.label), 9, _hoisted_1$j),
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (opt) => {
          return openBlock(), createElementBlock("div", {
            key: opt.value,
            class: "mt-[8px]"
          }, [
            createBaseVNode("label", _hoisted_2$j, [
              createBaseVNode("input", {
                type: "radio",
                name: props.name,
                value: opt.value,
                class: "mr-[8px] radio hocus-default checked:bg-transparent checked:hocus:bg-transparent checked:border-indigo-500 checked:hocus:border-indigo-500",
                checked: props.value === opt.value,
                onClick: ($event) => emits("update:value", opt.value)
              }, null, 8, _hoisted_3$e),
              renderSlot(_ctx.$slots, "option", {
                option: opt,
                checked: props.value === opt.value
              }, () => [
                createBaseVNode("span", _hoisted_4$7, toDisplayString$1(opt.label), 1),
                createBaseVNode("span", _hoisted_5$4, " - " + toDisplayString$1(opt.description), 1)
              ], true)
            ])
          ]);
        }), 128))
      ], 64);
    };
  }
});
const Radio = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["__scopeId", "data-v-8872dbd3"]]);
const _hoisted_1$i = { class: "relative shrink" };
const _hoisted_2$i = ["aria-label"];
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "AlertHeader",
  props: {
    title: null,
    prefixIcon: null,
    suffixIcon: null,
    suffixIconAriaLabel: null,
    alertClass: null,
    prefixIconClass: null,
    suffixIconClass: null,
    headerClass: null,
    suffixButtonClass: null
  },
  emits: ["suffixIconClicked"],
  setup(__props, { emit: emit3 }) {
    const onSuffixIconClicked = () => {
      emit3("suffixIconClicked");
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["flex gap-[8px] group items-center relative", [__props.alertClass, __props.headerClass]])
      }, [
        renderSlot(_ctx.$slots, "prefixIcon", {}, () => [
          __props.prefixIcon ? (openBlock(), createBlock(resolveDynamicComponent(__props.prefixIcon), {
            key: 0,
            "data-cy": "alert-prefix-icon",
            class: normalizeClass(["h-[16px] w-[16px] icon-dark-current", __props.prefixIconClass])
          }, null, 8, ["class"])) : createCommentVNode("", true)
        ]),
        createBaseVNode("h2", {
          class: normalizeClass(["grow font-medium text-left leading-normal decoration-current", __props.headerClass])
        }, [
          renderSlot(_ctx.$slots, "title", {}, () => [
            createTextVNode(toDisplayString$1(__props.title), 1)
          ])
        ], 2),
        createBaseVNode("div", _hoisted_1$i, [
          renderSlot(_ctx.$slots, "suffixIcon", normalizeProps(guardReactiveProps({ ariaLabel: __props.suffixIconAriaLabel, buttonClasses: __props.suffixButtonClass, iconClasses: __props.suffixIconClass, onClick: onSuffixIconClicked })), () => [
            __props.suffixIcon ? (openBlock(), createElementBlock("button", {
              key: 0,
              "data-cy": "alert-suffix-icon",
              "aria-label": __props.suffixIconAriaLabel,
              class: normalizeClass(["rounded-full flex outline-none h-[32px] -top-[16px] right-[-8px] w-[32px] hocus:ring-current items-center justify-center absolute hocus:ring-1", __props.suffixButtonClass]),
              onClick: onSuffixIconClicked
            }, [
              (openBlock(), createBlock(resolveDynamicComponent(__props.suffixIcon), {
                class: normalizeClass(["h-[16px] w-[16px]", __props.suffixIconClass])
              }, null, 8, ["class"]))
            ], 10, _hoisted_2$i)) : createCommentVNode("", true)
          ])
        ])
      ], 2);
    };
  }
});
const _hoisted_1$h = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$h = /* @__PURE__ */ createBaseVNode("path", {
  d: "M3 13L13 3M3 3L13 13",
  class: "icon-dark",
  stroke: "#1B1E2E",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null, -1);
const _hoisted_3$d = [
  _hoisted_2$h
];
function render$f(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$h, _hoisted_3$d);
}
const __unplugin_components_0$1 = { name: "cy-delete_x16", render: render$f };
const _hoisted_1$g = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$g = /* @__PURE__ */ createBaseVNode("path", {
  d: "M4 6L8 10L12 6",
  stroke: "currentColor",
  class: "icon-dark",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null, -1);
const _hoisted_3$c = [
  _hoisted_2$g
];
function render$e(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$g, _hoisted_3$c);
}
const __unplugin_components_0 = { name: "cy-chevron-down-small_x16", render: render$e };
const _hoisted_1$f = ["tabindex"];
const _hoisted_2$f = ["aria-expanded"];
const _hoisted_3$b = ["aria-hidden"];
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "Collapsible",
  props: {
    maxHeight: { default: "500px" },
    initiallyOpen: { type: Boolean, default: false },
    lazy: { type: Boolean, default: false },
    disable: { type: Boolean, default: false },
    overflow: { type: Boolean, default: true },
    fileRow: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const [isOpen, toggle] = useToggle(props.initiallyOpen);
    watch(() => props.initiallyOpen, (val, oldVal) => {
      if (oldVal === false && val === true) {
        isOpen.value = true;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        tabindex: __props.disable ? "-1" : "0",
        "data-cy": "collapsible",
        onKeypress: _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => !__props.disable && unref(toggle)(), ["self", "prevent"]), ["space", "enter"]))
      }, [
        createBaseVNode("div", {
          "data-cy": "collapsible-header",
          role: "button",
          "aria-expanded": unref(isOpen),
          class: normalizeClass(["rounded-t focus:outline-indigo-500", { "rounded-b": !unref(isOpen) }]),
          onClick: _cache[0] || (_cache[0] = ($event) => !__props.disable && unref(toggle)()),
          onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => !__props.disable && unref(toggle)(), ["self"]), ["space", "enter"]))
        }, [
          renderSlot(_ctx.$slots, "target", {
            open: unref(isOpen),
            toggle: unref(toggle)
          })
        ], 42, _hoisted_2$f),
        createBaseVNode("div", {
          style: normalizeStyle({
            maxHeight: unref(isOpen) ? __props.maxHeight : "0px"
          }),
          "aria-hidden": !unref(isOpen),
          class: normalizeClass({
            "overflow-auto": unref(isOpen) && __props.overflow,
            "border rounded rounded-t-none bg-light-50 border-gray-100 mb-4 w-full block": unref(isOpen) && __props.fileRow,
            "overflow-hidden": !unref(isOpen) && __props.fileRow
          })
        }, [
          !__props.lazy || __props.lazy && unref(isOpen) ? renderSlot(_ctx.$slots, "default", {
            key: 0,
            toggle: unref(toggle),
            open: unref(isOpen)
          }) : createCommentVNode("", true)
        ], 14, _hoisted_3$b)
      ], 40, _hoisted_1$f);
    };
  }
});
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "Alert",
  props: {
    title: { default: void 0 },
    status: { default: "info" },
    icon: { default: void 0 },
    headerClass: { default: void 0 },
    bodyClass: { default: void 0 },
    dismissible: { type: Boolean },
    collapsible: { type: Boolean },
    modelValue: { type: Boolean, default: true },
    iconClasses: { default: "" },
    maxHeight: { default: void 0 },
    overflow: { type: Boolean, default: true }
  },
  emits: ["update:modelValue"],
  setup(__props) {
    const props = __props;
    const { t: t2 } = useI18n();
    const slots = useSlots();
    const title = computed(() => props.title ?? "Alert");
    const alertStyles = {
      default: {
        headerClass: "text-gray-800 bg-gray-100",
        suffixIconClass: "icon-dark-gray-600",
        suffixButtonClass: "text-gray-600",
        bodyClass: "bg-gray-50",
        ring: "hocus:ring-gray-200 hocus:border-gray-300"
      },
      info: {
        headerClass: "text-info-700 bg-info-100",
        suffixIconClass: "icon-dark-info-500",
        suffixButtonClass: "text-info-500",
        bodyClass: "bg-info-50",
        ring: "hocus:ring-info-200 hocus:border-info-300"
      },
      warning: {
        headerClass: "text-warning-600 bg-warning-100",
        suffixIconClass: "icon-dark-warning-500",
        suffixButtonClass: "text-warning-500",
        bodyClass: "bg-warning-50",
        ring: "hocus:ring-warning-200 hocus:border-warning-300"
      },
      error: {
        headerClass: "text-error-600 bg-error-100",
        suffixIconClass: "icon-dark-error-500",
        suffixButtonClass: "text-error-500",
        bodyClass: "bg-error-50",
        ring: "hocus:ring-error-200 hocus:border-error-300"
      },
      success: {
        headerClass: "text-success-600 bg-success-100",
        suffixIconClass: "icon-dark-success-500",
        suffixButtonClass: "text-success-500",
        bodyClass: "bg-success-50",
        ring: "hocus:ring-success-200 hocus:border-success-300"
      },
      promo: {
        headerClass: "text-gray-900 bg-white border border-gray-100",
        suffixIconClass: "icon-dark-gray-700",
        suffixButtonClass: "text-gray-700",
        bodyClass: "bg-white border-t border-gray-100",
        ring: "hocus:ring-gray-100 hocus:border-gray-100"
      }
    };
    const classes = computed(() => {
      return {
        ...alertStyles[props.status],
        bodyClass: props.bodyClass ?? alertStyles[props.status].bodyClass,
        headerClass: props.headerClass ?? alertStyles[props.status].headerClass
      };
    });
    const canCollapse = computed(() => slots.default && props.collapsible);
    const initiallyOpen = computed(() => slots.default && !props.collapsible);
    const prefix = computed(() => {
      if (props.icon)
        return { classes: props.iconClasses, icon: props.icon };
      if (canCollapse.value) {
        return {
          icon: __unplugin_components_0,
          classes: "transition transform duration-150 w-[16px] h-[16px]"
        };
      }
      return {};
    });
    const computedBodyClass = computed(() => {
      return `${classes.value.bodyClass} ${props.bodyClass}`;
    });
    return (_ctx, _cache) => {
      return __props.modelValue ? (openBlock(), createBlock(_sfc_main$j, {
        key: 0,
        lazy: "",
        "initially-open": unref(initiallyOpen),
        disable: !unref(canCollapse),
        overflow: __props.overflow,
        class: normalizeClass(["rounded-t rounded-b outline-none group", [
          unref(classes).headerClass,
          { [`hocus-default border border-transparent rounded ${unref(classes).ring}`]: unref(canCollapse), "overflow-hidden": __props.overflow }
        ]]),
        "max-height": __props.maxHeight
      }, {
        target: withCtx(({ open }) => {
          var _a2, _b2, _c;
          return [
            createBaseVNode("div", {
              "data-cy": "alert-header",
              class: normalizeClass(["grid grid-cols-1 group", {
                "cursor-pointer": unref(canCollapse)
              }])
            }, [
              createVNode(_sfc_main$k, {
                title: unref(title),
                "header-class": `${props.headerClass} ${unref(canCollapse) ? "group-hocus:underline" : ""}`,
                "prefix-icon": (_a2 = unref(prefix)) == null ? void 0 : _a2.icon,
                "prefix-icon-class": open && __props.collapsible ? ((_b2 = unref(prefix)) == null ? void 0 : _b2.classes) + " rotate-180" : (_c = unref(prefix)) == null ? void 0 : _c.classes,
                "suffix-icon-aria-label": props.dismissible ? unref(t2)("components.alert.dismissAriaLabel") : "",
                "suffix-icon": props.dismissible ? unref(__unplugin_components_0$1) : null,
                "suffix-button-class": unref(classes).suffixButtonClass,
                "suffix-icon-class": unref(classes).suffixIconClass,
                "data-cy": "alert",
                class: "rounded min-w-[200px] p-[16px]",
                onSuffixIconClicked: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", !__props.modelValue))
              }, createSlots({ _: 2 }, [
                _ctx.$slots.title ? {
                  name: "title",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "title")
                  ]),
                  key: "0"
                } : void 0,
                _ctx.$slots.prefixIcon ? {
                  name: "prefixIcon",
                  fn: withCtx((slotProps) => [
                    renderSlot(_ctx.$slots, "prefixIcon", normalizeProps(guardReactiveProps(slotProps)))
                  ]),
                  key: "1"
                } : void 0,
                _ctx.$slots.suffixIcon ? {
                  name: "suffixIcon",
                  fn: withCtx((slotProps) => [
                    renderSlot(_ctx.$slots, "suffixIcon", normalizeProps(guardReactiveProps(slotProps)))
                  ]),
                  key: "2"
                } : void 0
              ]), 1032, ["title", "header-class", "prefix-icon", "prefix-icon-class", "suffix-icon-aria-label", "suffix-icon", "suffix-button-class", "suffix-icon-class"])
            ], 2)
          ];
        }),
        default: withCtx(() => [
          _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["text-left p-[16px]", unref(computedBodyClass)]),
            "data-cy": "alert-body"
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["initially-open", "disable", "overflow", "class", "max-height"])) : createCommentVNode("", true);
    };
  }
});
const _hoisted_1$e = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$e = /* @__PURE__ */ createBaseVNode("path", {
  d: "M2 8H8M14 8H8M8 8V2M8 8V14",
  stroke: "#1B1E2E",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  class: "icon-dark"
}, null, -1);
const _hoisted_3$a = [
  _hoisted_2$e
];
function render$d(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$e, _hoisted_3$a);
}
const __unplugin_components_1 = { name: "cy-add-large_x16", render: render$d };
const _hoisted_1$d = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$d = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M7.29289 2.29289C7.10536 2.10536 6.851 2 6.58579 2H2C1.44772 2 1 2.44772 1 3V6H6.58579C6.851 6 7.10536 5.89464 7.29289 5.70711L9 4L7.29289 2.29289Z",
  fill: "#D0D2E0",
  class: "icon-light"
}, null, -1);
const _hoisted_3$9 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M9 4L7.29289 2.29289C7.10536 2.10536 6.851 2 6.58579 2H2C1.44772 2 1 2.44772 1 3V6M9 4H14C14.5523 4 15 4.44772 15 5V13C15 13.5523 14.5523 14 14 14H2C1.44772 14 1 13.5523 1 13V6M9 4L7.29289 5.70711C7.10536 5.89464 6.851 6 6.58579 6H1",
  stroke: "#1B1E2E",
  "stroke-width": "2",
  "stroke-linejoin": "round",
  class: "icon-dark"
}, null, -1);
const _hoisted_4$6 = [
  _hoisted_2$d,
  _hoisted_3$9
];
function render$c(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$d, _hoisted_4$6);
}
const FolderIcon = { name: "cy-folder-outline_x16", render: render$c };
const _hoisted_1$c = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$c = /* @__PURE__ */ createStaticVNode('<path d="M10 4V14H14C14.5523 14 15 13.5523 15 13V5C15 4.44772 14.5523 4 14 4H10Z" class="icon-light" fill="#D0D2E0"></path><path d="M10 14H2C1.44772 14 1 13.5523 1 13V2C1 1.44772 1.44772 1 2 1H9C9.55228 1 10 1.44772 10 2V4M10 14V4M10 14H14C14.5523 14 15 13.5523 15 13V5C15 4.44772 14.5523 4 14 4H10" stroke="#1B1E2E" stroke-width="2" class="icon-dark"></path><path d="M3 3.5C3 3.22386 3.22386 3 3.5 3H4.5C4.77614 3 5 3.22386 5 3.5V4.5C5 4.77614 4.77614 5 4.5 5H3.5C3.22386 5 3 4.77614 3 4.5V3.5Z" fill="#1B1E2E" class="icon-dark"></path><path d="M12 6.5C12 6.22386 12.2239 6 12.5 6C12.7761 6 13 6.22386 13 6.5V7.5C13 7.77614 12.7761 8 12.5 8C12.2239 8 12 7.77614 12 7.5V6.5Z" fill="#1B1E2E" class="icon-dark"></path><path d="M12 9.5C12 9.22386 12.2239 9 12.5 9C12.7761 9 13 9.22386 13 9.5V10.5C13 10.7761 12.7761 11 12.5 11C12.2239 11 12 10.7761 12 10.5V9.5Z" fill="#1B1E2E" class="icon-dark"></path><path d="M3 6.5C3 6.22386 3.22386 6 3.5 6H4.5C4.77614 6 5 6.22386 5 6.5V7.5C5 7.77614 4.77614 8 4.5 8H3.5C3.22386 8 3 7.77614 3 7.5V6.5Z" fill="#1B1E2E" class="icon-dark"></path><path d="M3 9.5C3 9.22386 3.22386 9 3.5 9H4.5C4.77614 9 5 9.22386 5 9.5V10.5C5 10.7761 4.77614 11 4.5 11H3.5C3.22386 11 3 10.7761 3 10.5V9.5Z" fill="#1B1E2E" class="icon-dark"></path><path d="M6 3.5C6 3.22386 6.22386 3 6.5 3H7.5C7.77614 3 8 3.22386 8 3.5V4.5C8 4.77614 7.77614 5 7.5 5H6.5C6.22386 5 6 4.77614 6 4.5V3.5Z" fill="#1B1E2E" class="icon-dark"></path><path d="M6 6.5C6 6.22386 6.22386 6 6.5 6H7.5C7.77614 6 8 6.22386 8 6.5V7.5C8 7.77614 7.77614 8 7.5 8H6.5C6.22386 8 6 7.77614 6 7.5V6.5Z" fill="#1B1E2E" class="icon-dark"></path><path d="M6 9.5C6 9.22386 6.22386 9 6.5 9H7.5C7.77614 9 8 9.22386 8 9.5V10.5C8 10.7761 7.77614 11 7.5 11H6.5C6.22386 11 6 10.7761 6 10.5V9.5Z" fill="#1B1E2E" class="icon-dark"></path>', 10);
const _hoisted_12$1 = [
  _hoisted_2$c
];
function render$b(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$c, _hoisted_12$1);
}
const OrganizationIcon = { name: "cy-office-building_x16", render: render$b };
const _hoisted_1$b = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$b = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M2 8C2 4.68629 4.68629 2 8 2C11.3137 2 14 4.68629 14 8C14 11.3137 11.3137 14 8 14C4.68629 14 2 11.3137 2 8ZM8 0C3.58172 0 0 3.58172 0 8C0 12.4183 3.58172 16 8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0ZM9 5C9 4.44772 8.55228 4 8 4C7.44772 4 7 4.44772 7 5V8C7 8.55228 7.44772 9 8 9C8.55228 9 9 8.55228 9 8V5ZM8 12C8.55228 12 9 11.5523 9 11C9 10.4477 8.55228 10 8 10C7.44772 10 7 10.4477 7 11C7 11.5523 7.44772 12 8 12Z",
  fill: "currentColor",
  class: "icon-dark"
}, null, -1);
const _hoisted_3$8 = [
  _hoisted_2$b
];
function render$a(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$b, _hoisted_3$8);
}
const WarningIcon = { name: "cy-warning_x16", render: render$a };
function keyValMap(list, keyFn, valFn) {
  return list.reduce(function(map2, item) {
    map2[keyFn(item)] = valFn(item);
    return map2;
  }, /* @__PURE__ */ Object.create(null));
}
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(function(node) {
        return valueFromASTUntyped(node, variables);
      });
    case Kind.OBJECT:
      return keyValMap(valueNode.fields, function(field) {
        return field.name.value;
      }, function(field) {
        return valueFromASTUntyped(field.value, variables);
      });
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
  invariant$2(0, "Unexpected value node: " + inspect(valueNode));
}
const isFunction$1 = (value) => typeof value === "function";
const isString = (value) => typeof value === "string";
const isNonEmptyString = (value) => isString(value) && value.trim().length > 0;
const isNumber = (value) => typeof value === "number";
const isUndefined = (value) => typeof value === "undefined";
const isObject$3 = (value) => typeof value === "object" && value !== null;
const isJSX = (obj) => hasProp(obj, "tag") && isNonEmptyString(obj.tag);
const isTouchEvent = (event) => window.TouchEvent && event instanceof TouchEvent;
const isToastComponent = (obj) => hasProp(obj, "component") && isToastContent(obj.component);
const isVueComponent = (c2) => isFunction$1(c2) || isObject$3(c2);
const isToastContent = (obj) => (
  // Ignore undefined
  !isUndefined(obj) && // Is a string
  (isString(obj) || // Regular Vue component
  isVueComponent(obj) || // Nested object
  isToastComponent(obj))
);
const isDOMRect = (obj) => isObject$3(obj) && ["height", "width", "right", "left", "top", "bottom"].every((p2) => isNumber(obj[p2]));
const hasProp = (obj, propKey) => (isObject$3(obj) || isFunction$1(obj)) && propKey in obj;
const getId = /* @__PURE__ */ ((i) => () => i++)(0);
function getX(event) {
  return isTouchEvent(event) ? event.targetTouches[0].clientX : event.clientX;
}
function getY(event) {
  return isTouchEvent(event) ? event.targetTouches[0].clientY : event.clientY;
}
const removeElement = (el) => {
  if (!isUndefined(el.remove)) {
    el.remove();
  } else if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
};
const getVueComponentFromObj = (obj) => {
  if (isToastComponent(obj)) {
    return getVueComponentFromObj(obj.component);
  }
  if (isJSX(obj)) {
    return defineComponent({
      render() {
        return obj;
      }
    });
  }
  return typeof obj === "string" ? obj : toRaw(unref(obj));
};
const normalizeToastComponent = (obj) => {
  if (typeof obj === "string") {
    return obj;
  }
  const props = hasProp(obj, "props") && isObject$3(obj.props) ? obj.props : {};
  const listeners2 = hasProp(obj, "listeners") && isObject$3(obj.listeners) ? obj.listeners : {};
  return {
    component: getVueComponentFromObj(obj),
    props,
    listeners: listeners2
  };
};
const isBrowser$1 = () => typeof window !== "undefined";
class EventBus {
  constructor() {
    this.allHandlers = {};
  }
  getHandlers(eventType) {
    return this.allHandlers[eventType] || [];
  }
  on(eventType, handler) {
    const handlers = this.getHandlers(eventType);
    handlers.push(handler);
    this.allHandlers[eventType] = handlers;
  }
  off(eventType, handler) {
    const handlers = this.getHandlers(eventType);
    handlers.splice(handlers.indexOf(handler) >>> 0, 1);
  }
  emit(eventType, event) {
    const handlers = this.getHandlers(eventType);
    handlers.forEach((handler) => handler(event));
  }
}
const isEventBusInterface = (e) => ["on", "off", "emit"].every((f2) => hasProp(e, f2) && isFunction$1(e[f2]));
var TYPE;
(function(TYPE2) {
  TYPE2["SUCCESS"] = "success";
  TYPE2["ERROR"] = "error";
  TYPE2["WARNING"] = "warning";
  TYPE2["INFO"] = "info";
  TYPE2["DEFAULT"] = "default";
})(TYPE || (TYPE = {}));
var POSITION;
(function(POSITION2) {
  POSITION2["TOP_LEFT"] = "top-left";
  POSITION2["TOP_CENTER"] = "top-center";
  POSITION2["TOP_RIGHT"] = "top-right";
  POSITION2["BOTTOM_LEFT"] = "bottom-left";
  POSITION2["BOTTOM_CENTER"] = "bottom-center";
  POSITION2["BOTTOM_RIGHT"] = "bottom-right";
})(POSITION || (POSITION = {}));
var EVENTS;
(function(EVENTS2) {
  EVENTS2["ADD"] = "add";
  EVENTS2["DISMISS"] = "dismiss";
  EVENTS2["UPDATE"] = "update";
  EVENTS2["CLEAR"] = "clear";
  EVENTS2["UPDATE_DEFAULTS"] = "update_defaults";
})(EVENTS || (EVENTS = {}));
const VT_NAMESPACE = "Vue-Toastification";
const COMMON = {
  type: {
    type: String,
    default: TYPE.DEFAULT
  },
  classNames: {
    type: [String, Array],
    default: () => []
  },
  trueBoolean: {
    type: Boolean,
    default: true
  }
};
const ICON = {
  type: COMMON.type,
  customIcon: {
    type: [String, Boolean, Object, Function],
    default: true
  }
};
const CLOSE_BUTTON = {
  component: {
    type: [String, Object, Function, Boolean],
    default: "button"
  },
  classNames: COMMON.classNames,
  showOnHover: {
    type: Boolean,
    default: false
  },
  ariaLabel: {
    type: String,
    default: "close"
  }
};
const PROGRESS_BAR = {
  timeout: {
    type: [Number, Boolean],
    default: 5e3
  },
  hideProgressBar: {
    type: Boolean,
    default: false
  },
  isRunning: {
    type: Boolean,
    default: false
  }
};
const TRANSITION = {
  transition: {
    type: [Object, String],
    default: `${VT_NAMESPACE}__bounce`
  }
};
const CORE_TOAST = {
  position: {
    type: String,
    default: POSITION.TOP_RIGHT
  },
  draggable: COMMON.trueBoolean,
  draggablePercent: {
    type: Number,
    default: 0.6
  },
  pauseOnFocusLoss: COMMON.trueBoolean,
  pauseOnHover: COMMON.trueBoolean,
  closeOnClick: COMMON.trueBoolean,
  timeout: PROGRESS_BAR.timeout,
  hideProgressBar: PROGRESS_BAR.hideProgressBar,
  toastClassName: COMMON.classNames,
  bodyClassName: COMMON.classNames,
  icon: ICON.customIcon,
  closeButton: CLOSE_BUTTON.component,
  closeButtonClassName: CLOSE_BUTTON.classNames,
  showCloseButtonOnHover: CLOSE_BUTTON.showOnHover,
  accessibility: {
    type: Object,
    default: () => ({
      toastRole: "alert",
      closeButtonLabel: "close"
    })
  },
  rtl: {
    type: Boolean,
    default: false
  },
  eventBus: {
    type: Object,
    required: true,
    default: new EventBus()
  }
};
const TOAST = {
  id: {
    type: [String, Number],
    required: true,
    default: 0
  },
  type: COMMON.type,
  content: {
    type: [String, Object, Function],
    required: true,
    default: ""
  },
  onClick: {
    type: Function,
    default: () => {
    }
  },
  onClose: {
    type: Function,
    default: (
      /* istanbul ignore next */
      () => {
      }
    )
  }
};
const CONTAINER = {
  container: {
    type: [Object, Function],
    default: () => document.body
  },
  newestOnTop: COMMON.trueBoolean,
  maxToasts: {
    type: Number,
    default: 20
  },
  transition: TRANSITION.transition,
  toastDefaults: Object,
  filterBeforeCreate: {
    type: Function,
    default: (toast) => toast
  },
  filterToasts: {
    type: Function,
    default: (toasts) => toasts
  },
  containerClassName: COMMON.classNames,
  onMounted: Function
};
var PROPS = {
  CORE_TOAST,
  TOAST,
  CONTAINER,
  PROGRESS_BAR,
  ICON,
  TRANSITION,
  CLOSE_BUTTON
};
var script = defineComponent({
  name: "VtProgressBar",
  props: PROPS.PROGRESS_BAR,
  // TODO: The typescript compiler is not playing nice with emit types
  // Rollback this change once ts is able to infer emit types
  // emits: ["close-toast"],
  data() {
    return {
      hasClass: true
    };
  },
  computed: {
    style() {
      return {
        animationDuration: `${this.timeout}ms`,
        animationPlayState: this.isRunning ? "running" : "paused",
        opacity: this.hideProgressBar ? 0 : 1
      };
    },
    cpClass() {
      return this.hasClass ? `${VT_NAMESPACE}__progress-bar` : "";
    }
  },
  watch: {
    timeout() {
      this.hasClass = false;
      this.$nextTick(() => this.hasClass = true);
    }
  },
  mounted() {
    this.$el.addEventListener("animationend", this.animationEnded);
  },
  beforeUnmount() {
    this.$el.removeEventListener("animationend", this.animationEnded);
  },
  methods: {
    animationEnded() {
      this.$emit("close-toast");
    }
  }
});
function render$15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    "div",
    {
      style: _ctx.style,
      class: _ctx.cpClass
    },
    null,
    6
    /* CLASS, STYLE */
  );
}
script.render = render$15;
script.__file = "src/components/VtProgressBar.vue";
var script$1 = defineComponent({
  name: "VtCloseButton",
  props: PROPS.CLOSE_BUTTON,
  computed: {
    buttonComponent() {
      if (this.component !== false) {
        return getVueComponentFromObj(this.component);
      }
      return "button";
    },
    classes() {
      const classes = [`${VT_NAMESPACE}__close-button`];
      if (this.showOnHover) {
        classes.push("show-on-hover");
      }
      return classes.concat(this.classNames);
    }
  }
});
const _hoisted_1$a = /* @__PURE__ */ createTextVNode("  ");
function render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.buttonComponent), mergeProps({
    "aria-label": _ctx.ariaLabel,
    class: _ctx.classes
  }, _ctx.$attrs), {
    default: withCtx(() => [
      _hoisted_1$a
    ]),
    _: 1
  }, 16, ["aria-label", "class"]);
}
script$1.render = render$1$1;
script$1.__file = "src/components/VtCloseButton.vue";
var script$2 = {};
const _hoisted_1$1$1 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "check-circle",
  class: "svg-inline--fa fa-check-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
const _hoisted_2$a = /* @__PURE__ */ createVNode(
  "path",
  {
    fill: "currentColor",
    d: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"
  },
  null,
  -1
  /* HOISTED */
);
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock("svg", _hoisted_1$1$1, [
    _hoisted_2$a
  ]);
}
script$2.render = render$2;
script$2.__file = "src/components/icons/VtSuccessIcon.vue";
var script$3 = {};
const _hoisted_1$2$1 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "info-circle",
  class: "svg-inline--fa fa-info-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
const _hoisted_2$1$1 = /* @__PURE__ */ createVNode(
  "path",
  {
    fill: "currentColor",
    d: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"
  },
  null,
  -1
  /* HOISTED */
);
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock("svg", _hoisted_1$2$1, [
    _hoisted_2$1$1
  ]);
}
script$3.render = render$3;
script$3.__file = "src/components/icons/VtInfoIcon.vue";
var script$4 = {};
const _hoisted_1$3$1 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "exclamation-circle",
  class: "svg-inline--fa fa-exclamation-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
const _hoisted_2$2$1 = /* @__PURE__ */ createVNode(
  "path",
  {
    fill: "currentColor",
    d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
  },
  null,
  -1
  /* HOISTED */
);
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock("svg", _hoisted_1$3$1, [
    _hoisted_2$2$1
  ]);
}
script$4.render = render$4;
script$4.__file = "src/components/icons/VtWarningIcon.vue";
var script$5 = {};
const _hoisted_1$4$1 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "exclamation-triangle",
  class: "svg-inline--fa fa-exclamation-triangle fa-w-18",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 576 512"
};
const _hoisted_2$3$1 = /* @__PURE__ */ createVNode(
  "path",
  {
    fill: "currentColor",
    d: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
  },
  null,
  -1
  /* HOISTED */
);
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock("svg", _hoisted_1$4$1, [
    _hoisted_2$3$1
  ]);
}
script$5.render = render$5;
script$5.__file = "src/components/icons/VtErrorIcon.vue";
var script$6 = defineComponent({
  name: "VtIcon",
  props: PROPS.ICON,
  computed: {
    customIconChildren() {
      return hasProp(this.customIcon, "iconChildren") ? this.trimValue(this.customIcon.iconChildren) : "";
    },
    customIconClass() {
      if (isString(this.customIcon)) {
        return this.trimValue(this.customIcon);
      } else if (hasProp(this.customIcon, "iconClass")) {
        return this.trimValue(this.customIcon.iconClass);
      }
      return "";
    },
    customIconTag() {
      if (hasProp(this.customIcon, "iconTag")) {
        return this.trimValue(this.customIcon.iconTag, "i");
      }
      return "i";
    },
    hasCustomIcon() {
      return this.customIconClass.length > 0;
    },
    component() {
      if (this.hasCustomIcon) {
        return this.customIconTag;
      }
      if (isToastContent(this.customIcon)) {
        return getVueComponentFromObj(this.customIcon);
      }
      return this.iconTypeComponent;
    },
    iconTypeComponent() {
      const types = {
        [TYPE.DEFAULT]: script$3,
        [TYPE.INFO]: script$3,
        [TYPE.SUCCESS]: script$2,
        [TYPE.ERROR]: script$5,
        [TYPE.WARNING]: script$4
      };
      return types[this.type];
    },
    iconClasses() {
      const classes = [`${VT_NAMESPACE}__icon`];
      if (this.hasCustomIcon) {
        return classes.concat(this.customIconClass);
      }
      return classes;
    }
  },
  methods: {
    trimValue(value, empty2 = "") {
      return isNonEmptyString(value) ? value.trim() : empty2;
    }
  }
});
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.component), { class: _ctx.iconClasses }, {
    default: withCtx(() => [
      createTextVNode(
        toDisplayString$1(_ctx.customIconChildren),
        1
        /* TEXT */
      )
    ]),
    _: 1
  }, 8, ["class"]);
}
script$6.render = render$6;
script$6.__file = "src/components/VtIcon.vue";
var script$7 = defineComponent({
  name: "VtToast",
  components: {
    ProgressBar: script,
    CloseButton: script$1,
    Icon: script$6
  },
  inheritAttrs: false,
  props: Object.assign({}, PROPS.CORE_TOAST, PROPS.TOAST),
  data() {
    const data = {
      isRunning: true,
      disableTransitions: false,
      beingDragged: false,
      dragStart: 0,
      dragPos: {
        x: 0,
        y: 0
      },
      dragRect: {}
    };
    return data;
  },
  computed: {
    classes() {
      const classes = [`${VT_NAMESPACE}__toast`, `${VT_NAMESPACE}__toast--${this.type}`, `${this.position}`].concat(this.toastClassName);
      if (this.disableTransitions) {
        classes.push("disable-transition");
      }
      if (this.rtl) {
        classes.push(`${VT_NAMESPACE}__toast--rtl`);
      }
      return classes;
    },
    bodyClasses() {
      const classes = [`${VT_NAMESPACE}__toast-${isString(this.content) ? "body" : "component-body"}`].concat(this.bodyClassName);
      return classes;
    },
    /* istanbul ignore next */
    draggableStyle() {
      if (this.dragStart === this.dragPos.x) {
        return {};
      } else if (this.beingDragged) {
        return {
          transform: `translateX(${this.dragDelta}px)`,
          opacity: 1 - Math.abs(this.dragDelta / this.removalDistance)
        };
      } else {
        return {
          transition: "transform 0.2s, opacity 0.2s",
          transform: "translateX(0)",
          opacity: 1
        };
      }
    },
    dragDelta() {
      return this.beingDragged ? this.dragPos.x - this.dragStart : 0;
    },
    removalDistance() {
      if (isDOMRect(this.dragRect)) {
        return (this.dragRect.right - this.dragRect.left) * this.draggablePercent;
      }
      return 0;
    }
  },
  mounted() {
    if (this.draggable) {
      this.draggableSetup();
    }
    if (this.pauseOnFocusLoss) {
      this.focusSetup();
    }
  },
  beforeUnmount() {
    if (this.draggable) {
      this.draggableCleanup();
    }
    if (this.pauseOnFocusLoss) {
      this.focusCleanup();
    }
  },
  methods: {
    getVueComponentFromObj,
    closeToast() {
      this.eventBus.emit(EVENTS.DISMISS, this.id);
    },
    clickHandler() {
      if (this.onClick) {
        this.onClick(this.closeToast);
      }
      if (this.closeOnClick) {
        if (!this.beingDragged || this.dragStart === this.dragPos.x) {
          this.closeToast();
        }
      }
    },
    timeoutHandler() {
      this.closeToast();
    },
    hoverPause() {
      if (this.pauseOnHover) {
        this.isRunning = false;
      }
    },
    hoverPlay() {
      if (this.pauseOnHover) {
        this.isRunning = true;
      }
    },
    focusPause() {
      this.isRunning = false;
    },
    focusPlay() {
      this.isRunning = true;
    },
    focusSetup() {
      addEventListener("blur", this.focusPause);
      addEventListener("focus", this.focusPlay);
    },
    focusCleanup() {
      removeEventListener("blur", this.focusPause);
      removeEventListener("focus", this.focusPlay);
    },
    draggableSetup() {
      const element = this.$el;
      element.addEventListener("touchstart", this.onDragStart, {
        passive: true
      });
      element.addEventListener("mousedown", this.onDragStart);
      addEventListener("touchmove", this.onDragMove, {
        passive: false
      });
      addEventListener("mousemove", this.onDragMove);
      addEventListener("touchend", this.onDragEnd);
      addEventListener("mouseup", this.onDragEnd);
    },
    draggableCleanup() {
      const element = this.$el;
      element.removeEventListener("touchstart", this.onDragStart);
      element.removeEventListener("mousedown", this.onDragStart);
      removeEventListener("touchmove", this.onDragMove);
      removeEventListener("mousemove", this.onDragMove);
      removeEventListener("touchend", this.onDragEnd);
      removeEventListener("mouseup", this.onDragEnd);
    },
    onDragStart(event) {
      this.beingDragged = true;
      this.dragPos = {
        x: getX(event),
        y: getY(event)
      };
      this.dragStart = getX(event);
      this.dragRect = this.$el.getBoundingClientRect();
    },
    onDragMove(event) {
      if (this.beingDragged) {
        event.preventDefault();
        if (this.isRunning) {
          this.isRunning = false;
        }
        this.dragPos = {
          x: getX(event),
          y: getY(event)
        };
      }
    },
    onDragEnd() {
      if (this.beingDragged) {
        if (Math.abs(this.dragDelta) >= this.removalDistance) {
          this.disableTransitions = true;
          this.$nextTick(() => this.closeToast());
        } else {
          setTimeout(() => {
            this.beingDragged = false;
            if (isDOMRect(this.dragRect) && this.pauseOnHover && this.dragRect.bottom >= this.dragPos.y && this.dragPos.y >= this.dragRect.top && this.dragRect.left <= this.dragPos.x && this.dragPos.x <= this.dragRect.right) {
              this.isRunning = false;
            } else {
              this.isRunning = true;
            }
          });
        }
      }
    }
  }
});
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_CloseButton = resolveComponent("CloseButton");
  const _component_ProgressBar = resolveComponent("ProgressBar");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.classes,
      style: _ctx.draggableStyle,
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.clickHandler(...args)),
      onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.hoverPause(...args)),
      onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.hoverPlay(...args))
    },
    [
      _ctx.icon ? (openBlock(), createBlock(_component_Icon, {
        key: 0,
        "custom-icon": _ctx.icon,
        type: _ctx.type
      }, null, 8, ["custom-icon", "type"])) : createCommentVNode("v-if", true),
      createVNode("div", {
        role: _ctx.accessibility.toastRole || "alert",
        class: _ctx.bodyClasses
      }, [
        typeof _ctx.content === "string" ? (openBlock(), createBlock(
          Fragment,
          { key: 0 },
          [
            createTextVNode(
              toDisplayString$1(_ctx.content),
              1
              /* TEXT */
            )
          ],
          64
          /* STABLE_FRAGMENT */
        )) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.getVueComponentFromObj(_ctx.content)), mergeProps({
          key: 1,
          "toast-id": _ctx.id
        }, _ctx.content.props, toHandlers(_ctx.content.listeners), { onCloseToast: _ctx.closeToast }), null, 16, ["toast-id", "onCloseToast"]))
      ], 10, ["role"]),
      !!_ctx.closeButton ? (openBlock(), createBlock(_component_CloseButton, {
        key: 1,
        component: _ctx.closeButton,
        "class-names": _ctx.closeButtonClassName,
        "show-on-hover": _ctx.showCloseButtonOnHover,
        "aria-label": _ctx.accessibility.closeButtonLabel,
        onClick: withModifiers(_ctx.closeToast, ["stop"])
      }, null, 8, ["component", "class-names", "show-on-hover", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
      _ctx.timeout ? (openBlock(), createBlock(_component_ProgressBar, {
        key: 2,
        "is-running": _ctx.isRunning,
        "hide-progress-bar": _ctx.hideProgressBar,
        timeout: _ctx.timeout,
        onCloseToast: _ctx.timeoutHandler
      }, null, 8, ["is-running", "hide-progress-bar", "timeout", "onCloseToast"])) : createCommentVNode("v-if", true)
    ],
    38
    /* CLASS, STYLE, HYDRATE_EVENTS */
  );
}
script$7.render = render$7;
script$7.__file = "src/components/VtToast.vue";
var script$8 = defineComponent({
  name: "VtTransition",
  props: PROPS.TRANSITION,
  emits: ["leave"],
  methods: {
    leave(el) {
      el.style.left = el.offsetLeft + "px";
      el.style.top = el.offsetTop + "px";
      el.style.width = getComputedStyle(el).width;
      el.style.position = "absolute";
    }
  }
});
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(TransitionGroup, {
    tag: "div",
    "enter-active-class": _ctx.transition.enter ? _ctx.transition.enter : `${_ctx.transition}-enter-active`,
    "move-class": _ctx.transition.move ? _ctx.transition.move : `${_ctx.transition}-move`,
    "leave-active-class": _ctx.transition.leave ? _ctx.transition.leave : `${_ctx.transition}-leave-active`,
    onLeave: _ctx.leave
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["enter-active-class", "move-class", "leave-active-class", "onLeave"]);
}
script$8.render = render$8;
script$8.__file = "src/components/VtTransition.vue";
var script$9 = defineComponent({
  name: "VueToastification",
  components: {
    Toast: script$7,
    VtTransition: script$8
  },
  props: Object.assign({}, PROPS.CORE_TOAST, PROPS.CONTAINER, PROPS.TRANSITION),
  data() {
    const data = {
      count: 0,
      positions: Object.values(POSITION),
      toasts: {},
      defaults: {}
    };
    return data;
  },
  computed: {
    toastArray() {
      return Object.values(this.toasts);
    },
    filteredToasts() {
      return this.defaults.filterToasts(this.toastArray);
    }
  },
  beforeMount() {
    const events2 = this.eventBus;
    events2.on(EVENTS.ADD, this.addToast);
    events2.on(EVENTS.CLEAR, this.clearToasts);
    events2.on(EVENTS.DISMISS, this.dismissToast);
    events2.on(EVENTS.UPDATE, this.updateToast);
    events2.on(EVENTS.UPDATE_DEFAULTS, this.updateDefaults);
    this.defaults = this.$props;
  },
  mounted() {
    this.setup(this.container);
  },
  methods: {
    async setup(container) {
      if (isFunction$1(container)) {
        container = await container();
      }
      removeElement(this.$el);
      container.appendChild(this.$el);
    },
    setToast(props) {
      if (!isUndefined(props.id)) {
        this.toasts[props.id] = props;
      }
    },
    addToast(params) {
      params.content = normalizeToastComponent(params.content);
      const props = Object.assign({}, this.defaults, params.type && this.defaults.toastDefaults && this.defaults.toastDefaults[params.type], params);
      const toast = this.defaults.filterBeforeCreate(props, this.toastArray);
      toast && this.setToast(toast);
    },
    dismissToast(id2) {
      const toast = this.toasts[id2];
      if (!isUndefined(toast) && !isUndefined(toast.onClose)) {
        toast.onClose();
      }
      delete this.toasts[id2];
    },
    clearToasts() {
      Object.keys(this.toasts).forEach((id2) => {
        this.dismissToast(id2);
      });
    },
    getPositionToasts(position) {
      const toasts = this.filteredToasts.filter((toast) => toast.position === position).slice(0, this.defaults.maxToasts);
      return this.defaults.newestOnTop ? toasts.reverse() : toasts;
    },
    updateDefaults(update) {
      if (!isUndefined(update.container)) {
        this.setup(update.container);
      }
      this.defaults = Object.assign({}, this.defaults, update);
    },
    updateToast({
      id: id2,
      options: options2,
      create
    }) {
      if (this.toasts[id2]) {
        if (options2.timeout && options2.timeout === this.toasts[id2].timeout) {
          options2.timeout++;
        }
        this.setToast(Object.assign({}, this.toasts[id2], options2));
      } else if (create) {
        this.addToast(Object.assign({}, {
          id: id2
        }, options2));
      }
    },
    getClasses(position) {
      const classes = [`${VT_NAMESPACE}__container`, position];
      return classes.concat(this.defaults.containerClassName);
    }
  }
});
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Toast = resolveComponent("Toast");
  const _component_VtTransition = resolveComponent("VtTransition");
  return openBlock(), createBlock("div", null, [
    (openBlock(true), createBlock(
      Fragment,
      null,
      renderList(_ctx.positions, (pos) => {
        return openBlock(), createBlock("div", { key: pos }, [
          createVNode(_component_VtTransition, {
            transition: _ctx.defaults.transition,
            class: _ctx.getClasses(pos)
          }, {
            default: withCtx(() => [
              (openBlock(true), createBlock(
                Fragment,
                null,
                renderList(_ctx.getPositionToasts(pos), (toast) => {
                  return openBlock(), createBlock(
                    _component_Toast,
                    mergeProps({
                      key: toast.id
                    }, toast),
                    null,
                    16
                    /* FULL_PROPS */
                  );
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]),
            _: 2
          }, 1032, ["transition", "class"])
        ]);
      }),
      128
      /* KEYED_FRAGMENT */
    ))
  ]);
}
script$9.render = render$9;
script$9.__file = "src/components/VtToastContainer.vue";
const buildInterface = (globalOptions = {}, mountContainer = true) => {
  const events2 = globalOptions.eventBus = globalOptions.eventBus || new EventBus();
  if (mountContainer) {
    nextTick(() => {
      const app2 = createApp(script$9, Object.assign({}, globalOptions));
      const component = app2.mount(document.createElement("div"));
      const onMounted2 = globalOptions.onMounted;
      if (!isUndefined(onMounted2)) {
        onMounted2(component, app2);
      }
    });
  }
  const toast = (content, options2) => {
    const props = Object.assign({}, {
      id: getId(),
      type: TYPE.DEFAULT
    }, options2, {
      content
    });
    events2.emit(EVENTS.ADD, props);
    return props.id;
  };
  toast.clear = () => events2.emit(EVENTS.CLEAR, void 0);
  toast.updateDefaults = (update) => {
    events2.emit(EVENTS.UPDATE_DEFAULTS, update);
  };
  toast.dismiss = (id2) => {
    events2.emit(EVENTS.DISMISS, id2);
  };
  function updateToast(id2, {
    content,
    options: options2
  }, create = false) {
    const opt = Object.assign({}, options2, {
      content
    });
    events2.emit(EVENTS.UPDATE, {
      id: id2,
      options: opt,
      create
    });
  }
  toast.update = updateToast;
  toast.success = (content, options2) => toast(content, Object.assign({}, options2, {
    type: TYPE.SUCCESS
  }));
  toast.info = (content, options2) => toast(content, Object.assign({}, options2, {
    type: TYPE.INFO
  }));
  toast.error = (content, options2) => toast(content, Object.assign({}, options2, {
    type: TYPE.ERROR
  }));
  toast.warning = (content, options2) => toast(content, Object.assign({}, options2, {
    type: TYPE.WARNING
  }));
  return toast;
};
const createMockToastInterface = () => {
  const toast = () => console.warn("[Vue Toastification] This plugin does not support SSR!");
  return new Proxy(toast, {
    get() {
      return toast;
    }
  });
};
function createToastInterface(optionsOrEventBus) {
  if (!isBrowser$1()) {
    return createMockToastInterface();
  }
  if (isEventBusInterface(optionsOrEventBus)) {
    return buildInterface({
      eventBus: optionsOrEventBus
    }, false);
  }
  return buildInterface(optionsOrEventBus, true);
}
const toastInjectionKey = Symbol("VueToastification");
const globalEventBus = new EventBus();
const VueToastificationPlugin = (App, options2) => {
  const inter = createToastInterface(Object.assign({
    eventBus: globalEventBus
  }, options2));
  App.provide(toastInjectionKey, inter);
};
const useToast = (eventBus) => {
  if (eventBus) {
    return createToastInterface(eventBus);
  }
  const toast = getCurrentInstance() ? inject(toastInjectionKey) : void 0;
  return toast ? toast : createToastInterface(globalEventBus);
};
var build = { exports: {} };
var url$1 = {};
var re$1 = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
var parseuri$2 = function parseuri(str) {
  var src = str, b2 = str.indexOf("["), e = str.indexOf("]");
  if (b2 != -1 && e != -1) {
    str = str.substring(0, b2) + str.substring(b2, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  var m2 = re$1.exec(str || ""), uri = {}, i = 14;
  while (i--) {
    uri[parts[i]] = m2[i] || "";
  }
  if (b2 != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
};
function pathNames(obj, path) {
  var regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.substr(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.substr(path.length - 1, 1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query2) {
  var data = {};
  query2.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  ms = function(val, options2) {
    options2 = options2 || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type2 = (match2[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms;
}
function setup8(env2) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = requireMs();
  createDebug.destroy = destroy;
  Object.keys(env2).forEach((key) => {
    createDebug[key] = env2[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash2 = 0;
    for (let i = 0; i < namespace.length; i++) {
      hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
      hash2 |= 0;
    }
    return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(/* @__PURE__ */ new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
        if (match2 === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match2 = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match2;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace);
    debug2.extend = extend2;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend2(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split.length;
    for (i = 0; i < len; i++) {
      if (!split[i]) {
        continue;
      }
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name2) {
    if (name2[name2.length - 1] === "*") {
      return true;
    }
    let i;
    let len;
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name2)) {
        return false;
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common = setup8;
(function(module, exports) {
  var define_process_env_default2 = { CYPRESS_INTERNAL_ENV: "development", NODE_ENV: "production" };
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = /* @__PURE__ */ (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c2 = "color: " + this.color;
    args.splice(1, 0, c2, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match2) => {
      if (match2 === "%%") {
        return;
      }
      index++;
      if (match2 === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c2);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r2;
    try {
      r2 = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r2 && typeof process !== "undefined" && "env" in process) {
      r2 = define_process_env_default2.DEBUG;
    }
    return r2;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = common(exports);
  const { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
})(browser, browser.exports);
var browserExports = browser.exports;
const Debug = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
Object.defineProperty(url$1, "__esModule", { value: true });
url$1.url = void 0;
const parseuri$1 = parseuri$2;
const debug$7 = browserExports("socket.io-client:url");
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug$7("protocol-less url %s", uri);
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    debug$7("parse %s", uri);
    obj = parseuri$1(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
url$1.url = url;
var manager = {};
var lib$2 = { exports: {} };
var transports$1 = {};
var hasCors = { exports: {} };
try {
  hasCors.exports = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
  hasCors.exports = false;
}
var hasCorsExports = hasCors.exports;
var globalThis_browser = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
const hasCORS = hasCorsExports;
const globalThis$4 = globalThis_browser;
var xmlhttprequest = function(opts) {
  const xdomain = opts.xdomain;
  const xscheme = opts.xscheme;
  const enablesXDR = opts.enablesXDR;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  try {
    if ("undefined" !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThis$4[["Active"].concat("Object").join("X")](
        "Microsoft.XMLHTTP"
      );
    } catch (e) {
    }
  }
};
var pollingXhr = { exports: {} };
const PACKET_TYPES$1 = /* @__PURE__ */ Object.create(null);
PACKET_TYPES$1["open"] = "0";
PACKET_TYPES$1["close"] = "1";
PACKET_TYPES$1["ping"] = "2";
PACKET_TYPES$1["pong"] = "3";
PACKET_TYPES$1["message"] = "4";
PACKET_TYPES$1["upgrade"] = "5";
PACKET_TYPES$1["noop"] = "6";
const PACKET_TYPES_REVERSE$1 = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES$1).forEach((key) => {
  PACKET_TYPES_REVERSE$1[PACKET_TYPES$1[key]] = key;
});
const ERROR_PACKET$1 = { type: "error", data: "parser error" };
var commons = {
  PACKET_TYPES: PACKET_TYPES$1,
  PACKET_TYPES_REVERSE: PACKET_TYPES_REVERSE$1,
  ERROR_PACKET: ERROR_PACKET$1
};
const { PACKET_TYPES } = commons;
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
function isArrayBuffer$1(obj) {
  return typeof obj === "object" && obj !== null && toString.call(obj) === "[object ArrayBuffer]";
}
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket$1 = ({ type: type2, data }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isArrayBuffer$1(data) || isView$1(data))) {
    if (supportsBinary) {
      return callback(data instanceof ArrayBuffer || isArrayBuffer$1(data) ? data : data.buffer);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type2] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + content);
  };
  return fileReader.readAsDataURL(data);
};
var encodePacket_browser = encodePacket$1;
var base64Arraybuffer = {};
var hasRequiredBase64Arraybuffer;
function requireBase64Arraybuffer() {
  if (hasRequiredBase64Arraybuffer)
    return base64Arraybuffer;
  hasRequiredBase64Arraybuffer = 1;
  (function(chars) {
    base64Arraybuffer.encode = function(arraybuffer) {
      var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
      for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64 += chars[bytes[i + 2] & 63];
      }
      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }
      return base64;
    };
    base64Arraybuffer.decode = function(base64) {
      var bufferLength = base64.length * 0.75, len = base64.length, i, p2 = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
      for (i = 0; i < len; i += 4) {
        encoded1 = chars.indexOf(base64[i]);
        encoded2 = chars.indexOf(base64[i + 1]);
        encoded3 = chars.indexOf(base64[i + 2]);
        encoded4 = chars.indexOf(base64[i + 3]);
        bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
  })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
  return base64Arraybuffer;
}
const { PACKET_TYPES_REVERSE, ERROR_PACKET } = commons;
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
let base64decoder;
if (withNativeArrayBuffer$1) {
  base64decoder = requireBase64Arraybuffer();
}
const decodePacket$1 = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type2 = encodedPacket.charAt(0);
  if (type2 === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type2];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type2],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type2]
  };
};
const decodeBase64Packet = (data, binaryType) => {
  if (base64decoder) {
    const decoded = base64decoder.decode(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      return data instanceof ArrayBuffer ? new Blob([data]) : data;
    case "arraybuffer":
    default:
      return data;
  }
};
var decodePacket_browser = decodePacket$1;
const encodePacket = encodePacket_browser;
const decodePacket = decodePacket_browser;
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length2 = packets.length;
  const encodedPackets = new Array(length2);
  let count = 0;
  packets.forEach((packet, i) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i] = encodedPacket;
      if (++count === length2) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i = 0; i < encodedPackets.length; i++) {
    const decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
var lib$1 = {
  protocol: 4,
  encodePacket,
  encodePayload,
  decodePacket,
  decodePayload
};
var componentEmitter = { exports: {} };
(function(module) {
  {
    module.exports = Emitter2;
  }
  function Emitter2(obj) {
    if (obj)
      return mixin(obj);
  }
  function mixin(obj) {
    for (var key in Emitter2.prototype) {
      obj[key] = Emitter2.prototype[key];
    }
    return obj;
  }
  Emitter2.prototype.on = Emitter2.prototype.addEventListener = function(event, fn2) {
    this._callbacks = this._callbacks || {};
    (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn2);
    return this;
  };
  Emitter2.prototype.once = function(event, fn2) {
    function on2() {
      this.off(event, on2);
      fn2.apply(this, arguments);
    }
    on2.fn = fn2;
    this.on(event, on2);
    return this;
  };
  Emitter2.prototype.off = Emitter2.prototype.removeListener = Emitter2.prototype.removeAllListeners = Emitter2.prototype.removeEventListener = function(event, fn2) {
    this._callbacks = this._callbacks || {};
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }
    var callbacks2 = this._callbacks["$" + event];
    if (!callbacks2)
      return this;
    if (1 == arguments.length) {
      delete this._callbacks["$" + event];
      return this;
    }
    var cb;
    for (var i = 0; i < callbacks2.length; i++) {
      cb = callbacks2[i];
      if (cb === fn2 || cb.fn === fn2) {
        callbacks2.splice(i, 1);
        break;
      }
    }
    if (callbacks2.length === 0) {
      delete this._callbacks["$" + event];
    }
    return this;
  };
  Emitter2.prototype.emit = function(event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1), callbacks2 = this._callbacks["$" + event];
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
    if (callbacks2) {
      callbacks2 = callbacks2.slice(0);
      for (var i = 0, len = callbacks2.length; i < len; ++i) {
        callbacks2[i].apply(this, args);
      }
    }
    return this;
  };
  Emitter2.prototype.listeners = function(event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks["$" + event] || [];
  };
  Emitter2.prototype.hasListeners = function(event) {
    return !!this.listeners(event).length;
  };
})(componentEmitter);
var componentEmitterExports = componentEmitter.exports;
const Emitter$4 = /* @__PURE__ */ getDefaultExportFromCjs(componentEmitterExports);
const parser$4 = lib$1;
const Emitter$3 = componentEmitterExports;
const debug$6 = browserExports("engine.io-client:transport");
let Transport$2 = class Transport extends Emitter$3 {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} options.
   * @api private
   */
  constructor(opts) {
    super();
    this.opts = opts;
    this.query = opts.query;
    this.readyState = "";
    this.socket = opts.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} str
   * @return {Transport} for chaining
   * @api public
   */
  onError(msg, desc) {
    const err = new Error(msg);
    err.type = "TransportError";
    err.description = desc;
    this.emit("error", err);
    return this;
  }
  /**
   * Opens the transport.
   *
   * @api public
   */
  open() {
    if ("closed" === this.readyState || "" === this.readyState) {
      this.readyState = "opening";
      this.doOpen();
    }
    return this;
  }
  /**
   * Closes the transport.
   *
   * @api private
   */
  close() {
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   * @api private
   */
  send(packets) {
    if ("open" === this.readyState) {
      this.write(packets);
    } else {
      debug$6("transport is not open, discarding packets");
    }
  }
  /**
   * Called upon open
   *
   * @api private
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    this.emit("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @api private
   */
  onData(data) {
    const packet = parser$4.decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   */
  onPacket(packet) {
    this.emit("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @api private
   */
  onClose() {
    this.readyState = "closed";
    this.emit("close");
  }
};
var transport = Transport$2;
var parseqs$3 = {};
parseqs$3.encode = function(obj) {
  var str = "";
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
    }
  }
  return str;
};
parseqs$3.decode = function(qs) {
  var qry = {};
  var pairs = qs.split("&");
  for (var i = 0, l2 = pairs.length; i < l2; i++) {
    var pair = pairs[i].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};
var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {}, seed = 0, i$1 = 0, prev;
function encode$1(num) {
  var encoded = "";
  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
function decode$1(str) {
  var decoded = 0;
  for (i$1 = 0; i$1 < str.length; i$1++) {
    decoded = decoded * length + map[str.charAt(i$1)];
  }
  return decoded;
}
function yeast$2() {
  var now2 = encode$1(+/* @__PURE__ */ new Date());
  if (now2 !== prev)
    return seed = 0, prev = now2;
  return now2 + "." + encode$1(seed++);
}
for (; i$1 < length; i$1++)
  map[alphabet[i$1]] = i$1;
yeast$2.encode = encode$1;
yeast$2.decode = decode$1;
var yeast_1 = yeast$2;
const Transport$1 = transport;
const parseqs$2 = parseqs$3;
const parser$3 = lib$1;
const yeast$1 = yeast_1;
const debug$5 = browserExports("engine.io-client:polling");
let Polling$2 = class Polling extends Transport$1 {
  /**
   * Transport name.
   */
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @api private
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} callback upon buffers are flushed and transport is paused
   * @api private
   */
  pause(onPause) {
    const self2 = this;
    this.readyState = "pausing";
    function pause() {
      debug$5("paused");
      self2.readyState = "paused";
      onPause();
    }
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        debug$5("we are currently polling - waiting to pause");
        total++;
        this.once("pollComplete", function() {
          debug$5("pre-pause polling complete");
          --total || pause();
        });
      }
      if (!this.writable) {
        debug$5("we are currently writing - waiting to pause");
        total++;
        this.once("drain", function() {
          debug$5("pre-pause writing complete");
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @api public
   */
  poll() {
    debug$5("polling");
    this.polling = true;
    this.doPoll();
    this.emit("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @api private
   */
  onData(data) {
    const self2 = this;
    debug$5("polling got data %s", data);
    const callback = function(packet, index, total) {
      if ("opening" === self2.readyState && packet.type === "open") {
        self2.onOpen();
      }
      if ("close" === packet.type) {
        self2.onClose();
        return false;
      }
      self2.onPacket(packet);
    };
    parser$3.decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this.polling = false;
      this.emit("pollComplete");
      if ("open" === this.readyState) {
        this.poll();
      } else {
        debug$5('ignoring poll - transport state "%s"', this.readyState);
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @api private
   */
  doClose() {
    const self2 = this;
    function close() {
      debug$5("writing close packet");
      self2.write([{ type: "close" }]);
    }
    if ("open" === this.readyState) {
      debug$5("transport open - closing");
      close();
    } else {
      debug$5("transport not open - deferring close");
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} data packets
   * @param {Function} drain callback
   * @api private
   */
  write(packets) {
    this.writable = false;
    parser$3.encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emit("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @api private
   */
  uri() {
    let query2 = this.query || {};
    const schema = this.opts.secure ? "https" : "http";
    let port = "";
    if (false !== this.opts.timestampRequests) {
      query2[this.opts.timestampParam] = yeast$1();
    }
    if (!this.supportsBinary && !query2.sid) {
      query2.b64 = 1;
    }
    query2 = parseqs$2.encode(query2);
    if (this.opts.port && ("https" === schema && Number(this.opts.port) !== 443 || "http" === schema && Number(this.opts.port) !== 80)) {
      port = ":" + this.opts.port;
    }
    if (query2.length) {
      query2 = "?" + query2;
    }
    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query2;
  }
};
var polling$1 = Polling$2;
var util = {};
util.pick = (obj, ...attr) => {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
};
const XMLHttpRequest$2 = xmlhttprequest;
const Polling$1 = polling$1;
const Emitter$2 = componentEmitterExports;
const { pick: pick$1 } = util;
const globalThis$3 = globalThis_browser;
const debug$4 = browserExports("engine.io-client:polling-xhr");
function empty$1() {
}
const hasXHR2 = function() {
  const xhr = new XMLHttpRequest$2({ xdomain: false });
  return null != xhr.responseType;
}();
let XHR$1 = class XHR extends Polling$1 {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @api public
   */
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? 443 : 80;
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
      this.xs = opts.secure !== isSSL;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @api private
   */
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
    return new Request(this.uri(), opts);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @api private
   */
  doWrite(data, fn2) {
    const req = this.request({
      method: "POST",
      data
    });
    const self2 = this;
    req.on("success", fn2);
    req.on("error", function(err) {
      self2.onError("xhr post error", err);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @api private
   */
  doPoll() {
    debug$4("xhr poll");
    const req = this.request();
    const self2 = this;
    req.on("data", function(data) {
      self2.onData(data);
    });
    req.on("error", function(err) {
      self2.onError("xhr poll error", err);
    });
    this.pollXhr = req;
  }
};
class Request extends Emitter$2 {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @api public
   */
  constructor(uri, opts) {
    super();
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.async = false !== opts.async;
    this.data = void 0 !== opts.data ? opts.data : null;
    this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @api private
   */
  create() {
    const opts = pick$1(
      this.opts,
      "agent",
      "enablesXDR",
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "rejectUnauthorized",
      "autoUnref"
    );
    opts.xdomain = !!this.opts.xd;
    opts.xscheme = !!this.opts.xs;
    const xhr = this.xhr = new XMLHttpRequest$2(opts);
    const self2 = this;
    try {
      debug$4("xhr open %s: %s", this.method, this.uri);
      xhr.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i)) {
              xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this.method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }
      if (this.hasXDR()) {
        xhr.onload = function() {
          self2.onLoad();
        };
        xhr.onerror = function() {
          self2.onError(xhr.responseText);
        };
      } else {
        xhr.onreadystatechange = function() {
          if (4 !== xhr.readyState)
            return;
          if (200 === xhr.status || 1223 === xhr.status) {
            self2.onLoad();
          } else {
            setTimeout(function() {
              self2.onError(typeof xhr.status === "number" ? xhr.status : 0);
            }, 0);
          }
        };
      }
      debug$4("xhr data %s", this.data);
      xhr.send(this.data);
    } catch (e) {
      setTimeout(function() {
        self2.onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = Request.requestsCount++;
      Request.requests[this.index] = this;
    }
  }
  /**
   * Called upon successful response.
   *
   * @api private
   */
  onSuccess() {
    this.emit("success");
    this.cleanup();
  }
  /**
   * Called if we have data.
   *
   * @api private
   */
  onData(data) {
    this.emit("data", data);
    this.onSuccess();
  }
  /**
   * Called upon error.
   *
   * @api private
   */
  onError(err) {
    this.emit("error", err);
    this.cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @api private
   */
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    if (this.hasXDR()) {
      this.xhr.onload = this.xhr.onerror = empty$1;
    } else {
      this.xhr.onreadystatechange = empty$1;
    }
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this.index];
    }
    this.xhr = null;
  }
  /**
   * Called upon load.
   *
   * @api private
   */
  onLoad() {
    const data = this.xhr.responseText;
    if (data !== null) {
      this.onData(data);
    }
  }
  /**
   * Check if it has XDomainRequest.
   *
   * @api private
   */
  hasXDR() {
    return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
  }
  /**
   * Aborts the request.
   *
   * @api public
   */
  abort() {
    this.cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThis$3 ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
pollingXhr.exports = XHR$1;
pollingXhr.exports.Request = Request;
var pollingXhrExports = pollingXhr.exports;
const Polling2 = polling$1;
const globalThis$2 = globalThis_browser;
const rNewline = /\n/g;
const rEscapedNewline = /\\n/g;
let callbacks;
class JSONPPolling extends Polling2 {
  /**
   * JSONP Polling constructor.
   *
   * @param {Object} opts.
   * @api public
   */
  constructor(opts) {
    super(opts);
    this.query = this.query || {};
    if (!callbacks) {
      callbacks = globalThis$2.___eio = globalThis$2.___eio || [];
    }
    this.index = callbacks.length;
    const self2 = this;
    callbacks.push(function(msg) {
      self2.onData(msg);
    });
    this.query.j = this.index;
  }
  /**
   * JSONP only supports binary as base64 encoded strings
   */
  get supportsBinary() {
    return false;
  }
  /**
   * Closes the socket.
   *
   * @api private
   */
  doClose() {
    if (this.script) {
      this.script.onerror = () => {
      };
      this.script.parentNode.removeChild(this.script);
      this.script = null;
    }
    if (this.form) {
      this.form.parentNode.removeChild(this.form);
      this.form = null;
      this.iframe = null;
    }
    super.doClose();
  }
  /**
   * Starts a poll cycle.
   *
   * @api private
   */
  doPoll() {
    const self2 = this;
    const script2 = document.createElement("script");
    if (this.script) {
      this.script.parentNode.removeChild(this.script);
      this.script = null;
    }
    script2.async = true;
    script2.src = this.uri();
    script2.onerror = function(e) {
      self2.onError("jsonp poll error", e);
    };
    const insertAt = document.getElementsByTagName("script")[0];
    if (insertAt) {
      insertAt.parentNode.insertBefore(script2, insertAt);
    } else {
      (document.head || document.body).appendChild(script2);
    }
    this.script = script2;
    const isUAgecko = "undefined" !== typeof navigator && /gecko/i.test(navigator.userAgent);
    if (isUAgecko) {
      setTimeout(function() {
        const iframe = document.createElement("iframe");
        document.body.appendChild(iframe);
        document.body.removeChild(iframe);
      }, 100);
    }
  }
  /**
   * Writes with a hidden iframe.
   *
   * @param {String} data to send
   * @param {Function} called upon flush.
   * @api private
   */
  doWrite(data, fn2) {
    const self2 = this;
    let iframe;
    if (!this.form) {
      const form = document.createElement("form");
      const area = document.createElement("textarea");
      const id2 = this.iframeId = "eio_iframe_" + this.index;
      form.className = "socketio";
      form.style.position = "absolute";
      form.style.top = "-1000px";
      form.style.left = "-1000px";
      form.target = id2;
      form.method = "POST";
      form.setAttribute("accept-charset", "utf-8");
      area.name = "d";
      form.appendChild(area);
      document.body.appendChild(form);
      this.form = form;
      this.area = area;
    }
    this.form.action = this.uri();
    function complete() {
      initIframe();
      fn2();
    }
    function initIframe() {
      if (self2.iframe) {
        try {
          self2.form.removeChild(self2.iframe);
        } catch (e) {
          self2.onError("jsonp polling iframe removal error", e);
        }
      }
      try {
        const html = '<iframe src="javascript:0" name="' + self2.iframeId + '">';
        iframe = document.createElement(html);
      } catch (e) {
        iframe = document.createElement("iframe");
        iframe.name = self2.iframeId;
        iframe.src = "javascript:0";
      }
      iframe.id = self2.iframeId;
      self2.form.appendChild(iframe);
      self2.iframe = iframe;
    }
    initIframe();
    data = data.replace(rEscapedNewline, "\\\n");
    this.area.value = data.replace(rNewline, "\\n");
    try {
      this.form.submit();
    } catch (e) {
    }
    if (this.iframe.attachEvent) {
      this.iframe.onreadystatechange = function() {
        if (self2.iframe.readyState === "complete") {
          complete();
        }
      };
    } else {
      this.iframe.onload = complete;
    }
  }
}
var pollingJsonp = JSONPPolling;
const globalThis$1 = globalThis_browser;
var websocketConstructor_browser = {
  WebSocket: globalThis$1.WebSocket || globalThis$1.MozWebSocket,
  usingBrowserWebSocket: true,
  defaultBinaryType: "arraybuffer"
};
const Transport2 = transport;
const parser$2 = lib$1;
const parseqs$1 = parseqs$3;
const yeast = yeast_1;
const { pick } = util;
const {
  WebSocket: WebSocket$1,
  usingBrowserWebSocket,
  defaultBinaryType
} = websocketConstructor_browser;
const debug$3 = browserExports("engine.io-client:websocket");
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends Transport2 {
  /**
   * WebSocket transport constructor.
   *
   * @api {Object} connection options
   * @api public
   */
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  /**
   * Transport name.
   *
   * @api public
   */
  get name() {
    return "websocket";
  }
  /**
   * Opens socket.
   *
   * @api private
   */
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(
      this.opts,
      "agent",
      "perMessageDeflate",
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "rejectUnauthorized",
      "localAddress",
      "protocolVersion",
      "origin",
      "maxPayload",
      "family",
      "checkServerIdentity"
    );
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket$1(uri, protocols) : new WebSocket$1(uri) : new WebSocket$1(uri, protocols, opts);
    } catch (err) {
      return this.emit("error", err);
    }
    this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @api private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = this.onClose.bind(this);
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  /**
   * Writes data to socket.
   *
   * @param {Array} array of packets.
   * @api private
   */
  write(packets) {
    const self2 = this;
    this.writable = false;
    let total = packets.length;
    let i = 0;
    const l2 = total;
    for (; i < l2; i++) {
      (function(packet) {
        parser$2.encodePacket(packet, self2.supportsBinary, function(data) {
          const opts = {};
          if (!usingBrowserWebSocket) {
            if (packet.options) {
              opts.compress = packet.options.compress;
            }
            if (self2.opts.perMessageDeflate) {
              const len = "string" === typeof data ? Buffer.byteLength(data) : data.length;
              if (len < self2.opts.perMessageDeflate.threshold) {
                opts.compress = false;
              }
            }
          }
          try {
            if (usingBrowserWebSocket) {
              self2.ws.send(data);
            } else {
              self2.ws.send(data, opts);
            }
          } catch (e) {
            debug$3("websocket closed before onclose event");
          }
          --total || done();
        });
      })(packets[i]);
    }
    function done() {
      self2.emit("flush");
      setTimeout(function() {
        self2.writable = true;
        self2.emit("drain");
      }, 0);
    }
  }
  /**
   * Called upon close
   *
   * @api private
   */
  onClose() {
    Transport2.prototype.onClose.call(this);
  }
  /**
   * Closes socket.
   *
   * @api private
   */
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @api private
   */
  uri() {
    let query2 = this.query || {};
    const schema = this.opts.secure ? "wss" : "ws";
    let port = "";
    if (this.opts.port && ("wss" === schema && Number(this.opts.port) !== 443 || "ws" === schema && Number(this.opts.port) !== 80)) {
      port = ":" + this.opts.port;
    }
    if (this.opts.timestampRequests) {
      query2[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary) {
      query2.b64 = 1;
    }
    query2 = parseqs$1.encode(query2);
    if (query2.length) {
      query2 = "?" + query2;
    }
    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query2;
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @api public
   */
  check() {
    return !!WebSocket$1 && !("__initialize" in WebSocket$1 && this.name === WS.prototype.name);
  }
}
var websocket$1 = WS;
const XMLHttpRequest$1 = xmlhttprequest;
const XHR2 = pollingXhrExports;
const JSONP = pollingJsonp;
const websocket = websocket$1;
transports$1.polling = polling;
transports$1.websocket = websocket;
function polling(opts) {
  let xhr;
  let xd = false;
  let xs = false;
  const jsonp = false !== opts.jsonp;
  if (typeof location !== "undefined") {
    const isSSL = "https:" === location.protocol;
    let port = location.port;
    if (!port) {
      port = isSSL ? 443 : 80;
    }
    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }
  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest$1(opts);
  if ("open" in xhr && !opts.forceJSONP) {
    return new XHR2(opts);
  } else {
    if (!jsonp)
      throw new Error("JSONP disabled");
    return new JSONP(opts);
  }
}
const transports = transports$1;
const Emitter$1 = componentEmitterExports;
const debug$2 = browserExports("engine.io-client:socket");
const parser$1 = lib$1;
const parseuri2 = parseuri$2;
const parseqs = parseqs$3;
let Socket$2 = class Socket extends Emitter$1 {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri or options
   * @param {Object} options
   * @api public
   */
  constructor(uri, opts = {}) {
    super();
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parseuri2(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parseuri2(opts.host).host;
    }
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? 443 : 80);
    this.transports = opts.transports || ["polling", "websocket"];
    this.readyState = "";
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign(
      {
        path: "/engine.io",
        agent: false,
        withCredentials: false,
        upgrade: true,
        jsonp: true,
        timestampParam: "t",
        rememberUpgrade: false,
        rejectUnauthorized: true,
        perMessageDeflate: {
          threshold: 1024
        },
        transportOptions: {}
      },
      opts
    );
    this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
    if (typeof this.opts.query === "string") {
      this.opts.query = parseqs.decode(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      addEventListener(
        "beforeunload",
        () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        },
        false
      );
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close");
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} transport name
   * @return {Transport}
   * @api private
   */
  createTransport(name2) {
    debug$2('creating transport "%s"', name2);
    const query2 = clone(this.opts.query);
    query2.EIO = parser$1.protocol;
    query2.transport = name2;
    if (this.id)
      query2.sid = this.id;
    const opts = Object.assign(
      {},
      this.opts.transportOptions[name2],
      this.opts,
      {
        query: query2,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      }
    );
    debug$2("options: %j", opts);
    return new transports[name2](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @api private
   */
  open() {
    let transport2;
    if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport2 = "websocket";
    } else if (0 === this.transports.length) {
      const self2 = this;
      setTimeout(function() {
        self2.emit("error", "No transports available");
      }, 0);
      return;
    } else {
      transport2 = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport2 = this.createTransport(transport2);
    } catch (e) {
      debug$2("error while creating transport: %s", e);
      this.transports.shift();
      this.open();
      return;
    }
    transport2.open();
    this.setTransport(transport2);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @api private
   */
  setTransport(transport2) {
    debug$2("setting transport %s", transport2.name);
    const self2 = this;
    if (this.transport) {
      debug$2("clearing existing transport %s", this.transport.name);
      this.transport.removeAllListeners();
    }
    this.transport = transport2;
    transport2.on("drain", function() {
      self2.onDrain();
    }).on("packet", function(packet) {
      self2.onPacket(packet);
    }).on("error", function(e) {
      self2.onError(e);
    }).on("close", function() {
      self2.onClose("transport close");
    });
  }
  /**
   * Probes a transport.
   *
   * @param {String} transport name
   * @api private
   */
  probe(name2) {
    debug$2('probing transport "%s"', name2);
    let transport2 = this.createTransport(name2, { probe: 1 });
    let failed = false;
    const self2 = this;
    Socket.priorWebsocketSuccess = false;
    function onTransportOpen() {
      if (self2.onlyBinaryUpgrades) {
        const upgradeLosesBinary = !this.supportsBinary && self2.transport.supportsBinary;
        failed = failed || upgradeLosesBinary;
      }
      if (failed)
        return;
      debug$2('probe transport "%s" opened', name2);
      transport2.send([{ type: "ping", data: "probe" }]);
      transport2.once("packet", function(msg) {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          debug$2('probe transport "%s" pong', name2);
          self2.upgrading = true;
          self2.emit("upgrading", transport2);
          if (!transport2)
            return;
          Socket.priorWebsocketSuccess = "websocket" === transport2.name;
          debug$2('pausing current transport "%s"', self2.transport.name);
          self2.transport.pause(function() {
            if (failed)
              return;
            if ("closed" === self2.readyState)
              return;
            debug$2("changing transport and sending upgrade packet");
            cleanup();
            self2.setTransport(transport2);
            transport2.send([{ type: "upgrade" }]);
            self2.emit("upgrade", transport2);
            transport2 = null;
            self2.upgrading = false;
            self2.flush();
          });
        } else {
          debug$2('probe transport "%s" failed', name2);
          const err = new Error("probe error");
          err.transport = transport2.name;
          self2.emit("upgradeError", err);
        }
      });
    }
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport2.close();
      transport2 = null;
    }
    function onerror(err) {
      const error = new Error("probe error: " + err);
      error.transport = transport2.name;
      freezeTransport();
      debug$2('probe transport "%s" failed because of error: %s', name2, err);
      self2.emit("upgradeError", error);
    }
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport2 && to.name !== transport2.name) {
        debug$2('"%s" works - aborting "%s"', to.name, transport2.name);
        freezeTransport();
      }
    }
    function cleanup() {
      transport2.removeListener("open", onTransportOpen);
      transport2.removeListener("error", onerror);
      transport2.removeListener("close", onTransportClose);
      self2.removeListener("close", onclose);
      self2.removeListener("upgrading", onupgrade);
    }
    transport2.once("open", onTransportOpen);
    transport2.once("error", onerror);
    transport2.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    transport2.open();
  }
  /**
   * Called when connection is deemed open.
   *
   * @api public
   */
  onOpen() {
    debug$2("socket open");
    this.readyState = "open";
    Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emit("open");
    this.flush();
    if ("open" === this.readyState && this.opts.upgrade && this.transport.pause) {
      debug$2("starting upgrade probes");
      let i = 0;
      const l2 = this.upgrades.length;
      for (; i < l2; i++) {
        this.probe(this.upgrades[i]);
      }
    }
  }
  /**
   * Handles a packet.
   *
   * @api private
   */
  onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      debug$2('socket receive: type "%s", data "%s"', packet.type, packet.data);
      this.emit("packet", packet);
      this.emit("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.resetPingTimeout();
          this.sendPacket("pong");
          this.emit("pong");
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this.onError(err);
          break;
        case "message":
          this.emit("data", packet.data);
          this.emit("message", packet.data);
          break;
      }
    } else {
      debug$2('packet received with socket readyState "%s"', this.readyState);
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} handshake obj
   * @api private
   */
  onHandshake(data) {
    this.emit("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this.upgrades = this.filterUpgrades(data.upgrades);
    this.pingInterval = data.pingInterval;
    this.pingTimeout = data.pingTimeout;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @api private
   */
  resetPingTimeout() {
    clearTimeout(this.pingTimeoutTimer);
    this.pingTimeoutTimer = setTimeout(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @api private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emit("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @api private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      debug$2("flushing %d packets in socket", this.writeBuffer.length);
      this.transport.send(this.writeBuffer);
      this.prevBufferLen = this.writeBuffer.length;
      this.emit("flush");
    }
  }
  /**
   * Sends a message.
   *
   * @param {String} message.
   * @param {Function} callback function.
   * @param {Object} options.
   * @return {Socket} for chaining.
   * @api public
   */
  write(msg, options2, fn2) {
    this.sendPacket("message", msg, options2, fn2);
    return this;
  }
  send(msg, options2, fn2) {
    this.sendPacket("message", msg, options2, fn2);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} callback function.
   * @api private
   */
  sendPacket(type2, data, options2, fn2) {
    if ("function" === typeof data) {
      fn2 = data;
      data = void 0;
    }
    if ("function" === typeof options2) {
      fn2 = options2;
      options2 = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options2 = options2 || {};
    options2.compress = false !== options2.compress;
    const packet = {
      type: type2,
      data,
      options: options2
    };
    this.emit("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn2)
      this.once("flush", fn2);
    this.flush();
  }
  /**
   * Closes the connection.
   *
   * @api private
   */
  close() {
    const self2 = this;
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", function() {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    function close() {
      self2.onClose("forced close");
      debug$2("socket closing - telling transport to close");
      self2.transport.close();
    }
    function cleanupAndClose() {
      self2.removeListener("upgrade", cleanupAndClose);
      self2.removeListener("upgradeError", cleanupAndClose);
      close();
    }
    function waitForUpgrade() {
      self2.once("upgrade", cleanupAndClose);
      self2.once("upgradeError", cleanupAndClose);
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @api private
   */
  onError(err) {
    debug$2("socket error %j", err);
    Socket.priorWebsocketSuccess = false;
    this.emit("error", err);
    this.onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @api private
   */
  onClose(reason, desc) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      debug$2('socket close with reason: "%s"', reason);
      const self2 = this;
      clearTimeout(this.pingIntervalTimer);
      clearTimeout(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emit("close", reason, desc);
      self2.writeBuffer = [];
      self2.prevBufferLen = 0;
    }
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} server upgrades
   * @api private
   *
   */
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i = 0;
    const j = upgrades.length;
    for (; i < j; i++) {
      if (~this.transports.indexOf(upgrades[i]))
        filteredUpgrades.push(upgrades[i]);
    }
    return filteredUpgrades;
  }
};
Socket$2.priorWebsocketSuccess = false;
Socket$2.protocol = parser$1.protocol;
function clone(obj) {
  const o2 = {};
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      o2[i] = obj[i];
    }
  }
  return o2;
}
var socket$1 = Socket$2;
const Socket$1 = socket$1;
lib$2.exports = (uri, opts) => new Socket$1(uri, opts);
lib$2.exports.Socket = Socket$1;
lib$2.exports.protocol = Socket$1.protocol;
lib$2.exports.Transport = transport;
lib$2.exports.transports = transports$1;
lib$2.exports.parser = lib$1;
var libExports = lib$2.exports;
var socket = {};
var dist = {};
var binary = {};
var isBinary$1 = {};
Object.defineProperty(isBinary$1, "__esModule", { value: true });
isBinary$1.hasBinary = isBinary$1.isBinary = void 0;
const withNativeBuffer = typeof Buffer === "function" && typeof Buffer.isBuffer === "function";
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString$2 = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString$2.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString$2.call(File) === "[object FileConstructor]";
function isArrayBuffer(obj) {
  return typeof obj === "object" && obj !== null && toString$2.call(obj) === "[object ArrayBuffer]";
}
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isArrayBuffer(obj) || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File || withNativeBuffer && Buffer.isBuffer(obj);
}
isBinary$1.isBinary = isBinary;
function hasBinary(obj, known = [], toJSON2 = false) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (known.includes(obj)) {
    return false;
  }
  known.push(obj);
  if (Array.isArray(obj)) {
    for (let i = 0, l2 = obj.length; i < l2; i++) {
      if (hasBinary(obj[i], known)) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 2) {
    return hasBinary(obj.toJSON(), known, true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key], known)) {
      return true;
    }
  }
  return false;
}
isBinary$1.hasBinary = hasBinary;
Object.defineProperty(binary, "__esModule", { value: true });
binary.reconstructPacket = binary.deconstructPacket = void 0;
const is_binary_1 = isBinary$1;
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers, [], /* @__PURE__ */ new WeakMap());
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
binary.deconstructPacket = deconstructPacket;
function _deconstructPacket(data, buffers, known, retvals) {
  if (!data)
    return data;
  if (is_binary_1.isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (retvals.has(data)) {
    return retvals.get(data);
  } else if (known.includes(data)) {
    return data;
  }
  known.push(data);
  if (Array.isArray(data)) {
    const newData = new Array(data.length);
    retvals.set(data, newData);
    for (let i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers, known, retvals);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    retvals.set(data, newData);
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers, known, retvals);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers, []);
  packet.attachments = void 0;
  return packet;
}
binary.reconstructPacket = reconstructPacket;
function _reconstructPacket(data, buffers, known) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (known.includes(data)) {
    return data;
  }
  known.push(data);
  if (Array.isArray(data)) {
    for (let i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers, known);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (data.hasOwnProperty(key)) {
        data[key] = _reconstructPacket(data[key], buffers, known);
      }
    }
  }
  return data;
}
var cjs = {};
/*! (c) 2020 Andrea Giammarchi */
const { parse: $parse, stringify: $stringify } = JSON;
const { keys } = Object;
const Primitive = String;
const primitive = "string";
const ignore = {};
const object = "object";
const noop$2 = (_2, value) => value;
const primitives = (value) => value instanceof Primitive ? Primitive(value) : value;
const Primitives = (_2, value) => typeof value === primitive ? new Primitive(value) : value;
const revive = (input, parsed, output, $2) => {
  const lazy = [];
  for (let ke = keys(output), { length: length2 } = ke, y2 = 0; y2 < length2; y2++) {
    const k = ke[y2];
    const value = output[k];
    if (value instanceof Primitive) {
      const tmp = input[value];
      if (typeof tmp === object && !parsed.has(tmp)) {
        parsed.add(tmp);
        output[k] = ignore;
        lazy.push({ k, a: [input, parsed, tmp, $2] });
      } else
        output[k] = $2.call(output, k, tmp);
    } else if (output[k] !== ignore)
      output[k] = $2.call(output, k, value);
  }
  for (let { length: length2 } = lazy, i = 0; i < length2; i++) {
    const { k, a: a2 } = lazy[i];
    output[k] = $2.call(output, k, revive.apply(null, a2));
  }
  return output;
};
const set$1 = (known, input, value) => {
  const index = Primitive(input.push(value) - 1);
  known.set(value, index);
  return index;
};
const parse$2 = (text, reviver) => {
  const input = $parse(text, Primitives).map(primitives);
  const value = input[0];
  const $2 = reviver || noop$2;
  const tmp = typeof value === object && value ? revive(input, /* @__PURE__ */ new Set(), value, $2) : value;
  return $2.call({ "": tmp }, "", tmp);
};
cjs.parse = parse$2;
const stringify$1 = (value, replacer2, space) => {
  const $2 = replacer2 && typeof replacer2 === object ? (k, v) => k === "" || -1 < replacer2.indexOf(k) ? v : void 0 : replacer2 || noop$2;
  const known = /* @__PURE__ */ new Map();
  const input = [];
  const output = [];
  let i = +set$1(known, input, $2.call({ "": value }, "", value));
  let firstRun = !i;
  while (i < input.length) {
    firstRun = true;
    output[i] = $stringify(input[i++], replace, space);
  }
  return "[" + output.join(",") + "]";
  function replace(key, value2) {
    if (firstRun) {
      firstRun = !firstRun;
      return value2;
    }
    const after = $2.call(this, key, value2);
    switch (typeof after) {
      case object:
        if (after === null)
          return after;
      case primitive:
        return known.get(after) || set$1(known, input, after);
    }
    return after;
  }
};
cjs.stringify = stringify$1;
const toJSON = (any) => $parse(stringify$1(any));
cjs.toJSON = toJSON;
const fromJSON = (any) => parse$2($stringify(any));
cjs.fromJSON = fromJSON;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
  const Emitter2 = componentEmitterExports;
  const binary_1 = binary;
  const is_binary_12 = isBinary$1;
  const debug2 = browserExports("socket.io-parser");
  const flatted = cjs;
  exports.protocol = 5;
  var PacketType;
  (function(PacketType2) {
    PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
    PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
    PacketType2[PacketType2["ACK"] = 3] = "ACK";
    PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
  })(PacketType = exports.PacketType || (exports.PacketType = {}));
  class Encoder {
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
      debug2("encoding packet %j", obj);
      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if (is_binary_12.hasBinary(obj)) {
          obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
          return this.encodeAsBinary(obj);
        }
      }
      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
      let str = "" + obj.type;
      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      }
      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      }
      if (null != obj.id) {
        str += obj.id;
      }
      if (null != obj.data) {
        str += flatted.stringify(obj.data);
      }
      debug2("encoded %j as %s", obj, str);
      return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
      const deconstruction = binary_1.deconstructPacket(obj);
      const pack = this.encodeAsString(deconstruction.packet);
      const buffers = deconstruction.buffers;
      buffers.unshift(pack);
      return buffers;
    }
  }
  exports.Encoder = Encoder;
  class Decoder extends Emitter2 {
    constructor() {
      super();
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
      let packet;
      if (typeof obj === "string") {
        if (this.reconstructor) {
          throw new Error("got plaintext data when reconstructing a packet");
        }
        packet = this.decodeString(obj);
        if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
          this.reconstructor = new BinaryReconstructor(packet);
          if (packet.attachments === 0) {
            super.emit("decoded", packet);
          }
        } else {
          super.emit("decoded", packet);
        }
      } else if (is_binary_12.isBinary(obj) || obj.base64) {
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            this.reconstructor = null;
            super.emit("decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str) {
      let i = 0;
      const p2 = {
        type: Number(str.charAt(0))
      };
      if (PacketType[p2.type] === void 0) {
        throw new Error("unknown packet type " + p2.type);
      }
      if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
        const start2 = i + 1;
        while (str.charAt(++i) !== "-" && i != str.length) {
        }
        const buf = str.substring(start2, i);
        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }
        p2.attachments = Number(buf);
      }
      if ("/" === str.charAt(i + 1)) {
        const start2 = i + 1;
        while (++i) {
          const c2 = str.charAt(i);
          if ("," === c2)
            break;
          if (i === str.length)
            break;
        }
        p2.nsp = str.substring(start2, i);
      } else {
        p2.nsp = "/";
      }
      const next = str.charAt(i + 1);
      if ("" !== next && Number(next) == next) {
        const start2 = i + 1;
        while (++i) {
          const c2 = str.charAt(i);
          if (null == c2 || Number(c2) != c2) {
            --i;
            break;
          }
          if (i === str.length)
            break;
        }
        p2.id = Number(str.substring(start2, i + 1));
      }
      if (str.charAt(++i)) {
        const payload = tryParse(str.substr(i));
        if (Decoder.isPayloadValid(p2.type, payload)) {
          p2.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }
      debug2("decoded %s as %j", str, p2);
      return p2;
    }
    static isPayloadValid(type2, payload) {
      switch (type2) {
        case PacketType.CONNECT:
          return typeof payload === "object";
        case PacketType.DISCONNECT:
          return payload === void 0;
        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || typeof payload === "object";
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && payload.length > 0;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    }
  }
  exports.Decoder = Decoder;
  function tryParse(str) {
    try {
      return flatted.parse(str);
    } catch (e) {
      return false;
    }
  }
  class BinaryReconstructor {
    constructor(packet) {
      this.packet = packet;
      this.buffers = [];
      this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        const packet = binary_1.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }
})(dist);
var on$1 = {};
Object.defineProperty(on$1, "__esModule", { value: true });
on$1.on = void 0;
function on(obj, ev, fn2) {
  obj.on(ev, fn2);
  return function subDestroy() {
    obj.off(ev, fn2);
  };
}
on$1.on = on;
var typedEvents = {};
Object.defineProperty(typedEvents, "__esModule", { value: true });
typedEvents.StrictEventEmitter = void 0;
const Emitter = componentEmitterExports;
class StrictEventEmitter extends Emitter {
  /**
   * Adds the `listener` function as an event listener for `ev`.
   *
   * @param ev Name of the event
   * @param listener Callback function
   */
  on(ev, listener) {
    super.on(ev, listener);
    return this;
  }
  /**
   * Adds a one-time `listener` function as an event listener for `ev`.
   *
   * @param ev Name of the event
   * @param listener Callback function
   */
  once(ev, listener) {
    super.once(ev, listener);
    return this;
  }
  /**
   * Emits an event.
   *
   * @param ev Name of the event
   * @param args Values to send to listeners of this event
   */
  emit(ev, ...args) {
    super.emit(ev, ...args);
    return this;
  }
  /**
   * Emits a reserved event.
   *
   * This method is `protected`, so that only a class extending
   * `StrictEventEmitter` can emit its own reserved events.
   *
   * @param ev Reserved event name
   * @param args Arguments to emit along with the event
   */
  emitReserved(ev, ...args) {
    super.emit(ev, ...args);
    return this;
  }
  /**
   * Returns the listeners listening to an event.
   *
   * @param event Event name
   * @returns Array of listeners subscribed to `event`
   */
  listeners(event) {
    return super.listeners(event);
  }
}
typedEvents.StrictEventEmitter = StrictEventEmitter;
Object.defineProperty(socket, "__esModule", { value: true });
socket.Socket = void 0;
const socket_io_parser_1 = dist;
const on_1$1 = on$1;
const typed_events_1$1 = typedEvents;
const debug$1 = browserExports("socket.io-client:socket");
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket2 extends typed_events_1$1.StrictEventEmitter {
  /**
   * `Socket` constructor.
   *
   * @public
   */
  constructor(io2, nsp, opts) {
    super();
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io2;
    this.nsp = nsp;
    this.ids = 0;
    this.acks = {};
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this.connected = false;
    this.disconnected = true;
    this.flags = {};
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io2 = this.io;
    this.subs = [
      on_1$1.on(io2, "open", this.onopen.bind(this)),
      on_1$1.on(io2, "packet", this.onpacket.bind(this)),
      on_1$1.on(io2, "error", this.onerror.bind(this)),
      on_1$1.on(io2, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @public
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for connect()
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * @return self
   * @public
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @return self
   * @public
   */
  emit(ev, ...args) {
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev + '" is a reserved event name');
    }
    args.unshift(ev);
    const packet = {
      type: socket_io_parser_1.PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      debug$1("emitting packet with ack id %d", this.ids);
      this.acks[this.ids] = args.pop();
      packet.id = this.ids++;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket) {
      debug$1("discard packet as the transport is not currently writable");
    } else if (this.connected) {
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    debug$1("transport is open - connecting");
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data });
      });
    } else {
      this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: this.auth });
    }
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @private
   */
  onclose(reason) {
    debug$1("close (%s)", reason);
    this.connected = false;
    this.disconnected = true;
    delete this.id;
    this.emitReserved("disconnect", reason);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case socket_io_parser_1.PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          const id2 = packet.data.sid;
          this.onconnect(id2);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case socket_io_parser_1.PacketType.EVENT:
        this.onevent(packet);
        break;
      case socket_io_parser_1.PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case socket_io_parser_1.PacketType.ACK:
        this.onack(packet);
        break;
      case socket_io_parser_1.PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case socket_io_parser_1.PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case socket_io_parser_1.PacketType.CONNECT_ERROR:
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    debug$1("emitting event %j", args);
    if (null != packet.id) {
      debug$1("attaching ack callback to event");
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners2 = this._anyListeners.slice();
      for (const listener of listeners2) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id2) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      debug$1("sending ack %j", args);
      self2.packet({
        type: socket_io_parser_1.PacketType.ACK,
        id: id2,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if ("function" === typeof ack) {
      debug$1("calling ack %s with %j", packet.id, packet.data);
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    } else {
      debug$1("bad ack %s", packet.id);
    }
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id2) {
    debug$1("socket connected with id %s", id2);
    this.id = id2;
    this.connected = true;
    this.disconnected = false;
    this.emitReserved("connect");
    this.emitBuffered();
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => this.packet(packet));
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    debug$1("server disconnect (%s)", this.nsp);
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually.
   *
   * @return self
   * @public
   */
  disconnect() {
    if (this.connected) {
      debug$1("performing disconnect (%s)", this.nsp);
      this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for disconnect()
   *
   * @return self
   * @public
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   * @public
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @returns self
   * @public
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @param listener
   * @public
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @param listener
   * @public
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @param listener
   * @public
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners2 = this._anyListeners;
      for (let i = 0; i < listeners2.length; i++) {
        if (listener === listeners2[i]) {
          listeners2.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   *
   * @public
   */
  listenersAny() {
    return this._anyListeners || [];
  }
}
socket.Socket = Socket2;
var backo2 = Backoff$1;
function Backoff$1(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff$1.prototype.duration = function() {
  var ms2 = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms2);
    ms2 = (Math.floor(rand * 10) & 1) == 0 ? ms2 - deviation : ms2 + deviation;
  }
  return Math.min(ms2, this.max) | 0;
};
Backoff$1.prototype.reset = function() {
  this.attempts = 0;
};
Backoff$1.prototype.setMin = function(min2) {
  this.ms = min2;
};
Backoff$1.prototype.setMax = function(max2) {
  this.max = max2;
};
Backoff$1.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
Object.defineProperty(manager, "__esModule", { value: true });
manager.Manager = void 0;
const eio = libExports;
const socket_1 = socket;
const parser = dist;
const on_1 = on$1;
const Backoff = backo2;
const typed_events_1 = typedEvents;
const debug = browserExports("socket.io-client:manager");
class Manager extends typed_events_1.StrictEventEmitter {
  constructor(uri, opts) {
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor(opts.randomizationFactor || 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a2;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a2;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a2;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn2) {
    debug("readyState %s", this._readyState);
    if (~this._readyState.indexOf("open"))
      return this;
    debug("opening %s", this.uri);
    this.engine = eio(this.uri, this.opts);
    const socket2 = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on_1.on(socket2, "open", function() {
      self2.onopen();
      fn2 && fn2();
    });
    const errorSub = on_1.on(socket2, "error", (err) => {
      debug("error");
      self2.cleanup();
      self2._readyState = "closed";
      this.emitReserved("error", err);
      if (fn2) {
        fn2(err);
      } else {
        self2.maybeReconnectOnOpen();
      }
    });
    if (false !== this._timeout) {
      const timeout = this._timeout;
      debug("connect attempt will timeout after %d", timeout);
      if (timeout === 0) {
        openSubDestroy();
      }
      const timer = setTimeout(() => {
        debug("connect attempt timed out after %d", timeout);
        openSubDestroy();
        socket2.close();
        socket2.emit("error", new Error("timeout"));
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(function subDestroy() {
        clearTimeout(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn2) {
    return this.open(fn2);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    debug("open");
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket2 = this.engine;
    this.subs.push(on_1.on(socket2, "ping", this.onping.bind(this)), on_1.on(socket2, "data", this.ondata.bind(this)), on_1.on(socket2, "error", this.onerror.bind(this)), on_1.on(socket2, "close", this.onclose.bind(this)), on_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    this.decoder.add(data);
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    this.emitReserved("packet", packet);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    debug("error", err);
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket2 = this.nsps[nsp];
    if (!socket2) {
      socket2 = new socket_1.Socket(this, nsp, opts);
      this.nsps[nsp] = socket2;
    }
    return socket2;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket2) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket3 = this.nsps[nsp];
      if (socket3.active) {
        debug("socket %s is still active, skipping close", nsp);
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    debug("writing packet %j", packet);
    const encodedPackets = this.encoder.encode(packet);
    for (let i = 0; i < encodedPackets.length; i++) {
      this.engine.write(encodedPackets[i], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    debug("cleanup");
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    debug("disconnect");
    this.skipReconnect = true;
    this._reconnecting = false;
    if ("opening" === this._readyState) {
      this.cleanup();
    }
    this.backoff.reset();
    this._readyState = "closed";
    if (this.engine)
      this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(reason) {
    debug("onclose");
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      debug("reconnect failed");
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      debug("will wait %dms before reconnect attempt", delay);
      this._reconnecting = true;
      const timer = setTimeout(() => {
        if (self2.skipReconnect)
          return;
        debug("attempting reconnect");
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            debug("reconnect attempt error");
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            debug("reconnect success");
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(function subDestroy() {
        clearTimeout(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
manager.Manager = Manager;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Socket = exports.io = exports.Manager = exports.protocol = void 0;
  const url_1 = url$1;
  const manager_1 = manager;
  const socket_12 = socket;
  Object.defineProperty(exports, "Socket", { enumerable: true, get: function() {
    return socket_12.Socket;
  } });
  const debug2 = browserExports("socket.io-client");
  module.exports = exports = lookup;
  const cache2 = exports.managers = {};
  function lookup(uri, opts) {
    if (typeof uri === "object") {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    const parsed = url_1.url(uri, opts.path);
    const source = parsed.source;
    const id2 = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache2[id2] && path in cache2[id2]["nsps"];
    const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
    let io2;
    if (newConnection) {
      debug2("ignoring socket cache for %s", source);
      io2 = new manager_1.Manager(source, opts);
    } else {
      if (!cache2[id2]) {
        debug2("new io instance for %s", source);
        cache2[id2] = new manager_1.Manager(source, opts);
      }
      io2 = cache2[id2];
    }
    if (parsed.query && !opts.query) {
      opts.query = parsed.queryKey;
    }
    return io2.socket(parsed.path, opts);
  }
  exports.io = lookup;
  var socket_io_parser_12 = dist;
  Object.defineProperty(exports, "protocol", { enumerable: true, get: function() {
    return socket_io_parser_12.protocol;
  } });
  exports.connect = lookup;
  var manager_2 = manager;
  Object.defineProperty(exports, "Manager", { enumerable: true, get: function() {
    return manager_2.Manager;
  } });
  exports.default = lookup;
})(build, build.exports);
var buildExports = build.exports;
const io = /* @__PURE__ */ getDefaultExportFromCjs(buildExports);
io.Manager;
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid2) {
  return typeof uuid2 === "string" && REGEX.test(uuid2);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid2 = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate(uuid2)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid2;
}
function v4(options2, buf, offset2) {
  options2 = options2 || {};
  var rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset2 + i] = rnds[i];
    }
    return buf;
  }
  return stringify(rnds);
}
const encode = (data, namespace) => {
  return new Promise((resolve3, reject) => {
    try {
      const encoder = new dist.Encoder();
      const socketIoEncodedData = encoder.encode({
        type: dist.PacketType.EVENT,
        data,
        nsp: namespace
      });
      lib$1.encodePayload(socketIoEncodedData.map((item) => {
        return {
          type: "message",
          data: item
        };
      }), (encoded) => {
        resolve3(encoded);
      });
    } catch (err) {
      reject(err);
    }
  });
};
const decode = (data) => {
  return new Promise((resolve3, reject) => {
    try {
      const decoded = lib$1.decodePayload(data);
      const decoder = new dist.Decoder();
      decoder.on("decoded", (packet) => {
        decoder.destroy();
        resolve3(packet.data);
      });
      decoded.forEach((packet) => {
        decoder.add(packet.data);
      });
    } catch (error) {
      reject(error);
    }
  });
};
class CDPBrowserSocket extends Emitter$4 {
  constructor(namespace) {
    super();
    this.emit = (event, ...args) => {
      const uuid2 = v4();
      let callback;
      if (typeof args[args.length - 1] === "function") {
        callback = args.pop();
      }
      if (callback) {
        this.once(uuid2, callback);
      }
      encode([event, uuid2, args], this._namespace).then((encoded) => {
        window[`cypressSendToServer-${this._namespace}`](JSON.stringify(encoded));
      });
      return this;
    };
    this._namespace = namespace;
    const send = (payload) => {
      const parsed = JSON.parse(payload);
      decode(parsed).then((decoded) => {
        const [event, callbackEvent, args] = decoded;
        super.emit(event, ...args);
        this.emit(callbackEvent);
      });
    };
    let cypressSocket = window[`cypressSocket-${this._namespace}`];
    if (!cypressSocket) {
      cypressSocket = {};
      window[`cypressSocket-${this._namespace}`] = cypressSocket;
    }
    if (!cypressSocket.send) {
      cypressSocket.send = send;
    }
  }
  connect() {
    setTimeout(() => {
      super.emit("connect");
    }, 0);
  }
}
let chromium = false;
function client(uri, opts) {
  if (chromium) {
    const fullNamespace = `${opts == null ? void 0 : opts.path}${uri}`;
    window.cypressSockets || (window.cypressSockets = {});
    if (!window.cypressSockets[fullNamespace]) {
      window.cypressSockets[fullNamespace] = new CDPBrowserSocket(fullNamespace);
    }
    window.cypressSockets[fullNamespace].connect();
    return window.cypressSockets[fullNamespace];
  }
  return io(uri, opts);
}
function createWebsocket$1({ path, browserFamily }) {
  if (browserFamily === "chromium") {
    chromium = true;
    const fullNamespace = `${path}/default`;
    window.cypressSockets || (window.cypressSockets = {});
    if (!window.cypressSockets[fullNamespace]) {
      window.cypressSockets[fullNamespace] = new CDPBrowserSocket(fullNamespace);
    }
    window.cypressSockets[fullNamespace].connect();
    return window.cypressSockets[fullNamespace];
  }
  return io({
    path,
    // TODO(webkit): the websocket socket.io transport is busted in WebKit, need polling
    // https://github.com/cypress-io/cypress/issues/23807
    transports: browserFamily === "webkit" ? ["polling"] : ["websocket"]
  });
}
const baseHasOwnProperty = Object.prototype.hasOwnProperty;
function isObject$2(val) {
  return typeof val === "object" && val !== null;
}
function areGraphQLErrors(obj) {
  return Array.isArray(obj) && // must be at least one error
  obj.length > 0 && // error has at least a message
  obj.every((ob) => "message" in ob);
}
function hasOwnProperty$1(obj, prop) {
  return baseHasOwnProperty.call(obj, prop);
}
function hasOwnObjectProperty(obj, prop) {
  return baseHasOwnProperty.call(obj, prop) && isObject$2(obj[prop]);
}
function hasOwnStringProperty(obj, prop) {
  return baseHasOwnProperty.call(obj, prop) && typeof obj[prop] === "string";
}
function limitCloseReason(reason, whenTooLong) {
  return reason.length < 124 ? reason : whenTooLong;
}
const GRAPHQL_TRANSPORT_WS_PROTOCOL = "graphql-transport-ws";
var CloseCode;
(function(CloseCode2) {
  CloseCode2[CloseCode2["InternalServerError"] = 4500] = "InternalServerError";
  CloseCode2[CloseCode2["InternalClientError"] = 4005] = "InternalClientError";
  CloseCode2[CloseCode2["BadRequest"] = 4400] = "BadRequest";
  CloseCode2[CloseCode2["BadResponse"] = 4004] = "BadResponse";
  CloseCode2[CloseCode2["Unauthorized"] = 4401] = "Unauthorized";
  CloseCode2[CloseCode2["Forbidden"] = 4403] = "Forbidden";
  CloseCode2[CloseCode2["SubprotocolNotAcceptable"] = 4406] = "SubprotocolNotAcceptable";
  CloseCode2[CloseCode2["ConnectionInitialisationTimeout"] = 4408] = "ConnectionInitialisationTimeout";
  CloseCode2[CloseCode2["ConnectionAcknowledgementTimeout"] = 4504] = "ConnectionAcknowledgementTimeout";
  CloseCode2[CloseCode2["SubscriberAlreadyExists"] = 4409] = "SubscriberAlreadyExists";
  CloseCode2[CloseCode2["TooManyInitialisationRequests"] = 4429] = "TooManyInitialisationRequests";
})(CloseCode || (CloseCode = {}));
var MessageType;
(function(MessageType2) {
  MessageType2["ConnectionInit"] = "connection_init";
  MessageType2["ConnectionAck"] = "connection_ack";
  MessageType2["Ping"] = "ping";
  MessageType2["Pong"] = "pong";
  MessageType2["Subscribe"] = "subscribe";
  MessageType2["Next"] = "next";
  MessageType2["Error"] = "error";
  MessageType2["Complete"] = "complete";
})(MessageType || (MessageType = {}));
function isMessage(val) {
  if (isObject$2(val)) {
    if (!hasOwnStringProperty(val, "type")) {
      return false;
    }
    switch (val.type) {
      case MessageType.ConnectionInit:
        return !hasOwnProperty$1(val, "payload") || val.payload === void 0 || isObject$2(val.payload);
      case MessageType.ConnectionAck:
      case MessageType.Ping:
      case MessageType.Pong:
        return !hasOwnProperty$1(val, "payload") || val.payload === void 0 || isObject$2(val.payload);
      case MessageType.Subscribe:
        return hasOwnStringProperty(val, "id") && hasOwnObjectProperty(val, "payload") && (!hasOwnProperty$1(val.payload, "operationName") || val.payload.operationName === void 0 || val.payload.operationName === null || typeof val.payload.operationName === "string") && hasOwnStringProperty(val.payload, "query") && (!hasOwnProperty$1(val.payload, "variables") || val.payload.variables === void 0 || val.payload.variables === null || hasOwnObjectProperty(val.payload, "variables")) && (!hasOwnProperty$1(val.payload, "extensions") || val.payload.extensions === void 0 || val.payload.extensions === null || hasOwnObjectProperty(val.payload, "extensions"));
      case MessageType.Next:
        return hasOwnStringProperty(val, "id") && hasOwnObjectProperty(val, "payload");
      case MessageType.Error:
        return hasOwnStringProperty(val, "id") && areGraphQLErrors(val.payload);
      case MessageType.Complete:
        return hasOwnStringProperty(val, "id");
      default:
        return false;
    }
  }
  return false;
}
function parseMessage(data, reviver) {
  if (isMessage(data)) {
    return data;
  }
  if (typeof data !== "string") {
    throw new Error("Message not parsable");
  }
  const message = JSON.parse(data, reviver);
  if (!isMessage(message)) {
    throw new Error("Invalid message");
  }
  return message;
}
function stringifyMessage(msg, replacer2) {
  if (!isMessage(msg)) {
    throw new Error("Cannot stringify invalid message");
  }
  return JSON.stringify(msg, replacer2);
}
function createClient(options2) {
  const {
    url: url2,
    connectionParams,
    lazy = true,
    onNonLazyError = console.error,
    lazyCloseTimeout = 0,
    keepAlive = 0,
    disablePong,
    connectionAckWaitTimeout = 0,
    retryAttempts = 5,
    retryWait = async function randomisedExponentialBackoff(retries2) {
      let retryDelay = 1e3;
      for (let i = 0; i < retries2; i++) {
        retryDelay *= 2;
      }
      await new Promise((resolve3) => setTimeout(resolve3, retryDelay + // add random timeout from 300ms to 3s
      Math.floor(Math.random() * (3e3 - 300) + 300)));
    },
    isFatalConnectionProblem = (errOrCloseEvent) => (
      // non `CloseEvent`s are fatal by default
      !isLikeCloseEvent(errOrCloseEvent)
    ),
    on: on2,
    webSocketImpl,
    /**
     * Generates a v4 UUID to be used as the ID using `Math`
     * as the random number generator. Supply your own generator
     * in case you need more uniqueness.
     *
     * Reference: https://gist.github.com/jed/982883
     */
    generateID = function generateUUID() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
        const r2 = Math.random() * 16 | 0, v = c2 == "x" ? r2 : r2 & 3 | 8;
        return v.toString(16);
      });
    },
    jsonMessageReplacer: replacer2,
    jsonMessageReviver: reviver
  } = options2;
  let ws2;
  if (webSocketImpl) {
    if (!isWebSocket(webSocketImpl)) {
      throw new Error("Invalid WebSocket implementation provided");
    }
    ws2 = webSocketImpl;
  } else if (typeof WebSocket !== "undefined") {
    ws2 = WebSocket;
  } else if (typeof global !== "undefined") {
    ws2 = global.WebSocket || // @ts-expect-error: Support more browsers
    global.MozWebSocket;
  } else if (typeof window !== "undefined") {
    ws2 = window.WebSocket || // @ts-expect-error: Support more browsers
    window.MozWebSocket;
  }
  if (!ws2)
    throw new Error("WebSocket implementation missing");
  const WebSocketImpl = ws2;
  const emitter = (() => {
    const message = /* @__PURE__ */ (() => {
      const listeners3 = {};
      return {
        on(id2, listener) {
          listeners3[id2] = listener;
          return () => {
            delete listeners3[id2];
          };
        },
        emit(message2) {
          var _a2;
          if ("id" in message2)
            (_a2 = listeners3[message2.id]) === null || _a2 === void 0 ? void 0 : _a2.call(listeners3, message2);
        }
      };
    })();
    const listeners2 = {
      connecting: (on2 === null || on2 === void 0 ? void 0 : on2.connecting) ? [on2.connecting] : [],
      opened: (on2 === null || on2 === void 0 ? void 0 : on2.opened) ? [on2.opened] : [],
      connected: (on2 === null || on2 === void 0 ? void 0 : on2.connected) ? [on2.connected] : [],
      ping: (on2 === null || on2 === void 0 ? void 0 : on2.ping) ? [on2.ping] : [],
      pong: (on2 === null || on2 === void 0 ? void 0 : on2.pong) ? [on2.pong] : [],
      message: (on2 === null || on2 === void 0 ? void 0 : on2.message) ? [message.emit, on2.message] : [message.emit],
      closed: (on2 === null || on2 === void 0 ? void 0 : on2.closed) ? [on2.closed] : [],
      error: (on2 === null || on2 === void 0 ? void 0 : on2.error) ? [on2.error] : []
    };
    return {
      onMessage: message.on,
      on(event, listener) {
        const l2 = listeners2[event];
        l2.push(listener);
        return () => {
          l2.splice(l2.indexOf(listener), 1);
        };
      },
      emit(event, ...args) {
        for (const listener of [...listeners2[event]]) {
          listener(...args);
        }
      }
    };
  })();
  function errorOrClosed(cb) {
    const listening = [
      // errors are fatal and more critical than close events, throw them first
      emitter.on("error", (err) => {
        listening.forEach((unlisten) => unlisten());
        cb(err);
      }),
      // closes can be graceful and not fatal, throw them second (if error didnt throw)
      emitter.on("closed", (event) => {
        listening.forEach((unlisten) => unlisten());
        cb(event);
      })
    ];
  }
  let connecting, locks = 0, retrying = false, retries = 0, disposed = false;
  async function connect() {
    const [socket2, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise((connected, denied) => (async () => {
      if (retrying) {
        await retryWait(retries);
        if (!locks) {
          connecting = void 0;
          return denied({ code: 1e3, reason: "All Subscriptions Gone" });
        }
        retries++;
      }
      emitter.emit("connecting");
      const socket3 = new WebSocketImpl(typeof url2 === "function" ? await url2() : url2, GRAPHQL_TRANSPORT_WS_PROTOCOL);
      let connectionAckTimeout, queuedPing;
      function enqueuePing() {
        if (isFinite(keepAlive) && keepAlive > 0) {
          clearTimeout(queuedPing);
          queuedPing = setTimeout(() => {
            if (socket3.readyState === WebSocketImpl.OPEN) {
              socket3.send(stringifyMessage({ type: MessageType.Ping }));
              emitter.emit("ping", false, void 0);
            }
          }, keepAlive);
        }
      }
      errorOrClosed((errOrEvent) => {
        connecting = void 0;
        clearTimeout(connectionAckTimeout);
        clearTimeout(queuedPing);
        denied(errOrEvent);
      });
      socket3.onerror = (err) => emitter.emit("error", err);
      socket3.onclose = (event) => emitter.emit("closed", event);
      socket3.onopen = async () => {
        try {
          emitter.emit("opened", socket3);
          const payload = typeof connectionParams === "function" ? await connectionParams() : connectionParams;
          socket3.send(stringifyMessage(payload ? {
            type: MessageType.ConnectionInit,
            payload
          } : {
            type: MessageType.ConnectionInit
            // payload is completely absent if not provided
          }, replacer2));
          if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {
            connectionAckTimeout = setTimeout(() => {
              socket3.close(CloseCode.ConnectionAcknowledgementTimeout, "Connection acknowledgement timeout");
            }, connectionAckWaitTimeout);
          }
          enqueuePing();
        } catch (err) {
          emitter.emit("error", err);
          socket3.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, "Internal client error"));
        }
      };
      let acknowledged = false;
      socket3.onmessage = ({ data }) => {
        try {
          const message = parseMessage(data, reviver);
          emitter.emit("message", message);
          if (message.type === "ping" || message.type === "pong") {
            emitter.emit(message.type, true, message.payload);
            if (message.type === "pong") {
              enqueuePing();
            } else if (!disablePong) {
              socket3.send(stringifyMessage(message.payload ? {
                type: MessageType.Pong,
                payload: message.payload
              } : {
                type: MessageType.Pong
                // payload is completely absent if not provided
              }));
              emitter.emit("pong", false, message.payload);
            }
            return;
          }
          if (acknowledged)
            return;
          if (message.type !== MessageType.ConnectionAck)
            throw new Error(`First message cannot be of type ${message.type}`);
          clearTimeout(connectionAckTimeout);
          acknowledged = true;
          emitter.emit("connected", socket3, message.payload);
          retrying = false;
          retries = 0;
          connected([
            socket3,
            new Promise((_2, reject) => errorOrClosed(reject))
          ]);
        } catch (err) {
          socket3.onmessage = null;
          emitter.emit("error", err);
          socket3.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, "Bad response"));
        }
      };
    })()));
    if (socket2.readyState === WebSocketImpl.CLOSING)
      await throwOnClose;
    let release = () => {
    };
    const released = new Promise((resolve3) => release = resolve3);
    return [
      socket2,
      release,
      Promise.race([
        // wait for
        released.then(() => {
          if (!locks) {
            const complete = () => socket2.close(1e3, "Normal Closure");
            if (isFinite(lazyCloseTimeout) && lazyCloseTimeout > 0) {
              setTimeout(() => {
                if (!locks && socket2.readyState === WebSocketImpl.OPEN)
                  complete();
              }, lazyCloseTimeout);
            } else {
              complete();
            }
          }
        }),
        // or
        throwOnClose
      ])
    ];
  }
  function shouldRetryConnectOrThrow(errOrCloseEvent) {
    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [
      CloseCode.InternalServerError,
      CloseCode.InternalClientError,
      CloseCode.BadRequest,
      CloseCode.BadResponse,
      CloseCode.Unauthorized,
      // CloseCode.Forbidden, might grant access out after retry
      CloseCode.SubprotocolNotAcceptable,
      // CloseCode.ConnectionInitialisationTimeout, might not time out after retry
      // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry
      CloseCode.SubscriberAlreadyExists,
      CloseCode.TooManyInitialisationRequests
    ].includes(errOrCloseEvent.code)))
      throw errOrCloseEvent;
    if (disposed)
      return false;
    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1e3)
      return locks > 0;
    if (!retryAttempts || retries >= retryAttempts)
      throw errOrCloseEvent;
    if (isFatalConnectionProblem(errOrCloseEvent))
      throw errOrCloseEvent;
    return retrying = true;
  }
  if (!lazy) {
    (async () => {
      locks++;
      for (; ; ) {
        try {
          const [, , throwOnClose] = await connect();
          await throwOnClose;
        } catch (errOrCloseEvent) {
          try {
            if (!shouldRetryConnectOrThrow(errOrCloseEvent))
              return;
          } catch (errOrCloseEvent2) {
            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent2);
          }
        }
      }
    })();
  }
  return {
    on: emitter.on,
    subscribe(payload, sink) {
      const id2 = generateID();
      let done = false, errored = false, releaser = () => {
        locks--;
        done = true;
      };
      (async () => {
        locks++;
        for (; ; ) {
          try {
            const [socket2, release, waitForReleaseOrThrowOnClose] = await connect();
            if (done)
              return release();
            const unlisten = emitter.onMessage(id2, (message) => {
              switch (message.type) {
                case MessageType.Next: {
                  sink.next(message.payload);
                  return;
                }
                case MessageType.Error: {
                  errored = true, done = true;
                  sink.error(message.payload);
                  releaser();
                  return;
                }
                case MessageType.Complete: {
                  done = true;
                  releaser();
                  return;
                }
              }
            });
            socket2.send(stringifyMessage({
              id: id2,
              type: MessageType.Subscribe,
              payload
            }, replacer2));
            releaser = () => {
              if (!done && socket2.readyState === WebSocketImpl.OPEN)
                socket2.send(stringifyMessage({
                  id: id2,
                  type: MessageType.Complete
                }, replacer2));
              locks--;
              done = true;
              release();
            };
            await waitForReleaseOrThrowOnClose.finally(unlisten);
            return;
          } catch (errOrCloseEvent) {
            if (!shouldRetryConnectOrThrow(errOrCloseEvent))
              return;
          }
        }
      })().then(() => {
        if (!errored)
          sink.complete();
      }).catch((err) => {
        sink.error(err);
      });
      return () => {
        if (!done)
          releaser();
      };
    },
    async dispose() {
      disposed = true;
      if (connecting) {
        const [socket2] = await connecting;
        socket2.close(1e3, "Normal Closure");
      }
    }
  };
}
function isLikeCloseEvent(val) {
  return isObject$2(val) && "code" in val && "reason" in val;
}
function isFatalInternalCloseCode(code2) {
  if ([
    1e3,
    1001,
    1006,
    1005,
    1012,
    1013,
    1013
    // Bad Gateway
  ].includes(code2))
    return false;
  return code2 >= 1e3 && code2 <= 1999;
}
function isWebSocket(val) {
  return typeof val === "function" && "constructor" in val && "CLOSED" in val && "CLOSING" in val && "CONNECTING" in val && "OPEN" in val;
}
function _extends() {
  return (_extends = Object.assign || function(t2) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r2 in n) {
        if (Object.prototype.hasOwnProperty.call(n, r2)) {
          t2[r2] = n[r2];
        }
      }
    }
    return t2;
  }).apply(this, arguments);
}
function getName(e2) {
  return e2.name.value;
}
function getFragmentTypeName(e2) {
  return e2.typeCondition.name.value;
}
function getFieldAlias(e2) {
  return e2.alias ? e2.alias.value : getName(e2);
}
function getSelectionSet(e2) {
  return e2.selectionSet ? e2.selectionSet.selections : [];
}
function getTypeCondition(e2) {
  return e2.typeCondition ? getName(e2.typeCondition) : null;
}
function isFieldNode(e2) {
  return e2.kind === Kind.FIELD;
}
function isInlineFragment(e2) {
  return e2.kind === Kind.INLINE_FRAGMENT;
}
function getFieldArguments(e2, t2) {
  var r2 = {};
  var i2 = 0;
  if (e2.arguments && e2.arguments.length) {
    for (var n2 = 0, a2 = e2.arguments.length; n2 < a2; n2++) {
      var o2 = e2.arguments[n2];
      var s2 = valueFromASTUntyped(o2.value, t2);
      if (null != s2) {
        r2[getName(o2)] = s2;
        i2++;
      }
    }
  }
  return i2 > 0 ? r2 : null;
}
function filterVariables(e2, t2) {
  if (!t2 || !e2.variableDefinitions) {
    return;
  }
  var r2 = {};
  for (var i2 = 0, n2 = e2.variableDefinitions.length; i2 < n2; i2++) {
    var a2 = getName(e2.variableDefinitions[i2].variable);
    r2[a2] = t2[a2];
  }
  return r2;
}
function normalizeVariables(e2, t2) {
  var r2 = {};
  if (!t2) {
    return r2;
  }
  if (e2.variableDefinitions) {
    for (var i2 = 0, n2 = e2.variableDefinitions.length; i2 < n2; i2++) {
      var a2 = e2.variableDefinitions[i2];
      var o2 = getName(a2.variable);
      r2[o2] = void 0 === t2[o2] && a2.defaultValue ? valueFromASTUntyped(a2.defaultValue, t2) : t2[o2];
    }
  }
  for (var s2 in t2) {
    if (!(s2 in r2)) {
      r2[s2] = t2[s2];
    }
  }
  return r2;
}
var N = "\nhttps://bit.ly/2XbVrpR#";
function invariant$1(e2, t2, r2) {
  if (!e2) {
    var i2 = t2 || "Minfied Error #" + r2 + "\n";
    var n2 = new Error(i2 + N + r2);
    n2.name = "Graphcache Error";
    throw n2;
  }
}
function getMainOperation(e2) {
  for (var t2 = 0; t2 < e2.definitions.length; t2++) {
    if (e2.definitions[t2].kind === Kind.OPERATION_DEFINITION) {
      return e2.definitions[t2];
    }
  }
  invariant$1(false, "", 1);
}
function getFragments(e2) {
  var t2 = {};
  for (var r2 = 0; r2 < e2.definitions.length; r2++) {
    var i2 = e2.definitions[r2];
    if (i2.kind === Kind.FRAGMENT_DEFINITION) {
      t2[getName(i2)] = i2;
    }
  }
  return t2;
}
function shouldInclude(e2, t2) {
  for (var r2 = 0; e2.directives && r2 < e2.directives.length; r2++) {
    var i2 = e2.directives[r2];
    var n2 = getName(i2);
    if (("include" === n2 || "skip" === n2) && i2.arguments && i2.arguments[0] && "if" === getName(i2.arguments[0])) {
      var a2 = valueFromASTUntyped(i2.arguments[0].value, t2);
      return "include" === n2 ? !!a2 : !a2;
    }
  }
  return true;
}
function isDeferred(e2, t2) {
  for (var r2 = 0; e2.directives && r2 < e2.directives.length; r2++) {
    var i2 = e2.directives[r2];
    if ("defer" === getName(i2)) {
      for (var n2 = 0; i2.arguments && n2 < i2.arguments.length; n2++) {
        var a2 = i2.arguments[r2];
        if ("if" === getName(a2)) {
          return !!valueFromASTUntyped(a2.value, t2);
        }
      }
      return true;
    }
  }
  return false;
}
function isFieldNullable(e2, t2, r2) {
  var i2 = getField(e2, t2, r2);
  return !!i2 && "NON_NULL" !== i2.type.kind;
}
function isListNullable(e2, t2, r2) {
  var i2 = getField(e2, t2, r2);
  if (!i2) {
    return false;
  }
  var n2 = "NON_NULL" === i2.type.kind ? i2.type.ofType : i2.type;
  return "LIST" === n2.kind && "NON_NULL" !== n2.ofType.kind;
}
function isInterfaceOfType(e2, t2, r2) {
  if (!r2) {
    return false;
  }
  var i2 = getTypeCondition(t2);
  if (!i2 || r2 === i2) {
    return true;
  } else if (e2.types[i2] && "OBJECT" === e2.types[i2].kind) {
    return i2 === r2;
  }
  !function expectAbstractType(e3, t3) {
    invariant$1(e3.types[t3] && ("INTERFACE" === e3.types[t3].kind || "UNION" === e3.types[t3].kind), "", 5);
  }(e2, i2);
  expectObjectType(e2, r2);
  return e2.isSubType(i2, r2);
}
function getField(e2, t2, r2) {
  if (0 === r2.indexOf("__") || 0 === t2.indexOf("__")) {
    return;
  }
  expectObjectType(e2, t2);
  var i2 = e2.types[t2].fields[r2];
  return i2;
}
function expectObjectType(e2, t2) {
  invariant$1(e2.types[t2] && "OBJECT" === e2.types[t2].kind, "", 3);
}
function keyOfField(t2, r2) {
  return r2 ? t2 + "(" + stringifyVariables(r2) + ")" : t2;
}
function joinKeys(e2, t2) {
  return e2 + "." + t2;
}
function fieldInfoOfKey(e2) {
  var t2 = e2.indexOf("(");
  if (t2 > -1) {
    return {
      fieldKey: e2,
      fieldName: e2.slice(0, t2),
      arguments: JSON.parse(e2.slice(t2 + 1, -1))
    };
  } else {
    return {
      fieldKey: e2,
      fieldName: e2,
      arguments: null
    };
  }
}
function deserializeKeyInfo(e2) {
  var t2 = e2.indexOf(".");
  return {
    entityKey: e2.slice(0, t2).replace(/%2e/g, "."),
    fieldKey: e2.slice(t2 + 1)
  };
}
function makeDict() {
  return /* @__PURE__ */ Object.create(null);
}
var _ = null;
var E = null;
var b = null;
var D = null;
var w = null;
var F = null;
var S = false;
function makeNodeMap() {
  return {
    optimistic: makeDict(),
    base: /* @__PURE__ */ new Map()
  };
}
function makeData(e2) {
  var t2;
  if (e2) {
    if (_.has(e2)) {
      return e2;
    }
    t2 = E.get(e2) || _extends({}, e2);
    E.set(e2, t2);
  } else {
    t2 = {};
  }
  _.add(t2);
  return t2;
}
function ownsData(e2) {
  return !!e2 && _.has(e2);
}
function initDataState(e2, t2, r2, i2) {
  _ = /* @__PURE__ */ new Set();
  E = /* @__PURE__ */ new Map();
  b = e2;
  D = t2;
  w = makeDict();
  S = !!i2;
  if (!r2) {
    F = null;
  } else if (i2 || t2.optimisticOrder.length > 0) {
    if (!i2 && !t2.commutativeKeys.has(r2)) {
      reserveLayer(t2, r2);
    } else if (i2) {
      t2.commutativeKeys.delete(r2);
    }
    F = r2;
    !function createLayer(e3, t3) {
      if (-1 === e3.optimisticOrder.indexOf(t3)) {
        e3.optimisticOrder.unshift(t3);
      }
      if (!e3.refLock[t3]) {
        e3.refLock[t3] = makeDict();
        e3.links.optimistic[t3] = /* @__PURE__ */ new Map();
        e3.records.optimistic[t3] = /* @__PURE__ */ new Map();
      }
    }(t2, r2);
  } else {
    F = null;
    deleteLayer(t2, r2);
  }
}
function clearDataState() {
  var t2 = D;
  var r2 = F;
  S = false;
  F = null;
  if (r2 && t2.optimisticOrder.indexOf(r2) > -1) {
    var i2 = t2.optimisticOrder.length;
    while (--i2 >= 0 && t2.refLock[t2.optimisticOrder[i2]] && t2.commutativeKeys.has(t2.optimisticOrder[i2]) && !t2.deferredKeys.has(t2.optimisticOrder[i2])) {
      squashLayer(t2.optimisticOrder[i2]);
    }
  }
  _ = null;
  E = null;
  b = null;
  D = null;
  w = null;
  if (!t2.defer) {
    t2.defer = true;
    Promise.resolve().then(function() {
      initDataState("read", t2, null);
      !function gc() {
        D.gc.forEach(function(e2, t3, r3) {
          if ((D.refCount[e2] || 0) > 0) {
            r3.delete(e2);
            return;
          }
          for (var i3 in D.refLock) {
            var n2 = D.refLock[i3];
            if ((n2[e2] || 0) > 0) {
              return;
            }
            delete n2[e2];
          }
          delete D.refCount[e2];
          r3.delete(e2);
          D.records.base.delete(e2);
          var a2 = D.links.base.get(e2);
          if (a2) {
            D.links.base.delete(e2);
            for (var o2 in a2) {
              updateRCForLink(r3, D.refCount, a2[o2], -1);
            }
          }
        });
      }();
      !function persistData() {
        if (D.storage) {
          S = true;
          b = "read";
          var t3 = makeDict();
          D.persist.forEach(function(r3) {
            var i3 = deserializeKeyInfo(r3);
            var n2 = i3.entityKey;
            var a2 = i3.fieldKey;
            var o2;
            if (void 0 !== (o2 = readLink(n2, a2))) {
              t3[r3] = ":" + stringifyVariables(o2);
            } else if (void 0 !== (o2 = readRecord(n2, a2))) {
              t3[r3] = stringifyVariables(o2);
            } else {
              t3[r3] = void 0;
            }
          });
          S = false;
          D.storage.writeData(t3);
          D.persist.clear();
        }
      }();
      clearDataState();
      t2.defer = false;
    });
  }
}
function noopDataState(e2, t2, r2) {
  if (t2 && !r2) {
    e2.deferredKeys.delete(t2);
  }
  initDataState("read", e2, t2, r2);
  clearDataState();
}
function getCurrentOperation() {
  invariant$1(null !== b, "", 2);
  return b;
}
function getCurrentDependencies() {
  invariant$1(null !== w, "", 2);
  return w;
}
function setNode(e2, t2, r2, i2) {
  var n2 = F ? e2.optimistic[F] : e2.base;
  var a2 = n2.get(t2);
  if (void 0 === a2) {
    n2.set(t2, a2 = makeDict());
  }
  if (void 0 === i2 && !F) {
    delete a2[r2];
  } else {
    a2[r2] = i2;
  }
}
function getNode(e2, t2, r2) {
  var i2;
  var n2 = !S && "read" === b && F && D.commutativeKeys.has(F);
  for (var a2 = 0, o2 = D.optimisticOrder.length; a2 < o2; a2++) {
    var s2 = D.optimisticOrder[a2];
    var u2 = e2.optimistic[s2];
    n2 = n2 && s2 !== F;
    if (u2 && (!n2 || !D.commutativeKeys.has(s2)) && (!S || "write" === b || D.commutativeKeys.has(s2)) && void 0 !== (i2 = u2.get(t2)) && r2 in i2) {
      return i2[r2];
    }
  }
  return void 0 !== (i2 = e2.base.get(t2)) ? i2[r2] : void 0;
}
function updateRCForEntity(e2, t2, r2, i2) {
  var n2 = void 0 !== t2[r2] ? t2[r2] : 0;
  var a2 = t2[r2] = n2 + i2 | 0;
  if (void 0 !== e2) {
    if (a2 <= 0) {
      e2.add(r2);
    } else if (n2 <= 0 && a2 > 0) {
      e2.delete(r2);
    }
  }
}
function updateRCForLink(e2, t2, r2, i2) {
  if ("string" == typeof r2) {
    updateRCForEntity(e2, t2, r2, i2);
  } else if (Array.isArray(r2)) {
    for (var n2 = 0, a2 = r2.length; n2 < a2; n2++) {
      if (Array.isArray(r2[n2])) {
        updateRCForLink(e2, t2, r2[n2], i2);
      } else if (r2[n2]) {
        updateRCForEntity(e2, t2, r2[n2], i2);
      }
    }
  }
}
function extractNodeFields(e2, t2, r2) {
  if (void 0 !== r2) {
    for (var i2 in r2) {
      if (!t2.has(i2)) {
        e2.push(fieldInfoOfKey(i2));
        t2.add(i2);
      }
    }
  }
}
function extractNodeMapFields(e2, t2, r2, i2) {
  extractNodeFields(e2, t2, i2.base.get(r2));
  for (var n2 = 0, a2 = D.optimisticOrder.length; n2 < a2; n2++) {
    var o2 = i2.optimistic[D.optimisticOrder[n2]];
    if (void 0 !== o2) {
      extractNodeFields(e2, t2, o2.get(r2));
    }
  }
}
function updateDependencies(e2, t2) {
  if ("__typename" !== t2) {
    if (e2 !== D.queryRootKey) {
      w[e2] = true;
    } else if (void 0 !== t2) {
      w[joinKeys(e2, t2)] = true;
    }
  }
}
function updatePersist(e2, t2) {
  if (!S && D.storage) {
    D.persist.add(function serializeKeys(e3, t3) {
      return e3.replace(/\./g, "%2e") + "." + t3;
    }(e2, t2));
  }
}
function readRecord(e2, t2) {
  updateDependencies(e2, t2);
  return getNode(D.records, e2, t2);
}
function readLink(e2, t2) {
  updateDependencies(e2, t2);
  return getNode(D.links, e2, t2);
}
function writeRecord(e2, t2, r2) {
  updateDependencies(e2, t2);
  updatePersist(e2, t2);
  setNode(D.records, e2, t2, r2);
}
function writeLink(e2, t2, r2) {
  var i2 = D;
  var n2;
  var a2;
  var o2;
  if (F) {
    n2 = i2.refLock[F] || (i2.refLock[F] = makeDict());
    a2 = i2.links.optimistic[F];
  } else {
    n2 = i2.refCount;
    a2 = i2.links.base;
    o2 = i2.gc;
  }
  var s2 = a2 && a2.get(e2);
  var u2 = s2 && s2[t2];
  updateDependencies(e2, t2);
  updatePersist(e2, t2);
  setNode(i2.links, e2, t2, r2);
  updateRCForLink(o2, n2, u2, -1);
  updateRCForLink(o2, n2, r2, 1);
}
function reserveLayer(e2, t2, r2) {
  var i2 = e2.optimisticOrder.indexOf(t2);
  if (-1 === i2) {
    e2.optimisticOrder.unshift(t2);
  } else if (!e2.commutativeKeys.has(t2)) {
    clearLayer(e2, t2);
    e2.optimisticOrder.splice(i2, 1);
    e2.optimisticOrder.unshift(t2);
  }
  if (r2) {
    e2.deferredKeys.add(t2);
  } else {
    e2.deferredKeys.delete(t2);
  }
  e2.commutativeKeys.add(t2);
}
function clearLayer(e2, t2) {
  if (e2.refLock[t2]) {
    delete e2.refLock[t2];
    delete e2.records.optimistic[t2];
    delete e2.links.optimistic[t2];
    e2.deferredKeys.delete(t2);
  }
}
function deleteLayer(e2, t2) {
  var r2 = e2.optimisticOrder.indexOf(t2);
  if (r2 > -1) {
    e2.optimisticOrder.splice(r2, 1);
    e2.commutativeKeys.delete(t2);
  }
  clearLayer(e2, t2);
}
function squashLayer(e2) {
  var t2 = w;
  w = makeDict();
  var r2 = D.links.optimistic[e2];
  if (r2) {
    r2.forEach(function(e3, t3) {
      for (var r3 in e3) {
        writeLink(t3, r3, e3[r3]);
      }
    });
  }
  var i2 = D.records.optimistic[e2];
  if (i2) {
    i2.forEach(function(e3, t3) {
      for (var r3 in e3) {
        writeRecord(t3, r3, e3[r3]);
      }
    });
  }
  w = t2;
  deleteLayer(D, e2);
}
function inspectFields(e2) {
  var t2 = D.links;
  var r2 = D.records;
  var i2 = [];
  var n2 = /* @__PURE__ */ new Set();
  updateDependencies(e2);
  extractNodeMapFields(i2, n2, e2, t2);
  extractNodeMapFields(i2, n2, e2, r2);
  return i2;
}
var L = {
  current: null
};
var x = {
  current: false
};
function getFieldError(e2) {
  return e2.__internal.path.length > 0 && e2.__internal.errorMap ? e2.__internal.errorMap[e2.__internal.path.join(".")] : void 0;
}
function makeContext(e2, t2, r2, i2, n2, a2, o2) {
  var s2 = {
    store: e2,
    variables: t2,
    fragments: r2,
    parent: {
      __typename: i2
    },
    parentTypeName: i2,
    parentKey: n2,
    parentFieldKey: "",
    fieldName: "",
    error: void 0,
    partial: false,
    optimistic: !!a2,
    __internal: {
      path: [],
      errorMap: void 0
    }
  };
  if (o2 && o2.graphQLErrors) {
    for (var u2 = 0; u2 < o2.graphQLErrors.length; u2++) {
      var c2 = o2.graphQLErrors[u2];
      if (c2.path && c2.path.length) {
        if (!s2.__internal.errorMap) {
          s2.__internal.errorMap = /* @__PURE__ */ Object.create(null);
        }
        s2.__internal.errorMap[c2.path.join(".")] = c2;
      }
    }
  }
  return s2;
}
function updateContext(e2, t2, r2, i2, n2, a2) {
  L.current = e2;
  e2.parent = t2;
  e2.parentTypeName = r2;
  e2.parentKey = i2;
  e2.parentFieldKey = n2;
  e2.fieldName = a2;
  e2.error = getFieldError(e2);
}
function isFragmentHeuristicallyMatching(e2, t2, r2, i2) {
  if (!t2) {
    return false;
  }
  var n2 = getTypeCondition(e2);
  if (!n2 || t2 === n2) {
    return true;
  }
  return !getSelectionSet(e2).some(function(e3) {
    if (!isFieldNode(e3)) {
      return false;
    }
    var t3 = keyOfField(getName(e3), getFieldArguments(e3, i2));
    return !function hasField(e4, t4) {
      return void 0 !== readRecord(e4, t4) || void 0 !== readLink(e4, t4);
    }(r2, t3);
  });
}
function makeSelectionIterator(e2, t2, r2, i2) {
  var n2 = false;
  var a2;
  var o2 = 0;
  return function next() {
    if (!x.current && n2) {
      x.current = n2;
    }
    if (a2) {
      var s2 = a2();
      if (null != s2) {
        return s2;
      }
      a2 = void 0;
      n2 = false;
    }
    while (o2 < r2.length) {
      var u2 = r2[o2++];
      if (!shouldInclude(u2, i2.variables)) {
        continue;
      } else if (!isFieldNode(u2)) {
        var c2 = !isInlineFragment(u2) ? i2.fragments[getName(u2)] : u2;
        if (void 0 !== c2) {
          if (i2.store.schema ? isInterfaceOfType(i2.store.schema, c2, e2) : isFragmentHeuristicallyMatching(c2, e2, t2, i2.variables)) {
            n2 = !!isDeferred(u2, i2.variables);
            if (!x.current && n2) {
              x.current = n2;
            }
            return (a2 = makeSelectionIterator(e2, t2, getSelectionSet(c2), i2))();
          }
        }
      } else {
        return u2;
      }
    }
  };
}
function ensureData(e2) {
  return null == e2 ? null : e2;
}
function ensureLink(e2, t2) {
  if (null == t2) {
    return t2;
  } else if (Array.isArray(t2)) {
    var r2 = new Array(t2.length);
    for (var i2 = 0, n2 = r2.length; i2 < n2; i2++) {
      r2[i2] = ensureLink(e2, t2[i2]);
    }
    return r2;
  }
  var a2 = e2.keyOfEntity(t2);
  return a2;
}
function write$1(e2, t2, r2, i2, n2) {
  initDataState("write", e2.data, n2 || null);
  var a2 = startWrite(e2, t2, r2, i2);
  clearDataState();
  return a2;
}
function startWrite(e2, t2, r2, i2, n2) {
  var a2 = getMainOperation(t2.query);
  var o2 = {
    data: r2,
    dependencies: getCurrentDependencies()
  };
  var s2 = e2.rootFields[a2.operation];
  var u2 = makeContext(e2, normalizeVariables(a2, t2.variables), getFragments(t2.query), s2, s2, !!n2, i2);
  writeSelection(u2, s2, getSelectionSet(a2), r2);
  return o2;
}
function writeSelection(e2, t2, r2, i2) {
  var n2 = t2 === e2.store.rootFields.query;
  var a2 = !n2 && !!e2.store.rootNames[t2];
  var o2 = a2 || n2 ? t2 : i2.__typename;
  if (!o2) {
    return;
  } else if (!a2 && !n2 && t2) {
    writeRecord(t2, "__typename", o2);
  }
  var s2 = makeSelectionIterator(o2, t2 || o2, r2, e2);
  var u2;
  while (u2 = s2()) {
    var c2 = getName(u2);
    var l2 = getFieldArguments(u2, e2.variables);
    var d2 = keyOfField(c2, l2);
    var f2 = getFieldAlias(u2);
    var p2 = i2[f2];
    if ("__typename" === c2 || void 0 === p2 && x.current) {
      continue;
    }
    e2.__internal.path.push(f2);
    if (e2.optimistic && a2) {
      var v2 = e2.store.optimisticMutations[c2];
      if (!v2) {
        continue;
      }
      updateContext(e2, i2, o2, o2, d2, c2);
      p2 = i2[f2] = ensureData(v2(l2 || {}, e2.store, e2));
    }
    if (u2.selectionSet) {
      if (t2 && !a2) {
        var y2 = joinKeys(t2, d2);
        writeLink(t2 || o2, d2, writeField(e2, getSelectionSet(u2), ensureData(p2), y2));
      } else {
        writeField(e2, getSelectionSet(u2), ensureData(p2));
      }
    } else if (t2 && !a2) {
      writeRecord(t2 || o2, d2, null !== p2 || !getFieldError(e2) ? p2 : void 0);
    }
    if (a2) {
      var m2 = e2.store.updates[o2][c2];
      if (m2) {
        updateContext(e2, i2, o2, o2, joinKeys(o2, d2), c2);
        i2[c2] = p2;
        m2(i2, l2 || {}, e2.store, e2);
      }
    }
    e2.__internal.path.pop();
  }
}
function writeField(e2, t2, r2, i2) {
  if (Array.isArray(r2)) {
    var n2 = new Array(r2.length);
    for (var a2 = 0, o2 = r2.length; a2 < o2; a2++) {
      e2.__internal.path.push(a2);
      var s2 = i2 ? joinKeys(i2, "" + a2) : void 0;
      var u2 = writeField(e2, t2, r2[a2], s2);
      n2[a2] = u2;
      e2.__internal.path.pop();
    }
    return n2;
  } else if (null === r2) {
    return getFieldError(e2) ? void 0 : null;
  }
  var c2 = e2.store.keyOfEntity(r2);
  r2.__typename;
  var d2 = c2 || i2;
  writeSelection(e2, d2, t2, r2);
  return d2 || null;
}
function Store(e2) {
  var t2, r2;
  this.keyOfField = keyOfField;
  this.resolveFieldByKey = this.resolve;
  if (!e2) {
    e2 = {};
  }
  this.resolvers = e2.resolvers || {};
  this.optimisticMutations = e2.optimistic || {};
  this.keys = e2.keys || {};
  var i2 = "Query";
  var n2 = "Mutation";
  var a2 = "Subscription";
  if (e2.schema) {
    var o2 = function buildClientSchema(e3) {
      var t3 = e3.__schema;
      var r3 = {};
      function buildNameMap(e4) {
        var t4 = {};
        for (var r4 = 0; r4 < e4.length; r4++) {
          t4[e4[r4].name] = e4[r4];
        }
        return t4;
      }
      function buildType(e4) {
        switch (e4.kind) {
          case "OBJECT":
          case "INTERFACE":
            return {
              name: e4.name,
              kind: e4.kind,
              interfaces: buildNameMap(e4.interfaces || []),
              fields: buildNameMap(e4.fields.map(function(e5) {
                return {
                  name: e5.name,
                  type: e5.type,
                  args: buildNameMap(e5.args)
                };
              }))
            };
          case "UNION":
            return {
              name: e4.name,
              kind: e4.kind,
              types: buildNameMap(e4.possibleTypes || [])
            };
        }
      }
      var i3 = {
        query: t3.queryType ? t3.queryType.name : null,
        mutation: t3.mutationType ? t3.mutationType.name : null,
        subscription: t3.subscriptionType ? t3.subscriptionType.name : null,
        types: void 0,
        isSubType: function isSubType(e4, t4) {
          var i4 = r3[e4];
          var n4 = r3[t4];
          if (!i4 || !n4) {
            return false;
          } else if ("UNION" === i4.kind) {
            return !!i4.types[t4];
          } else if ("OBJECT" !== i4.kind && "OBJECT" === n4.kind) {
            return !!n4.interfaces[e4];
          } else {
            return e4 === t4;
          }
        }
      };
      if (t3.types) {
        i3.types = r3;
        for (var n3 = 0; n3 < t3.types.length; n3++) {
          var a3 = t3.types[n3];
          if (a3 && a3.name) {
            var o3 = buildType(a3);
            if (o3) {
              r3[a3.name] = o3;
            }
          }
        }
      }
      return i3;
    }(e2.schema);
    i2 = o2.query || i2;
    n2 = o2.mutation || n2;
    a2 = o2.subscription || a2;
    if (o2.types) {
      this.schema = o2;
    }
  }
  this.updates = ((t2 = {})[n2] = e2.updates && e2.updates.Mutation || {}, t2[a2] = e2.updates && e2.updates.Subscription || {}, t2);
  this.rootFields = {
    query: i2,
    mutation: n2,
    subscription: a2
  };
  this.rootNames = ((r2 = {})[i2] = "query", r2[n2] = "mutation", r2[a2] = "subscription", r2);
  this.data = function make(e3) {
    return {
      defer: false,
      gc: /* @__PURE__ */ new Set(),
      persist: /* @__PURE__ */ new Set(),
      queryRootKey: e3,
      refCount: makeDict(),
      refLock: makeDict(),
      links: makeNodeMap(),
      records: makeNodeMap(),
      deferredKeys: /* @__PURE__ */ new Set(),
      commutativeKeys: /* @__PURE__ */ new Set(),
      optimisticOrder: [],
      storage: null
    };
  }(i2);
  if (this.schema && false) {
    !/* @__PURE__ */ function expectValidKeyingConfig(e3, t3) {
    }(this.schema, this.keys);
    !function expectValidUpdatesConfig(e3, t3) {
      {
        return;
      }
    }(this.schema, this.updates);
    !function expectValidResolversConfig(e3, t3) {
      {
        return;
      }
    }(this.schema, this.resolvers);
    !function expectValidOptimisticMutationsConfig(e3, t3) {
      {
        return;
      }
    }(this.schema, this.optimisticMutations);
  }
}
Store.prototype.keyOfEntity = function keyOfEntity(e2) {
  if (L.current && e2 === L.current.parent) {
    return L.current.parentKey;
  }
  if (null == e2 || "string" == typeof e2) {
    return e2 || null;
  }
  if (!e2.__typename) {
    return null;
  }
  if (this.rootNames[e2.__typename]) {
    return e2.__typename;
  }
  var t2;
  if (this.keys[e2.__typename]) {
    t2 = this.keys[e2.__typename](e2);
  } else if (null != e2.id) {
    t2 = "" + e2.id;
  } else if (null != e2._id) {
    t2 = "" + e2._id;
  }
  return t2 ? e2.__typename + ":" + t2 : null;
};
Store.prototype.resolve = function resolve2(e2, t2, r2) {
  var i2 = keyOfField(t2, r2);
  var n2 = this.keyOfEntity(e2);
  if (!n2) {
    return null;
  }
  var a2 = readRecord(n2, i2);
  if (void 0 !== a2) {
    return a2;
  }
  return readLink(n2, i2) || null;
};
Store.prototype.invalidate = function invalidate(e2, t2, r2) {
  var i2 = this.keyOfEntity(e2);
  invariant$1(i2, "", 19);
  !function invalidateEntity(e3, t3, r3) {
    var i3 = t3 ? [{
      fieldKey: keyOfField(t3, r3)
    }] : inspectFields(e3);
    for (var n2 = 0, a2 = i3.length; n2 < a2; n2++) {
      var o2 = i3[n2].fieldKey;
      if (void 0 !== readLink(e3, o2)) {
        writeLink(e3, o2, void 0);
      } else {
        writeRecord(e3, o2, void 0);
      }
    }
  }(i2, t2, r2);
};
Store.prototype.inspectFields = function inspectFields$1(e2) {
  var t2 = this.keyOfEntity(e2);
  return t2 ? inspectFields(t2) : [];
};
Store.prototype.updateQuery = function updateQuery(e2, i2) {
  var n2 = createRequest(e2.query, e2.variables);
  n2.query = formatDocument(n2.query);
  var a2 = i2(this.readQuery(n2));
  if (null !== a2) {
    startWrite(this, n2, a2);
  }
};
Store.prototype.readQuery = function readQuery(e2) {
  var i2 = createRequest(e2.query, e2.variables);
  i2.query = formatDocument(i2.query);
  return read$2(this, i2).data;
};
Store.prototype.readFragment = function readFragment$1(e2, t2, i2) {
  return function readFragment(e3, t3, r2, i3) {
    var n2 = getFragments(t3);
    var a2 = Object.keys(n2);
    var o2 = n2[a2[0]];
    if (!o2) {
      return null;
    }
    var s2 = getFragmentTypeName(o2);
    if ("string" != typeof r2 && !r2.__typename) {
      r2.__typename = s2;
    }
    var u2 = e3.keyOfEntity(r2);
    if (!u2) {
      return null;
    }
    var c2 = readSelection(makeContext(e3, i3 || {}, n2, s2, u2), u2, getSelectionSet(o2), makeData()) || null;
    return c2;
  }(this, formatDocument(e2), t2, i2);
};
Store.prototype.writeFragment = function writeFragment$1(e2, t2, i2) {
  !function writeFragment(e3, t3, r2, i3) {
    var n2 = getFragments(t3);
    var a2 = n2[Object.keys(n2)[0]];
    if (!a2) {
      return void 0;
    }
    var o2 = getFragmentTypeName(a2);
    var s2 = _extends({}, {
      __typename: o2
    }, r2);
    var u2 = e3.keyOfEntity(s2);
    if (!u2) {
      return void 0;
    }
    writeSelection(makeContext(e3, i3 || {}, n2, o2, u2, void 0), u2, getSelectionSet(a2), s2);
  }(this, formatDocument(e2), t2, i2);
};
Store.prototype.link = function link(e2, t2, r2, i2) {
  var n2 = void 0 !== i2 ? r2 : null;
  var link2 = void 0 !== i2 ? i2 : r2;
  var a2 = ensureLink(this, e2);
  if ("string" == typeof a2) {
    writeLink(a2, keyOfField(t2, n2), ensureLink(this, link2));
  }
};
function query(e2, t2, r2, i2, n2) {
  initDataState("read", e2.data, n2);
  var a2 = read$2(e2, t2, r2, i2);
  clearDataState();
  return a2;
}
function read$2(e2, t2, r2, i2) {
  var n2 = getMainOperation(t2.query);
  var a2 = e2.rootFields[n2.operation];
  var o2 = getSelectionSet(n2);
  var s2 = makeContext(e2, normalizeVariables(n2, t2.variables), getFragments(t2.query), a2, a2, false, i2);
  if (!r2) {
    r2 = makeData();
  }
  var u2 = a2 !== s2.store.rootFields.query ? readRoot(s2, a2, o2, r2) : readSelection(s2, a2, o2, r2);
  return {
    dependencies: getCurrentDependencies(),
    partial: s2.partial || !u2,
    data: u2 || null
  };
}
function readRoot(e2, t2, r2, i2) {
  if ("string" != typeof (e2.store.rootNames[t2] ? t2 : i2.__typename)) {
    return i2;
  }
  var n2 = makeSelectionIterator(t2, t2, r2, e2);
  var a2;
  var o2 = false;
  var s2 = makeData(i2);
  while (a2 = n2()) {
    var u2 = getFieldAlias(a2);
    var c2 = i2[u2];
    e2.__internal.path.push(u2);
    var l2 = void 0;
    if (a2.selectionSet && null !== c2) {
      l2 = readRootField(e2, getSelectionSet(a2), ensureData(c2));
    } else {
      l2 = c2;
    }
    o2 = o2 || l2 !== c2;
    if (void 0 !== l2) {
      s2[u2] = l2;
    }
    e2.__internal.path.pop();
  }
  return o2 ? s2 : i2;
}
function readRootField(e2, t2, r2) {
  if (Array.isArray(r2)) {
    var i2 = new Array(r2.length);
    var n2 = false;
    for (var a2 = 0, o2 = r2.length; a2 < o2; a2++) {
      e2.__internal.path.push(a2);
      i2[a2] = readRootField(e2, t2, r2[a2]);
      n2 = n2 || i2[a2] !== r2[a2];
      e2.__internal.path.pop();
    }
    return n2 ? i2 : r2;
  } else if (null === r2) {
    return null;
  }
  var s2 = e2.store.keyOfEntity(r2);
  if (null !== s2) {
    return readSelection(e2, s2, t2, r2) || null;
  } else {
    return readRoot(e2, r2.__typename, t2, r2);
  }
}
function readSelection(e2, t2, r2, i2, n2) {
  var a2 = e2.store;
  var o2 = t2 === a2.rootFields.query;
  var s2 = n2 && a2.keyOfEntity(n2) || t2;
  var u2 = !o2 ? readRecord(s2, "__typename") || n2 && n2.__typename : t2;
  if ("string" != typeof u2) {
    return;
  } else if (n2 && u2 !== n2.__typename) {
    return;
  }
  var c2 = makeSelectionIterator(u2, s2, r2, e2);
  var l2 = false;
  var d2 = false;
  var f2 = u2 !== i2.__typename;
  var p2;
  var v2 = makeData(i2);
  while (void 0 !== (p2 = c2())) {
    var y2 = getName(p2);
    var m2 = getFieldArguments(p2, e2.variables);
    var h2 = getFieldAlias(p2);
    var g2 = keyOfField(y2, m2);
    var N2 = joinKeys(s2, g2);
    var k2 = readRecord(s2, g2);
    var O2 = n2 ? n2[y2] : void 0;
    var _2 = a2.resolvers[u2];
    e2.__internal.path.push(h2);
    var E2 = void 0;
    if ("__typename" === y2) {
      E2 = u2;
    } else if (void 0 !== O2 && void 0 === p2.selectionSet) {
      E2 = O2;
    } else if ("read" === getCurrentOperation() && _2 && "function" == typeof _2[y2]) {
      updateContext(e2, v2, u2, s2, N2, y2);
      if (void 0 !== k2) {
        v2[h2] = k2;
      }
      E2 = _2[y2](v2, m2 || {}, a2, e2);
      if (p2.selectionSet) {
        E2 = resolveResolverResult(e2, u2, y2, N2, getSelectionSet(p2), void 0 !== v2[h2] ? v2[h2] : i2[h2], E2, ownsData(i2));
      }
      if (a2.schema && null === E2 && !isFieldNullable(a2.schema, u2, y2)) {
        return;
      }
    } else if (!p2.selectionSet) {
      E2 = k2;
    } else if (void 0 !== O2) {
      E2 = resolveResolverResult(e2, u2, y2, N2, getSelectionSet(p2), void 0 !== v2[h2] ? v2[h2] : i2[h2], O2, ownsData(i2));
    } else {
      var b2 = readLink(s2, g2);
      if (void 0 !== b2) {
        E2 = resolveLink(e2, b2, u2, y2, getSelectionSet(p2), void 0 !== v2[h2] ? v2[h2] : i2[h2], ownsData(i2));
      } else if ("object" == typeof k2 && null !== k2) {
        E2 = k2;
      }
    }
    if (void 0 === E2 && x.current) {
      l2 = true;
    } else if (void 0 === E2 && (a2.schema && isFieldNullable(a2.schema, u2, y2) || getFieldError(e2))) {
      d2 = true;
      E2 = null;
    } else if (void 0 === E2) {
      e2.__internal.path.pop();
      return;
    } else {
      l2 = l2 || "__typename" !== y2;
    }
    e2.__internal.path.pop();
    f2 = f2 || E2 !== i2[h2];
    if (void 0 !== E2) {
      v2[h2] = E2;
    }
  }
  e2.partial = e2.partial || d2;
  return o2 && d2 && !l2 ? void 0 : f2 ? v2 : i2;
}
function resolveResolverResult(e2, t2, r2, i2, n2, a2, o2, s2) {
  if (Array.isArray(o2)) {
    var u2 = e2.store;
    var c2 = u2.schema ? isListNullable(u2.schema, t2, r2) : false;
    var l2 = new Array(o2.length);
    var d2 = !Array.isArray(a2) || o2.length !== a2.length;
    for (var f2 = 0, p2 = o2.length; f2 < p2; f2++) {
      e2.__internal.path.push(f2);
      var v2 = resolveResolverResult(e2, t2, r2, joinKeys(i2, "" + f2), n2, null != a2 ? a2[f2] : void 0, o2[f2], s2);
      e2.__internal.path.pop();
      if (void 0 === v2 && !c2) {
        return;
      } else {
        e2.partial = e2.partial || void 0 === v2 && c2;
        l2[f2] = null != v2 ? v2 : null;
        d2 = d2 || l2[f2] !== a2[f2];
      }
    }
    return d2 ? l2 : a2;
  } else if (null == o2) {
    return o2;
  } else if (s2 && null === a2) {
    return null;
  } else if (function isDataOrKey(e3) {
    return "string" == typeof e3 || "object" == typeof e3 && "string" == typeof e3.__typename;
  }(o2)) {
    var y2 = a2 || makeData();
    return "string" == typeof o2 ? readSelection(e2, o2, n2, y2) : readSelection(e2, i2, n2, y2, o2);
  } else {
    return;
  }
}
function resolveLink(e2, t2, r2, i2, n2, a2, o2) {
  if (Array.isArray(t2)) {
    var s2 = e2.store;
    var u2 = s2.schema ? isListNullable(s2.schema, r2, i2) : false;
    var c2 = new Array(t2.length);
    var l2 = !Array.isArray(a2) || c2.length !== a2.length;
    for (var d2 = 0, f2 = t2.length; d2 < f2; d2++) {
      e2.__internal.path.push(d2);
      var p2 = resolveLink(e2, t2[d2], r2, i2, n2, null != a2 ? a2[d2] : void 0, o2);
      e2.__internal.path.pop();
      if (void 0 === p2 && !u2) {
        return;
      } else {
        e2.partial = e2.partial || void 0 === p2 && u2;
        c2[d2] = p2 || null;
        l2 = l2 || c2[d2] !== a2[d2];
      }
    }
    return l2 ? c2 : a2;
  } else if (null === t2 || null === a2 && o2) {
    return null;
  }
  return readSelection(e2, t2, n2, a2 || makeData());
}
function addCacheOutcome(e2, t2) {
  return makeOperation(e2.kind, e2, _extends({}, e2.context, {
    meta: _extends({}, e2.context.meta, {
      cacheOutcome: t2
    })
  }));
}
function toRequestPolicy(e2, t2) {
  return makeOperation(e2.kind, e2, _extends({}, e2.context, {
    requestPolicy: t2
  }));
}
function cacheExchange(e2) {
  return function(t2) {
    var v2 = t2.forward;
    var y2 = t2.client;
    t2.dispatchDebug;
    var h2 = new Store(e2);
    var g2;
    if (e2 && e2.storage) {
      g2 = e2.storage.readData().then(function(t3) {
        !function hydrateData(e3, t4, r2) {
          initDataState("write", e3, null);
          for (var i2 in r2) {
            var n2 = r2[i2];
            if (void 0 !== n2) {
              var a2 = deserializeKeyInfo(i2);
              var o2 = a2.entityKey;
              var s2 = a2.fieldKey;
              if (":" === n2[0]) {
                writeLink(o2, s2, JSON.parse(n2.slice(1)));
              } else {
                writeRecord(o2, s2, JSON.parse(n2));
              }
            }
          }
          clearDataState();
          e3.storage = t4;
        }(h2.data, e2.storage, t3);
      });
    }
    var N2 = /* @__PURE__ */ new Map();
    var k2 = [];
    var O2 = /* @__PURE__ */ new Map();
    var _2 = /* @__PURE__ */ new Map();
    var E2 = makeDict();
    var b2 = /* @__PURE__ */ new Set();
    var D2 = makeDict();
    function isBlockedByOptimisticUpdate(e3) {
      for (var t3 in e3) {
        if (E2[t3]) {
          return true;
        }
      }
      return false;
    }
    function collectPendingOperations(e3, t3) {
      if (t3) {
        for (var r2 in t3) {
          var i2 = D2[r2];
          if (i2) {
            D2[r2] = [];
            for (var n2 = 0, a2 = i2.length; n2 < a2; n2++) {
              e3.add(i2[n2]);
            }
          }
        }
      }
    }
    function executePendingOperations(e3, t3) {
      t3.forEach(function(t4) {
        if (t4 !== e3.key) {
          var r2 = O2.get(t4);
          if (r2) {
            O2.delete(t4);
            var i2 = "cache-first";
            if (b2.has(t4)) {
              b2.delete(t4);
              i2 = "cache-and-network";
            }
            y2.reexecuteOperation(toRequestPolicy(r2, i2));
          }
        }
      });
    }
    function prepareForwardedOperation(e3) {
      if ("query" === e3.kind) {
        reserveLayer(h2.data, e3.key);
      } else if ("teardown" === e3.kind) {
        O2.delete(e3.key);
        _2.delete(e3.key);
        noopDataState(h2.data, e3.key);
      } else if ("mutation" === e3.kind && "network-only" !== e3.context.requestPolicy) {
        var t3 = function writeOptimistic(e4, t4, r2) {
          initDataState("write", e4.data, r2, true);
          var i2 = startWrite(e4, t4, {}, void 0, true);
          clearDataState();
          return i2;
        }(h2, e3, e3.key).dependencies;
        if (!function isDictEmpty(e4) {
          for (var t4 in e4) {
            return false;
          }
          return true;
        }(t3)) {
          for (var n2 in t3) {
            E2[n2] = true;
          }
          N2.set(e3.key, t3);
          var a2 = /* @__PURE__ */ new Set();
          collectPendingOperations(a2, t3);
          executePendingOperations(e3, a2);
        }
      }
      return makeOperation(e3.kind, {
        key: e3.key,
        query: formatDocument(e3.query),
        variables: e3.variables ? filterVariables(getMainOperation(e3.query), e3.variables) : e3.variables
      }, e3.context);
    }
    function updateDependencies2(e3, t3) {
      for (var r2 in t3) {
        (D2[r2] || (D2[r2] = [])).push(e3.key);
        O2.set(e3.key, e3);
      }
    }
    function operationResultFromCache(e3) {
      var t3 = query(h2, e3, _2.get(e3.key));
      var r2 = t3.data ? !t3.partial ? "hit" : "partial" : "miss";
      _2.set(e3.key, t3.data);
      updateDependencies2(e3, t3.dependencies);
      return {
        outcome: r2,
        operation: e3,
        data: t3.data,
        dependencies: t3.dependencies
      };
    }
    function updateCacheWithResult(e3, t3) {
      var r2 = e3.operation;
      var i2 = e3.error;
      var n2 = e3.extensions;
      var a2 = r2.key;
      if ("mutation" === r2.kind) {
        collectPendingOperations(t3, N2.get(a2));
        N2.delete(a2);
      }
      reserveLayer(h2.data, r2.key, e3.hasNext);
      var o2;
      var s2 = e3.data;
      if (s2) {
        collectPendingOperations(t3, write$1(h2, r2, s2, e3.error, a2).dependencies);
        var u2 = query(h2, r2, "query" === r2.kind ? _2.get(r2.key) || s2 : s2, e3.error, a2);
        s2 = u2.data;
        if ("query" === r2.kind) {
          collectPendingOperations(t3, o2 = u2.dependencies);
          _2.set(r2.key, e3.data);
        }
      } else {
        noopDataState(h2.data, r2.key);
      }
      if (o2) {
        updateDependencies2(e3.operation, o2);
      }
      return {
        data: s2,
        error: i2,
        extensions: n2,
        operation: r2
      };
    }
    return function(e3) {
      var t3 = share$1(e3);
      var r2 = g2 ? share$1(merge$1([D$1(p$1)(buffer$1(fromPromise$1(g2))(t3)), skipUntil$1(fromPromise$1(g2))(t3)])) : t3;
      var i2 = share$1(map$1(operationResultFromCache)(filter$1(function(e4) {
        return "query" === e4.kind && "network-only" !== e4.context.requestPolicy;
      })(r2)));
      var O3 = filter$1(function(e4) {
        return "query" !== e4.kind || "network-only" === e4.context.requestPolicy;
      })(r2);
      var _3 = map$1(function(e4) {
        return addCacheOutcome(e4.operation, "miss");
      })(filter$1(function(e4) {
        return "miss" === e4.outcome && "cache-only" !== e4.operation.context.requestPolicy && !isBlockedByOptimisticUpdate(e4.dependencies);
      })(i2));
      var D3 = map$1(function(e4) {
        var t4 = e4.operation;
        var r3 = e4.outcome;
        var i3 = e4.dependencies;
        var n2 = {
          operation: addCacheOutcome(t4, r3),
          data: e4.data,
          error: e4.error,
          extensions: e4.extensions
        };
        if ("cache-and-network" === t4.context.requestPolicy || "cache-first" === t4.context.requestPolicy && "partial" === r3) {
          n2.stale = true;
          if (!isBlockedByOptimisticUpdate(i3)) {
            y2.reexecuteOperation(toRequestPolicy(t4, "network-only"));
          } else if ("cache-and-network" === t4.context.requestPolicy) {
            b2.add(t4.key);
          }
        }
        return n2;
      })(filter$1(function(e4) {
        return "miss" !== e4.outcome || "cache-only" === e4.operation.context.requestPolicy;
      })(i2));
      var w2 = share$1(v2(map$1(prepareForwardedOperation)(merge$1([O3, _3]))));
      var F2 = map$1(function(e4) {
        var t4 = /* @__PURE__ */ new Set();
        var r3 = updateCacheWithResult(e4, t4);
        executePendingOperations(e4.operation, t4);
        return r3;
      })(filter$1(function(e4) {
        return !N2.has(e4.operation.key);
      })(w2));
      var S2 = D$1(function(e4) {
        if (k2.push(e4) < N2.size) {
          return u$1;
        }
        for (var t4 = 0; t4 < k2.length; t4++) {
          reserveLayer(h2.data, k2[t4].operation.key);
        }
        for (var r3 in E2) {
          delete E2[r3];
        }
        var i3 = [];
        var n2 = /* @__PURE__ */ new Set();
        var a2;
        while (a2 = k2.shift()) {
          i3.push(updateCacheWithResult(a2, n2));
        }
        executePendingOperations(e4.operation, n2);
        return p$1(i3);
      })(filter$1(function(e4) {
        return N2.has(e4.operation.key);
      })(w2));
      return merge$1([F2, S2, D3]);
    };
  };
}
var a = {
  __typename: "PageInfo",
  endCursor: null,
  startCursor: null,
  hasNextPage: false,
  hasPreviousPage: false
};
function ensureKey(e) {
  return "string" == typeof e ? e : null;
}
function concatEdges(e, r2, a2) {
  var n = /* @__PURE__ */ new Set();
  for (var t2 = 0, o2 = r2.length; t2 < o2; t2++) {
    var s2 = e.resolve(r2[t2], "node");
    if ("string" == typeof s2) {
      n.add(s2);
    }
  }
  var i = r2.slice();
  for (var f2 = 0, u2 = a2.length; f2 < u2; f2++) {
    var v = a2[f2];
    var l2 = e.resolve(v, "node");
    if ("string" == typeof l2 && !n.has(l2)) {
      n.add(l2);
      i.push(v);
    }
  }
  return i;
}
function concatNodes(e, r2) {
  var a2 = /* @__PURE__ */ new Set();
  for (var n = 0, t2 = e.length; n < t2; n++) {
    var o2 = e[n];
    if ("string" == typeof o2) {
      a2.add(o2);
    }
  }
  var s2 = e.slice();
  for (var i = 0, f2 = r2.length; i < f2; i++) {
    var u2 = r2[i];
    if ("string" == typeof u2 && !a2.has(u2)) {
      a2.add(u2);
      s2.push(u2);
    }
  }
  return s2;
}
function compareArgs(e, a2) {
  for (var n in a2) {
    if ("first" === n || "last" === n || "after" === n || "before" === n) {
      continue;
    } else if (!(n in e)) {
      return false;
    }
    var t2 = e[n];
    var o2 = a2[n];
    if (typeof t2 != typeof o2 || "object" != typeof t2 ? t2 !== o2 : stringifyVariables(t2) !== stringifyVariables(o2)) {
      return false;
    }
  }
  for (var s2 in e) {
    if ("first" === s2 || "last" === s2 || "after" === s2 || "before" === s2) {
      continue;
    }
    if (!(s2 in a2)) {
      return false;
    }
  }
  return true;
}
function getPage(e, r2, n) {
  var t2 = ensureKey(e.resolve(r2, n));
  if (!t2) {
    return null;
  }
  var o2 = e.resolve(t2, "__typename");
  var s2 = e.resolve(t2, "edges") || [];
  var i = e.resolve(t2, "nodes") || [];
  if ("string" != typeof o2) {
    return null;
  }
  var f2 = {
    __typename: o2,
    edges: s2,
    nodes: i,
    pageInfo: a
  };
  var u2 = e.resolve(t2, "pageInfo");
  if ("string" == typeof u2) {
    var v = ensureKey(e.resolve(u2, "__typename"));
    var l2 = ensureKey(e.resolve(u2, "endCursor"));
    var g = ensureKey(e.resolve(u2, "startCursor"));
    var c2 = e.resolve(u2, "hasNextPage");
    var d2 = e.resolve(u2, "hasPreviousPage");
    var p2 = f2.pageInfo = {
      __typename: "string" == typeof v ? v : "PageInfo",
      hasNextPage: "boolean" == typeof c2 ? c2 : !!l2,
      hasPreviousPage: "boolean" == typeof d2 ? d2 : !!g,
      endCursor: l2,
      startCursor: g
    };
    if (null === p2.endCursor) {
      var y2 = s2[s2.length - 1];
      if (y2) {
        var m2 = e.resolve(y2, "cursor");
        p2.endCursor = ensureKey(m2);
      }
    }
    if (null === p2.startCursor) {
      var h2 = s2[0];
      if (h2) {
        var P = e.resolve(h2, "cursor");
        p2.startCursor = ensureKey(P);
      }
    }
  }
  return f2;
}
function relayPagination(r2) {
  if (void 0 === r2) {
    r2 = {};
  }
  var n = r2.mergeMode || "inwards";
  return function(r3, t2, o2, s2) {
    var i = s2.parentKey;
    var f2 = s2.fieldName;
    var u2 = o2.inspectFields(i).filter(function(e) {
      return e.fieldName === f2;
    });
    var v = u2.length;
    if (0 === v) {
      return;
    }
    var l2 = null;
    var g = [];
    var c2 = [];
    var d2 = [];
    var p2 = [];
    var y2 = _extends({}, a);
    for (var m2 = 0; m2 < v; m2++) {
      var h2 = u2[m2];
      var P = h2.fieldKey;
      var _2 = h2.arguments;
      if (null === _2 || !compareArgs(t2, _2)) {
        continue;
      }
      var N2 = getPage(o2, i, P);
      if (null === N2) {
        continue;
      }
      if (!N2.nodes.length && !N2.edges.length && l2) {
        continue;
      }
      if ("inwards" === n && "number" == typeof _2.last && "number" == typeof _2.first) {
        var C2 = N2.edges.slice(0, _2.first + 1);
        var I = N2.edges.slice(-_2.last);
        var K2 = N2.nodes.slice(0, _2.first + 1);
        var b2 = N2.nodes.slice(-_2.last);
        g = concatEdges(o2, g, C2);
        c2 = concatEdges(o2, I, c2);
        d2 = concatNodes(d2, K2);
        p2 = concatNodes(b2, p2);
        y2 = N2.pageInfo;
      } else if (_2.after) {
        g = concatEdges(o2, g, N2.edges);
        d2 = concatNodes(d2, N2.nodes);
        y2.endCursor = N2.pageInfo.endCursor;
        y2.hasNextPage = N2.pageInfo.hasNextPage;
      } else if (_2.before) {
        c2 = concatEdges(o2, N2.edges, c2);
        p2 = concatNodes(N2.nodes, p2);
        y2.startCursor = N2.pageInfo.startCursor;
        y2.hasPreviousPage = N2.pageInfo.hasPreviousPage;
      } else if ("number" == typeof _2.last) {
        c2 = concatEdges(o2, N2.edges, c2);
        p2 = concatNodes(N2.nodes, p2);
        y2 = N2.pageInfo;
      } else {
        g = concatEdges(o2, g, N2.edges);
        d2 = concatNodes(d2, N2.nodes);
        y2 = N2.pageInfo;
      }
      if (N2.pageInfo.__typename !== y2.__typename) {
        y2.__typename = N2.pageInfo.__typename;
      }
      if (l2 !== N2.__typename) {
        l2 = N2.__typename;
      }
    }
    if ("string" != typeof l2) {
      return;
    }
    if (!!!ensureKey(o2.resolve(i, f2, t2))) {
      if (!s2.store.schema) {
        return;
      } else {
        s2.partial = true;
      }
    }
    return {
      __typename: l2,
      edges: "inwards" === n ? concatEdges(o2, g, c2) : concatEdges(o2, c2, g),
      nodes: "inwards" === n ? concatNodes(d2, p2) : concatNodes(p2, d2),
      pageInfo: {
        __typename: y2.__typename,
        endCursor: y2.endCursor,
        startCursor: y2.startCursor,
        hasNextPage: y2.hasNextPage,
        hasPreviousPage: y2.hasPreviousPage
      }
    };
  };
}
const urqlCacheKeys = {
  keys: {
    DevState: (data) => data.__typename,
    Wizard: (data) => data.__typename,
    Migration: (data) => data.__typename,
    CloudRunCommitInfo: () => null,
    GitInfo: () => null,
    MigrationFile: () => null,
    MigrationFilePart: () => null,
    CodeFrame: () => null,
    ProjectPreferences: (data) => data.__typename,
    VersionData: () => null,
    ScaffoldedFile: () => null,
    SpecDataAggregate: () => null,
    LocalSettings: (data) => data.__typename,
    LocalSettingsPreferences: () => null,
    AuthState: () => null,
    CloudProjectNotFound: (data) => data.__typename,
    CloudProjectSpecNotFound: (data) => null,
    CloudProjectUnauthorized: (data) => data.__typename,
    CloudLatestRunUpdateSpecData: (data) => null,
    CloudProjectSpecFlakyStatus: (data) => null,
    CloudPollingIntervals: (data) => null,
    GeneratedSpecError: () => null,
    GenerateSpecResponse: (data) => data.__typename,
    CloudFeatureNotEnabled: () => null,
    UsageLimitExceeded: () => null
  },
  resolvers: {
    CloudProject: {
      runs: relayPagination({ mergeMode: "outwards" })
    }
  }
};
const urqlSchema = {
  "__schema": {
    "queryType": {
      "name": "Query"
    },
    "mutationType": {
      "name": "Mutation"
    },
    "subscriptionType": {
      "name": "Subscription"
    },
    "types": [
      {
        "kind": "OBJECT",
        "name": "AuthState",
        "fields": [
          {
            "name": "browserOpened",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "message",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "Browser",
        "fields": [
          {
            "name": "channel",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "disabled",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "displayName",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "family",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isFocusSupported",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isSelected",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isVersionSupported",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "majorVersion",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "path",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "version",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "warning",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CachedUser",
        "fields": [
          {
            "name": "email",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "fullName",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudBrowserInfo",
        "fields": [
          {
            "name": "formattedName",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "formattedNameWithVersion",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "formattedVersion",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "unformattedName",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "unformattedVersion",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudCiBuildInfo",
        "fields": [
          {
            "name": "ciBuildNumber",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "ciBuildNumberFormatted",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "formattedProvider",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "provider",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "url",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudFeatureNotEnabled",
        "fields": [
          {
            "name": "message",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudLatestRunUpdateSpecData",
        "fields": [
          {
            "name": "mostRecentUpdate",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "pollingInterval",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudOperatingSystem",
        "fields": [
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "nameWithVersion",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "platform",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "unformattedName",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "version",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudOrganization",
        "fields": [
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "projects",
            "type": {
              "kind": "OBJECT",
              "name": "CloudProjectConnection",
              "ofType": null
            },
            "args": [
              {
                "name": "after",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "before",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "first",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "last",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudOrganizationConnection",
        "fields": [
          {
            "name": "edges",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "CloudOrganizationEdge",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "nodes",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "CloudOrganization",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "pageInfo",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "PageInfo",
                "ofType": null
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudOrganizationEdge",
        "fields": [
          {
            "name": "cursor",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "node",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "CloudOrganization",
                "ofType": null
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudPollingIntervals",
        "fields": [
          {
            "name": "runByNumber",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "runsByCommitShas",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudProject",
        "fields": [
          {
            "name": "cloudProjectSettingsUrl",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "cloudProjectUrl",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "latestRun",
            "type": {
              "kind": "OBJECT",
              "name": "CloudRun",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "organization",
            "type": {
              "kind": "OBJECT",
              "name": "CloudOrganization",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "recordKeys",
            "type": {
              "kind": "LIST",
              "ofType": {
                "kind": "NON_NULL",
                "ofType": {
                  "kind": "OBJECT",
                  "name": "CloudRecordKey",
                  "ofType": null
                }
              }
            },
            "args": []
          },
          {
            "name": "runByNumber",
            "type": {
              "kind": "OBJECT",
              "name": "CloudRun",
              "ofType": null
            },
            "args": [
              {
                "name": "runNumber",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "runs",
            "type": {
              "kind": "OBJECT",
              "name": "CloudRunConnection",
              "ofType": null
            },
            "args": [
              {
                "name": "after",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "before",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "cypressVersion",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "first",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "last",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "status",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          },
          {
            "name": "runsByCommitShas",
            "type": {
              "kind": "LIST",
              "ofType": {
                "kind": "OBJECT",
                "name": "CloudRun",
                "ofType": null
              }
            },
            "args": [
              {
                "name": "commitShas",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "LIST",
                    "ofType": {
                      "kind": "NON_NULL",
                      "ofType": {
                        "kind": "SCALAR",
                        "name": "Any"
                      }
                    }
                  }
                }
              },
              {
                "name": "runLimit",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "slug",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudProjectConnection",
        "fields": [
          {
            "name": "edges",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "CloudProjectEdge",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "nodes",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "CloudProject",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "pageInfo",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "PageInfo",
                "ofType": null
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudProjectEdge",
        "fields": [
          {
            "name": "cursor",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "node",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "CloudProject",
                "ofType": null
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudProjectNotFound",
        "fields": [
          {
            "name": "message",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "UNION",
        "name": "CloudProjectResult",
        "possibleTypes": [
          {
            "kind": "OBJECT",
            "name": "CloudProject"
          },
          {
            "kind": "OBJECT",
            "name": "CloudProjectNotFound"
          },
          {
            "kind": "OBJECT",
            "name": "CloudProjectUnauthorized"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudProjectSpec",
        "fields": [
          {
            "name": "averageDuration",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "fromBranch",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "averageDurationForRunIds",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "cloudRunIds",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "LIST",
                    "ofType": {
                      "kind": "NON_NULL",
                      "ofType": {
                        "kind": "SCALAR",
                        "name": "Any"
                      }
                    }
                  }
                }
              }
            ]
          },
          {
            "name": "flakyStatus",
            "type": {
              "kind": "UNION",
              "name": "CloudProjectSpecFlakyResult",
              "ofType": null
            },
            "args": [
              {
                "name": "flakyRunsWindow",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "fromBranch",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "flakyStatusForRunIds",
            "type": {
              "kind": "UNION",
              "name": "CloudProjectSpecFlakyResult",
              "ofType": null
            },
            "args": [
              {
                "name": "cloudRunIds",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "LIST",
                    "ofType": {
                      "kind": "NON_NULL",
                      "ofType": {
                        "kind": "SCALAR",
                        "name": "Any"
                      }
                    }
                  }
                }
              }
            ]
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isConsideredFlaky",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "fromBranch",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "isConsideredFlakyForRunIds",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "cloudRunIds",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "LIST",
                    "ofType": {
                      "kind": "NON_NULL",
                      "ofType": {
                        "kind": "SCALAR",
                        "name": "Any"
                      }
                    }
                  }
                }
              }
            ]
          },
          {
            "name": "retrievedAt",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "specPath",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "specRuns",
            "type": {
              "kind": "OBJECT",
              "name": "CloudSpecRunConnection",
              "ofType": null
            },
            "args": [
              {
                "name": "after",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "before",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "first",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "fromBranch",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "last",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          },
          {
            "name": "specRunsForRunIds",
            "type": {
              "kind": "LIST",
              "ofType": {
                "kind": "OBJECT",
                "name": "CloudSpecRun",
                "ofType": null
              }
            },
            "args": [
              {
                "name": "cloudRunIds",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "LIST",
                    "ofType": {
                      "kind": "NON_NULL",
                      "ofType": {
                        "kind": "SCALAR",
                        "name": "Any"
                      }
                    }
                  }
                }
              }
            ]
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "UNION",
        "name": "CloudProjectSpecFlakyResult",
        "possibleTypes": [
          {
            "kind": "OBJECT",
            "name": "CloudFeatureNotEnabled"
          },
          {
            "kind": "OBJECT",
            "name": "CloudProjectSpecFlakyStatus"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudProjectSpecFlakyStatus",
        "fields": [
          {
            "name": "dashboardUrl",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "flakyRuns",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "flakyRunsWindow",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "lastFlaky",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "lastFlakyRunCommitSha",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "lastFlakyRunNumber",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "severity",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudProjectSpecNotFound",
        "fields": [
          {
            "name": "message",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "retrievedAt",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "UNION",
        "name": "CloudProjectSpecResult",
        "possibleTypes": [
          {
            "kind": "OBJECT",
            "name": "CloudProjectSpec"
          },
          {
            "kind": "OBJECT",
            "name": "CloudProjectSpecNotFound"
          },
          {
            "kind": "OBJECT",
            "name": "CloudProjectUnauthorized"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudProjectUnauthorized",
        "fields": [
          {
            "name": "hasRequestedAccess",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "message",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudRecordKey",
        "fields": [
          {
            "name": "createdAt",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "key",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "lastUsedAt",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudRun",
        "fields": [
          {
            "name": "cancelOnFailure",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "cancelledAt",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "cancelledBy",
            "type": {
              "kind": "OBJECT",
              "name": "CloudUser",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "ci",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "CloudCiBuildInfo",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "commitInfo",
            "type": {
              "kind": "OBJECT",
              "name": "CloudRunCommitInfo",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "completedAt",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "completedInstanceCount",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "createdAt",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "errors",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "groups",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "CloudRunGroup",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isHidden",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "overLimitActionType",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "overLimitActionUrl",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "reasonsRunIsHidden",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "UNION",
                  "name": "CloudRunHidingReason",
                  "ofType": null
                }
              }
            },
            "args": []
          },
          {
            "name": "runNumber",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "scheduledToCompleteAt",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "specs",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "CloudSpecRun",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "status",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "tags",
            "type": {
              "kind": "LIST",
              "ofType": {
                "kind": "OBJECT",
                "name": "CloudRunTag",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "testsForReview",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "CloudTestResult",
                    "ofType": null
                  }
                }
              }
            },
            "args": [
              {
                "name": "limit",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "totalDuration",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalFailed",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalFlakyTests",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalInstanceCount",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalPassed",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalPending",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalRunning",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalSkipped",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalTests",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "url",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudRunCommitInfo",
        "fields": [
          {
            "name": "authorAvatar",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "authorEmail",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "authorName",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "branch",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "branchUrl",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "message",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "truncate",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          },
          {
            "name": "sha",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "summary",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "url",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudRunConnection",
        "fields": [
          {
            "name": "edges",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "CloudRunEdge",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "nodes",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "CloudRun",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "pageInfo",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "PageInfo",
                "ofType": null
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudRunEdge",
        "fields": [
          {
            "name": "cursor",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "node",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "CloudRun",
                "ofType": null
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudRunGroup",
        "fields": [
          {
            "name": "browser",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "CloudBrowserInfo",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "completedAt",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "createdAt",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "duration",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "groupName",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "os",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "CloudOperatingSystem",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "status",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "testingType",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "totalFailures",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "totalPasses",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "totalPending",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "totalSkipped",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "UNION",
        "name": "CloudRunHidingReason",
        "possibleTypes": [
          {
            "kind": "OBJECT",
            "name": "DataRetentionLimitExceeded"
          },
          {
            "kind": "OBJECT",
            "name": "UsageLimitExceeded"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudRunInstance",
        "fields": [
          {
            "name": "groupId",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "hasReplay",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "hasScreenshots",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "hasStdout",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "hasVideo",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "replayUrl",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "screenshotsUrl",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "status",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "stdoutUrl",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalFailed",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalPassed",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalPending",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalRunning",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalSkipped",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "videoUrl",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudRunTag",
        "fields": [
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudSpecRun",
        "fields": [
          {
            "name": "basename",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "completedAt",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "createdAt",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "extension",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "groupCount",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "groupIds",
            "type": {
              "kind": "LIST",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "path",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "runNumber",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "shortPath",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "specDuration",
            "type": {
              "kind": "OBJECT",
              "name": "SpecDataAggregate",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "status",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "testsFailed",
            "type": {
              "kind": "OBJECT",
              "name": "SpecDataAggregate",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "testsPassed",
            "type": {
              "kind": "OBJECT",
              "name": "SpecDataAggregate",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "testsPending",
            "type": {
              "kind": "OBJECT",
              "name": "SpecDataAggregate",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "testsSkipped",
            "type": {
              "kind": "OBJECT",
              "name": "SpecDataAggregate",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "url",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudSpecRunConnection",
        "fields": [
          {
            "name": "edges",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "CloudSpecRunEdge",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "nodes",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "CloudSpecRun",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "pageInfo",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "PageInfo",
                "ofType": null
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudSpecRunEdge",
        "fields": [
          {
            "name": "cursor",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "node",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "CloudSpecRun",
                "ofType": null
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CloudTestResult",
        "fields": [
          {
            "name": "duration",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "instance",
            "type": {
              "kind": "OBJECT",
              "name": "CloudRunInstance",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "isFlaky",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "specId",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "state",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "testUrl",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "thumbprint",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "title",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": [
              {
                "name": "depth",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "titleParts",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CloudUser",
        "fields": [
          {
            "name": "cloudOrganizationsUrl",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "cloudProfileUrl",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "createCloudOrganizationUrl",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "email",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "fullName",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "organizations",
            "type": {
              "kind": "OBJECT",
              "name": "CloudOrganizationConnection",
              "ofType": null
            },
            "args": [
              {
                "name": "after",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "before",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "first",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "last",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          },
          {
            "name": "userIsViewer",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "CodeFrame",
        "fields": [
          {
            "name": "codeBlock",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "column",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "file",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "FileParts",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "line",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CodeGenGlobs",
        "fields": [
          {
            "name": "component",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "Cohort",
        "fields": [
          {
            "name": "cohort",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CommitInfo",
        "fields": [
          {
            "name": "message",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "sha",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "CurrentProject",
        "fields": [
          {
            "name": "activeBrowser",
            "type": {
              "kind": "OBJECT",
              "name": "Browser",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "branch",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "browserStatus",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "browsers",
            "type": {
              "kind": "LIST",
              "ofType": {
                "kind": "NON_NULL",
                "ofType": {
                  "kind": "OBJECT",
                  "name": "Browser",
                  "ofType": null
                }
              }
            },
            "args": []
          },
          {
            "name": "cloudProject",
            "type": {
              "kind": "UNION",
              "name": "CloudProjectResult",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "cloudProjectRemote",
            "type": {
              "kind": "OBJECT",
              "name": "RemoteFetchableCloudProjectResult",
              "ofType": null
            },
            "args": [
              {
                "name": "name",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "codeGenCandidates",
            "type": {
              "kind": "LIST",
              "ofType": {
                "kind": "OBJECT",
                "name": "FileParts",
                "ofType": null
              }
            },
            "args": [
              {
                "name": "glob",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "codeGenFramework",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "codeGenGlobs",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "CodeGenGlobs",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "config",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "configFile",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "configFileAbsolutePath",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "currentTestingType",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "defaultSpecFileName",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "fileExtensionToUse",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "hasNonExampleSpec",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "hasValidConfigFile",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isCTConfigured",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "isDefaultSpecPattern",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isE2EConfigured",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "isFullConfigReady",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "isLoadingConfigFile",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "isLoadingNodeEvents",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "isUsingTypeScript",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "needsLegacyConfigMigration",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "packageManager",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "preferences",
            "type": {
              "kind": "OBJECT",
              "name": "ProjectPreferences",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "projectId",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "projectRoot",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "savedState",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "serveConfig",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "specs",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "Spec",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "title",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          },
          {
            "kind": "INTERFACE",
            "name": "ProjectLike"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "DataRetentionLimitExceeded",
        "fields": [
          {
            "name": "dataRetentionDays",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "DevState",
        "fields": [
          {
            "name": "needsRelaunch",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "state",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "Editor",
        "fields": [
          {
            "name": "binary",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "ErrorWrapper",
        "fields": [
          {
            "name": "codeFrame",
            "type": {
              "kind": "OBJECT",
              "name": "CodeFrame",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "errorMessage",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "errorName",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "errorStack",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "errorType",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isUserCodeError",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "title",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "FileParts",
        "fields": [
          {
            "name": "absolute",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "baseName",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "column",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "contents",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "fileExtension",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "fileName",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "line",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "relative",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "GenerateSpecResponse",
        "fields": [
          {
            "name": "currentProject",
            "type": {
              "kind": "OBJECT",
              "name": "CurrentProject",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "generatedSpecResult",
            "type": {
              "kind": "UNION",
              "name": "GeneratedSpecResult",
              "ofType": null
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "GeneratedSpecError",
        "fields": [
          {
            "name": "erroredCodegenCandidate",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "fileName",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "UNION",
        "name": "GeneratedSpecResult",
        "possibleTypes": [
          {
            "kind": "OBJECT",
            "name": "GeneratedSpecError"
          },
          {
            "kind": "OBJECT",
            "name": "ScaffoldedFile"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "GitInfo",
        "fields": [
          {
            "name": "author",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "lastModifiedHumanReadable",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "lastModifiedTimestamp",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "shortHash",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "statusType",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "subject",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "GlobalProject",
        "fields": [
          {
            "name": "cloudProjectRemote",
            "type": {
              "kind": "OBJECT",
              "name": "RemoteFetchableCloudProjectResult",
              "ofType": null
            },
            "args": [
              {
                "name": "name",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "projectId",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "projectRoot",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "title",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          },
          {
            "kind": "INTERFACE",
            "name": "ProjectLike"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "LocalSettings",
        "fields": [
          {
            "name": "availableEditors",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "Editor",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "preferences",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "LocalSettingsPreferences",
                "ofType": null
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "LocalSettingsPreferences",
        "fields": [
          {
            "name": "autoScrollingEnabled",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "debugSlideshowComplete",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "desktopNotificationsEnabled",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "dismissNotificationBannerUntil",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "isSideNavigationOpen",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "isSpecsListOpen",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "majorVersionWelcomeDismissed",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "notifyWhenRunCompletes",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "notifyWhenRunStarts",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "notifyWhenRunStartsFailing",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "preferredEditorBinary",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "proxyBypass",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "proxyServer",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "reporterWidth",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "shouldLaunchBrowserFromOpenBrowser",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "specListWidth",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "wasBrowserSetInCLI",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "ManualMigration",
        "fields": [
          {
            "name": "completed",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "files",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "ManualMigrationFile",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "ManualMigrationFile",
        "fields": [
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "moved",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "relative",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "Migration",
        "fields": [
          {
            "name": "componentFolder",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "configAfterCode",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "configBeforeCode",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "configFileNameAfter",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "configFileNameBefore",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "filteredSteps",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "MigrationStep",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "hasComponentTesting",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "hasCustomComponentFolder",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "hasCustomComponentTestFiles",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "hasCustomIntegrationFolder",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "hasCustomIntegrationTestFiles",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "integrationFolder",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isUsingTypeScript",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "manualFiles",
            "type": {
              "kind": "OBJECT",
              "name": "ManualMigration",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "shouldMigratePreExtension",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "specFiles",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "MigrationFile",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "supportFiles",
            "type": {
              "kind": "OBJECT",
              "name": "MigrationFile",
              "ofType": null
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "MigrationFile",
        "fields": [
          {
            "name": "after",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "MigrationFileData",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "before",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "MigrationFileData",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "testingType",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "MigrationFileData",
        "fields": [
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "parts",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "MigrationFilePart",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "relative",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "MigrationFilePart",
        "fields": [
          {
            "name": "group",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "highlight",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "text",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "MigrationRegexp",
        "fields": [
          {
            "name": "afterComponent",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "afterE2E",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "beforeComponent",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "beforeE2E",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "MigrationStep",
        "fields": [
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "index",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isCompleted",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isCurrentStep",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "Mutation",
        "fields": [
          {
            "name": "_clearCloudCache",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "_cloudCacheInvalidate",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "args",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          },
          {
            "name": "_showUrqlCache",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "addProject",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": [
              {
                "name": "open",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "path",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          },
          {
            "name": "clearCurrentProject",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "clearCurrentTestingType",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "closeBrowser",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "cloudProjectCreate",
            "type": {
              "kind": "OBJECT",
              "name": "CloudProject",
              "ofType": null
            },
            "args": [
              {
                "name": "campaign",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "ciProviders",
                "type": {
                  "kind": "LIST",
                  "ofType": {
                    "kind": "NON_NULL",
                    "ofType": {
                      "kind": "SCALAR",
                      "name": "Any"
                    }
                  }
                }
              },
              {
                "name": "cohort",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "medium",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "name",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "orgId",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "public",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "source",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          },
          {
            "name": "cloudProjectRequestAccess",
            "type": {
              "kind": "UNION",
              "name": "CloudProjectResult",
              "ofType": null
            },
            "args": [
              {
                "name": "projectSlug",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "cloudRecordEvent",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "localTestCounts",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          },
          {
            "name": "completeSetup",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "copyTextToClipboard",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "text",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "determineCohort",
            "type": {
              "kind": "OBJECT",
              "name": "Cohort",
              "ofType": null
            },
            "args": [
              {
                "name": "cohortConfig",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "devRelaunch",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "action",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "dismissWarning",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": [
              {
                "name": "id",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "e2eExamples",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "ScaffoldedFile",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "finishedRenamingComponentSpecs",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "focusActiveBrowserWindow",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "generateSpecFromSource",
            "type": {
              "kind": "OBJECT",
              "name": "GenerateSpecResponse",
              "ofType": null
            },
            "args": [
              {
                "name": "codeGenCandidate",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "componentName",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "isDefault",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "type",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "getReactComponentsFromFile",
            "type": {
              "kind": "OBJECT",
              "name": "ReactComponentResponse",
              "ofType": null
            },
            "args": [
              {
                "name": "filePath",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "initializeCtFrameworks",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "internal_clearAllProjectPreferencesCache",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "internal_clearLatestProjectCache",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "internal_clearProjectPreferencesCache",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "projectTitle",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "launchOpenProject",
            "type": {
              "kind": "OBJECT",
              "name": "CurrentProject",
              "ofType": null
            },
            "args": [
              {
                "name": "shouldLaunchNewTab",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "specPath",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          },
          {
            "name": "launchpadSetBrowser",
            "type": {
              "kind": "OBJECT",
              "name": "CurrentProject",
              "ofType": null
            },
            "args": [
              {
                "name": "id",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "loadRemoteFetchables",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "INTERFACE",
                  "name": "RemoteFetchable",
                  "ofType": null
                }
              }
            },
            "args": [
              {
                "name": "ids",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "LIST",
                    "ofType": {
                      "kind": "NON_NULL",
                      "ofType": {
                        "kind": "SCALAR",
                        "name": "Any"
                      }
                    }
                  }
                }
              }
            ]
          },
          {
            "name": "login",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": [
              {
                "name": "utmContent",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "utmMedium",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "utmSource",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "logout",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "matchesSpecPattern",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": [
              {
                "name": "specFile",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "migrateCloseManualRenameWatcher",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "migrateComponentTesting",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "migrateConfigFile",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "migrateRenameSpecs",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": [
              {
                "name": "after",
                "type": {
                  "kind": "LIST",
                  "ofType": {
                    "kind": "NON_NULL",
                    "ofType": {
                      "kind": "SCALAR",
                      "name": "Any"
                    }
                  }
                }
              },
              {
                "name": "before",
                "type": {
                  "kind": "LIST",
                  "ofType": {
                    "kind": "NON_NULL",
                    "ofType": {
                      "kind": "SCALAR",
                      "name": "Any"
                    }
                  }
                }
              },
              {
                "name": "skip",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          },
          {
            "name": "migrateRenameSpecsFolder",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "migrateRenameSupport",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "migrateSkipManualRename",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "moveToRelevantRun",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "runNumber",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "openDirectoryInIDE",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "path",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "openExternal",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "includeGraphqlPort",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "url",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "openFileInIDE",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "input",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "openInFinder",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "path",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "pingBaseUrl",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "reconfigureProject",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "recordEvent",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "campaign",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "cohort",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "includeMachineId",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              },
              {
                "name": "medium",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "messageId",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "payload",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          },
          {
            "name": "refetchRemote",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "refreshCloudViewer",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "removeProject",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": [
              {
                "name": "path",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "resetAuthState",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "Query",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "resetErrorAndLoadConfig",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": [
              {
                "name": "id",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "resetLatestVersionTelemetry",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "resetWizard",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "runSpec",
            "type": {
              "kind": "UNION",
              "name": "RunSpecResult",
              "ofType": null
            },
            "args": [
              {
                "name": "specPath",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "scaffoldTestingType",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "setAndLoadCurrentTestingType",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": [
              {
                "name": "testingType",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "setCurrentProject",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": [
              {
                "name": "path",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "setPreferences",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": [
              {
                "name": "type",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "setProjectIdInConfigFile",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": [
              {
                "name": "projectId",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "setProjectPreferencesInGlobalCache",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "Query",
                "ofType": null
              }
            },
            "args": [
              {
                "name": "testingType",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "setPromptShown",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "slug",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "setRunAllSpecs",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "runAllSpecs",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "LIST",
                    "ofType": {
                      "kind": "NON_NULL",
                      "ofType": {
                        "kind": "SCALAR",
                        "name": "Any"
                      }
                    }
                  }
                }
              }
            ]
          },
          {
            "name": "setTestsForRun",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "testsBySpec",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "LIST",
                    "ofType": {
                      "kind": "NON_NULL",
                      "ofType": {
                        "kind": "SCALAR",
                        "name": "Any"
                      }
                    }
                  }
                }
              }
            ]
          },
          {
            "name": "showDebugForCloudRun",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "runNumber",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "showSystemNotification",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "body",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "title",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "switchTestingTypeAndRelaunch",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": [
              {
                "name": "testingType",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "testsForRun",
            "type": {
              "kind": "LIST",
              "ofType": {
                "kind": "NON_NULL",
                "ofType": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            },
            "args": [
              {
                "name": "spec",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "wizardUpdate",
            "type": {
              "kind": "OBJECT",
              "name": "Wizard",
              "ofType": null
            },
            "args": [
              {
                "name": "input",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          }
        ],
        "interfaces": []
      },
      {
        "kind": "INTERFACE",
        "name": "Node",
        "fields": [
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [],
        "possibleTypes": [
          {
            "kind": "OBJECT",
            "name": "Browser"
          },
          {
            "kind": "OBJECT",
            "name": "CachedUser"
          },
          {
            "kind": "OBJECT",
            "name": "CloudBrowserInfo"
          },
          {
            "kind": "OBJECT",
            "name": "CloudCiBuildInfo"
          },
          {
            "kind": "OBJECT",
            "name": "CloudOperatingSystem"
          },
          {
            "kind": "OBJECT",
            "name": "CloudOrganization"
          },
          {
            "kind": "OBJECT",
            "name": "CloudProject"
          },
          {
            "kind": "OBJECT",
            "name": "CloudProjectSpec"
          },
          {
            "kind": "OBJECT",
            "name": "CloudRecordKey"
          },
          {
            "kind": "OBJECT",
            "name": "CloudRun"
          },
          {
            "kind": "OBJECT",
            "name": "CloudRunGroup"
          },
          {
            "kind": "OBJECT",
            "name": "CloudRunInstance"
          },
          {
            "kind": "OBJECT",
            "name": "CloudRunTag"
          },
          {
            "kind": "OBJECT",
            "name": "CloudSpecRun"
          },
          {
            "kind": "OBJECT",
            "name": "CloudTestResult"
          },
          {
            "kind": "OBJECT",
            "name": "CloudUser"
          },
          {
            "kind": "OBJECT",
            "name": "CodeGenGlobs"
          },
          {
            "kind": "OBJECT",
            "name": "CurrentProject"
          },
          {
            "kind": "OBJECT",
            "name": "FileParts"
          },
          {
            "kind": "OBJECT",
            "name": "GlobalProject"
          },
          {
            "kind": "OBJECT",
            "name": "ManualMigration"
          },
          {
            "kind": "OBJECT",
            "name": "ManualMigrationFile"
          },
          {
            "kind": "OBJECT",
            "name": "MigrationFileData"
          },
          {
            "kind": "OBJECT",
            "name": "MigrationFilePart"
          },
          {
            "kind": "OBJECT",
            "name": "MigrationStep"
          },
          {
            "kind": "OBJECT",
            "name": "RemoteFetchableCloudProjectResult"
          },
          {
            "kind": "OBJECT",
            "name": "RemoteFetchableCloudProjectSpecResult"
          },
          {
            "kind": "OBJECT",
            "name": "Spec"
          },
          {
            "kind": "OBJECT",
            "name": "TestingTypeInfo"
          },
          {
            "kind": "OBJECT",
            "name": "WizardBundler"
          },
          {
            "kind": "OBJECT",
            "name": "WizardErroredFramework"
          },
          {
            "kind": "OBJECT",
            "name": "WizardFrontendFramework"
          },
          {
            "kind": "OBJECT",
            "name": "WizardNpmPackage"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "PageInfo",
        "fields": [
          {
            "name": "endCursor",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "hasNextPage",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "hasPreviousPage",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "startCursor",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "INTERFACE",
        "name": "ProjectLike",
        "fields": [
          {
            "name": "cloudProjectRemote",
            "type": {
              "kind": "OBJECT",
              "name": "RemoteFetchableCloudProjectResult",
              "ofType": null
            },
            "args": [
              {
                "name": "name",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "projectId",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "projectRoot",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "title",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [],
        "possibleTypes": [
          {
            "kind": "OBJECT",
            "name": "CurrentProject"
          },
          {
            "kind": "OBJECT",
            "name": "GlobalProject"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "ProjectPreferences",
        "fields": [
          {
            "name": "testingType",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "PushFragmentPayload",
        "fields": [
          {
            "name": "data",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "errors",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "fragment",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "invalidateCache",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "target",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "variables",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "Query",
        "fields": [
          {
            "name": "authState",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "AuthState",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "baseError",
            "type": {
              "kind": "OBJECT",
              "name": "ErrorWrapper",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "cachedUser",
            "type": {
              "kind": "OBJECT",
              "name": "CachedUser",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "cloudLatestRunUpdateSpecData",
            "type": {
              "kind": "OBJECT",
              "name": "CloudLatestRunUpdateSpecData",
              "ofType": null
            },
            "args": [
              {
                "name": "commitBranch",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "projectSlug",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "sinceDateTime",
                "type": {
                  "kind": "SCALAR",
                  "name": "Any"
                }
              }
            ]
          },
          {
            "name": "cloudNode",
            "type": {
              "kind": "INTERFACE",
              "name": "Node",
              "ofType": null
            },
            "args": [
              {
                "name": "id",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "cloudNodesByIds",
            "type": {
              "kind": "LIST",
              "ofType": {
                "kind": "INTERFACE",
                "name": "Node",
                "ofType": null
              }
            },
            "args": [
              {
                "name": "ids",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "LIST",
                    "ofType": {
                      "kind": "NON_NULL",
                      "ofType": {
                        "kind": "SCALAR",
                        "name": "Any"
                      }
                    }
                  }
                }
              }
            ]
          },
          {
            "name": "cloudProjectBySlug",
            "type": {
              "kind": "UNION",
              "name": "CloudProjectResult",
              "ofType": null
            },
            "args": [
              {
                "name": "slug",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "cloudProjectsBySlugs",
            "type": {
              "kind": "LIST",
              "ofType": {
                "kind": "UNION",
                "name": "CloudProjectResult",
                "ofType": null
              }
            },
            "args": [
              {
                "name": "slugs",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "LIST",
                    "ofType": {
                      "kind": "NON_NULL",
                      "ofType": {
                        "kind": "SCALAR",
                        "name": "Any"
                      }
                    }
                  }
                }
              }
            ]
          },
          {
            "name": "cloudSpecByPath",
            "type": {
              "kind": "UNION",
              "name": "CloudProjectSpecResult",
              "ofType": null
            },
            "args": [
              {
                "name": "projectSlug",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              },
              {
                "name": "specPath",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "cloudViewer",
            "type": {
              "kind": "OBJECT",
              "name": "CloudUser",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "cohort",
            "type": {
              "kind": "OBJECT",
              "name": "Cohort",
              "ofType": null
            },
            "args": [
              {
                "name": "name",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "currentProject",
            "type": {
              "kind": "OBJECT",
              "name": "CurrentProject",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "dev",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "DevState",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "invokedFromCli",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isGlobalMode",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "localSettings",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "LocalSettings",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "machineId",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "migration",
            "type": {
              "kind": "OBJECT",
              "name": "Migration",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "node",
            "type": {
              "kind": "INTERFACE",
              "name": "Node",
              "ofType": null
            },
            "args": [
              {
                "name": "id",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "pollingIntervals",
            "type": {
              "kind": "OBJECT",
              "name": "CloudPollingIntervals",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "projects",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "INTERFACE",
                    "name": "ProjectLike",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "scaffoldedFiles",
            "type": {
              "kind": "LIST",
              "ofType": {
                "kind": "NON_NULL",
                "ofType": {
                  "kind": "OBJECT",
                  "name": "ScaffoldedFile",
                  "ofType": null
                }
              }
            },
            "args": []
          },
          {
            "name": "versions",
            "type": {
              "kind": "OBJECT",
              "name": "VersionData",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "videoEmbedHtml",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "warnings",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "ErrorWrapper",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "wizard",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "Wizard",
                "ofType": null
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "ReactComponentDescriptor",
        "fields": [
          {
            "name": "exportName",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isDefault",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "ReactComponentResponse",
        "fields": [
          {
            "name": "components",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "ReactComponentDescriptor",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "errored",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "RelevantRun",
        "fields": [
          {
            "name": "all",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "RelevantRunInfo",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "commitsAhead",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "currentCommitInfo",
            "type": {
              "kind": "OBJECT",
              "name": "CommitInfo",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "latest",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "RelevantRunInfo",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "selectedRunNumber",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "RelevantRunInfo",
        "fields": [
          {
            "name": "runId",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "runNumber",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "sha",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "status",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "totalFailed",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "INTERFACE",
        "name": "RemoteFetchable",
        "fields": [
          {
            "name": "dataRaw",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "error",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "fetchingStatus",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "operation",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "operationHash",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "operationVariables",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ],
        "possibleTypes": [
          {
            "kind": "OBJECT",
            "name": "RemoteFetchableCloudProjectResult"
          },
          {
            "kind": "OBJECT",
            "name": "RemoteFetchableCloudProjectSpecResult"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "RemoteFetchableCloudProjectResult",
        "fields": [
          {
            "name": "data",
            "type": {
              "kind": "UNION",
              "name": "CloudProjectResult",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "dataRaw",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "error",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "fetchingStatus",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "operation",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "operationHash",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "operationVariables",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          },
          {
            "kind": "INTERFACE",
            "name": "RemoteFetchable"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "RemoteFetchableCloudProjectSpecResult",
        "fields": [
          {
            "name": "data",
            "type": {
              "kind": "UNION",
              "name": "CloudProjectSpecResult",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "dataRaw",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "error",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "fetchingStatus",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "operation",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "operationHash",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "operationVariables",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          },
          {
            "kind": "INTERFACE",
            "name": "RemoteFetchable"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "RunSpecError",
        "fields": [
          {
            "name": "code",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "detailMessage",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "RunSpecResponse",
        "fields": [
          {
            "name": "browser",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "Browser",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "spec",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "Spec",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "testingType",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "UNION",
        "name": "RunSpecResult",
        "possibleTypes": [
          {
            "kind": "OBJECT",
            "name": "RunSpecError"
          },
          {
            "kind": "OBJECT",
            "name": "RunSpecResponse"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "ScaffoldedFile",
        "fields": [
          {
            "name": "description",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "file",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "FileParts",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "status",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "Spec",
        "fields": [
          {
            "name": "absolute",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "baseName",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "cloudSpec",
            "type": {
              "kind": "OBJECT",
              "name": "RemoteFetchableCloudProjectSpecResult",
              "ofType": null
            },
            "args": [
              {
                "name": "name",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "fileExtension",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "fileName",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "gitInfo",
            "type": {
              "kind": "OBJECT",
              "name": "GitInfo",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "relative",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "specFileExtension",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "specType",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "SpecDataAggregate",
        "fields": [
          {
            "name": "max",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "min",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "Subscription",
        "fields": [
          {
            "name": "authChange",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "branchChange",
            "type": {
              "kind": "OBJECT",
              "name": "CurrentProject",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "browserStatusChange",
            "type": {
              "kind": "OBJECT",
              "name": "CurrentProject",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "cloudViewerChange",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "configChange",
            "type": {
              "kind": "OBJECT",
              "name": "CurrentProject",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "devChange",
            "type": {
              "kind": "OBJECT",
              "name": "DevState",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "errorWarningChange",
            "type": {
              "kind": "OBJECT",
              "name": "Query",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "frameworkDetectionChange",
            "type": {
              "kind": "OBJECT",
              "name": "Wizard",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "gitInfoChange",
            "type": {
              "kind": "LIST",
              "ofType": {
                "kind": "OBJECT",
                "name": "Spec",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "pushFragment",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "PushFragmentPayload",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "relevantRunSpecChange",
            "type": {
              "kind": "OBJECT",
              "name": "CloudRun",
              "ofType": null
            },
            "args": [
              {
                "name": "runId",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "relevantRuns",
            "type": {
              "kind": "OBJECT",
              "name": "RelevantRun",
              "ofType": null
            },
            "args": [
              {
                "name": "location",
                "type": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "SCALAR",
                    "name": "Any"
                  }
                }
              }
            ]
          },
          {
            "name": "specsChange",
            "type": {
              "kind": "OBJECT",
              "name": "CurrentProject",
              "ofType": null
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "TestingTypeInfo",
        "fields": [
          {
            "name": "description",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "title",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "type",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "UsageLimitExceeded",
        "fields": [
          {
            "name": "monthlyTests",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "Version",
        "fields": [
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "released",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "version",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "VersionData",
        "fields": [
          {
            "name": "current",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "Version",
                "ofType": null
              }
            },
            "args": []
          },
          {
            "name": "latest",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "OBJECT",
                "name": "Version",
                "ofType": null
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "Wizard",
        "fields": [
          {
            "name": "allBundlers",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "WizardBundler",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "bundler",
            "type": {
              "kind": "OBJECT",
              "name": "WizardBundler",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "erroredFrameworks",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "WizardErroredFramework",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "framework",
            "type": {
              "kind": "OBJECT",
              "name": "WizardFrontendFramework",
              "ofType": null
            },
            "args": []
          },
          {
            "name": "frameworks",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "WizardFrontendFramework",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "installDependenciesCommand",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "packagesToInstall",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "WizardNpmPackage",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          }
        ],
        "interfaces": []
      },
      {
        "kind": "OBJECT",
        "name": "WizardBundler",
        "fields": [
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isDetected",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "type",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "WizardErroredFramework",
        "fields": [
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "path",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "WizardFrontendFramework",
        "fields": [
          {
            "name": "category",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "icon",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isDetected",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "isSelected",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "supportStatus",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "supportedBundlers",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "LIST",
                "ofType": {
                  "kind": "NON_NULL",
                  "ofType": {
                    "kind": "OBJECT",
                    "name": "WizardBundler",
                    "ofType": null
                  }
                }
              }
            },
            "args": []
          },
          {
            "name": "type",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "OBJECT",
        "name": "WizardNpmPackage",
        "fields": [
          {
            "name": "description",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "detectedVersion",
            "type": {
              "kind": "SCALAR",
              "name": "Any"
            },
            "args": []
          },
          {
            "name": "id",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "minVersion",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "name",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "package",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          },
          {
            "name": "satisfied",
            "type": {
              "kind": "NON_NULL",
              "ofType": {
                "kind": "SCALAR",
                "name": "Any"
              }
            },
            "args": []
          }
        ],
        "interfaces": [
          {
            "kind": "INTERFACE",
            "name": "Node"
          }
        ]
      },
      {
        "kind": "SCALAR",
        "name": "Any"
      }
    ],
    "directives": []
  }
};
const pubSubExchange = (io2) => {
  return ({ client: client2, forward }) => {
    const watchedOperations = /* @__PURE__ */ new Map();
    const observedOperations = /* @__PURE__ */ new Map();
    const awaitingMount = {};
    function reexecuteOperation2(op, refetchHeader = "true") {
      client2.reexecuteOperation(
        client2.createRequestOperation("query", op, {
          requestPolicy: "cache-and-network",
          fetchOptions: {
            headers: {
              "x-cypress-graphql-refetch": refetchHeader
            }
          }
        })
      );
    }
    io2.on("graphql-refetch", (refreshOnly) => {
      if (refreshOnly == null ? void 0 : refreshOnly.operation) {
        const fieldHeader = `${refreshOnly.operation}.${refreshOnly.field}`;
        const toRefresh = Array.from(watchedOperations.values()).find((o2) => getOperationName(o2.query) === refreshOnly.operation);
        if (!toRefresh) {
          awaitingMount[refreshOnly.operation] = refreshOnly;
        } else {
          reexecuteOperation2(toRefresh, fieldHeader);
        }
      } else {
        watchedOperations.forEach((op) => {
          reexecuteOperation2(op);
        });
      }
    });
    const processIncomingOperation = (op) => {
      if (op.kind === "teardown" && observedOperations.has(op.key)) {
        observedOperations.delete(op.key);
        watchedOperations.delete(op.key);
      }
    };
    const processResultOperation = (op) => {
      if (op.operation.kind === "query" && !observedOperations.has(op.operation.key)) {
        observedOperations.set(op.operation.key, 1);
        watchedOperations.set(op.operation.key, op.operation);
        const name2 = getOperationName(op.operation.query);
        if (name2 && awaitingMount[name2]) {
          const awaiting = awaitingMount[name2];
          delete awaitingMount[name2];
          reexecuteOperation2(op.operation, `${awaiting.operation}.${awaiting.field}`);
        }
      }
    };
    return (ops$) => {
      if (typeof window === "undefined") {
        return forward(ops$);
      }
      return pipe(forward(pipe(ops$, H(processIncomingOperation))), H(processResultOperation));
    };
  };
};
function getOperationName(query2) {
  var _a2, _b2;
  return (_b2 = (_a2 = getPrimaryOperation(query2)) == null ? void 0 : _a2.name) == null ? void 0 : _b2.value;
}
function getPrimaryOperation(query2) {
  return query2.definitions.find(isOperationDefinitionNode);
}
function isOperationDefinitionNode(node) {
  return node.kind === "OperationDefinition";
}
const namedRouteExchange = ({ client: client2, forward }) => {
  return (ops$) => {
    return forward(pipe(
      ops$,
      map$1((o2) => {
        if (!o2.context.url.endsWith("/graphql")) {
          return o2;
        }
        return {
          ...o2,
          context: {
            ...o2.context,
            url: `${o2.context.url}/${o2.kind}-${getOperationName$1(o2.query)}`
          }
        };
      })
    ));
  };
};
const urqlFetchSocketAdapter = (io2) => {
  return (url2, fetchOptions = {}) => {
    return new Promise((resolve3, reject) => {
      if (fetchOptions.signal) {
        fetchOptions.signal.onabort = () => {
          reject(new DOMException("Aborted", "AbortError"));
        };
        if (fetchOptions.signal.aborted) {
          return reject(new DOMException("Aborted", "AbortError"));
        }
      }
      const uid2 = _$1.uniqueId("gql");
      io2.emit(`graphql:request`, uid2, fetchOptions.body, (payload) => {
        resolve3(new Response(JSON.stringify(payload), {
          status: 200,
          headers: {
            "Content-Type": "application/json"
          }
        }));
      });
    });
  };
};
gql`
 subscription GlobalSubscriptions_PushFragment {
   pushFragment {
     target
     fragment
     data
     errors
     variables
     invalidateCache
   }
 }
`;
gql`
subscription GlobalSubscriptions_ErrorWarningChange {
  errorWarningChange {
    baseError {
      id
      ...BaseError
    }
    warnings {
      id
      ...WarningContent
    }
  }
}
`;
gql`
fragment WarningContent on ErrorWrapper {
  id
  title
  errorType
  errorMessage
}
`;
function initializeGlobalSubscriptions(client2) {
  const { unsubscribe: unsubscribeErrorWarning } = pipe(
    client2.subscription(GlobalSubscriptions_ErrorWarningChangeDocument),
    N$1(() => {
    })
  );
  const { unsubscribe: unsubscribePushFragment } = pipe(
    client2.subscription(GlobalSubscriptions_PushFragmentDocument),
    N$1((val) => {
    })
  );
  return () => {
    unsubscribeErrorWarning();
    unsubscribePushFragment();
  };
}
useToast();
function showError(error) {
  var _a2, _b2, _c, _d, _e, _f, _g;
  `
    GraphQL Field Path: [${(_c = (_b2 = (_a2 = error.graphQLErrors) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.path) == null ? void 0 : _c.join(", ")}]:

    ${error.message ?? ((_e = (_d = error.graphQLErrors) == null ? void 0 : _d[0]) == null ? void 0 : _e.message)}

    ${error.stack ?? ((_g = (_f = error.graphQLErrors) == null ? void 0 : _f[0]) == null ? void 0 : _g.stack) ?? ""}
  `;
  console.error(error);
}
function makeCacheExchange(schema = urqlSchema) {
  return cacheExchange({
    ...urqlCacheKeys,
    schema,
    updates: {
      Subscription: {
        pushFragment(parent, args, cache2, info) {
          var _a2;
          const { pushFragment } = parent;
          for (const toPush of pushFragment) {
            if (toPush.invalidateCache) {
              cache2.invalidate({ __typename: "Query" });
              continue;
            }
            cache2.writeFragment(toPush.fragment, toPush.data, toPush.variables ?? {});
            if ((_a2 = toPush.errors) == null ? void 0 : _a2.length) {
              showError({
                graphQLErrors: toPush.errors
              });
            }
          }
        }
      },
      Mutation: {
        logout(parent, args, cache2, info) {
          cache2.invalidate({ __typename: "Query" });
        }
      }
    }
  });
}
const cypressInRunMode = window.top === window && window.__CYPRESS_MODE__ === "run";
async function makeUrqlClient(config2) {
  const exchanges = [dedupExchange];
  const io2 = getPubSubSource(config2);
  const connectPromise = new Promise((resolve3) => {
    io2.once("connect", resolve3);
  });
  const socketClient = getSocketSource(config2);
  if (config2.target === "launchpad" || config2.target === "app" && !cypressInRunMode) {
    exchanges.push(pubSubExchange(io2));
  }
  exchanges.push(
    errorExchange({
      onError(error) {
        showError(error);
      }
    }),
    // https://formidable.com/open-source/urql/docs/graphcache/errors/
    makeCacheExchange(),
    namedRouteExchange,
    fetchExchange,
    subscriptionExchange({
      forwardSubscription(op) {
        return {
          subscribe: (sink) => {
            const dispose = socketClient.subscribe(op, sink);
            return {
              unsubscribe: dispose
            };
          }
        };
      }
    })
  );
  const url2 = config2.target === "launchpad" ? `/__launchpad/graphql` : `/${config2.namespace}/graphql`;
  const client2 = W({
    url: url2,
    requestPolicy: cypressInRunMode ? "cache-only" : "cache-first",
    exchanges,
    // Rather than authoring a custom exchange, let's just polyfill the "fetch"
    // exchange to adapt to a similar interface. This way it'll be simple to
    // swap in-and-out during integration tests.
    fetch: config2.target === "launchpad" || window.__CYPRESS_GQL_NO_SOCKET__ ? window.fetch : urqlFetchSocketAdapter(io2)
  });
  await connectPromise;
  if (window.__CYPRESS_MODE__ !== "run") {
    initializeGlobalSubscriptions(client2);
  }
  return client2;
}
function getPubSubSource(config2) {
  if (config2.target === "launchpad") {
    return client("/data-context", {
      path: "/__launchpad/socket",
      transports: ["websocket"]
    });
  }
  return client("/data-context", {
    path: config2.socketIoRoute,
    transports: ["websocket"]
  });
}
function getSocketSource(config2) {
  const protocol = window.location.protocol.replace("http", "ws");
  const wsUrl = config2.target === "launchpad" ? `ws://${window.location.host}/__launchpad/graphql-ws` : `${protocol}//${window.location.host}${config2.socketIoRoute}-graphql`;
  return createClient({
    url: wsUrl
  });
}
const _hoisted_1$9 = {
  key: 1,
  class: "w-[640px]"
};
const _hoisted_2$9 = { key: 0 };
const _hoisted_3$7 = { class: "flex font-normal my-[8px] text-[16px] leading-[24px] items-end justify-between" };
const _hoisted_4$5 = { class: "" };
const _hoisted_5$3 = { class: "flex font-normal text-[16px] leading-[24px] items-center justify-between" };
const _hoisted_6 = { class: "text-gray-800" };
const _hoisted_7 = /* @__PURE__ */ createBaseVNode("span", { class: "text-red-500" }, "*", -1);
const _hoisted_8 = { class: "flex font-normal mt-[24px] text-[16px] leading-[24px] items-center" };
const _hoisted_9 = {
  class: "grow",
  for: "projectName"
};
const _hoisted_10 = { class: "text-gray-800" };
const _hoisted_11 = /* @__PURE__ */ createBaseVNode("span", { class: "ml-[4px] text-red-500" }, "*", -1);
const _hoisted_12 = { class: "ml-[8px] text-gray-500" };
const _hoisted_13 = { class: "flex gap-[16px]" };
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "SelectCloudProjectModal",
  props: {
    gql: null,
    utmMedium: null,
    utmContent: null
  },
  emits: ["success", "cancel", "update-projectId-failed"],
  setup(__props, { emit: emit3 }) {
    var _a2;
    const props = __props;
    const { t: t2 } = useI18n();
    const online = useOnline();
    gql`
fragment CloudProjectNode on CloudProject {
  id
  slug
  name
}
`;
    gql`
fragment SelectCloudProjectModal on Query {
  cloudViewer {
    id
    cloudOrganizationsUrl
    organizations(first: 100) { # Not expecting there will be > 100 orgs for a user. If there are we will implement pagination
      nodes {
        id
        name
        projects(first: 100) { # Not expecting there will be > 100 projects. If there are we will implement pagination
          nodes {
            id
            ...CloudProjectNode
          }
        }
      }
    }
  }
  currentProject{
    id
    title
    ...NeedManualUpdateModal
  }
}
`;
    gql`
mutation SelectCloudProjectModal_SetProjectId( $projectId: String! ) {
  setProjectIdInConfigFile(projectId: $projectId) {
    currentProject{
      id
      projectId
      cloudProject {
        __typename
        ... on CloudProject {
          id
          runs(first: 10) {
            nodes {
              id 
              createdAt
              status
              totalDuration
              url
              tags {
                id
                name
              }
              totalPassed
              totalFailed
              totalPending
              totalSkipped
              totalFlakyTests
              commitInfo {
                authorName
                authorEmail
                summary
                branch
              }
            }
          }
        }
      }
    }
  }
}
`;
    gql`
mutation SelectCloudProjectModal_CreateCloudProject( $name: String!, $orgId: ID!, $public: Boolean!, $campaign: String, $cohort: String, $medium: String, $source: String! ) {
  cloudProjectCreate(name: $name, orgId: $orgId, public: $public, campaign: $campaign, cohort: $cohort, medium: $medium, source: $source) {
    id
    slug
  }
}
`;
    const isInternalServerError = ref(false);
    const graphqlError = ref();
    const projectName = ref(((_a2 = props.gql.currentProject) == null ? void 0 : _a2.title) || "");
    const projectAccess = ref("private");
    const organizationOptions = computed(() => {
      var _a3, _b2, _c;
      const options2 = (_c = (_b2 = (_a3 = props.gql.cloudViewer) == null ? void 0 : _a3.organizations) == null ? void 0 : _b2.nodes) == null ? void 0 : _c.map((org) => {
        return {
          id: org.id,
          name: org.name,
          icon: FolderIcon
        };
      });
      return lodashExports.sortBy(options2 || [], "name");
    });
    const pickedOrganization = ref(organizationOptions.value.length >= 1 ? organizationOptions.value[0] : void 0);
    const projectOptions = computed(() => {
      var _a3, _b2, _c, _d, _e;
      const organization = (_c = (_b2 = (_a3 = props.gql.cloudViewer) == null ? void 0 : _a3.organizations) == null ? void 0 : _b2.nodes) == null ? void 0 : _c.find((org) => {
        var _a4;
        return org.id === ((_a4 = pickedOrganization == null ? void 0 : pickedOrganization.value) == null ? void 0 : _a4.id);
      });
      const options2 = (_e = (_d = organization == null ? void 0 : organization.projects) == null ? void 0 : _d.nodes) == null ? void 0 : _e.map((project) => {
        return {
          id: project.id,
          name: project.name,
          slug: project.slug
        };
      });
      return lodashExports.sortBy(options2 || [], "name");
    });
    const newProject = ref(projectOptions.value.length === 0);
    const pickedProject = ref();
    watch(projectOptions, (newVal, oldVal) => {
      if (lodashExports.isEqual(newVal, oldVal)) {
        return;
      }
      if (newVal.length === 1) {
        pickedProject.value = newVal[0];
      } else {
        pickedProject.value = newVal.find((p2) => p2.name === projectName.value);
      }
      newProject.value = newVal.length === 0;
    }, {
      immediate: true
    });
    const orgPlaceholder = t2("runs.connect.modal.selectProject.placeholderOrganizations");
    const projectPlaceholder = computed(() => {
      return pickedOrganization.value ? t2("runs.connect.modal.selectProject.placeholderProjects") : t2("runs.connect.modal.selectProject.placeholderProjectsPending");
    });
    const organizationUrl = computed(() => {
      var _a3;
      return (_a3 = props.gql.cloudViewer) == null ? void 0 : _a3.cloudOrganizationsUrl;
    });
    const createCloudProjectMutation = useMutation(SelectCloudProjectModal_CreateCloudProjectDocument);
    const setProjectIdMutation = useMutation(SelectCloudProjectModal_SetProjectIdDocument);
    async function createOrConnectProject() {
      var _a3, _b2, _c, _d, _e;
      let projectId;
      const isNewProject = Boolean(newProject.value && pickedOrganization.value);
      if (isNewProject) {
        const { data, error } = await createCloudProjectMutation.executeMutation({
          orgId: pickedOrganization.value.id,
          name: projectName.value,
          public: projectAccess.value === "public",
          campaign: "Create project",
          cohort: props.utmContent || "",
          medium: props.utmMedium,
          source: getUtmSource()
        });
        if (error == null ? void 0 : error.graphQLErrors.length) {
          const err = error.graphQLErrors[0];
          const extension = (_a3 = err.extensions) == null ? void 0 : _a3.code;
          isInternalServerError.value = extension === "INTERNAL_SERVER_ERROR";
          graphqlError.value = {
            extension,
            message: err.message
          };
        } else {
          graphqlError.value = void 0;
        }
        projectId = (_b2 = data == null ? void 0 : data.cloudProjectCreate) == null ? void 0 : _b2.slug;
      } else {
        projectId = (_c = pickedProject.value) == null ? void 0 : _c.slug;
      }
      if (projectId) {
        const { data } = await setProjectIdMutation.executeMutation({ projectId });
        const updatedProjectId = (_e = (_d = data == null ? void 0 : data.setProjectIdInConfigFile) == null ? void 0 : _d.currentProject) == null ? void 0 : _e.projectId;
        if (updatedProjectId === projectId) {
          emit3("success");
        } else {
          emit3("update-projectId-failed", projectId);
        }
      }
    }
    const isOnline = computed(() => online.value);
    const disableButton = computed(() => {
      if (newProject.value) {
        return !projectName.value;
      }
      return !pickedProject.value;
    });
    return (_ctx, _cache) => {
      const _component_i18n_t = resolveComponent("i18n-t");
      return openBlock(), createBlock(_sfc_main$o, {
        "model-value": "",
        title: newProject.value ? unref(t2)("runs.connect.modal.selectProject.createProject") : unref(t2)("runs.connect.modal.title"),
        "help-link": "https://on.cypress.io/adding-new-project",
        "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => emit3("cancel"))
      }, createSlots({
        default: withCtx(() => [
          !unref(isOnline) ? (openBlock(), createBlock(_sfc_main$w, {
            key: 0,
            class: "mt-[24px]"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString$1(unref(t2)("launchpadErrors.noInternet.message")), 1)
            ]),
            _: 1
          })) : (openBlock(), createElementBlock("div", _hoisted_1$9, [
            graphqlError.value ? (openBlock(), createBlock(_sfc_main$i, {
              key: 0,
              "v-model": Boolean(graphqlError.value),
              status: "error",
              title: isInternalServerError.value ? unref(t2)("runs.connect.errors.internalServerError.title") : unref(t2)("runs.connect.errors.baseError.title"),
              class: "mb-[16px]",
              icon: unref(WarningIcon),
              dismissible: isInternalServerError.value
            }, {
              default: withCtx(() => [
                !isInternalServerError.value ? (openBlock(), createElementBlock("p", _hoisted_2$9, toDisplayString$1(graphqlError.value.message), 1)) : (openBlock(), createBlock(_component_i18n_t, {
                  key: 1,
                  scope: "global",
                  keypath: "runs.connect.errors.internalServerError.description"
                }, {
                  default: withCtx(() => [
                    createVNode(_sfc_main$z, { href: "https://www.cypressstatus.com/" }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString$1(unref(t2)("runs.connect.errors.internalServerError.link")), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }))
              ]),
              _: 1
            }, 8, ["v-model", "title", "icon", "dismissible"])) : createCommentVNode("", true),
            createVNode(_sfc_main$n, {
              modelValue: pickedOrganization.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => pickedOrganization.value = $event),
              options: unref(organizationOptions),
              "item-value": "name",
              "item-key": "id",
              placeholder: unref(orgPlaceholder),
              "data-cy": "selectOrganization"
            }, {
              label: withCtx(() => [
                createBaseVNode("span", _hoisted_3$7, [
                  createBaseVNode("span", _hoisted_4$5, toDisplayString$1(unref(t2)("runs.connect.modal.selectProject.organization")), 1),
                  unref(organizationUrl) ? (openBlock(), createBlock(_sfc_main$z, {
                    key: 0,
                    class: "cursor-pointer text-right text-indigo-500 hover:underline",
                    href: unref(organizationUrl)
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString$1(unref(t2)("runs.connect.modal.selectProject.manageOrgs")), 1)
                    ]),
                    _: 1
                  }, 8, ["href"])) : createCommentVNode("", true)
                ])
              ]),
              "input-prefix": withCtx(() => [
                createVNode(unref(OrganizationIcon), { class: "h-[16px] w-[16px] icon-dark-gray-500" })
              ]),
              "item-prefix": withCtx(() => [
                createVNode(unref(OrganizationIcon), { class: "h-[16px] w-[16px] icon-dark-gray-500" })
              ]),
              _: 1
            }, 8, ["modelValue", "options", "placeholder"]),
            !newProject.value ? (openBlock(), createBlock(_sfc_main$n, {
              key: 1,
              modelValue: pickedProject.value,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => pickedProject.value = $event),
              class: normalizeClass(["mt-[16px] transition-all", pickedOrganization.value ? void 0 : "opacity-50"]),
              options: unref(projectOptions),
              "item-value": "name",
              "item-key": "id",
              disabled: !pickedOrganization.value,
              placeholder: unref(projectPlaceholder),
              "data-cy": "selectProject"
            }, {
              label: withCtx(() => [
                createBaseVNode("div", _hoisted_5$3, [
                  createBaseVNode("p", _hoisted_6, [
                    createTextVNode(toDisplayString$1(unref(t2)("runs.connect.modal.selectProject.project")) + " ", 1),
                    _hoisted_7
                  ]),
                  createBaseVNode("a", {
                    class: "cursor-pointer my-[8px] text-right text-indigo-500 hover:underline",
                    onClick: _cache[1] || (_cache[1] = ($event) => newProject.value = true)
                  }, toDisplayString$1(unref(t2)("runs.connect.modal.selectProject.createNewProject")), 1)
                ])
              ]),
              "input-prefix": withCtx(() => [
                createVNode(unref(FolderIcon), { class: "h-[16px] w-[16px] icon-dark-gray-500" })
              ]),
              "item-prefix": withCtx(() => [
                createVNode(unref(FolderIcon), { class: "h-[16px] w-[16px] icon-dark-gray-500" })
              ]),
              _: 1
            }, 8, ["modelValue", "class", "options", "disabled", "placeholder"])) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
              createBaseVNode("div", _hoisted_8, [
                createBaseVNode("label", _hoisted_9, [
                  createBaseVNode("span", _hoisted_10, toDisplayString$1(unref(t2)("runs.connect.modal.selectProject.projectName")), 1),
                  _hoisted_11,
                  createBaseVNode("span", _hoisted_12, toDisplayString$1(unref(t2)("runs.connect.modal.selectProject.projectNameDisclaimer")), 1)
                ]),
                unref(projectOptions).length > 0 ? (openBlock(), createElementBlock("a", {
                  key: 0,
                  class: "cursor-pointer text-indigo-500 hover:underline",
                  onClick: _cache[3] || (_cache[3] = ($event) => newProject.value = false)
                }, toDisplayString$1(unref(t2)("runs.connect.modal.selectProject.chooseExistingProject")), 1)) : createCommentVNode("", true)
              ]),
              createVNode(Input, {
                id: "projectName",
                modelValue: projectName.value,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => projectName.value = $event),
                class: "mt-[8px]",
                "input-classes": "h-[38px]",
                "prefix-icon": unref(FolderIcon),
                "prefix-icon-classes": "icon-dark-gray-500"
              }, null, 8, ["modelValue", "prefix-icon"]),
              createVNode(Radio, {
                value: projectAccess.value,
                "onUpdate:value": _cache[5] || (_cache[5] = ($event) => projectAccess.value = $event),
                name: "projectAccess",
                label: unref(t2)("runs.connect.modal.selectProject.newProjectAccess"),
                options: [
                  {
                    label: unref(t2)("runs.connect.modal.selectProject.privateLabel"),
                    description: unref(t2)("runs.connect.modal.selectProject.privateDescription"),
                    value: "private"
                  },
                  {
                    label: unref(t2)("runs.connect.modal.selectProject.publicLabel"),
                    description: unref(t2)("runs.connect.modal.selectProject.publicDescription"),
                    value: "public"
                  }
                ]
              }, null, 8, ["value", "label", "options"])
            ], 64))
          ]))
        ]),
        _: 2
      }, [
        unref(isOnline) ? {
          name: "footer",
          fn: withCtx(() => [
            createBaseVNode("div", _hoisted_13, [
              createVNode(_sfc_main$y, {
                size: "lg",
                "prefix-icon": newProject.value ? unref(__unplugin_components_1) : unref(ConnectIcon),
                "prefix-icon-class": "icon-dark-white",
                disabled: unref(disableButton),
                "data-cy": "connect-project",
                onClick: createOrConnectProject
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(newProject.value ? unref(t2)("runs.connect.modal.selectProject.createProject") : unref(t2)("runs.connect.modal.selectProject.connectProject")), 1)
                ]),
                _: 1
              }, 8, ["prefix-icon", "disabled"]),
              createVNode(_sfc_main$y, {
                variant: "outline",
                size: "lg",
                onClick: _cache[6] || (_cache[6] = ($event) => emit3("cancel"))
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t2)("runs.connect.modal.cancel")), 1)
                ]),
                _: 1
              })
            ])
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["title"]);
    };
  }
});
const _hoisted_1$8 = {
  key: 1,
  class: "border border-dashed rounded border-gray-100 text-center p-[24px] w-[592px]"
};
const _hoisted_2$8 = { class: "mb-[16px] text-gray-700" };
const _hoisted_3$6 = { class: "flex gap-[16px]" };
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "CreateCloudOrgModal",
  props: {
    gql: null
  },
  emits: ["cancel"],
  setup(__props, { emit: emit3 }) {
    const props = __props;
    const { t: t2 } = useI18n();
    const online = useOnline();
    gql`
fragment CreateCloudOrgModal on CloudUser {
  id
  createCloudOrganizationUrl
}
`;
    gql`
mutation CreateCloudOrgModal_CloudOrganizationsCheck {
  refreshCloudViewer {
    ...CloudConnectModals
  }
}
`;
    const refreshOrgs = useMutation(CreateCloudOrgModal_CloudOrganizationsCheckDocument);
    const refetch = useDebounceFn(() => refreshOrgs.executeMutation({}), 1e3);
    const waitingOrgToBeCreated = ref(false);
    let timer;
    function startWaitingOrgToBeCreated() {
      waitingOrgToBeCreated.value = true;
      timer = setTimeout(() => {
        waitingOrgToBeCreated.value = false;
      }, 6e4);
    }
    onBeforeUnmount(() => {
      window.clearTimeout(timer);
    });
    const createOrgUrl = computed(() => props.gql.createCloudOrganizationUrl);
    const isOnline = computed(() => online.value);
    return (_ctx, _cache) => {
      const _component_i_cy_office_building_x16 = OrganizationIcon;
      const _component_i_cy_loading_x16 = __unplugin_components_0$6;
      return openBlock(), createBlock(_sfc_main$o, {
        "model-value": "",
        title: unref(t2)("runs.connect.modal.title"),
        "help-link": "https://on.cypress.io/adding-new-project",
        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => emit3("cancel"))
      }, createSlots({
        default: withCtx(() => [
          !unref(isOnline) ? (openBlock(), createBlock(_sfc_main$w, {
            key: 0,
            class: "mt-[24px]"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString$1(unref(t2)("launchpadErrors.noInternet.message")), 1)
            ]),
            _: 1
          })) : (openBlock(), createElementBlock("div", _hoisted_1$8, [
            createBaseVNode("p", _hoisted_2$8, toDisplayString$1(unref(t2)("runs.connect.modal.createOrg.description")), 1),
            unref(createOrgUrl) ? (openBlock(), createBlock(_sfc_main$z, {
              key: 0,
              class: "border rounded mx-auto outline-none bg-indigo-500 border-indigo-500 text-white max-h-[60px] py-[11px] px-[16px] inline-block hocus-default",
              href: unref(createOrgUrl),
              "include-graphql-port": true,
              onClick: _cache[0] || (_cache[0] = ($event) => startWaitingOrgToBeCreated())
            }, {
              default: withCtx(() => [
                createVNode(_component_i_cy_office_building_x16, { class: "inline-block icon-dark-white" }),
                createTextVNode(" " + toDisplayString$1(unref(t2)("runs.connect.modal.createOrg.button")), 1)
              ]),
              _: 1
            }, 8, ["href"])) : createCommentVNode("", true)
          ]))
        ]),
        _: 2
      }, [
        unref(isOnline) ? {
          name: "footer",
          fn: withCtx(() => [
            createBaseVNode("div", _hoisted_3$6, [
              waitingOrgToBeCreated.value ? (openBlock(), createBlock(_sfc_main$y, {
                key: 0,
                size: "lg",
                variant: "pending"
              }, {
                prefix: withCtx(() => [
                  createVNode(_component_i_cy_loading_x16, { class: "animate-spin icon-dark-white icon-light-gray-400" })
                ]),
                default: withCtx(() => [
                  createTextVNode(" " + toDisplayString$1(unref(t2)("runs.connect.modal.createOrg.waitingButton")), 1)
                ]),
                _: 1
              })) : (openBlock(), createBlock(_sfc_main$y, {
                key: 1,
                size: "lg",
                onClick: _cache[1] || (_cache[1] = ($event) => unref(refetch)())
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t2)("runs.connect.modal.createOrg.refreshButton")), 1)
                ]),
                _: 1
              })),
              createVNode(_sfc_main$y, {
                variant: "outline",
                size: "lg",
                onClick: _cache[2] || (_cache[2] = ($event) => emit3("cancel"))
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString$1(unref(t2)("runs.connect.modal.cancel")), 1)
                ]),
                _: 1
              })
            ])
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["title"]);
    };
  }
});
const information_for_contributors$8 = [
  "This file has been converted from https://github.com/atom/language-css/blob/master/grammars/css.cson",
  "If you want to provide a fix or improvement, please create a pull request against the original repository.",
  "Once accepted there, we are happy to receive an update request."
];
const version$8 = "https://github.com/atom/language-css/commit/033087e8caa1b87ca91ee5b211de118b6b3c311d";
const name$b = "css";
const scopeName$a = "source.css";
const patterns$a = [
  {
    include: "#comment-block"
  },
  {
    include: "#escapes"
  },
  {
    include: "#combinators"
  },
  {
    include: "#selector"
  },
  {
    include: "#at-rules"
  },
  {
    include: "#rule-list"
  }
];
const repository$a = {
  "at-rules": {
    patterns: [
      {
        begin: "\\A(?:\\xEF\\xBB\\xBF)?(?i:(?=\\s*@charset\\b))",
        end: ";|(?=$)",
        endCaptures: {
          "0": {
            name: "punctuation.terminator.rule.css"
          }
        },
        name: "meta.at-rule.charset.css",
        patterns: [
          {
            captures: {
              "1": {
                name: "invalid.illegal.not-lowercase.charset.css"
              },
              "2": {
                name: "invalid.illegal.leading-whitespace.charset.css"
              },
              "3": {
                name: "invalid.illegal.no-whitespace.charset.css"
              },
              "4": {
                name: "invalid.illegal.whitespace.charset.css"
              },
              "5": {
                name: "invalid.illegal.not-double-quoted.charset.css"
              },
              "6": {
                name: "invalid.illegal.unclosed-string.charset.css"
              },
              "7": {
                name: "invalid.illegal.unexpected-characters.charset.css"
              }
            },
            match: '(?x)        # Possible errors:\n\\G\n((?!@charset)@\\w+)   # Not lowercase (@charset is case-sensitive)\n|\n\\G(\\s+)             # Preceding whitespace\n|\n(@charset\\S[^;]*)    # No whitespace after @charset\n|\n(?<=@charset)         # Before quoted charset name\n(\\x20{2,}|\\t+)      # More than one space used, or a tab\n|\n(?<=@charset\\x20)    # Beginning of charset name\n([^";]+)              # Not double-quoted\n|\n("[^"]+$)             # Unclosed quote\n|\n(?<=")                # After charset name\n([^;]+)               # Unexpected junk instead of semicolon'
          },
          {
            captures: {
              "1": {
                name: "keyword.control.at-rule.charset.css"
              },
              "2": {
                name: "punctuation.definition.keyword.css"
              }
            },
            match: "((@)charset)(?=\\s)"
          },
          {
            begin: '"',
            beginCaptures: {
              "0": {
                name: "punctuation.definition.string.begin.css"
              }
            },
            end: '"|$',
            endCaptures: {
              "0": {
                name: "punctuation.definition.string.end.css"
              }
            },
            name: "string.quoted.double.css",
            patterns: [
              {
                begin: '(?:\\G|^)(?=(?:[^"])+$)',
                end: "$",
                name: "invalid.illegal.unclosed.string.css"
              }
            ]
          }
        ]
      },
      {
        begin: `(?i)((@)import)(?:\\s+|$|(?=['"]|/\\*))`,
        beginCaptures: {
          "1": {
            name: "keyword.control.at-rule.import.css"
          },
          "2": {
            name: "punctuation.definition.keyword.css"
          }
        },
        end: ";",
        endCaptures: {
          "0": {
            name: "punctuation.terminator.rule.css"
          }
        },
        name: "meta.at-rule.import.css",
        patterns: [
          {
            begin: "\\G\\s*(?=/\\*)",
            end: "(?<=\\*/)\\s*",
            patterns: [
              {
                include: "#comment-block"
              }
            ]
          },
          {
            include: "#string"
          },
          {
            include: "#url"
          },
          {
            include: "#media-query-list"
          }
        ]
      },
      {
        begin: "(?i)((@)font-face)(?=\\s*|{|/\\*|$)",
        beginCaptures: {
          "1": {
            name: "keyword.control.at-rule.font-face.css"
          },
          "2": {
            name: "punctuation.definition.keyword.css"
          }
        },
        end: "(?!\\G)",
        name: "meta.at-rule.font-face.css",
        patterns: [
          {
            include: "#comment-block"
          },
          {
            include: "#escapes"
          },
          {
            include: "#rule-list"
          }
        ]
      },
      {
        begin: "(?i)(@)page(?=[\\s:{]|/\\*|$)",
        captures: {
          "0": {
            name: "keyword.control.at-rule.page.css"
          },
          "1": {
            name: "punctuation.definition.keyword.css"
          }
        },
        end: "(?=\\s*($|[:{;]))",
        name: "meta.at-rule.page.css",
        patterns: [
          {
            include: "#rule-list"
          }
        ]
      },
      {
        begin: "(?i)(?=@media(\\s|\\(|/\\*|$))",
        end: "(?<=})(?!\\G)",
        patterns: [
          {
            begin: "(?i)\\G(@)media",
            beginCaptures: {
              "0": {
                name: "keyword.control.at-rule.media.css"
              },
              "1": {
                name: "punctuation.definition.keyword.css"
              }
            },
            end: "(?=\\s*[{;])",
            name: "meta.at-rule.media.header.css",
            patterns: [
              {
                include: "#media-query-list"
              }
            ]
          },
          {
            begin: "{",
            beginCaptures: {
              "0": {
                name: "punctuation.section.media.begin.bracket.curly.css"
              }
            },
            end: "}",
            endCaptures: {
              "0": {
                name: "punctuation.section.media.end.bracket.curly.css"
              }
            },
            name: "meta.at-rule.media.body.css",
            patterns: [
              {
                include: "$self"
              }
            ]
          }
        ]
      },
      {
        begin: `(?i)(?=@counter-style([\\s'"{;]|/\\*|$))`,
        end: "(?<=})(?!\\G)",
        patterns: [
          {
            begin: "(?i)\\G(@)counter-style",
            beginCaptures: {
              "0": {
                name: "keyword.control.at-rule.counter-style.css"
              },
              "1": {
                name: "punctuation.definition.keyword.css"
              }
            },
            end: "(?=\\s*{)",
            name: "meta.at-rule.counter-style.header.css",
            patterns: [
              {
                include: "#comment-block"
              },
              {
                include: "#escapes"
              },
              {
                captures: {
                  "0": {
                    patterns: [
                      {
                        include: "#escapes"
                      }
                    ]
                  }
                },
                match: "(?x)\n(?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n(?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n  |\\\\(?:[0-9a-fA-F]{1,6}|.)\n)*",
                name: "variable.parameter.style-name.css"
              }
            ]
          },
          {
            begin: "{",
            beginCaptures: {
              "0": {
                name: "punctuation.section.property-list.begin.bracket.curly.css"
              }
            },
            end: "}",
            endCaptures: {
              "0": {
                name: "punctuation.section.property-list.end.bracket.curly.css"
              }
            },
            name: "meta.at-rule.counter-style.body.css",
            patterns: [
              {
                include: "#comment-block"
              },
              {
                include: "#escapes"
              },
              {
                include: "#rule-list-innards"
              }
            ]
          }
        ]
      },
      {
        begin: `(?i)(?=@document([\\s'"{;]|/\\*|$))`,
        end: "(?<=})(?!\\G)",
        patterns: [
          {
            begin: "(?i)\\G(@)document",
            beginCaptures: {
              "0": {
                name: "keyword.control.at-rule.document.css"
              },
              "1": {
                name: "punctuation.definition.keyword.css"
              }
            },
            end: "(?=\\s*[{;])",
            name: "meta.at-rule.document.header.css",
            patterns: [
              {
                begin: "(?i)(?<![\\w-])(url-prefix|domain|regexp)(\\()",
                beginCaptures: {
                  "1": {
                    name: "support.function.document-rule.css"
                  },
                  "2": {
                    name: "punctuation.section.function.begin.bracket.round.css"
                  }
                },
                end: "\\)",
                endCaptures: {
                  "0": {
                    name: "punctuation.section.function.end.bracket.round.css"
                  }
                },
                name: "meta.function.document-rule.css",
                patterns: [
                  {
                    include: "#string"
                  },
                  {
                    include: "#comment-block"
                  },
                  {
                    include: "#escapes"
                  },
                  {
                    match: `[^'")\\s]+`,
                    name: "variable.parameter.document-rule.css"
                  }
                ]
              },
              {
                include: "#url"
              },
              {
                include: "#commas"
              },
              {
                include: "#comment-block"
              },
              {
                include: "#escapes"
              }
            ]
          },
          {
            begin: "{",
            beginCaptures: {
              "0": {
                name: "punctuation.section.document.begin.bracket.curly.css"
              }
            },
            end: "}",
            endCaptures: {
              "0": {
                name: "punctuation.section.document.end.bracket.curly.css"
              }
            },
            name: "meta.at-rule.document.body.css",
            patterns: [
              {
                include: "$self"
              }
            ]
          }
        ]
      },
      {
        begin: `(?i)(?=@(?:-(?:webkit|moz|o|ms)-)?keyframes([\\s'"{;]|/\\*|$))`,
        end: "(?<=})(?!\\G)",
        patterns: [
          {
            begin: "(?i)\\G(@)(?:-(?:webkit|moz|o|ms)-)?keyframes",
            beginCaptures: {
              "0": {
                name: "keyword.control.at-rule.keyframes.css"
              },
              "1": {
                name: "punctuation.definition.keyword.css"
              }
            },
            end: "(?=\\s*{)",
            name: "meta.at-rule.keyframes.header.css",
            patterns: [
              {
                include: "#comment-block"
              },
              {
                include: "#escapes"
              },
              {
                captures: {
                  "0": {
                    patterns: [
                      {
                        include: "#escapes"
                      }
                    ]
                  }
                },
                match: "(?x)\n(?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n(?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n  |\\\\(?:[0-9a-fA-F]{1,6}|.)\n)*",
                name: "variable.parameter.keyframe-list.css"
              }
            ]
          },
          {
            begin: "{",
            beginCaptures: {
              "0": {
                name: "punctuation.section.keyframes.begin.bracket.curly.css"
              }
            },
            end: "}",
            endCaptures: {
              "0": {
                name: "punctuation.section.keyframes.end.bracket.curly.css"
              }
            },
            name: "meta.at-rule.keyframes.body.css",
            patterns: [
              {
                include: "#comment-block"
              },
              {
                include: "#escapes"
              },
              {
                captures: {
                  "1": {
                    name: "entity.other.keyframe-offset.css"
                  },
                  "2": {
                    name: "entity.other.keyframe-offset.percentage.css"
                  }
                },
                match: "(?xi)\n(?<![\\w-]) (from|to) (?![\\w-])         # Keywords for 0% | 100%\n|\n([-+]?(?:\\d+(?:\\.\\d+)?|\\.\\d+)%)     # Percentile value"
              },
              {
                include: "#rule-list"
              }
            ]
          }
        ]
      },
      {
        begin: "(?i)(?=@supports(\\s|\\(|/\\*|$))",
        end: "(?<=})(?!\\G)|(?=;)",
        patterns: [
          {
            begin: "(?i)\\G(@)supports",
            beginCaptures: {
              "0": {
                name: "keyword.control.at-rule.supports.css"
              },
              "1": {
                name: "punctuation.definition.keyword.css"
              }
            },
            end: "(?=\\s*[{;])",
            name: "meta.at-rule.supports.header.css",
            patterns: [
              {
                include: "#feature-query-operators"
              },
              {
                include: "#feature-query"
              },
              {
                include: "#comment-block"
              },
              {
                include: "#escapes"
              }
            ]
          },
          {
            begin: "{",
            beginCaptures: {
              "0": {
                name: "punctuation.section.supports.begin.bracket.curly.css"
              }
            },
            end: "}",
            endCaptures: {
              "0": {
                name: "punctuation.section.supports.end.bracket.curly.css"
              }
            },
            name: "meta.at-rule.supports.body.css",
            patterns: [
              {
                include: "$self"
              }
            ]
          }
        ]
      },
      {
        begin: `(?i)((@)(-(ms|o)-)?viewport)(?=[\\s'"{;]|/\\*|$)`,
        beginCaptures: {
          "1": {
            name: "keyword.control.at-rule.viewport.css"
          },
          "2": {
            name: "punctuation.definition.keyword.css"
          }
        },
        end: "(?=\\s*[@{;])",
        name: "meta.at-rule.viewport.css",
        patterns: [
          {
            include: "#comment-block"
          },
          {
            include: "#escapes"
          }
        ]
      },
      {
        begin: `(?i)((@)font-feature-values)(?=[\\s'"{;]|/\\*|$)\\s*`,
        beginCaptures: {
          "1": {
            name: "keyword.control.at-rule.font-feature-values.css"
          },
          "2": {
            name: "punctuation.definition.keyword.css"
          }
        },
        contentName: "variable.parameter.font-name.css",
        end: "(?=\\s*[@{;])",
        name: "meta.at-rule.font-features.css",
        patterns: [
          {
            include: "#comment-block"
          },
          {
            include: "#escapes"
          }
        ]
      },
      {
        include: "#font-features"
      },
      {
        begin: `(?i)((@)namespace)(?=[\\s'";]|/\\*|$)`,
        beginCaptures: {
          "1": {
            name: "keyword.control.at-rule.namespace.css"
          },
          "2": {
            name: "punctuation.definition.keyword.css"
          }
        },
        end: ";|(?=[@{])",
        endCaptures: {
          "0": {
            name: "punctuation.terminator.rule.css"
          }
        },
        name: "meta.at-rule.namespace.css",
        patterns: [
          {
            include: "#url"
          },
          {
            captures: {
              "1": {
                patterns: [
                  {
                    include: "#comment-block"
                  }
                ]
              },
              "2": {
                name: "entity.name.function.namespace-prefix.css",
                patterns: [
                  {
                    include: "#escapes"
                  }
                ]
              }
            },
            match: "(?xi)\n(?:\\G|^|(?<=\\s))\n(?=\n  (?<=\\s|^)                             # Starts with whitespace\n  (?:[-a-zA-Z_]|[^\\x00-\\x7F])          # Then a valid identifier character\n  |\n  \\s*                                   # Possible adjoining whitespace\n  /\\*(?:[^*]|\\*[^/])*\\*/              # Injected comment\n)\n(.*?)                                    # Grouped to embed #comment-block\n(\n  (?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n  (?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n    |\\\\(?:[0-9a-fA-F]{1,6}|.)\n  )*\n)"
          },
          {
            include: "#comment-block"
          },
          {
            include: "#escapes"
          },
          {
            include: "#string"
          }
        ]
      },
      {
        begin: "(?i)(?=@[\\w-]+[^;]+;s*$)",
        end: "(?<=;)(?!\\G)",
        patterns: [
          {
            begin: "(?i)\\G(@)[\\w-]+",
            beginCaptures: {
              "0": {
                name: "keyword.control.at-rule.css"
              },
              "1": {
                name: "punctuation.definition.keyword.css"
              }
            },
            end: ";",
            endCaptures: {
              "0": {
                name: "punctuation.terminator.rule.css"
              }
            },
            name: "meta.at-rule.header.css"
          }
        ]
      },
      {
        begin: "(?i)(?=@[\\w-]+(\\s|\\(|{|/\\*|$))",
        end: "(?<=})(?!\\G)",
        patterns: [
          {
            begin: "(?i)\\G(@)[\\w-]+",
            beginCaptures: {
              "0": {
                name: "keyword.control.at-rule.css"
              },
              "1": {
                name: "punctuation.definition.keyword.css"
              }
            },
            end: "(?=\\s*[{;])",
            name: "meta.at-rule.header.css"
          },
          {
            begin: "{",
            beginCaptures: {
              "0": {
                name: "punctuation.section.begin.bracket.curly.css"
              }
            },
            end: "}",
            endCaptures: {
              "0": {
                name: "punctuation.section.end.bracket.curly.css"
              }
            },
            name: "meta.at-rule.body.css",
            patterns: [
              {
                include: "$self"
              }
            ]
          }
        ]
      }
    ]
  },
  "color-keywords": {
    patterns: [
      {
        match: "(?i)(?<![\\w-])(aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)(?![\\w-])",
        name: "support.constant.color.w3c-standard-color-name.css"
      },
      {
        match: "(?xi) (?<![\\w-])\n(aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood\n|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan\n|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange\n|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise\n|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen\n|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki\n|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow\n|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray\n|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue\n|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise\n|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered\n|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum\n|powderblue|rebeccapurple|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell\n|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato\n|transparent|turquoise|violet|wheat|whitesmoke|yellowgreen)\n(?![\\w-])",
        name: "support.constant.color.w3c-extended-color-name.css"
      },
      {
        match: "(?i)(?<![\\w-])currentColor(?![\\w-])",
        name: "support.constant.color.current.css"
      },
      {
        match: "(?xi) (?<![\\w-])\n(ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow\n|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption\n|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow\n|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText)\n(?![\\w-])",
        name: "invalid.deprecated.color.system.css"
      }
    ]
  },
  combinators: {
    patterns: [
      {
        match: "/deep/|>>>",
        name: "invalid.deprecated.combinator.css"
      },
      {
        match: ">>|>|\\+|~",
        name: "keyword.operator.combinator.css"
      }
    ]
  },
  commas: {
    match: ",",
    name: "punctuation.separator.list.comma.css"
  },
  "comment-block": {
    begin: "/\\*",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.comment.begin.css"
      }
    },
    end: "\\*/",
    endCaptures: {
      "0": {
        name: "punctuation.definition.comment.end.css"
      }
    },
    name: "comment.block.css"
  },
  escapes: {
    patterns: [
      {
        match: "\\\\[0-9a-fA-F]{1,6}",
        name: "constant.character.escape.codepoint.css"
      },
      {
        begin: "\\\\$\\s*",
        end: "^(?<!\\G)",
        name: "constant.character.escape.newline.css"
      },
      {
        match: "\\\\.",
        name: "constant.character.escape.css"
      }
    ]
  },
  "feature-query": {
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.condition.begin.bracket.round.css"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "punctuation.definition.condition.end.bracket.round.css"
      }
    },
    name: "meta.feature-query.css",
    patterns: [
      {
        include: "#feature-query-operators"
      },
      {
        include: "#feature-query"
      }
    ]
  },
  "feature-query-operators": {
    patterns: [
      {
        match: "(?i)(?<=[\\s()]|^|\\*/)(and|not|or)(?=[\\s()]|/\\*|$)",
        name: "keyword.operator.logical.feature.$1.css"
      },
      {
        include: "#rule-list-innards"
      }
    ]
  },
  "font-features": {
    begin: `(?xi)
((@)(annotation|character-variant|ornaments|styleset|stylistic|swash))
(?=[\\s@'"{;]|/\\*|$)`,
    beginCaptures: {
      "1": {
        name: "keyword.control.at-rule.${3:/downcase}.css"
      },
      "2": {
        name: "punctuation.definition.keyword.css"
      }
    },
    end: "(?<=})",
    name: "meta.at-rule.${3:/downcase}.css",
    patterns: [
      {
        begin: "{",
        beginCaptures: {
          "0": {
            name: "punctuation.section.property-list.begin.bracket.curly.css"
          }
        },
        end: "}",
        endCaptures: {
          "0": {
            name: "punctuation.section.property-list.end.bracket.curly.css"
          }
        },
        name: "meta.property-list.font-feature.css",
        patterns: [
          {
            captures: {
              "0": {
                patterns: [
                  {
                    include: "#escapes"
                  }
                ]
              }
            },
            match: "(?x)\n(?: [-a-zA-Z_]    | [^\\x00-\\x7F] )   # First letter\n(?: [-a-zA-Z0-9_] | [^\\x00-\\x7F]     # Remainder of identifier\n  | \\\\(?:[0-9a-fA-F]{1,6}|.)\n)*",
            name: "variable.font-feature.css"
          },
          {
            include: "#rule-list-innards"
          }
        ]
      }
    ]
  },
  functions: {
    patterns: [
      {
        begin: "(?i)(?<![\\w-])(calc)(\\()",
        beginCaptures: {
          "1": {
            name: "support.function.calc.css"
          },
          "2": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        name: "meta.function.calc.css",
        patterns: [
          {
            match: "[*/]|(?<=\\s|^)[-+](?=\\s|$)",
            name: "keyword.operator.arithmetic.css"
          },
          {
            include: "#property-values"
          }
        ]
      },
      {
        begin: "(?i)(?<![\\w-])(rgba?|hsla?)(\\()",
        beginCaptures: {
          "1": {
            name: "support.function.misc.css"
          },
          "2": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        name: "meta.function.color.css",
        patterns: [
          {
            include: "#property-values"
          }
        ]
      },
      {
        begin: '(?xi) (?<![\\w-])\n(\n  (?:-webkit-|-moz-|-o-)?    # Accept prefixed/historical variants\n  (?:repeating-)?            # "Repeating"-type gradient\n  (?:linear|radial|conic)    # Shape\n  -gradient\n)\n(\\()',
        beginCaptures: {
          "1": {
            name: "support.function.gradient.css"
          },
          "2": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        name: "meta.function.gradient.css",
        patterns: [
          {
            match: "(?i)(?<![\\w-])(from|to|at)(?![\\w-])",
            name: "keyword.operator.gradient.css"
          },
          {
            include: "#property-values"
          }
        ]
      },
      {
        begin: "(?i)(?<![\\w-])(-webkit-gradient)(\\()",
        beginCaptures: {
          "1": {
            name: "invalid.deprecated.gradient.function.css"
          },
          "2": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        name: "meta.function.gradient.invalid.deprecated.gradient.css",
        patterns: [
          {
            begin: "(?i)(?<![\\w-])(from|to|color-stop)(\\()",
            beginCaptures: {
              "1": {
                name: "invalid.deprecated.function.css"
              },
              "2": {
                name: "punctuation.section.function.begin.bracket.round.css"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "punctuation.section.function.end.bracket.round.css"
              }
            },
            patterns: [
              {
                include: "#property-values"
              }
            ]
          },
          {
            include: "#property-values"
          }
        ]
      },
      {
        begin: "(?xi) (?<![\\w-])\n(annotation|attr|blur|brightness|character-variant|contrast|counters?\n|cross-fade|drop-shadow|element|fit-content|format|grayscale|hue-rotate\n|image-set|invert|local|minmax|opacity|ornaments|repeat|saturate|sepia\n|styleset|stylistic|swash|symbols)\n(\\()",
        beginCaptures: {
          "1": {
            name: "support.function.misc.css"
          },
          "2": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        name: "meta.function.misc.css",
        patterns: [
          {
            match: `(?i)(?<=[,\\s"]|\\*/|^)\\d+x(?=[\\s,"')]|/\\*|$)`,
            name: "constant.numeric.other.density.css"
          },
          {
            include: "#property-values"
          },
          {
            match: `[^'"),\\s]+`,
            name: "variable.parameter.misc.css"
          }
        ]
      },
      {
        begin: "(?i)(?<![\\w-])(circle|ellipse|inset|polygon|rect)(\\()",
        beginCaptures: {
          "1": {
            name: "support.function.shape.css"
          },
          "2": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        name: "meta.function.shape.css",
        patterns: [
          {
            match: "(?i)(?<=\\s|^|\\*/)(at|round)(?=\\s|/\\*|$)",
            name: "keyword.operator.shape.css"
          },
          {
            include: "#property-values"
          }
        ]
      },
      {
        begin: "(?i)(?<![\\w-])(cubic-bezier|steps)(\\()",
        beginCaptures: {
          "1": {
            name: "support.function.timing-function.css"
          },
          "2": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        name: "meta.function.timing-function.css",
        patterns: [
          {
            match: "(?i)(?<![\\w-])(start|end)(?=\\s*\\)|$)",
            name: "support.constant.step-direction.css"
          },
          {
            include: "#property-values"
          }
        ]
      },
      {
        begin: "(?xi) (?<![\\w-])\n( (?:translate|scale|rotate)(?:[XYZ]|3D)?\n| matrix(?:3D)?\n| skew[XY]?\n| perspective\n)\n(\\()",
        beginCaptures: {
          "1": {
            name: "support.function.transform.css"
          },
          "2": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        patterns: [
          {
            include: "#property-values"
          }
        ]
      },
      {
        include: "#url"
      },
      {
        begin: "(?i)(?<![\\w-])(var)(\\()",
        beginCaptures: {
          "1": {
            name: "support.function.misc.css"
          },
          "2": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        name: "meta.function.variable.css",
        patterns: [
          {
            name: "variable.argument.css",
            match: "(?x)\n--\n(?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n(?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n  |\\\\(?:[0-9a-fA-F]{1,6}|.)\n)*"
          },
          {
            include: "#property-values"
          }
        ]
      }
    ]
  },
  "functional-pseudo-classes": {
    patterns: [
      {
        begin: "(?i)((:)dir)(\\()",
        beginCaptures: {
          "1": {
            name: "entity.other.attribute-name.pseudo-class.css"
          },
          "2": {
            name: "punctuation.definition.entity.css"
          },
          "3": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        patterns: [
          {
            include: "#comment-block"
          },
          {
            include: "#escapes"
          },
          {
            match: "(?i)(?<![\\w-])(ltr|rtl)(?![\\w-])",
            name: "support.constant.text-direction.css"
          },
          {
            include: "#property-values"
          }
        ]
      },
      {
        begin: "(?i)((:)lang)(\\()",
        beginCaptures: {
          "1": {
            name: "entity.other.attribute-name.pseudo-class.css"
          },
          "2": {
            name: "punctuation.definition.entity.css"
          },
          "3": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        patterns: [
          {
            match: "(?<=[(,\\s])[a-zA-Z]+(-[a-zA-Z0-9]*|\\\\(?:[0-9a-fA-F]{1,6}|.))*(?=[),\\s])",
            name: "support.constant.language-range.css"
          },
          {
            begin: '"',
            beginCaptures: {
              "0": {
                name: "punctuation.definition.string.begin.css"
              }
            },
            end: '"',
            endCaptures: {
              "0": {
                name: "punctuation.definition.string.end.css"
              }
            },
            name: "string.quoted.double.css",
            patterns: [
              {
                include: "#escapes"
              },
              {
                match: '(?<=["\\s])[a-zA-Z*]+(-[a-zA-Z0-9*]*)*(?=["\\s])',
                name: "support.constant.language-range.css"
              }
            ]
          },
          {
            begin: "'",
            beginCaptures: {
              "0": {
                name: "punctuation.definition.string.begin.css"
              }
            },
            end: "'",
            endCaptures: {
              "0": {
                name: "punctuation.definition.string.end.css"
              }
            },
            name: "string.quoted.single.css",
            patterns: [
              {
                include: "#escapes"
              },
              {
                match: "(?<=['\\s])[a-zA-Z*]+(-[a-zA-Z0-9*]*)*(?=['\\s])",
                name: "support.constant.language-range.css"
              }
            ]
          },
          {
            include: "#commas"
          }
        ]
      },
      {
        begin: "(?i)((:)(?:not|has|matches))(\\()",
        beginCaptures: {
          "1": {
            name: "entity.other.attribute-name.pseudo-class.css"
          },
          "2": {
            name: "punctuation.definition.entity.css"
          },
          "3": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        patterns: [
          {
            include: "#selector-innards"
          }
        ]
      },
      {
        begin: "(?i)((:)nth-(?:last-)?(?:child|of-type))(\\()",
        beginCaptures: {
          "1": {
            name: "entity.other.attribute-name.pseudo-class.css"
          },
          "2": {
            name: "punctuation.definition.entity.css"
          },
          "3": {
            name: "punctuation.section.function.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.section.function.end.bracket.round.css"
          }
        },
        patterns: [
          {
            match: "(?i)[+-]?(\\d+n?|n)(\\s*[+-]\\s*\\d+)?",
            name: "constant.numeric.css"
          },
          {
            match: "(?i)even|odd",
            name: "support.constant.parity.css"
          }
        ]
      }
    ]
  },
  "media-features": {
    captures: {
      "1": {
        name: "support.type.property-name.media.css"
      },
      "2": {
        name: "support.type.property-name.media.css"
      },
      "3": {
        name: "support.type.vendored.property-name.media.css"
      }
    },
    match: "(?xi)\n(?<=^|\\s|\\(|\\*/)           # Preceded by whitespace, bracket or comment\n(?:\n  # Standardised features\n  (\n    (?:min-|max-)?            # Range features\n    (?: height\n      | width\n      | aspect-ratio\n      | color\n      | color-index\n      | monochrome\n      | resolution\n    )\n    | grid                    # Discrete features\n    | scan\n    | orientation\n    | display-mode\n    | hover\n  )\n  |\n  # Deprecated features\n  (\n    (?:min-|max-)?            # Deprecated in Media Queries 4\n    device-\n    (?: height\n      | width\n      | aspect-ratio\n    )\n  )\n  |\n  # Vendor extensions\n  (\n    (?:\n      # Spec-compliant syntax\n      [-_]\n      (?: webkit              # Webkit/Blink\n        | apple|khtml         # Webkit aliases\n        | epub                # ePub3\n        | moz                 # Gecko\n        | ms                  # Microsoft\n        | o                   # Presto (pre-Opera 15)\n        | xv|ah|rim|atsc|     # Less common vendors\n          hp|tc|wap|ro\n      )\n      |\n      # Non-standard prefixes\n      (?: mso                 # Microsoft Office\n        | prince              # YesLogic\n      )\n    )\n    -\n    [\\w-]+                   # Feature name\n    (?=                       # Terminates correctly\n      \\s*                    # Possible whitespace\n      (?:                     # Possible injected comment\n        /\\*\n        (?:[^*]|\\*[^/])*\n        \\*/\n      )?\n      \\s*\n      [:)]                    # Ends with a colon or closed bracket\n    )\n  )\n)\n(?=\\s|$|[><:=]|\\)|/\\*)     # Terminates cleanly"
  },
  "media-feature-keywords": {
    match: "(?xi)\n(?<=^|\\s|:|\\*/)\n(?: portrait                  # Orientation\n  | landscape\n  | progressive               # Scan types\n  | interlace\n  | fullscreen                # Display modes\n  | standalone\n  | minimal-ui\n  | browser\n  | hover\n)\n(?=\\s|\\)|$)",
    name: "support.constant.property-value.css"
  },
  "media-query": {
    begin: "\\G",
    end: "(?=\\s*[{;])",
    patterns: [
      {
        include: "#comment-block"
      },
      {
        include: "#escapes"
      },
      {
        include: "#media-types"
      },
      {
        match: "(?i)(?<=\\s|^|,|\\*/)(only|not)(?=\\s|{|/\\*|$)",
        name: "keyword.operator.logical.$1.media.css"
      },
      {
        match: "(?i)(?<=\\s|^|\\*/|\\))and(?=\\s|/\\*|$)",
        name: "keyword.operator.logical.and.media.css"
      },
      {
        match: ",(?:(?:\\s*,)+|(?=\\s*[;){]))",
        name: "invalid.illegal.comma.css"
      },
      {
        include: "#commas"
      },
      {
        begin: "\\(",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.parameters.begin.bracket.round.css"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.definition.parameters.end.bracket.round.css"
          }
        },
        patterns: [
          {
            include: "#media-features"
          },
          {
            include: "#media-feature-keywords"
          },
          {
            match: ":",
            name: "punctuation.separator.key-value.css"
          },
          {
            match: ">=|<=|=|<|>",
            name: "keyword.operator.comparison.css"
          },
          {
            captures: {
              "1": {
                name: "constant.numeric.css"
              },
              "2": {
                name: "keyword.operator.arithmetic.css"
              },
              "3": {
                name: "constant.numeric.css"
              }
            },
            match: "(\\d+)\\s*(/)\\s*(\\d+)",
            name: "meta.ratio.css"
          },
          {
            include: "#numeric-values"
          },
          {
            include: "#comment-block"
          }
        ]
      }
    ]
  },
  "media-query-list": {
    begin: "(?=\\s*[^{;])",
    end: "(?=\\s*[{;])",
    patterns: [
      {
        include: "#media-query"
      }
    ]
  },
  "media-types": {
    captures: {
      "1": {
        name: "support.constant.media.css"
      },
      "2": {
        name: "invalid.deprecated.constant.media.css"
      }
    },
    match: "(?xi)\n(?<=^|\\s|,|\\*/)\n(?:\n  # Valid media types\n  (all|print|screen|speech)\n  |\n  # Deprecated in Media Queries 4: http://dev.w3.org/csswg/mediaqueries/#media-types\n  (aural|braille|embossed|handheld|projection|tty|tv)\n)\n(?=$|[{,\\s;]|/\\*)"
  },
  "numeric-values": {
    patterns: [
      {
        captures: {
          "1": {
            name: "punctuation.definition.constant.css"
          }
        },
        match: "(#)(?:[0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})\\b",
        name: "constant.other.color.rgb-value.hex.css"
      },
      {
        captures: {
          "1": {
            name: "keyword.other.unit.percentage.css"
          },
          "2": {
            name: "keyword.other.unit.${2:/downcase}.css"
          }
        },
        match: "(?xi) (?<![\\w-])\n[-+]?                               # Sign indicator\n\n(?:                                 # Numerals\n    [0-9]+ (?:\\.[0-9]+)?           # Integer/float with leading digits\n  | \\.[0-9]+                       # Float without leading digits\n)\n\n(?:                                 # Scientific notation\n  (?<=[0-9])                        # Exponent must follow a digit\n  E                                 # Exponent indicator\n  [-+]?                             # Possible sign indicator\n  [0-9]+                            # Exponent value\n)?\n\n(?:                                 # Possible unit for data-type:\n  (%)                               # - Percentage\n  | ( deg|grad|rad|turn             # - Angle\n    | Hz|kHz                        # - Frequency\n    | ch|cm|em|ex|fr|in|mm|mozmm|   # - Length\n      pc|pt|px|q|rem|vh|vmax|vmin|\n      vw\n    | dpi|dpcm|dppx                 # - Resolution\n    | s|ms                          # - Time\n    )\n  \\b                               # Boundary checking intentionally lax to\n)?                                  # facilitate embedding in CSS-like grammars",
        name: "constant.numeric.css"
      }
    ]
  },
  "property-keywords": {
    patterns: [
      {
        match: "(?xi) (?<![\\w-])\n(above|absolute|active|add|additive|after-edge|alias|all|all-petite-caps|all-scroll|all-small-caps|alpha|alphabetic|alternate|alternate-reverse\n|always|antialiased|auto|auto-pos|available|avoid|avoid-column|avoid-page|avoid-region|backwards|balance|baseline|before-edge|below|bevel\n|bidi-override|blink|block|block-axis|block-start|block-end|bold|bolder|border|border-box|both|bottom|bottom-outside|break-all|break-word|bullets\n|butt|capitalize|caption|cell|center|central|char|circle|clip|clone|close-quote|closest-corner|closest-side|col-resize|collapse|color|color-burn\n|color-dodge|column|column-reverse|common-ligatures|compact|condensed|contain|content|content-box|contents|context-menu|contextual|copy|cover\n|crisp-edges|crispEdges|crosshair|cyclic|darken|dashed|decimal|default|dense|diagonal-fractions|difference|digits|disabled|disc|discretionary-ligatures\n|distribute|distribute-all-lines|distribute-letter|distribute-space|dot|dotted|double|double-circle|downleft|downright|e-resize|each-line|ease|ease-in\n|ease-in-out|ease-out|economy|ellipse|ellipsis|embed|end|evenodd|ew-resize|exact|exclude|exclusion|expanded|extends|extra-condensed|extra-expanded\n|fallback|farthest-corner|farthest-side|fill|fill-available|fill-box|filled|fit-content|fixed|flat|flex|flex-end|flex-start|flip|flow-root|forwards|freeze\n|from-image|full-width|geometricPrecision|georgian|grab|grabbing|grayscale|grid|groove|hand|hanging|hard-light|help|hidden|hide\n|historical-forms|historical-ligatures|horizontal|horizontal-tb|hue|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space\n|ideographic|inactive|infinite|inherit|initial|inline|inline-axis|inline-block|inline-end|inline-flex|inline-grid|inline-list-item|inline-start\n|inline-table|inset|inside|inter-character|inter-ideograph|inter-word|intersect|invert|isolate|isolate-override|italic|jis04|jis78|jis83\n|jis90|justify|justify-all|kannada|keep-all|landscape|large|larger|left|lighten|lighter|line|line-edge|line-through|linear|linearRGB\n|lining-nums|list-item|local|loose|lowercase|lr|lr-tb|ltr|luminance|luminosity|main-size|mandatory|manipulation|manual|margin-box|match-parent\n|match-source|mathematical|max-content|medium|menu|message-box|middle|min-content|miter|mixed|move|multiply|n-resize|narrower|ne-resize\n|nearest-neighbor|nesw-resize|newspaper|no-change|no-clip|no-close-quote|no-common-ligatures|no-contextual|no-discretionary-ligatures\n|no-drop|no-historical-ligatures|no-open-quote|no-repeat|none|nonzero|normal|not-allowed|nowrap|ns-resize|numbers|numeric|nw-resize|nwse-resize\n|oblique|oldstyle-nums|open|open-quote|optimizeLegibility|optimizeQuality|optimizeSpeed|optional|ordinal|outset|outside|over|overlay|overline|padding\n|padding-box|page|painted|pan-down|pan-left|pan-right|pan-up|pan-x|pan-y|paused|petite-caps|pixelated|plaintext|pointer|portrait|pre|pre-line\n|pre-wrap|preserve-3d|progress|progressive|proportional-nums|proportional-width|proximity|radial|recto|region|relative|remove|repeat|repeat-[xy]\n|reset-size|reverse|revert|ridge|right|rl|rl-tb|round|row|row-resize|row-reverse|row-severse|rtl|ruby|ruby-base|ruby-base-container|ruby-text\n|ruby-text-container|run-in|running|s-resize|saturation|scale-down|screen|scroll|scroll-position|se-resize|semi-condensed|semi-expanded|separate\n|sesame|show|sideways|sideways-left|sideways-lr|sideways-right|sideways-rl|simplified|slashed-zero|slice|small|small-caps|small-caption|smaller\n|smooth|soft-light|solid|space|space-around|space-between|space-evenly|spell-out|square|sRGB|stacked-fractions|start|static|status-bar|swap\n|step-end|step-start|sticky|stretch|strict|stroke|stroke-box|style|sub|subgrid|subpixel-antialiased|subtract|super|sw-resize|symbolic|table\n|table-caption|table-cell|table-column|table-column-group|table-footer-group|table-header-group|table-row|table-row-group|tabular-nums|tb|tb-rl\n|text|text-after-edge|text-before-edge|text-bottom|text-top|thick|thin|titling-caps|top|top-outside|touch|traditional|transparent|triangle\n|ultra-condensed|ultra-expanded|under|underline|unicase|unset|upleft|uppercase|upright|use-glyph-orientation|use-script|verso|vertical\n|vertical-ideographic|vertical-lr|vertical-rl|vertical-text|view-box|visible|visibleFill|visiblePainted|visibleStroke|w-resize|wait|wavy\n|weight|whitespace|wider|words|wrap|wrap-reverse|x|x-large|x-small|xx-large|xx-small|y|zero|zoom-in|zoom-out)\n(?![\\w-])",
        name: "support.constant.property-value.css"
      },
      {
        match: "(?xi) (?<![\\w-])\n(arabic-indic|armenian|bengali|cambodian|circle|cjk-decimal|cjk-earthly-branch|cjk-heavenly-stem|cjk-ideographic\n|decimal|decimal-leading-zero|devanagari|disc|disclosure-closed|disclosure-open|ethiopic-halehame-am\n|ethiopic-halehame-ti-e[rt]|ethiopic-numeric|georgian|gujarati|gurmukhi|hangul|hangul-consonant|hebrew\n|hiragana|hiragana-iroha|japanese-formal|japanese-informal|kannada|katakana|katakana-iroha|khmer\n|korean-hangul-formal|korean-hanja-formal|korean-hanja-informal|lao|lower-alpha|lower-armenian|lower-greek\n|lower-latin|lower-roman|malayalam|mongolian|myanmar|oriya|persian|simp-chinese-formal|simp-chinese-informal\n|square|tamil|telugu|thai|tibetan|trad-chinese-formal|trad-chinese-informal|upper-alpha|upper-armenian\n|upper-latin|upper-roman|urdu)\n(?![\\w-])",
        name: "support.constant.property-value.list-style-type.css"
      },
      {
        match: "(?<![\\w-])(?i:-(?:ah|apple|atsc|epub|hp|khtml|moz|ms|o|rim|ro|tc|wap|webkit|xv)|(?:mso|prince))-[a-zA-Z-]+",
        name: "support.constant.vendored.property-value.css"
      },
      {
        match: "(?<![\\w-])(?i:arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|system-ui|system|tahoma|times|trebuchet|ui-monospace|ui-rounded|ui-sans-serif|ui-serif|utopia|verdana|webdings|sans-serif|serif|monospace)(?![\\w-])",
        name: "support.constant.font-name.css"
      }
    ]
  },
  "property-names": {
    patterns: [
      {
        match: "(?xi) (?<![\\w-])\n(?:\n  # Standard CSS\n  additive-symbols|align-content|align-items|align-self|all|animation|animation-delay|animation-direction|animation-duration\n  | animation-fill-mode|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|backdrop-filter\n  | backface-visibility|background|background-attachment|background-blend-mode|background-clip|background-color|background-image\n  | background-origin|background-position|background-position-[xy]|background-repeat|background-size|bleed|block-size|border\n  | border-block-end|border-block-end-color|border-block-end-style|border-block-end-width|border-block-start|border-block-start-color\n  | border-block-start-style|border-block-start-width|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius\n  | border-bottom-style|border-bottom-width|border-collapse|border-color|border-end-end-radius|border-end-start-radius|border-image\n  | border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-inline-end\n  | border-inline-end-color|border-inline-end-style|border-inline-end-width|border-inline-start|border-inline-start-color\n  | border-inline-start-style|border-inline-start-width|border-left|border-left-color|border-left-style|border-left-width\n  | border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-start-end-radius\n  | border-start-start-radius|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style\n  | border-top-width|border-width|bottom|box-decoration-break|box-shadow|box-sizing|break-after|break-before|break-inside|caption-side\n  | caret-color|clear|clip|clip-path|clip-rule|color|print-color-adjust|color-interpolation-filters|column-count|column-fill|column-gap\n  | column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|contain|content|counter-increment\n  | counter-reset|cursor|direction|display|empty-cells|enable-background|fallback|fill|fill-opacity|fill-rule|filter|flex|flex-basis\n  | flex-direction|flex-flow|flex-grow|flex-shrink|flex-wrap|float|flood-color|flood-opacity|font|font-display|font-family\n  | font-feature-settings|font-kerning|font-language-override|font-optical-sizing|font-size|font-size-adjust|font-stretch\n  | font-style|font-synthesis|font-variant|font-variant-alternates|font-variant-caps|font-variant-east-asian|font-variant-ligatures\n  | font-variant-numeric|font-variant-position|font-variation-settings|font-weight|gap|glyph-orientation-horizontal|glyph-orientation-vertical\n  | grid|grid-area|grid-auto-columns|grid-auto-flow|grid-auto-rows|grid-column|grid-column-end|grid-column-gap|grid-column-start\n  | grid-gap|grid-row|grid-row-end|grid-row-gap|grid-row-start|grid-template|grid-template-areas|grid-template-columns|grid-template-rows\n  | hanging-punctuation|height|hyphens|image-orientation|image-rendering|image-resolution|ime-mode|initial-letter|initial-letter-align\n  | inline-size|inset|inset-block|inset-block-end|inset-block-start|inset-inline|inset-inline-end|inset-inline-start|isolation\n  | justify-content|justify-items|justify-self|kerning|left|letter-spacing|lighting-color|line-break|line-clamp|line-height|list-style\n  | list-style-image|list-style-position|list-style-type|margin|margin-block-end|margin-block-start|margin-bottom|margin-inline-end|margin-inline-start\n  | margin-left|margin-right|margin-top|marker-end|marker-mid|marker-start|marks|mask|mask-border|mask-border-mode|mask-border-outset\n  | mask-border-repeat|mask-border-slice|mask-border-source|mask-border-width|mask-clip|mask-composite|mask-image|mask-mode\n  | mask-origin|mask-position|mask-repeat|mask-size|mask-type|max-block-size|max-height|max-inline-size|max-lines|max-width\n  | max-zoom|min-block-size|min-height|min-inline-size|min-width|min-zoom|mix-blend-mode|negative|object-fit|object-position\n  | offset|offset-anchor|offset-distance|offset-path|offset-position|offset-rotation|opacity|order|orientation|orphans\n  | outline|outline-color|outline-offset|outline-style|outline-width|overflow|overflow-anchor|overflow-block|overflow-inline\n  | overflow-wrap|overflow-[xy]|overscroll-behavior|overscroll-behavior-block|overscroll-behavior-inline|overscroll-behavior-[xy]\n  | pad|padding|padding-block-end|padding-block-start|padding-bottom|padding-inline-end|padding-inline-start|padding-left\n  | padding-right|padding-top|page-break-after|page-break-before|page-break-inside|paint-order|perspective|perspective-origin\n  | place-content|place-items|place-self|pointer-events|position|prefix|quotes|range|resize|right|rotate|row-gap|ruby-align\n  | ruby-merge|ruby-position|scale|scroll-behavior|scroll-margin|scroll-margin-block|scroll-margin-block-end|scroll-margin-block-start\n  | scroll-margin-bottom|scroll-margin-inline|scroll-margin-inline-end|scroll-margin-inline-start|scroll-margin-left|scroll-margin-right\n  | scroll-margin-top|scroll-padding|scroll-padding-block|scroll-padding-block-end|scroll-padding-block-start|scroll-padding-bottom\n  | scroll-padding-inline|scroll-padding-inline-end|scroll-padding-inline-start|scroll-padding-left|scroll-padding-right\n  | scroll-padding-top|scroll-snap-align|scroll-snap-coordinate|scroll-snap-destination|scroll-snap-stop|scroll-snap-type\n  | scrollbar-color|scrollbar-gutter|scrollbar-width|shape-image-threshold|shape-margin|shape-outside|shape-rendering|size\n  | speak-as|src|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit\n  | stroke-opacity|stroke-width|suffix|symbols|system|tab-size|table-layout|text-align|text-align-last|text-anchor|text-combine-upright\n  | text-decoration|text-decoration-color|text-decoration-line|text-decoration-skip|text-decoration-skip-ink|text-decoration-style\n  | text-emphasis|text-emphasis-color|text-emphasis-position|text-emphasis-style|text-indent|text-justify|text-orientation\n  | text-overflow|text-rendering|text-shadow|text-size-adjust|text-transform|text-underline-position|top|touch-action|transform\n  | transform-box|transform-origin|transform-style|transition|transition-delay|transition-duration|transition-property|transition-timing-function\n  | translate|unicode-bidi|unicode-range|user-select|user-zoom|vertical-align|visibility|white-space|widows|width|will-change\n  | word-break|word-spacing|word-wrap|writing-mode|z-index|zoom\n\n  # SVG attributes\n  | alignment-baseline|baseline-shift|clip-rule|color-interpolation|color-interpolation-filters|color-profile\n  | color-rendering|cx|cy|dominant-baseline|enable-background|fill|fill-opacity|fill-rule|flood-color|flood-opacity\n  | glyph-orientation-horizontal|glyph-orientation-vertical|height|kerning|lighting-color|marker-end|marker-mid\n  | marker-start|r|rx|ry|shape-rendering|stop-color|stop-opacity|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap\n  | stroke-linejoin|stroke-miterlimit|stroke-opacity|stroke-width|text-anchor|width|x|y\n\n  # Not listed on MDN; presumably deprecated\n  | adjust|after|align|align-last|alignment|alignment-adjust|appearance|attachment|azimuth|background-break\n  | balance|baseline|before|bidi|binding|bookmark|bookmark-label|bookmark-level|bookmark-target|border-length\n  | bottom-color|bottom-left-radius|bottom-right-radius|bottom-style|bottom-width|box|box-align|box-direction\n  | box-flex|box-flex-group|box-lines|box-ordinal-group|box-orient|box-pack|break|character|collapse|column\n  | column-break-after|column-break-before|count|counter|crop|cue|cue-after|cue-before|decoration|decoration-break\n  | delay|display-model|display-role|down|drop|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust\n  | drop-initial-before-align|drop-initial-size|drop-initial-value|duration|elevation|emphasis|family|fit|fit-position\n  | flex-group|float-offset|gap|grid-columns|grid-rows|hanging-punctuation|header|hyphenate|hyphenate-after|hyphenate-before\n  | hyphenate-character|hyphenate-lines|hyphenate-resource|icon|image|increment|indent|index|initial-after-adjust\n  | initial-after-align|initial-before-adjust|initial-before-align|initial-size|initial-value|inline-box-align|iteration-count\n  | justify|label|left-color|left-style|left-width|length|level|line|line-stacking|line-stacking-ruby|line-stacking-shift\n  | line-stacking-strategy|lines|list|mark|mark-after|mark-before|marks|marquee|marquee-direction|marquee-play-count|marquee-speed\n  | marquee-style|max|min|model|move-to|name|nav|nav-down|nav-index|nav-left|nav-right|nav-up|new|numeral|offset|ordinal-group\n  | orient|origin|overflow-style|overhang|pack|page|page-policy|pause|pause-after|pause-before|phonemes|pitch|pitch-range\n  | play-count|play-during|play-state|point|presentation|presentation-level|profile|property|punctuation|punctuation-trim\n  | radius|rate|rendering-intent|repeat|replace|reset|resolution|resource|respond-to|rest|rest-after|rest-before|richness\n  | right-color|right-style|right-width|role|rotation|rotation-point|rows|ruby|ruby-overhang|ruby-span|rule|rule-color\n  | rule-style|rule-width|shadow|size|size-adjust|sizing|space|space-collapse|spacing|span|speak|speak-header|speak-numeral\n  | speak-punctuation|speech|speech-rate|speed|stacking|stacking-ruby|stacking-shift|stacking-strategy|stress|stretch\n  | string-set|style|style-image|style-position|style-type|target|target-name|target-new|target-position|text|text-height\n  | text-justify|text-outline|text-replace|text-wrap|timing-function|top-color|top-left-radius|top-right-radius|top-style\n  | top-width|trim|unicode|up|user-select|variant|voice|voice-balance|voice-duration|voice-family|voice-pitch|voice-pitch-range\n  | voice-rate|voice-stress|voice-volume|volume|weight|white|white-space-collapse|word|wrap\n)\n(?![\\w-])",
        name: "support.type.property-name.css"
      },
      {
        match: "(?<![\\w-])(?i:-(?:ah|apple|atsc|epub|hp|khtml|moz|ms|o|rim|ro|tc|wap|webkit|xv)|(?:mso|prince))-[a-zA-Z-]+",
        name: "support.type.vendored.property-name.css"
      }
    ]
  },
  "property-values": {
    patterns: [
      {
        include: "#commas"
      },
      {
        include: "#comment-block"
      },
      {
        include: "#escapes"
      },
      {
        include: "#functions"
      },
      {
        include: "#property-keywords"
      },
      {
        include: "#unicode-range"
      },
      {
        include: "#numeric-values"
      },
      {
        include: "#color-keywords"
      },
      {
        include: "#string"
      },
      {
        match: "!\\s*important(?![\\w-])",
        name: "keyword.other.important.css"
      }
    ]
  },
  "pseudo-classes": {
    captures: {
      "1": {
        name: "punctuation.definition.entity.css"
      },
      "2": {
        name: "invalid.illegal.colon.css"
      }
    },
    match: "(?xi)\n(:)(:*)\n(?: active|any-link|checked|default|disabled|empty|enabled|first\n  | (?:first|last|only)-(?:child|of-type)|focus|focus-visible|focus-within|fullscreen|host|hover\n  | in-range|indeterminate|invalid|left|link|optional|out-of-range\n  | read-only|read-write|required|right|root|scope|target|unresolved\n  | valid|visited\n)(?![\\w-]|\\s*[;}])",
    name: "entity.other.attribute-name.pseudo-class.css"
  },
  "pseudo-elements": {
    captures: {
      "1": {
        name: "punctuation.definition.entity.css"
      },
      "2": {
        name: "punctuation.definition.entity.css"
      }
    },
    match: "(?xi)\n(?:\n  (::?)                       # Elements using both : and :: notation\n  (?: after\n    | before\n    | first-letter\n    | first-line\n    | (?:-(?:ah|apple|atsc|epub|hp|khtml|moz\n            |ms|o|rim|ro|tc|wap|webkit|xv)\n        | (?:mso|prince))\n      -[a-z-]+\n  )\n  |\n  (::)                        # Double-colon only\n  (?: backdrop\n    | content\n    | grammar-error\n    | marker\n    | placeholder\n    | selection\n    | shadow\n    | spelling-error\n  )\n)\n(?![\\w-]|\\s*[;}])",
    name: "entity.other.attribute-name.pseudo-element.css"
  },
  "rule-list": {
    begin: "{",
    beginCaptures: {
      "0": {
        name: "punctuation.section.property-list.begin.bracket.curly.css"
      }
    },
    end: "}",
    endCaptures: {
      "0": {
        name: "punctuation.section.property-list.end.bracket.curly.css"
      }
    },
    name: "meta.property-list.css",
    patterns: [
      {
        include: "#rule-list-innards"
      }
    ]
  },
  "rule-list-innards": {
    patterns: [
      {
        include: "#comment-block"
      },
      {
        include: "#escapes"
      },
      {
        include: "#font-features"
      },
      {
        match: "(?x) (?<![\\w-])\n--\n(?:[-a-zA-Z_]    | [^\\x00-\\x7F])     # First letter\n(?:[-a-zA-Z0-9_] | [^\\x00-\\x7F]      # Remainder of identifier\n  |\\\\(?:[0-9a-fA-F]{1,6}|.)\n)*",
        name: "variable.css"
      },
      {
        begin: "(?<![-a-zA-Z])(?=[-a-zA-Z])",
        end: "$|(?![-a-zA-Z])",
        name: "meta.property-name.css",
        patterns: [
          {
            include: "#property-names"
          }
        ]
      },
      {
        begin: "(:)\\s*",
        beginCaptures: {
          "1": {
            name: "punctuation.separator.key-value.css"
          }
        },
        end: "\\s*(;)|\\s*(?=}|\\))",
        endCaptures: {
          "1": {
            name: "punctuation.terminator.rule.css"
          }
        },
        contentName: "meta.property-value.css",
        patterns: [
          {
            include: "#comment-block"
          },
          {
            include: "#property-values"
          }
        ]
      },
      {
        match: ";",
        name: "punctuation.terminator.rule.css"
      }
    ]
  },
  selector: {
    begin: "(?x)\n(?=\n  (?:\\|)?                    # Possible anonymous namespace prefix\n  (?:\n    [-\\[:.*\\#a-zA-Z_]       # Valid selector character\n    |\n    [^\\x00-\\x7F]            # Which can include non-ASCII symbols\n    |\n    \\\\                      # Or an escape sequence\n    (?:[0-9a-fA-F]{1,6}|.)\n  )\n)",
    end: "(?=\\s*[/@{)])",
    name: "meta.selector.css",
    patterns: [
      {
        include: "#selector-innards"
      }
    ]
  },
  "selector-innards": {
    patterns: [
      {
        include: "#comment-block"
      },
      {
        include: "#commas"
      },
      {
        include: "#escapes"
      },
      {
        include: "#combinators"
      },
      {
        captures: {
          "1": {
            name: "entity.other.namespace-prefix.css"
          },
          "2": {
            name: "punctuation.separator.css"
          }
        },
        match: "(?x)\n(?:^|(?<=[\\s,(};]))         # Follows whitespace, comma, semicolon, or bracket\n(?!\n  [-\\w*]+\n  \\|\n  (?!\n      [-\\[:.*\\#a-zA-Z_]    # Make sure there's a selector to match\n    | [^\\x00-\\x7F]\n  )\n)\n(\n  (?: [-a-zA-Z_]    | [^\\x00-\\x7F] )   # First letter\n  (?: [-a-zA-Z0-9_] | [^\\x00-\\x7F]     # Remainder of identifier\n    | \\\\(?:[0-9a-fA-F]{1,6}|.)\n  )*\n  |\n  \\*     # Universal namespace\n)?\n(\\|)     # Namespace separator"
      },
      {
        include: "#tag-names"
      },
      {
        match: "\\*",
        name: "entity.name.tag.wildcard.css"
      },
      {
        captures: {
          "1": {
            name: "punctuation.definition.entity.css"
          },
          "2": {
            patterns: [
              {
                include: "#escapes"
              }
            ]
          }
        },
        match: "(?x) (?<![@\\w-])\n([.\\#])\n# Invalid identifier\n(\n  (?:\n    # Starts with ASCII digits, with possible hyphen preceding it\n    -?[0-9]\n    |\n    # Consists of a hyphen only\n    -                                      # Terminated by either:\n    (?= $                                  # - End-of-line\n      | [\\s,.\\#)\\[:{>+~|]               # - Followed by another selector\n      | /\\*                               # - Followed by a block comment\n    )\n    |\n    # Name contains unescaped ASCII symbol\n    (?:                                    # Check for acceptable preceding characters\n        [-a-zA-Z_0-9]|[^\\x00-\\x7F]       # - Valid selector character\n      | \\\\(?:[0-9a-fA-F]{1,6}|.)         # - Escape sequence\n    )*\n    (?:                                    # Invalid punctuation\n      [!\"'%&(*;<?@^`|\\]}]                 # - NOTE: We exempt `)` from the list of checked\n      |                                    #   symbols to avoid matching `:not(.invalid)`\n      / (?!\\*)                            # - Avoid invalidating the start of a comment\n    )+\n  )\n  # Mark remainder of selector invalid\n  (?: [-a-zA-Z_0-9]|[^\\x00-\\x7F]         # - Otherwise valid identifier characters\n    | \\\\(?:[0-9a-fA-F]{1,6}|.)           # - Escape sequence\n  )*\n)",
        name: "invalid.illegal.bad-identifier.css"
      },
      {
        captures: {
          "1": {
            name: "punctuation.definition.entity.css"
          },
          "2": {
            patterns: [
              {
                include: "#escapes"
              }
            ]
          }
        },
        match: "(?x)\n(\\.)                                  # Valid class-name\n(\n  (?: [-a-zA-Z_0-9]|[^\\x00-\\x7F]     # Valid identifier characters\n    | \\\\(?:[0-9a-fA-F]{1,6}|.)       # Escape sequence\n  )+\n)                                      # Followed by either:\n(?= $                                  # - End of the line\n  | [\\s,.\\#)\\[:{>+~|]               # - Another selector\n  | /\\*                               # - A block comment\n)",
        name: "entity.other.attribute-name.class.css"
      },
      {
        captures: {
          "1": {
            name: "punctuation.definition.entity.css"
          },
          "2": {
            patterns: [
              {
                include: "#escapes"
              }
            ]
          }
        },
        match: "(?x)\n(\\#)\n(\n  -?\n  (?![0-9])\n  (?:[-a-zA-Z0-9_]|[^\\x00-\\x7F]|\\\\(?:[0-9a-fA-F]{1,6}|.))+\n)\n(?=$|[\\s,.\\#)\\[:{>+~|]|/\\*)",
        name: "entity.other.attribute-name.id.css"
      },
      {
        begin: "\\[",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.entity.begin.bracket.square.css"
          }
        },
        end: "\\]",
        endCaptures: {
          "0": {
            name: "punctuation.definition.entity.end.bracket.square.css"
          }
        },
        name: "meta.attribute-selector.css",
        patterns: [
          {
            include: "#comment-block"
          },
          {
            include: "#string"
          },
          {
            captures: {
              "1": {
                name: "storage.modifier.ignore-case.css"
              }
            },
            match: `(?<=["'\\s]|^|\\*/)\\s*([iI])\\s*(?=[\\s\\]]|/\\*|$)`
          },
          {
            captures: {
              "1": {
                name: "string.unquoted.attribute-value.css",
                patterns: [
                  {
                    include: "#escapes"
                  }
                ]
              }
            },
            match: `(?x)(?<==)\\s*((?!/\\*)(?:[^\\\\"'\\s\\]]|\\\\.)+)`
          },
          {
            include: "#escapes"
          },
          {
            match: "[~|^$*]?=",
            name: "keyword.operator.pattern.css"
          },
          {
            match: "\\|",
            name: "punctuation.separator.css"
          },
          {
            captures: {
              "1": {
                name: "entity.other.namespace-prefix.css",
                patterns: [
                  {
                    include: "#escapes"
                  }
                ]
              }
            },
            match: "(?x)\n# Qualified namespace prefix\n( -?(?!\\d)(?:[\\w-]|[^\\x00-\\x7F]|\\\\(?:[0-9a-fA-F]{1,6}|.))+\n| \\*\n)\n# Lookahead to ensure there's a valid identifier ahead\n(?=\n  \\| (?!\\s|=|$|\\])\n  (?: -?(?!\\d)\n   |   [\\\\\\w-]\n   |   [^\\x00-\\x7F]\n   )\n)"
          },
          {
            captures: {
              "1": {
                name: "entity.other.attribute-name.css",
                patterns: [
                  {
                    include: "#escapes"
                  }
                ]
              }
            },
            match: "(?x)\n(-?(?!\\d)(?>[\\w-]|[^\\x00-\\x7F]|\\\\(?:[0-9a-fA-F]{1,6}|.))+)\n\\s*\n(?=[~|^\\]$*=]|/\\*)"
          }
        ]
      },
      {
        include: "#pseudo-classes"
      },
      {
        include: "#pseudo-elements"
      },
      {
        include: "#functional-pseudo-classes"
      },
      {
        match: "(?x) (?<![@\\w-])\n(?=            # Custom element names must:\n  [a-z]        # - start with a lowercase ASCII letter,\n  \\w* -       # - contain at least one dash\n)\n(?:\n  (?![A-Z])    # No uppercase ASCII letters are allowed\n  [\\w-]       # Allow any other word character or dash\n)+\n(?![(\\w-])",
        name: "entity.name.tag.custom.css"
      }
    ]
  },
  string: {
    patterns: [
      {
        begin: '"',
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.css"
          }
        },
        end: '"|(?<!\\\\)(?=$|\\n)',
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.end.css"
          }
        },
        name: "string.quoted.double.css",
        patterns: [
          {
            begin: '(?:\\G|^)(?=(?:[^\\\\"]|\\\\.)+$)',
            end: "$",
            name: "invalid.illegal.unclosed.string.css",
            patterns: [
              {
                include: "#escapes"
              }
            ]
          },
          {
            include: "#escapes"
          }
        ]
      },
      {
        begin: "'",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.css"
          }
        },
        end: "'|(?<!\\\\)(?=$|\\n)",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.end.css"
          }
        },
        name: "string.quoted.single.css",
        patterns: [
          {
            begin: "(?:\\G|^)(?=(?:[^\\\\']|\\\\.)+$)",
            end: "$",
            name: "invalid.illegal.unclosed.string.css",
            patterns: [
              {
                include: "#escapes"
              }
            ]
          },
          {
            include: "#escapes"
          }
        ]
      }
    ]
  },
  "tag-names": {
    match: "(?xi) (?<![\\w:-])\n(?:\n    # HTML\n    a|abbr|acronym|address|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound\n  | big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|command\n  | content|data|datalist|dd|del|details|dfn|dialog|dir|div|dl|dt|element|em|embed|fieldset\n  | figcaption|figure|font|footer|form|frame|frameset|h[1-6]|head|header|hgroup|hr|html|i\n  | iframe|image|img|input|ins|isindex|kbd|keygen|label|legend|li|link|listing|main|map|mark\n  | marquee|math|menu|menuitem|meta|meter|multicol|nav|nextid|nobr|noembed|noframes|noscript\n  | object|ol|optgroup|option|output|p|param|picture|plaintext|pre|progress|q|rb|rp|rt|rtc\n  | ruby|s|samp|script|section|select|shadow|slot|small|source|spacer|span|strike|strong\n  | style|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr\n  | track|tt|u|ul|var|video|wbr|xmp\n\n  # SVG\n  | altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform\n  | circle|clipPath|color-profile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix\n  | feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap\n  | feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur\n  | feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting\n  | feSpotLight|feTile|feTurbulence|filter|font-face|font-face-format|font-face-name\n  | font-face-src|font-face-uri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern\n  | line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata\n  | missing-glyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor\n  | stop|svg|switch|symbol|text|textPath|tref|tspan|use|view|vkern\n\n  # MathML\n  | annotation|annotation-xml|maction|maligngroup|malignmark|math|menclose|merror|mfenced\n  | mfrac|mglyph|mi|mlabeledtr|mlongdiv|mmultiscripts|mn|mo|mover|mpadded|mphantom|mroot\n  | mrow|ms|mscarries|mscarry|msgroup|msline|mspace|msqrt|msrow|mstack|mstyle|msub|msubsup\n  | msup|mtable|mtd|mtext|mtr|munder|munderover|semantics\n)\n(?=[+~>\\s,.\\#|){\\[]|/\\*|:[^\\s]|$)",
    name: "entity.name.tag.css"
  },
  "unicode-range": {
    captures: {
      "0": {
        name: "constant.other.unicode-range.css"
      },
      "1": {
        name: "punctuation.separator.dash.unicode-range.css"
      }
    },
    match: "(?<![\\w-])[Uu]\\+[0-9A-Fa-f?]{1,6}(?:(-)[0-9A-Fa-f]{1,6})?(?![\\w-])"
  },
  url: {
    begin: "(?i)(?<![\\w@-])(url)(\\()",
    beginCaptures: {
      "1": {
        name: "support.function.url.css"
      },
      "2": {
        name: "punctuation.section.function.begin.bracket.round.css"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "punctuation.section.function.end.bracket.round.css"
      }
    },
    name: "meta.function.url.css",
    patterns: [
      {
        match: `[^'")\\s]+`,
        name: "variable.parameter.url.css"
      },
      {
        include: "#string"
      },
      {
        include: "#comment-block"
      },
      {
        include: "#escapes"
      }
    ]
  }
};
const css_tmLanguage = {
  information_for_contributors: information_for_contributors$8,
  version: version$8,
  name: name$b,
  scopeName: scopeName$a,
  patterns: patterns$a,
  repository: repository$a
};
const __vite_glob_0_0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: css_tmLanguage,
  information_for_contributors: information_for_contributors$8,
  name: name$b,
  patterns: patterns$a,
  repository: repository$a,
  scopeName: scopeName$a,
  version: version$8
}, Symbol.toStringTag, { value: "Module" }));
const information_for_contributors$7 = [
  "This file has been converted from https://github.com/textmate/html.tmbundle/blob/master/Syntaxes/HTML.plist",
  "If you want to provide a fix or improvement, please create a pull request against the original repository.",
  "Once accepted there, we are happy to receive an update request."
];
const version$7 = "https://github.com/textmate/html.tmbundle/commit/0c3d5ee54de3a993f747f54186b73a4d2d3c44a2";
const name$a = "html";
const scopeName$9 = "text.html.basic";
const injections = {
  "R:text.html - (comment.block, text.html meta.embedded, meta.tag.*.*.html, meta.tag.*.*.*.html, meta.tag.*.*.*.*.html)": {
    comment: "Uses R: to ensure this matches after any other injections.",
    patterns: [
      {
        match: "<",
        name: "invalid.illegal.bad-angle-bracket.html"
      }
    ]
  }
};
const patterns$9 = [
  {
    include: "#xml-processing"
  },
  {
    include: "#comment"
  },
  {
    include: "#doctype"
  },
  {
    include: "#cdata"
  },
  {
    include: "#tags-valid"
  },
  {
    include: "#tags-invalid"
  },
  {
    include: "#entities"
  }
];
const repository$9 = {
  attribute: {
    patterns: [
      {
        begin: "(s(hape|cope|t(ep|art)|ize(s)?|p(ellcheck|an)|elected|lot|andbox|rc(set|doc|lang)?)|h(ttp-equiv|i(dden|gh)|e(ight|aders)|ref(lang)?)|n(o(nce|validate|module)|ame)|c(h(ecked|arset)|ite|o(nt(ent(editable)?|rols)|ords|l(s(pan)?|or))|lass|rossorigin)|t(ype(mustmatch)?|itle|a(rget|bindex)|ranslate)|i(s(map)?|n(tegrity|putmode)|tem(scope|type|id|prop|ref)|d)|op(timum|en)|d(i(sabled|r(name)?)|ownload|e(coding|f(er|ault))|at(etime|a)|raggable)|usemap|p(ing|oster|la(ysinline|ceholder)|attern|reload)|enctype|value|kind|for(m(novalidate|target|enctype|action|method)?)?|w(idth|rap)|l(ist|o(op|w)|a(ng|bel))|a(s(ync)?|c(ce(sskey|pt(-charset)?)|tion)|uto(c(omplete|apitalize)|play|focus)|l(t|low(usermedia|paymentrequest|fullscreen))|bbr)|r(ows(pan)?|e(versed|quired|ferrerpolicy|l|adonly))|m(in(length)?|u(ted|ltiple)|e(thod|dia)|a(nifest|x(length)?)))(?![\\w:-])",
        beginCaptures: {
          "0": {
            name: "entity.other.attribute-name.html"
          }
        },
        comment: "HTML5 attributes, not event handlers",
        end: "(?=\\s*+[^=\\s])",
        name: "meta.attribute.$1.html",
        patterns: [
          {
            include: "#attribute-interior"
          }
        ]
      },
      {
        begin: "style(?![\\w:-])",
        beginCaptures: {
          "0": {
            name: "entity.other.attribute-name.html"
          }
        },
        comment: "HTML5 style attribute",
        end: "(?=\\s*+[^=\\s])",
        name: "meta.attribute.style.html",
        patterns: [
          {
            begin: "=",
            beginCaptures: {
              "0": {
                name: "punctuation.separator.key-value.html"
              }
            },
            end: "(?<=[^\\s=])(?!\\s*=)|(?=/?>)",
            patterns: [
              {
                begin: "(?=[^\\s=<>`/]|/(?!>))",
                end: "(?!\\G)",
                name: "meta.embedded.line.css",
                patterns: [
                  {
                    captures: {
                      "0": {
                        name: "source.css"
                      }
                    },
                    match: "([^\\s\"'=<>`/]|/(?!>))+",
                    name: "string.unquoted.html"
                  },
                  {
                    begin: '"',
                    beginCaptures: {
                      "0": {
                        name: "punctuation.definition.string.begin.html"
                      }
                    },
                    contentName: "source.css",
                    end: '(")',
                    endCaptures: {
                      "0": {
                        name: "punctuation.definition.string.end.html"
                      },
                      "1": {
                        name: "source.css-ignored-vscode"
                      }
                    },
                    name: "string.quoted.double.html",
                    patterns: [
                      {
                        include: "#entities"
                      }
                    ]
                  },
                  {
                    begin: "'",
                    beginCaptures: {
                      "0": {
                        name: "punctuation.definition.string.begin.html"
                      }
                    },
                    contentName: "source.css",
                    end: "(')",
                    endCaptures: {
                      "0": {
                        name: "punctuation.definition.string.end.html"
                      },
                      "1": {
                        name: "source.css-ignored-vscode"
                      }
                    },
                    name: "string.quoted.single.html",
                    patterns: [
                      {
                        include: "#entities"
                      }
                    ]
                  }
                ]
              },
              {
                match: "=",
                name: "invalid.illegal.unexpected-equals-sign.html"
              }
            ]
          }
        ]
      },
      {
        begin: "on(s(croll|t(orage|alled)|u(spend|bmit)|e(curitypolicyviolation|ek(ing|ed)|lect))|hashchange|c(hange|o(ntextmenu|py)|u(t|echange)|l(ick|ose)|an(cel|play(through)?))|t(imeupdate|oggle)|in(put|valid)|o(nline|ffline)|d(urationchange|r(op|ag(start|over|e(n(ter|d)|xit)|leave)?)|blclick)|un(handledrejection|load)|p(opstate|lay(ing)?|a(ste|use|ge(show|hide))|rogress)|e(nded|rror|mptied)|volumechange|key(down|up|press)|focus|w(heel|aiting)|l(oad(start|e(nd|d(data|metadata)))?|anguagechange)|a(uxclick|fterprint|bort)|r(e(s(ize|et)|jectionhandled)|atechange)|m(ouse(o(ut|ver)|down|up|enter|leave|move)|essage(error)?)|b(efore(unload|print)|lur))(?![\\w:-])",
        beginCaptures: {
          "0": {
            name: "entity.other.attribute-name.html"
          }
        },
        comment: "HTML5 attributes, event handlers",
        end: "(?=\\s*+[^=\\s])",
        name: "meta.attribute.event-handler.$1.html",
        patterns: [
          {
            begin: "=",
            beginCaptures: {
              "0": {
                name: "punctuation.separator.key-value.html"
              }
            },
            end: "(?<=[^\\s=])(?!\\s*=)|(?=/?>)",
            patterns: [
              {
                begin: "(?=[^\\s=<>`/]|/(?!>))",
                end: "(?!\\G)",
                name: "meta.embedded.line.js",
                patterns: [
                  {
                    captures: {
                      "0": {
                        name: "source.js"
                      },
                      "1": {
                        patterns: [
                          {
                            include: "source.js"
                          }
                        ]
                      }
                    },
                    match: "(([^\\s\"'=<>`/]|/(?!>))+)",
                    name: "string.unquoted.html"
                  },
                  {
                    begin: '"',
                    beginCaptures: {
                      "0": {
                        name: "punctuation.definition.string.begin.html"
                      }
                    },
                    contentName: "source.js",
                    end: '(")',
                    endCaptures: {
                      "0": {
                        name: "punctuation.definition.string.end.html"
                      },
                      "1": {
                        name: "source.js-ignored-vscode"
                      }
                    },
                    name: "string.quoted.double.html",
                    patterns: [
                      {
                        captures: {
                          "0": {
                            patterns: [
                              {
                                include: "source.js"
                              }
                            ]
                          }
                        },
                        match: '([^\\n"/]|/(?![/*]))+'
                      },
                      {
                        begin: "//",
                        beginCaptures: {
                          "0": {
                            name: "punctuation.definition.comment.js"
                          }
                        },
                        end: '(?=")|\\n',
                        name: "comment.line.double-slash.js"
                      },
                      {
                        begin: "/\\*",
                        beginCaptures: {
                          "0": {
                            name: "punctuation.definition.comment.begin.js"
                          }
                        },
                        end: '(?=")|\\*/',
                        endCaptures: {
                          "0": {
                            name: "punctuation.definition.comment.end.js"
                          }
                        },
                        name: "comment.block.js"
                      }
                    ]
                  },
                  {
                    begin: "'",
                    beginCaptures: {
                      "0": {
                        name: "punctuation.definition.string.begin.html"
                      }
                    },
                    contentName: "source.js",
                    end: "(')",
                    endCaptures: {
                      "0": {
                        name: "punctuation.definition.string.end.html"
                      },
                      "1": {
                        name: "source.js-ignored-vscode"
                      }
                    },
                    name: "string.quoted.single.html",
                    patterns: [
                      {
                        captures: {
                          "0": {
                            patterns: [
                              {
                                include: "source.js"
                              }
                            ]
                          }
                        },
                        match: "([^\\n'/]|/(?![/*]))+"
                      },
                      {
                        begin: "//",
                        beginCaptures: {
                          "0": {
                            name: "punctuation.definition.comment.js"
                          }
                        },
                        end: "(?=')|\\n",
                        name: "comment.line.double-slash.js"
                      },
                      {
                        begin: "/\\*",
                        beginCaptures: {
                          "0": {
                            name: "punctuation.definition.comment.begin.js"
                          }
                        },
                        end: "(?=')|\\*/",
                        endCaptures: {
                          "0": {
                            name: "punctuation.definition.comment.end.js"
                          }
                        },
                        name: "comment.block.js"
                      }
                    ]
                  }
                ]
              },
              {
                match: "=",
                name: "invalid.illegal.unexpected-equals-sign.html"
              }
            ]
          }
        ]
      },
      {
        begin: "(data-[a-z\\-]+)(?![\\w:-])",
        beginCaptures: {
          "0": {
            name: "entity.other.attribute-name.html"
          }
        },
        comment: "HTML5 attributes, data-*",
        end: "(?=\\s*+[^=\\s])",
        name: "meta.attribute.data-x.$1.html",
        patterns: [
          {
            include: "#attribute-interior"
          }
        ]
      },
      {
        begin: "(align|bgcolor|border)(?![\\w:-])",
        beginCaptures: {
          "0": {
            name: "invalid.deprecated.entity.other.attribute-name.html"
          }
        },
        comment: "HTML attributes, deprecated",
        end: "(?=\\s*+[^=\\s])",
        name: "meta.attribute.$1.html",
        patterns: [
          {
            include: "#attribute-interior"
          }
        ]
      },
      {
        begin: `([^\\x{0020}"'<>/=\\x{0000}-\\x{001F}\\x{007F}-\\x{009F}\\x{FDD0}-\\x{FDEF}\\x{FFFE}\\x{FFFF}\\x{1FFFE}\\x{1FFFF}\\x{2FFFE}\\x{2FFFF}\\x{3FFFE}\\x{3FFFF}\\x{4FFFE}\\x{4FFFF}\\x{5FFFE}\\x{5FFFF}\\x{6FFFE}\\x{6FFFF}\\x{7FFFE}\\x{7FFFF}\\x{8FFFE}\\x{8FFFF}\\x{9FFFE}\\x{9FFFF}\\x{AFFFE}\\x{AFFFF}\\x{BFFFE}\\x{BFFFF}\\x{CFFFE}\\x{CFFFF}\\x{DFFFE}\\x{DFFFF}\\x{EFFFE}\\x{EFFFF}\\x{FFFFE}\\x{FFFFF}\\x{10FFFE}\\x{10FFFF}]+)`,
        beginCaptures: {
          "0": {
            name: "entity.other.attribute-name.html"
          }
        },
        comment: "Anything else that is valid",
        end: "(?=\\s*+[^=\\s])",
        name: "meta.attribute.unrecognized.$1.html",
        patterns: [
          {
            include: "#attribute-interior"
          }
        ]
      },
      {
        match: "[^\\s>]+",
        name: "invalid.illegal.character-not-allowed-here.html"
      }
    ]
  },
  "attribute-interior": {
    patterns: [
      {
        begin: "=",
        beginCaptures: {
          "0": {
            name: "punctuation.separator.key-value.html"
          }
        },
        end: "(?<=[^\\s=])(?!\\s*=)|(?=/?>)",
        patterns: [
          {
            match: "([^\\s\"'=<>`/]|/(?!>))+",
            name: "string.unquoted.html"
          },
          {
            begin: '"',
            beginCaptures: {
              "0": {
                name: "punctuation.definition.string.begin.html"
              }
            },
            end: '"',
            endCaptures: {
              "0": {
                name: "punctuation.definition.string.end.html"
              }
            },
            name: "string.quoted.double.html",
            patterns: [
              {
                include: "#entities"
              }
            ]
          },
          {
            begin: "'",
            beginCaptures: {
              "0": {
                name: "punctuation.definition.string.begin.html"
              }
            },
            end: "'",
            endCaptures: {
              "0": {
                name: "punctuation.definition.string.end.html"
              }
            },
            name: "string.quoted.single.html",
            patterns: [
              {
                include: "#entities"
              }
            ]
          },
          {
            match: "=",
            name: "invalid.illegal.unexpected-equals-sign.html"
          }
        ]
      }
    ]
  },
  cdata: {
    begin: "<!\\[CDATA\\[",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.tag.begin.html"
      }
    },
    contentName: "string.other.inline-data.html",
    end: "]]>",
    endCaptures: {
      "0": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    name: "meta.tag.metadata.cdata.html"
  },
  comment: {
    begin: "<!--",
    captures: {
      "0": {
        name: "punctuation.definition.comment.html"
      }
    },
    end: "-->",
    name: "comment.block.html",
    patterns: [
      {
        match: "\\G-?>",
        name: "invalid.illegal.characters-not-allowed-here.html"
      },
      {
        match: "<!--(?!>)|<!-(?=-->)",
        name: "invalid.illegal.characters-not-allowed-here.html"
      },
      {
        match: "--!>",
        name: "invalid.illegal.characters-not-allowed-here.html"
      }
    ]
  },
  "core-minus-invalid": {
    comment: "This should be the root pattern array includes minus #tags-invalid",
    patterns: [
      {
        include: "#xml-processing"
      },
      {
        include: "#comment"
      },
      {
        include: "#doctype"
      },
      {
        include: "#cdata"
      },
      {
        include: "#tags-valid"
      },
      {
        include: "#entities"
      }
    ]
  },
  doctype: {
    begin: "<!(?=(?i:DOCTYPE\\s))",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.tag.begin.html"
      }
    },
    end: ">",
    endCaptures: {
      "0": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    name: "meta.tag.metadata.doctype.html",
    patterns: [
      {
        match: "\\G(?i:DOCTYPE)",
        name: "entity.name.tag.html"
      },
      {
        begin: '"',
        end: '"',
        name: "string.quoted.double.html"
      },
      {
        match: "[^\\s>]+",
        name: "entity.other.attribute-name.html"
      }
    ]
  },
  entities: {
    patterns: [
      {
        captures: {
          "1": {
            name: "punctuation.definition.entity.html"
          },
          "912": {
            name: "punctuation.definition.entity.html"
          }
        },
        comment: "Yes this is a bit ridiculous, there are quite a lot of these",
        match: "(?x)\n						(&)	(?=[a-zA-Z])\n						(\n							(a(s(ymp(eq)?|cr|t)|n(d(slope|d|v|and)?|g(s(t|ph)|zarr|e|le|rt(vb(d)?)?|msd(a(h|c|d|e|f|a|g|b))?)?)|c(y|irc|d|ute|E)?|tilde|o(pf|gon)|uml|p(id|os|prox(eq)?|e|E|acir)?|elig|f(r)?|w(conint|int)|l(pha|e(ph|fsym))|acute|ring|grave|m(p|a(cr|lg))|breve)|A(s(sign|cr)|nd|MP|c(y|irc)|tilde|o(pf|gon)|uml|pplyFunction|fr|Elig|lpha|acute|ring|grave|macr|breve))\n						  | (B(scr|cy|opf|umpeq|e(cause|ta|rnoullis)|fr|a(ckslash|r(v|wed))|reve)|b(s(cr|im(e)?|ol(hsub|b)?|emi)|n(ot|e(quiv)?)|c(y|ong)|ig(s(tar|qcup)|c(irc|up|ap)|triangle(down|up)|o(times|dot|plus)|uplus|vee|wedge)|o(t(tom)?|pf|wtie|x(h(d|u|D|U)?|times|H(d|u|D|U)?|d(R|l|r|L)|u(R|l|r|L)|plus|D(R|l|r|L)|v(R|h|H|l|r|L)?|U(R|l|r|L)|V(R|h|H|l|r|L)?|minus|box))|Not|dquo|u(ll(et)?|mp(e(q)?|E)?)|prime|e(caus(e)?|t(h|ween|a)|psi|rnou|mptyv)|karow|fr|l(ock|k(1(2|4)|34)|a(nk|ck(square|triangle(down|left|right)?|lozenge)))|a(ck(sim(eq)?|cong|prime|epsilon)|r(vee|wed(ge)?))|r(eve|vbar)|brk(tbrk)?))\n						  | (c(s(cr|u(p(e)?|b(e)?))|h(cy|i|eck(mark)?)|ylcty|c(irc|ups(sm)?|edil|a(ps|ron))|tdot|ir(scir|c(eq|le(d(R|circ|S|dash|ast)|arrow(left|right)))?|e|fnint|E|mid)?|o(n(int|g(dot)?)|p(y(sr)?|f|rod)|lon(e(q)?)?|m(p(fn|le(xes|ment))?|ma(t)?))|dot|u(darr(l|r)|p(s|c(up|ap)|or|dot|brcap)?|e(sc|pr)|vee|wed|larr(p)?|r(vearrow(left|right)|ly(eq(succ|prec)|vee|wedge)|arr(m)?|ren))|e(nt(erdot)?|dil|mptyv)|fr|w(conint|int)|lubs(uit)?|a(cute|p(s|c(up|ap)|dot|and|brcup)?|r(on|et))|r(oss|arr))|C(scr|hi|c(irc|onint|edil|aron)|ircle(Minus|Times|Dot|Plus)|Hcy|o(n(tourIntegral|int|gruent)|unterClockwiseContourIntegral|p(f|roduct)|lon(e)?)|dot|up(Cap)?|OPY|e(nterDot|dilla)|fr|lo(seCurly(DoubleQuote|Quote)|ckwiseContourIntegral)|a(yleys|cute|p(italDifferentialD)?)|ross))\n						  | (d(s(c(y|r)|trok|ol)|har(l|r)|c(y|aron)|t(dot|ri(f)?)|i(sin|e|v(ide(ontimes)?|onx)?|am(s|ond(suit)?)?|gamma)|Har|z(cy|igrarr)|o(t(square|plus|eq(dot)?|minus)?|ublebarwedge|pf|wn(harpoon(left|right)|downarrows|arrow)|llar)|d(otseq|a(rr|gger))?|u(har|arr)|jcy|e(lta|g|mptyv)|f(isht|r)|wangle|lc(orn|rop)|a(sh(v)?|leth|rr|gger)|r(c(orn|rop)|bkarow)|b(karow|lac)|Arr)|D(s(cr|trok)|c(y|aron)|Scy|i(fferentialD|a(critical(Grave|Tilde|Do(t|ubleAcute)|Acute)|mond))|o(t(Dot|Equal)?|uble(Right(Tee|Arrow)|ContourIntegral|Do(t|wnArrow)|Up(DownArrow|Arrow)|VerticalBar|L(ong(RightArrow|Left(RightArrow|Arrow))|eft(RightArrow|Tee|Arrow)))|pf|wn(Right(TeeVector|Vector(Bar)?)|Breve|Tee(Arrow)?|arrow|Left(RightVector|TeeVector|Vector(Bar)?)|Arrow(Bar|UpArrow)?))|Zcy|el(ta)?|D(otrahd)?|Jcy|fr|a(shv|rr|gger)))\n						  | (e(s(cr|im|dot)|n(sp|g)|c(y|ir(c)?|olon|aron)|t(h|a)|o(pf|gon)|dot|u(ro|ml)|p(si(v|lon)?|lus|ar(sl)?)|e|D(ot|Dot)|q(s(im|lant(less|gtr))|c(irc|olon)|u(iv(DD)?|est|als)|vparsl)|f(Dot|r)|l(s(dot)?|inters|l)?|a(ster|cute)|r(Dot|arr)|g(s(dot)?|rave)?|x(cl|ist|p(onentiale|ectation))|m(sp(1(3|4))?|pty(set|v)?|acr))|E(s(cr|im)|c(y|irc|aron)|ta|o(pf|gon)|NG|dot|uml|TH|psilon|qu(ilibrium|al(Tilde)?)|fr|lement|acute|grave|x(ists|ponentialE)|m(pty(SmallSquare|VerySmallSquare)|acr)))\n						  | (f(scr|nof|cy|ilig|o(pf|r(k(v)?|all))|jlig|partint|emale|f(ilig|l(ig|lig)|r)|l(tns|lig|at)|allingdotseq|r(own|a(sl|c(1(2|8|3|4|5|6)|78|2(3|5)|3(8|4|5)|45|5(8|6)))))|F(scr|cy|illed(SmallSquare|VerySmallSquare)|o(uriertrf|pf|rAll)|fr))\n						  | (G(scr|c(y|irc|edil)|t|opf|dot|T|Jcy|fr|amma(d)?|reater(Greater|SlantEqual|Tilde|Equal(Less)?|FullEqual|Less)|g|breve)|g(s(cr|im(e|l)?)|n(sim|e(q(q)?)?|E|ap(prox)?)|c(y|irc)|t(c(c|ir)|dot|quest|lPar|r(sim|dot|eq(qless|less)|less|a(pprox|rr)))?|imel|opf|dot|jcy|e(s(cc|dot(o(l)?)?|l(es)?)?|q(slant|q)?|l)?|v(nE|ertneqq)|fr|E(l)?|l(j|E|a)?|a(cute|p|mma(d)?)|rave|g(g)?|breve))\n						  | (h(s(cr|trok|lash)|y(phen|bull)|circ|o(ok(leftarrow|rightarrow)|pf|arr|rbar|mtht)|e(llip|arts(uit)?|rcon)|ks(earow|warow)|fr|a(irsp|lf|r(dcy|r(cir|w)?)|milt)|bar|Arr)|H(s(cr|trok)|circ|ilbertSpace|o(pf|rizontalLine)|ump(DownHump|Equal)|fr|a(cek|t)|ARDcy))\n						  | (i(s(cr|in(s(v)?|dot|v|E)?)|n(care|t(cal|prod|e(rcal|gers)|larhk)?|odot|fin(tie)?)?|c(y|irc)?|t(ilde)?|i(nfin|i(nt|int)|ota)?|o(cy|ta|pf|gon)|u(kcy|ml)|jlig|prod|e(cy|xcl)|quest|f(f|r)|acute|grave|m(of|ped|a(cr|th|g(part|e|line))))|I(scr|n(t(e(rsection|gral))?|visible(Comma|Times))|c(y|irc)|tilde|o(ta|pf|gon)|dot|u(kcy|ml)|Ocy|Jlig|fr|Ecy|acute|grave|m(plies|a(cr|ginaryI))?))\n						  | (j(s(cr|ercy)|c(y|irc)|opf|ukcy|fr|math)|J(s(cr|ercy)|c(y|irc)|opf|ukcy|fr))\n						  | (k(scr|hcy|c(y|edil)|opf|jcy|fr|appa(v)?|green)|K(scr|c(y|edil)|Hcy|opf|Jcy|fr|appa))\n						  | (l(s(h|cr|trok|im(e|g)?|q(uo(r)?|b)|aquo)|h(ar(d|u(l)?)|blk)|n(sim|e(q(q)?)?|E|ap(prox)?)|c(y|ub|e(il|dil)|aron)|Barr|t(hree|c(c|ir)|imes|dot|quest|larr|r(i(e|f)?|Par))?|Har|o(ng(left(arrow|rightarrow)|rightarrow|mapsto)|times|z(enge|f)?|oparrow(left|right)|p(f|lus|ar)|w(ast|bar)|a(ng|rr)|brk)|d(sh|ca|quo(r)?|r(dhar|ushar))|ur(dshar|uhar)|jcy|par(lt)?|e(s(s(sim|dot|eq(qgtr|gtr)|approx|gtr)|cc|dot(o(r)?)?|g(es)?)?|q(slant|q)?|ft(harpoon(down|up)|threetimes|leftarrows|arrow(tail)?|right(squigarrow|harpoons|arrow(s)?))|g)?|v(nE|ertneqq)|f(isht|loor|r)|E(g)?|l(hard|corner|tri|arr)?|a(ng(d|le)?|cute|t(e(s)?|ail)?|p|emptyv|quo|rr(sim|hk|tl|pl|fs|lp|b(fs)?)?|gran|mbda)|r(har(d)?|corner|tri|arr|m)|g(E)?|m(idot|oust(ache)?)|b(arr|r(k(sl(d|u)|e)|ac(e|k))|brk)|A(tail|arr|rr))|L(s(h|cr|trok)|c(y|edil|aron)|t|o(ng(RightArrow|left(arrow|rightarrow)|rightarrow|Left(RightArrow|Arrow))|pf|wer(RightArrow|LeftArrow))|T|e(ss(Greater|SlantEqual|Tilde|EqualGreater|FullEqual|Less)|ft(Right(Vector|Arrow)|Ceiling|T(ee(Vector|Arrow)?|riangle(Bar|Equal)?)|Do(ubleBracket|wn(TeeVector|Vector(Bar)?))|Up(TeeVector|DownVector|Vector(Bar)?)|Vector(Bar)?|arrow|rightarrow|Floor|A(ngleBracket|rrow(RightArrow|Bar)?)))|Jcy|fr|l(eftarrow)?|a(ng|cute|placetrf|rr|mbda)|midot))\n						  | (M(scr|cy|inusPlus|opf|u|e(diumSpace|llintrf)|fr|ap)|m(s(cr|tpos)|ho|nplus|c(y|omma)|i(nus(d(u)?|b)?|cro|d(cir|dot|ast)?)|o(dels|pf)|dash|u(ltimap|map)?|p|easuredangle|DDot|fr|l(cp|dr)|a(cr|p(sto(down|up|left)?)?|l(t(ese)?|e)|rker)))\n						  | (n(s(hort(parallel|mid)|c(cue|e|r)?|im(e(q)?)?|u(cc(eq)?|p(set(eq(q)?)?|e|E)?|b(set(eq(q)?)?|e|E)?)|par|qsu(pe|be)|mid)|Rightarrow|h(par|arr|Arr)|G(t(v)?|g)|c(y|ong(dot)?|up|edil|a(p|ron))|t(ilde|lg|riangle(left(eq)?|right(eq)?)|gl)|i(s(d)?|v)?|o(t(ni(v(c|a|b))?|in(dot|v(c|a|b)|E)?)?|pf)|dash|u(m(sp|ero)?)?|jcy|p(olint|ar(sl|t|allel)?|r(cue|e(c(eq)?)?)?)|e(s(im|ear)|dot|quiv|ar(hk|r(ow)?)|xist(s)?|Arr)?|v(sim|infin|Harr|dash|Dash|l(t(rie)?|e|Arr)|ap|r(trie|Arr)|g(t|e))|fr|w(near|ar(hk|r(ow)?)|Arr)|V(dash|Dash)|l(sim|t(ri(e)?)?|dr|e(s(s)?|q(slant|q)?|ft(arrow|rightarrow))?|E|arr|Arr)|a(ng|cute|tur(al(s)?)?|p(id|os|prox|E)?|bla)|r(tri(e)?|ightarrow|arr(c|w)?|Arr)|g(sim|t(r)?|e(s|q(slant|q)?)?|E)|mid|L(t(v)?|eft(arrow|rightarrow)|l)|b(sp|ump(e)?))|N(scr|c(y|edil|aron)|tilde|o(nBreakingSpace|Break|t(R(ightTriangle(Bar|Equal)?|everseElement)|Greater(Greater|SlantEqual|Tilde|Equal|FullEqual|Less)?|S(u(cceeds(SlantEqual|Tilde|Equal)?|perset(Equal)?|bset(Equal)?)|quareSu(perset(Equal)?|bset(Equal)?))|Hump(DownHump|Equal)|Nested(GreaterGreater|LessLess)|C(ongruent|upCap)|Tilde(Tilde|Equal|FullEqual)?|DoubleVerticalBar|Precedes(SlantEqual|Equal)?|E(qual(Tilde)?|lement|xists)|VerticalBar|Le(ss(Greater|SlantEqual|Tilde|Equal|Less)?|ftTriangle(Bar|Equal)?))?|pf)|u|e(sted(GreaterGreater|LessLess)|wLine|gative(MediumSpace|Thi(nSpace|ckSpace)|VeryThinSpace))|Jcy|fr|acute))\n						  | (o(s(cr|ol|lash)|h(m|bar)|c(y|ir(c)?)|ti(lde|mes(as)?)|S|int|opf|d(sold|iv|ot|ash|blac)|uml|p(erp|lus|ar)|elig|vbar|f(cir|r)|l(c(ir|ross)|t|ine|arr)|a(st|cute)|r(slope|igof|or|d(er(of)?|f|m)?|v|arr)?|g(t|on|rave)|m(i(nus|cron|d)|ega|acr))|O(s(cr|lash)|c(y|irc)|ti(lde|mes)|opf|dblac|uml|penCurly(DoubleQuote|Quote)|ver(B(ar|rac(e|ket))|Parenthesis)|fr|Elig|acute|r|grave|m(icron|ega|acr)))\n						  | (p(s(cr|i)|h(i(v)?|one|mmat)|cy|i(tchfork|v)?|o(intint|und|pf)|uncsp|er(cnt|tenk|iod|p|mil)|fr|l(us(sim|cir|two|d(o|u)|e|acir|mn|b)?|an(ck(h)?|kv))|ar(s(im|l)|t|a(llel)?)?|r(sim|n(sim|E|ap)|cue|ime(s)?|o(d|p(to)?|f(surf|line|alar))|urel|e(c(sim|n(sim|eqq|approx)|curlyeq|eq|approx)?)?|E|ap)?|m)|P(s(cr|i)|hi|cy|i|o(incareplane|pf)|fr|lusMinus|artialD|r(ime|o(duct|portion(al)?)|ecedes(SlantEqual|Tilde|Equal)?)?))\n						  | (q(scr|int|opf|u(ot|est(eq)?|at(int|ernions))|prime|fr)|Q(scr|opf|UOT|fr))\n						  | (R(s(h|cr)|ho|c(y|edil|aron)|Barr|ight(Ceiling|T(ee(Vector|Arrow)?|riangle(Bar|Equal)?)|Do(ubleBracket|wn(TeeVector|Vector(Bar)?))|Up(TeeVector|DownVector|Vector(Bar)?)|Vector(Bar)?|arrow|Floor|A(ngleBracket|rrow(Bar|LeftArrow)?))|o(undImplies|pf)|uleDelayed|e(verse(UpEquilibrium|E(quilibrium|lement)))?|fr|EG|a(ng|cute|rr(tl)?)|rightarrow)|r(s(h|cr|q(uo(r)?|b)|aquo)|h(o(v)?|ar(d|u(l)?))|nmid|c(y|ub|e(il|dil)|aron)|Barr|t(hree|imes|ri(e|f|ltri)?)|i(singdotseq|ng|ght(squigarrow|harpoon(down|up)|threetimes|left(harpoons|arrows)|arrow(tail)?|rightarrows))|Har|o(times|p(f|lus|ar)|a(ng|rr)|brk)|d(sh|ca|quo(r)?|ldhar)|uluhar|p(polint|ar(gt)?)|e(ct|al(s|ine|part)?|g)|f(isht|loor|r)|l(har|arr|m)|a(ng(d|e|le)?|c(ute|e)|t(io(nals)?|ail)|dic|emptyv|quo|rr(sim|hk|c|tl|pl|fs|w|lp|ap|b(fs)?)?)|rarr|x|moust(ache)?|b(arr|r(k(sl(d|u)|e)|ac(e|k))|brk)|A(tail|arr|rr)))\n						  | (s(s(cr|tarf|etmn|mile)|h(y|c(hcy|y)|ort(parallel|mid)|arp)|c(sim|y|n(sim|E|ap)|cue|irc|polint|e(dil)?|E|a(p|ron))?|t(ar(f)?|r(ns|aight(phi|epsilon)))|i(gma(v|f)?|m(ne|dot|plus|e(q)?|l(E)?|rarr|g(E)?)?)|zlig|o(pf|ftcy|l(b(ar)?)?)|dot(e|b)?|u(ng|cc(sim|n(sim|eqq|approx)|curlyeq|eq|approx)?|p(s(im|u(p|b)|et(neq(q)?|eq(q)?)?)|hs(ol|ub)|1|n(e|E)|2|d(sub|ot)|3|plus|e(dot)?|E|larr|mult)?|m|b(s(im|u(p|b)|et(neq(q)?|eq(q)?)?)|n(e|E)|dot|plus|e(dot)?|E|rarr|mult)?)|pa(des(uit)?|r)|e(swar|ct|tm(n|inus)|ar(hk|r(ow)?)|xt|mi|Arr)|q(su(p(set(eq)?|e)?|b(set(eq)?|e)?)|c(up(s)?|ap(s)?)|u(f|ar(e|f))?)|fr(own)?|w(nwar|ar(hk|r(ow)?)|Arr)|larr|acute|rarr|m(t(e(s)?)?|i(d|le)|eparsl|a(shp|llsetminus))|bquo)|S(scr|hort(RightArrow|DownArrow|UpArrow|LeftArrow)|c(y|irc|edil|aron)?|tar|igma|H(cy|CHcy)|opf|u(c(hThat|ceeds(SlantEqual|Tilde|Equal)?)|p(set|erset(Equal)?)?|m|b(set(Equal)?)?)|OFTcy|q(uare(Su(perset(Equal)?|bset(Equal)?)|Intersection|Union)?|rt)|fr|acute|mallCircle))\n						  | (t(s(hcy|c(y|r)|trok)|h(i(nsp|ck(sim|approx))|orn|e(ta(sym|v)?|re(4|fore))|k(sim|ap))|c(y|edil|aron)|i(nt|lde|mes(d|b(ar)?)?)|o(sa|p(cir|f(ork)?|bot)?|ea)|dot|prime|elrec|fr|w(ixt|ohead(leftarrow|rightarrow))|a(u|rget)|r(i(sb|time|dot|plus|e|angle(down|q|left(eq)?|right(eq)?)?|minus)|pezium|ade)|brk)|T(s(cr|trok)|RADE|h(i(nSpace|ckSpace)|e(ta|refore))|c(y|edil|aron)|S(cy|Hcy)|ilde(Tilde|Equal|FullEqual)?|HORN|opf|fr|a(u|b)|ripleDot))\n						  | (u(scr|h(ar(l|r)|blk)|c(y|irc)|t(ilde|dot|ri(f)?)|Har|o(pf|gon)|d(har|arr|blac)|u(arr|ml)|p(si(h|lon)?|harpoon(left|right)|downarrow|uparrows|lus|arrow)|f(isht|r)|wangle|l(c(orn(er)?|rop)|tri)|a(cute|rr)|r(c(orn(er)?|rop)|tri|ing)|grave|m(l|acr)|br(cy|eve)|Arr)|U(scr|n(ion(Plus)?|der(B(ar|rac(e|ket))|Parenthesis))|c(y|irc)|tilde|o(pf|gon)|dblac|uml|p(si(lon)?|downarrow|Tee(Arrow)?|per(RightArrow|LeftArrow)|DownArrow|Equilibrium|arrow|Arrow(Bar|DownArrow)?)|fr|a(cute|rr(ocir)?)|ring|grave|macr|br(cy|eve)))\n						  | (v(s(cr|u(pn(e|E)|bn(e|E)))|nsu(p|b)|cy|Bar(v)?|zigzag|opf|dash|prop|e(e(eq|bar)?|llip|r(t|bar))|Dash|fr|ltri|a(ngrt|r(s(igma|u(psetneq(q)?|bsetneq(q)?))|nothing|t(heta|riangle(left|right))|p(hi|i|ropto)|epsilon|kappa|r(ho)?))|rtri|Arr)|V(scr|cy|opf|dash(l)?|e(e|r(yThinSpace|t(ical(Bar|Separator|Tilde|Line))?|bar))|Dash|vdash|fr|bar))\n						  | (w(scr|circ|opf|p|e(ierp|d(ge(q)?|bar))|fr|r(eath)?)|W(scr|circ|opf|edge|fr))\n						  | (X(scr|i|opf|fr)|x(s(cr|qcup)|h(arr|Arr)|nis|c(irc|up|ap)|i|o(time|dot|p(f|lus))|dtri|u(tri|plus)|vee|fr|wedge|l(arr|Arr)|r(arr|Arr)|map))\n						  | (y(scr|c(y|irc)|icy|opf|u(cy|ml)|en|fr|ac(y|ute))|Y(scr|c(y|irc)|opf|uml|Icy|Ucy|fr|acute|Acy))\n						  | (z(scr|hcy|c(y|aron)|igrarr|opf|dot|e(ta|etrf)|fr|w(nj|j)|acute)|Z(scr|c(y|aron)|Hcy|opf|dot|e(ta|roWidthSpace)|fr|acute))\n						)\n						(;)\n					",
        name: "constant.character.entity.named.$2.html"
      },
      {
        captures: {
          "1": {
            name: "punctuation.definition.entity.html"
          },
          "3": {
            name: "punctuation.definition.entity.html"
          }
        },
        match: "(&)#[0-9]+(;)",
        name: "constant.character.entity.numeric.decimal.html"
      },
      {
        captures: {
          "1": {
            name: "punctuation.definition.entity.html"
          },
          "3": {
            name: "punctuation.definition.entity.html"
          }
        },
        match: "(&)#[xX][0-9a-fA-F]+(;)",
        name: "constant.character.entity.numeric.hexadecimal.html"
      },
      {
        match: "&(?=[a-zA-Z0-9]+;)",
        name: "invalid.illegal.ambiguous-ampersand.html"
      }
    ]
  },
  math: {
    patterns: [
      {
        begin: `(?i)(<)(math)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`,
        beginCaptures: {
          "0": {
            name: "meta.tag.structure.$2.start.html"
          },
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            patterns: [
              {
                include: "#attribute"
              }
            ]
          },
          "5": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?i)(</)(\\2)\\s*(>)",
        endCaptures: {
          "0": {
            name: "meta.tag.structure.$2.end.html"
          },
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.element.structure.$2.html",
        patterns: [
          {
            begin: "(?<!>)\\G",
            end: ">",
            endCaptures: {
              "0": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.tag.structure.start.html",
            patterns: [
              {
                include: "#attribute"
              }
            ]
          },
          {
            include: "#tags"
          }
        ]
      }
    ],
    repository: {
      attribute: {
        patterns: [
          {
            begin: "(s(hift|ymmetric|cript(sizemultiplier|level|minsize)|t(ackalign|retchy)|ide|u(pscriptshift|bscriptshift)|e(parator(s)?|lection)|rc)|h(eight|ref)|n(otation|umalign)|c(haralign|olumn(spa(n|cing)|width|lines|align)|lose|rossout)|i(n(dent(shift(first|last)?|target|align(first|last)?)|fixlinebreakstyle)|d)|o(pen|verflow)|d(i(splay(style)?|r)|e(nomalign|cimalpoint|pth))|position|e(dge|qual(columns|rows))|voffset|f(orm|ence|rame(spacing)?)|width|l(space|ine(thickness|leading|break(style|multchar)?)|o(ngdivstyle|cation)|ength|quote|argeop)|a(c(cent(under)?|tiontype)|l(t(text|img(-(height|valign|width))?)|ign(mentscope)?))|r(space|ow(spa(n|cing)|lines|align)|quote)|groupalign|x(link:href|mlns)|m(in(size|labelspacing)|ovablelimits|a(th(size|color|variant|background)|xsize))|bevelled)(?![\\w:-])",
            beginCaptures: {
              "0": {
                name: "entity.other.attribute-name.html"
              }
            },
            end: "(?=\\s*+[^=\\s])",
            name: "meta.attribute.$1.html",
            patterns: [
              {
                include: "#attribute-interior"
              }
            ]
          },
          {
            begin: `([^\\x{0020}"'<>/=\\x{0000}-\\x{001F}\\x{007F}-\\x{009F}\\x{FDD0}-\\x{FDEF}\\x{FFFE}\\x{FFFF}\\x{1FFFE}\\x{1FFFF}\\x{2FFFE}\\x{2FFFF}\\x{3FFFE}\\x{3FFFF}\\x{4FFFE}\\x{4FFFF}\\x{5FFFE}\\x{5FFFF}\\x{6FFFE}\\x{6FFFF}\\x{7FFFE}\\x{7FFFF}\\x{8FFFE}\\x{8FFFF}\\x{9FFFE}\\x{9FFFF}\\x{AFFFE}\\x{AFFFF}\\x{BFFFE}\\x{BFFFF}\\x{CFFFE}\\x{CFFFF}\\x{DFFFE}\\x{DFFFF}\\x{EFFFE}\\x{EFFFF}\\x{FFFFE}\\x{FFFFF}\\x{10FFFE}\\x{10FFFF}]+)`,
            beginCaptures: {
              "0": {
                name: "entity.other.attribute-name.html"
              }
            },
            comment: "Anything else that is valid",
            end: "(?=\\s*+[^=\\s])",
            name: "meta.attribute.unrecognized.$1.html",
            patterns: [
              {
                include: "#attribute-interior"
              }
            ]
          },
          {
            match: "[^\\s>]+",
            name: "invalid.illegal.character-not-allowed-here.html"
          }
        ]
      },
      tags: {
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#cdata"
          },
          {
            captures: {
              "0": {
                name: "meta.tag.structure.math.$2.void.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            match: `(?i)(<)(annotation|annotation-xml|semantics|menclose|merror|mfenced|mfrac|mpadded|mphantom|mroot|mrow|msqrt|mstyle|mmultiscripts|mover|mprescripts|msub|msubsup|msup|munder|munderover|none|mlabeledtr|mtable|mtd|mtr|mlongdiv|mscarries|mscarry|msgroup|msline|msrow|mstack|maction)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`,
            name: "meta.element.structure.math.$2.html"
          },
          {
            begin: `(?i)(<)(annotation|annotation-xml|semantics|menclose|merror|mfenced|mfrac|mpadded|mphantom|mroot|mrow|msqrt|mstyle|mmultiscripts|mover|mprescripts|msub|msubsup|msup|munder|munderover|none|mlabeledtr|mtable|mtd|mtr|mlongdiv|mscarries|mscarry|msgroup|msline|msrow|mstack|maction)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`,
            beginCaptures: {
              "0": {
                name: "meta.tag.structure.math.$2.start.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            end: "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)",
            endCaptures: {
              "0": {
                name: "meta.tag.structure.math.$2.end.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "punctuation.definition.tag.end.html"
              },
              "4": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.element.structure.math.$2.html",
            patterns: [
              {
                begin: "(?<!>)\\G",
                end: "(?=/>)|>",
                endCaptures: {
                  "0": {
                    name: "punctuation.definition.tag.end.html"
                  }
                },
                name: "meta.tag.structure.start.html",
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              {
                include: "#tags"
              }
            ]
          },
          {
            captures: {
              "0": {
                name: "meta.tag.inline.math.$2.void.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            match: `(?i)(<)(mi|mn|mo|ms|mspace|mtext|maligngroup|malignmark)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`,
            name: "meta.element.inline.math.$2.html"
          },
          {
            begin: `(?i)(<)(mi|mn|mo|ms|mspace|mtext|maligngroup|malignmark)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`,
            beginCaptures: {
              "0": {
                name: "meta.tag.inline.math.$2.start.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            end: "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)",
            endCaptures: {
              "0": {
                name: "meta.tag.inline.math.$2.end.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "punctuation.definition.tag.end.html"
              },
              "4": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.element.inline.math.$2.html",
            patterns: [
              {
                begin: "(?<!>)\\G",
                end: "(?=/>)|>",
                endCaptures: {
                  "0": {
                    name: "punctuation.definition.tag.end.html"
                  }
                },
                name: "meta.tag.inline.start.html",
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              {
                include: "#tags"
              }
            ]
          },
          {
            captures: {
              "0": {
                name: "meta.tag.object.math.$2.void.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            match: `(?i)(<)(mglyph)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`,
            name: "meta.element.object.math.$2.html"
          },
          {
            begin: `(?i)(<)(mglyph)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`,
            beginCaptures: {
              "0": {
                name: "meta.tag.object.math.$2.start.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            end: "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)",
            endCaptures: {
              "0": {
                name: "meta.tag.object.math.$2.end.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "punctuation.definition.tag.end.html"
              },
              "4": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.element.object.math.$2.html",
            patterns: [
              {
                begin: "(?<!>)\\G",
                end: "(?=/>)|>",
                endCaptures: {
                  "0": {
                    name: "punctuation.definition.tag.end.html"
                  }
                },
                name: "meta.tag.object.start.html",
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              {
                include: "#tags"
              }
            ]
          },
          {
            captures: {
              "0": {
                name: "meta.tag.other.invalid.void.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "invalid.illegal.unrecognized-tag.html"
              },
              "4": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "6": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            match: `(?i)(<)(([\\w:]+))(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`,
            name: "meta.element.other.invalid.html"
          },
          {
            begin: `(?i)(<)((\\w[^\\s>]*))(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`,
            beginCaptures: {
              "0": {
                name: "meta.tag.other.invalid.start.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "invalid.illegal.unrecognized-tag.html"
              },
              "4": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "6": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            end: "(?i)(</)((\\2))\\s*(>)|(/>)|(?=</\\w+)",
            endCaptures: {
              "0": {
                name: "meta.tag.other.invalid.end.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "invalid.illegal.unrecognized-tag.html"
              },
              "4": {
                name: "punctuation.definition.tag.end.html"
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.element.other.invalid.html",
            patterns: [
              {
                begin: "(?<!>)\\G",
                end: "(?=/>)|>",
                endCaptures: {
                  "0": {
                    name: "punctuation.definition.tag.end.html"
                  }
                },
                name: "meta.tag.other.invalid.start.html",
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              {
                include: "#tags"
              }
            ]
          },
          {
            include: "#tags-invalid"
          }
        ]
      }
    }
  },
  svg: {
    patterns: [
      {
        begin: `(?i)(<)(svg)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`,
        beginCaptures: {
          "0": {
            name: "meta.tag.structure.$2.start.html"
          },
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            patterns: [
              {
                include: "#attribute"
              }
            ]
          },
          "5": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?i)(</)(\\2)\\s*(>)",
        endCaptures: {
          "0": {
            name: "meta.tag.structure.$2.end.html"
          },
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.element.structure.$2.html",
        patterns: [
          {
            begin: "(?<!>)\\G",
            end: ">",
            endCaptures: {
              "0": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.tag.structure.start.html",
            patterns: [
              {
                include: "#attribute"
              }
            ]
          },
          {
            include: "#tags"
          }
        ]
      }
    ],
    repository: {
      attribute: {
        patterns: [
          {
            begin: "(s(hape-rendering|ystemLanguage|cale|t(yle|itchTiles|op-(color|opacity)|dDeviation|em(h|v)|artOffset|r(i(ng|kethrough-(thickness|position))|oke(-(opacity|dash(offset|array)|width|line(cap|join)|miterlimit))?))|urfaceScale|p(e(cular(Constant|Exponent)|ed)|acing|readMethod)|eed|lope)|h(oriz-(origin-x|adv-x)|eight|anging|ref(lang)?)|y(1|2|ChannelSelector)?|n(umOctaves|ame)|c(y|o(ntentS(criptType|tyleType)|lor(-(interpolation(-filters)?|profile|rendering))?)|ursor|l(ip(-(path|rule)|PathUnits)?|ass)|a(p-height|lcMode)|x)|t(ype|o|ext(-(decoration|anchor|rendering)|Length)|a(rget(X|Y)?|b(index|leValues))|ransform)|i(n(tercept|2)?|d(eographic)?|mage-rendering)|z(oomAndPan)?|o(p(erator|acity)|ver(flow|line-(thickness|position))|ffset|r(i(ent(ation)?|gin)|der))|d(y|i(splay|visor|ffuseConstant|rection)|ominant-baseline|ur|e(scent|celerate)|x)?|u(1|n(i(code(-(range|bidi))?|ts-per-em)|derline-(thickness|position))|2)|p(ing|oint(s(At(X|Y|Z))?|er-events)|a(nose-1|t(h(Length)?|tern(ContentUnits|Transform|Units))|int-order)|r(imitiveUnits|eserveA(spectRatio|lpha)))|e(n(d|able-background)|dgeMode|levation|x(ternalResourcesRequired|ponent))|v(i(sibility|ew(Box|Target))|-(hanging|ideographic|alphabetic|mathematical)|e(ctor-effect|r(sion|t-(origin-(y|x)|adv-y)))|alues)|k(1|2|3|e(y(Splines|Times|Points)|rn(ing|el(Matrix|UnitLength)))|4)?|f(y|il(ter(Res|Units)?|l(-(opacity|rule))?)|o(nt-(s(t(yle|retch)|ize(-adjust)?)|variant|family|weight)|rmat)|lood-(color|opacity)|r(om)?|x)|w(idth(s)?|ord-spacing|riting-mode)|l(i(ghting-color|mitingConeAngle)|ocal|e(ngthAdjust|tter-spacing)|ang)|a(scent|cc(umulate|ent-height)|ttribute(Name|Type)|zimuth|dditive|utoReverse|l(ignment-baseline|phabetic|lowReorder)|rabic-form|mplitude)|r(y|otate|e(s(tart|ult)|ndering-intent|peat(Count|Dur)|quired(Extensions|Features)|f(X|Y|errerPolicy)|l)|adius|x)?|g(1|2|lyph(Ref|-(name|orientation-(horizontal|vertical)))|radient(Transform|Units))|x(1|2|ChannelSelector|-height|link:(show|href|t(ype|itle)|a(ctuate|rcrole)|role)|ml:(space|lang|base))?|m(in|ode|e(thod|dia)|a(sk(ContentUnits|Units)?|thematical|rker(Height|-(start|end|mid)|Units|Width)|x))|b(y|ias|egin|ase(Profile|line-shift|Frequency)|box))(?![\\w:-])",
            beginCaptures: {
              "0": {
                name: "entity.other.attribute-name.html"
              }
            },
            end: "(?=\\s*+[^=\\s])",
            name: "meta.attribute.$1.html",
            patterns: [
              {
                include: "#attribute-interior"
              }
            ]
          },
          {
            begin: `([^\\x{0020}"'<>/=\\x{0000}-\\x{001F}\\x{007F}-\\x{009F}\\x{FDD0}-\\x{FDEF}\\x{FFFE}\\x{FFFF}\\x{1FFFE}\\x{1FFFF}\\x{2FFFE}\\x{2FFFF}\\x{3FFFE}\\x{3FFFF}\\x{4FFFE}\\x{4FFFF}\\x{5FFFE}\\x{5FFFF}\\x{6FFFE}\\x{6FFFF}\\x{7FFFE}\\x{7FFFF}\\x{8FFFE}\\x{8FFFF}\\x{9FFFE}\\x{9FFFF}\\x{AFFFE}\\x{AFFFF}\\x{BFFFE}\\x{BFFFF}\\x{CFFFE}\\x{CFFFF}\\x{DFFFE}\\x{DFFFF}\\x{EFFFE}\\x{EFFFF}\\x{FFFFE}\\x{FFFFF}\\x{10FFFE}\\x{10FFFF}]+)`,
            beginCaptures: {
              "0": {
                name: "entity.other.attribute-name.html"
              }
            },
            comment: "Anything else that is valid",
            end: "(?=\\s*+[^=\\s])",
            name: "meta.attribute.unrecognized.$1.html",
            patterns: [
              {
                include: "#attribute-interior"
              }
            ]
          },
          {
            match: "[^\\s>]+",
            name: "invalid.illegal.character-not-allowed-here.html"
          }
        ]
      },
      tags: {
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#cdata"
          },
          {
            captures: {
              "0": {
                name: "meta.tag.metadata.svg.$2.void.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            match: `(?i)(<)(color-profile|desc|metadata|script|style|title)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`,
            name: "meta.element.metadata.svg.$2.html"
          },
          {
            begin: `(?i)(<)(color-profile|desc|metadata|script|style|title)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`,
            beginCaptures: {
              "0": {
                name: "meta.tag.metadata.svg.$2.start.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            end: "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)",
            endCaptures: {
              "0": {
                name: "meta.tag.metadata.svg.$2.end.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "punctuation.definition.tag.end.html"
              },
              "4": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.element.metadata.svg.$2.html",
            patterns: [
              {
                begin: "(?<!>)\\G",
                end: "(?=/>)|>",
                endCaptures: {
                  "0": {
                    name: "punctuation.definition.tag.end.html"
                  }
                },
                name: "meta.tag.metadata.start.html",
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              {
                include: "#tags"
              }
            ]
          },
          {
            captures: {
              "0": {
                name: "meta.tag.structure.svg.$2.void.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            match: `(?i)(<)(animateMotion|clipPath|defs|feComponentTransfer|feDiffuseLighting|feMerge|feSpecularLighting|filter|g|hatch|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|pattern|radialGradient|switch|text|textPath)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`,
            name: "meta.element.structure.svg.$2.html"
          },
          {
            begin: `(?i)(<)(animateMotion|clipPath|defs|feComponentTransfer|feDiffuseLighting|feMerge|feSpecularLighting|filter|g|hatch|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|pattern|radialGradient|switch|text|textPath)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`,
            beginCaptures: {
              "0": {
                name: "meta.tag.structure.svg.$2.start.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            end: "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)",
            endCaptures: {
              "0": {
                name: "meta.tag.structure.svg.$2.end.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "punctuation.definition.tag.end.html"
              },
              "4": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.element.structure.svg.$2.html",
            patterns: [
              {
                begin: "(?<!>)\\G",
                end: "(?=/>)|>",
                endCaptures: {
                  "0": {
                    name: "punctuation.definition.tag.end.html"
                  }
                },
                name: "meta.tag.structure.start.html",
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              {
                include: "#tags"
              }
            ]
          },
          {
            captures: {
              "0": {
                name: "meta.tag.inline.svg.$2.void.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            match: `(?i)(<)(a|animate|discard|feBlend|feColorMatrix|feComposite|feConvolveMatrix|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feMergeNode|feMorphology|feOffset|fePointLight|feSpotLight|feTile|feTurbulence|hatchPath|mpath|set|solidcolor|stop|tspan)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`,
            name: "meta.element.inline.svg.$2.html"
          },
          {
            begin: `(?i)(<)(a|animate|discard|feBlend|feColorMatrix|feComposite|feConvolveMatrix|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feMergeNode|feMorphology|feOffset|fePointLight|feSpotLight|feTile|feTurbulence|hatchPath|mpath|set|solidcolor|stop|tspan)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`,
            beginCaptures: {
              "0": {
                name: "meta.tag.inline.svg.$2.start.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            end: "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)",
            endCaptures: {
              "0": {
                name: "meta.tag.inline.svg.$2.end.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "punctuation.definition.tag.end.html"
              },
              "4": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.element.inline.svg.$2.html",
            patterns: [
              {
                begin: "(?<!>)\\G",
                end: "(?=/>)|>",
                endCaptures: {
                  "0": {
                    name: "punctuation.definition.tag.end.html"
                  }
                },
                name: "meta.tag.inline.start.html",
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              {
                include: "#tags"
              }
            ]
          },
          {
            captures: {
              "0": {
                name: "meta.tag.object.svg.$2.void.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            match: `(?i)(<)(circle|ellipse|feImage|foreignObject|image|line|path|polygon|polyline|rect|symbol|use|view)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`,
            name: "meta.element.object.svg.$2.html"
          },
          {
            begin: `(?i)(<)(a|circle|ellipse|feImage|foreignObject|image|line|path|polygon|polyline|rect|symbol|use|view)(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`,
            beginCaptures: {
              "0": {
                name: "meta.tag.object.svg.$2.start.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            end: "(?i)(</)(\\2)\\s*(>)|(/>)|(?=</\\w+)",
            endCaptures: {
              "0": {
                name: "meta.tag.object.svg.$2.end.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "punctuation.definition.tag.end.html"
              },
              "4": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.element.object.svg.$2.html",
            patterns: [
              {
                begin: "(?<!>)\\G",
                end: "(?=/>)|>",
                endCaptures: {
                  "0": {
                    name: "punctuation.definition.tag.end.html"
                  }
                },
                name: "meta.tag.object.start.html",
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              {
                include: "#tags"
              }
            ]
          },
          {
            captures: {
              "0": {
                name: "meta.tag.other.svg.$2.void.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "invalid.deprecated.html"
              },
              "4": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "6": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            match: `(?i)(<)((altGlyph|altGlyphDef|altGlyphItem|animateColor|animateTransform|cursor|font|font-face|font-face-format|font-face-name|font-face-src|font-face-uri|glyph|glyphRef|hkern|missing-glyph|tref|vkern))(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`,
            name: "meta.element.other.svg.$2.html"
          },
          {
            begin: `(?i)(<)((altGlyph|altGlyphDef|altGlyphItem|animateColor|animateTransform|cursor|font|font-face|font-face-format|font-face-name|font-face-src|font-face-uri|glyph|glyphRef|hkern|missing-glyph|tref|vkern))(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`,
            beginCaptures: {
              "0": {
                name: "meta.tag.other.svg.$2.start.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "invalid.deprecated.html"
              },
              "4": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "6": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            end: "(?i)(</)((\\2))\\s*(>)|(/>)|(?=</\\w+)",
            endCaptures: {
              "0": {
                name: "meta.tag.other.svg.$2.end.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "invalid.deprecated.html"
              },
              "4": {
                name: "punctuation.definition.tag.end.html"
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.element.other.svg.$2.html",
            patterns: [
              {
                begin: "(?<!>)\\G",
                end: "(?=/>)|>",
                endCaptures: {
                  "0": {
                    name: "punctuation.definition.tag.end.html"
                  }
                },
                name: "meta.tag.other.start.html",
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              {
                include: "#tags"
              }
            ]
          },
          {
            captures: {
              "0": {
                name: "meta.tag.other.invalid.void.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "invalid.illegal.unrecognized-tag.html"
              },
              "4": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "6": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            match: `(?i)(<)(([\\w:]+))(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(/>))`,
            name: "meta.element.other.invalid.html"
          },
          {
            begin: `(?i)(<)((\\w[^\\s>]*))(?=\\s|/?>)(?:(([^"'>]|"[^"]*"|'[^']*')*)(>))?`,
            beginCaptures: {
              "0": {
                name: "meta.tag.other.invalid.start.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "invalid.illegal.unrecognized-tag.html"
              },
              "4": {
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              "6": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            end: "(?i)(</)((\\2))\\s*(>)|(/>)|(?=</\\w+)",
            endCaptures: {
              "0": {
                name: "meta.tag.other.invalid.end.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "invalid.illegal.unrecognized-tag.html"
              },
              "4": {
                name: "punctuation.definition.tag.end.html"
              },
              "5": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.element.other.invalid.html",
            patterns: [
              {
                begin: "(?<!>)\\G",
                end: "(?=/>)|>",
                endCaptures: {
                  "0": {
                    name: "punctuation.definition.tag.end.html"
                  }
                },
                name: "meta.tag.other.invalid.start.html",
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              {
                include: "#tags"
              }
            ]
          },
          {
            include: "#tags-invalid"
          }
        ]
      }
    }
  },
  "tags-invalid": {
    patterns: [
      {
        begin: "(</?)((\\w[^\\s>]*))(?<!/)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "invalid.illegal.unrecognized-tag.html"
          }
        },
        end: "((?: ?/)?>)",
        endCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.other.$2.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      }
    ]
  },
  "tags-valid": {
    patterns: [
      {
        begin: "(^[ \\t]+)?(?=<(?i:style)\\b(?!-))",
        beginCaptures: {
          "1": {
            name: "punctuation.whitespace.embedded.leading.html"
          }
        },
        end: "(?!\\G)([ \\t]*$\\n?)?",
        endCaptures: {
          "1": {
            name: "punctuation.whitespace.embedded.trailing.html"
          }
        },
        patterns: [
          {
            begin: "(?i)(<)(style)(?=\\s|/?>)",
            beginCaptures: {
              "0": {
                name: "meta.tag.metadata.style.start.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              }
            },
            end: "(?i)((<)/)(style)\\s*(>)",
            endCaptures: {
              "0": {
                name: "meta.tag.metadata.style.end.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "source.css-ignored-vscode"
              },
              "3": {
                name: "entity.name.tag.html"
              },
              "4": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.embedded.block.html",
            patterns: [
              {
                begin: "\\G",
                captures: {
                  "1": {
                    name: "punctuation.definition.tag.end.html"
                  }
                },
                end: "(>)",
                name: "meta.tag.metadata.style.start.html",
                patterns: [
                  {
                    include: "#attribute"
                  }
                ]
              },
              {
                begin: "(?!\\G)",
                end: "(?=</(?i:style))",
                name: "source.css",
                patterns: [
                  {
                    include: "source.css"
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        begin: "(^[ \\t]+)?(?=<(?i:script)\\b(?!-))",
        beginCaptures: {
          "1": {
            name: "punctuation.whitespace.embedded.leading.html"
          }
        },
        end: "(?!\\G)([ \\t]*$\\n?)?",
        endCaptures: {
          "1": {
            name: "punctuation.whitespace.embedded.trailing.html"
          }
        },
        patterns: [
          {
            begin: "(<)((?i:script))\\b",
            beginCaptures: {
              "0": {
                name: "meta.tag.metadata.script.start.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              }
            },
            end: "(/)((?i:script))(>)",
            endCaptures: {
              "0": {
                name: "meta.tag.metadata.script.end.html"
              },
              "1": {
                name: "punctuation.definition.tag.begin.html"
              },
              "2": {
                name: "entity.name.tag.html"
              },
              "3": {
                name: "punctuation.definition.tag.end.html"
              }
            },
            name: "meta.embedded.block.html",
            patterns: [
              {
                begin: "\\G",
                end: "(?=/)",
                patterns: [
                  {
                    begin: "(>)",
                    beginCaptures: {
                      "0": {
                        name: "meta.tag.metadata.script.start.html"
                      },
                      "1": {
                        name: "punctuation.definition.tag.end.html"
                      }
                    },
                    end: "((<))(?=/(?i:script))",
                    endCaptures: {
                      "0": {
                        name: "meta.tag.metadata.script.end.html"
                      },
                      "1": {
                        name: "punctuation.definition.tag.begin.html"
                      },
                      "2": {
                        name: "source.js-ignored-vscode"
                      }
                    },
                    patterns: [
                      {
                        begin: "\\G",
                        end: "(?=</(?i:script))",
                        name: "source.js",
                        patterns: [
                          {
                            begin: "(^[ \\t]+)?(?=//)",
                            beginCaptures: {
                              "1": {
                                name: "punctuation.whitespace.comment.leading.js"
                              }
                            },
                            end: "(?!\\G)",
                            patterns: [
                              {
                                begin: "//",
                                beginCaptures: {
                                  "0": {
                                    name: "punctuation.definition.comment.js"
                                  }
                                },
                                end: "(?=<\/script)|\\n",
                                name: "comment.line.double-slash.js"
                              }
                            ]
                          },
                          {
                            begin: "/\\*",
                            captures: {
                              "0": {
                                name: "punctuation.definition.comment.js"
                              }
                            },
                            end: "\\*/|(?=<\/script)",
                            name: "comment.block.js"
                          },
                          {
                            include: "source.js"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    begin: "\\G",
                    end: `(?ix:
												(?=>											# Tag without type attribute
												  | type(?=[\\s=])
												  	(?!\\s*=\\s*
														(
															''								# Empty
														  | ""									#   Values
														  | ('|"|)
															(
																text/							# Text mime-types
																(
																	javascript(1\\.[0-5])?
																  | x-javascript
																  | jscript
																  | livescript
																  | (x-)?ecmascript
																  | babel						# Javascript variant currently
																  								#   recognized as such
															  	)
															  | application/					# Application mime-types
															  	(
																	(x-)?javascript
																  | (x-)?ecmascript
																)
															  | module
														  	)
															[\\s"'>]
														)
													)
												)
											)`,
                    name: "meta.tag.metadata.script.start.html",
                    patterns: [
                      {
                        include: "#attribute"
                      }
                    ]
                  },
                  {
                    begin: `(?ix:
												(?=
													type\\s*=\\s*
													('|"|)
													text/
													(
														x-handlebars
													  | (x-(handlebars-)?|ng-)?template
													  | html
													)
													[\\s"'>]
												)
											)`,
                    end: "((<))(?=/(?i:script))",
                    endCaptures: {
                      "0": {
                        name: "meta.tag.metadata.script.end.html"
                      },
                      "1": {
                        name: "punctuation.definition.tag.begin.html"
                      },
                      "2": {
                        name: "text.html.basic"
                      }
                    },
                    patterns: [
                      {
                        begin: "\\G",
                        end: "(>)",
                        endCaptures: {
                          "1": {
                            name: "punctuation.definition.tag.end.html"
                          }
                        },
                        name: "meta.tag.metadata.script.start.html",
                        patterns: [
                          {
                            include: "#attribute"
                          }
                        ]
                      },
                      {
                        begin: "(?!\\G)",
                        end: "(?=</(?i:script))",
                        name: "text.html.basic",
                        patterns: [
                          {
                            include: "text.html.basic"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    begin: "(?=(?i:type))",
                    end: "(<)(?=/(?i:script))",
                    endCaptures: {
                      "0": {
                        name: "meta.tag.metadata.script.end.html"
                      },
                      "1": {
                        name: "punctuation.definition.tag.begin.html"
                      }
                    },
                    patterns: [
                      {
                        begin: "\\G",
                        end: "(>)",
                        endCaptures: {
                          "1": {
                            name: "punctuation.definition.tag.end.html"
                          }
                        },
                        name: "meta.tag.metadata.script.start.html",
                        patterns: [
                          {
                            include: "#attribute"
                          }
                        ]
                      },
                      {
                        begin: "(?!\\G)",
                        end: "(?=</(?i:script))",
                        name: "source.unknown"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        begin: "(?i)(<)(base|link|meta)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: "/?>",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.metadata.$2.void.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)(noscript|title)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.metadata.$2.start.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(</)(noscript|title)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.metadata.$2.end.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)(col|hr|input)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: "/?>",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.structure.$2.void.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)(address|article|aside|blockquote|body|button|caption|colgroup|datalist|dd|details|dialog|div|dl|dt|fieldset|figcaption|figure|footer|form|head|header|hgroup|html|h[1-6]|label|legend|li|main|map|menu|meter|nav|ol|optgroup|option|output|p|pre|progress|section|select|slot|summary|table|tbody|td|template|textarea|tfoot|th|thead|tr|ul)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.structure.$2.start.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(</)(address|article|aside|blockquote|body|button|caption|colgroup|datalist|dd|details|dialog|div|dl|dt|fieldset|figcaption|figure|footer|form|head|header|hgroup|html|h[1-6]|label|legend|li|main|map|menu|meter|nav|ol|optgroup|option|output|p|pre|progress|section|select|slot|summary|table|tbody|td|template|textarea|tfoot|th|thead|tr|ul)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.structure.$2.end.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)(area|br|wbr)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: "/?>",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.inline.$2.void.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)(a|abbr|b|bdi|bdo|cite|code|data|del|dfn|em|i|ins|kbd|mark|q|rp|rt|ruby|s|samp|small|span|strong|sub|sup|time|u|var)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.inline.$2.start.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(</)(a|abbr|b|bdi|bdo|cite|code|data|del|dfn|em|i|ins|kbd|mark|q|rp|rt|ruby|s|samp|small|span|strong|sub|sup|time|u|var)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.inline.$2.end.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)(embed|img|param|source|track)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: "/?>",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.object.$2.void.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)(audio|canvas|iframe|object|picture|video)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.object.$2.start.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(</)(audio|canvas|iframe|object|picture|video)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.object.$2.end.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)((basefont|isindex))(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "invalid.deprecated.html"
          }
        },
        end: "/?>",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.metadata.$2.void.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)((center|frameset|noembed|noframes))(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "invalid.deprecated.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.structure.$2.start.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(</)((center|frameset|noembed|noframes))(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "invalid.deprecated.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.structure.$2.end.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)((acronym|big|blink|font|strike|tt|xmp))(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "invalid.deprecated.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.inline.$2.start.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(</)((acronym|big|blink|font|strike|tt|xmp))(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "invalid.deprecated.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.inline.$2.end.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)((frame))(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "invalid.deprecated.html"
          }
        },
        end: "/?>",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.object.$2.void.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)((applet))(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "invalid.deprecated.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.object.$2.start.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(</)((applet))(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "invalid.deprecated.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.object.$2.end.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(<)((dir|keygen|listing|menuitem|plaintext|spacer))(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "invalid.illegal.no-longer-supported.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.other.$2.start.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(?i)(</)((dir|keygen|listing|menuitem|plaintext|spacer))(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          },
          "3": {
            name: "invalid.illegal.no-longer-supported.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.other.$2.end.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        include: "#math"
      },
      {
        include: "#svg"
      },
      {
        begin: "(<)([a-zA-Z][.0-9_a-zA-Z\\x{00B7}\\x{00C0}-\\x{00D6}\\x{00D8}-\\x{00F6}\\x{00F8}-\\x{037D}\\x{037F}-\\x{1FFF}\\x{200C}-\\x{200D}\\x{203F}-\\x{2040}\\x{2070}-\\x{218F}\\x{2C00}-\\x{2FEF}\\x{3001}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFFD}\\x{10000}-\\x{EFFFF}]*-[\\-.0-9_a-zA-Z\\x{00B7}\\x{00C0}-\\x{00D6}\\x{00D8}-\\x{00F6}\\x{00F8}-\\x{037D}\\x{037F}-\\x{1FFF}\\x{200C}-\\x{200D}\\x{203F}-\\x{2040}\\x{2070}-\\x{218F}\\x{2C00}-\\x{2FEF}\\x{3001}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFFD}\\x{10000}-\\x{EFFFF}]*)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: "/?>",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.custom.start.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      },
      {
        begin: "(</)([a-zA-Z][.0-9_a-zA-Z\\x{00B7}\\x{00C0}-\\x{00D6}\\x{00D8}-\\x{00F6}\\x{00F8}-\\x{037D}\\x{037F}-\\x{1FFF}\\x{200C}-\\x{200D}\\x{203F}-\\x{2040}\\x{2070}-\\x{218F}\\x{2C00}-\\x{2FEF}\\x{3001}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFFD}\\x{10000}-\\x{EFFFF}]*-[\\-.0-9_a-zA-Z\\x{00B7}\\x{00C0}-\\x{00D6}\\x{00D8}-\\x{00F6}\\x{00F8}-\\x{037D}\\x{037F}-\\x{1FFF}\\x{200C}-\\x{200D}\\x{203F}-\\x{2040}\\x{2070}-\\x{218F}\\x{2C00}-\\x{2FEF}\\x{3001}-\\x{D7FF}\\x{F900}-\\x{FDCF}\\x{FDF0}-\\x{FFFD}\\x{10000}-\\x{EFFFF}]*)(?=\\s|/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.html"
          },
          "2": {
            name: "entity.name.tag.html"
          }
        },
        end: ">",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        name: "meta.tag.custom.end.html",
        patterns: [
          {
            include: "#attribute"
          }
        ]
      }
    ]
  },
  "xml-processing": {
    begin: "(<\\?)(xml)",
    captures: {
      "1": {
        name: "punctuation.definition.tag.html"
      },
      "2": {
        name: "entity.name.tag.html"
      }
    },
    end: "(\\?>)",
    name: "meta.tag.metadata.processing.xml.html",
    patterns: [
      {
        include: "#attribute"
      }
    ]
  }
};
const html_tmLanguage = {
  information_for_contributors: information_for_contributors$7,
  version: version$7,
  name: name$a,
  scopeName: scopeName$9,
  injections,
  patterns: patterns$9,
  repository: repository$9
};
const __vite_glob_0_1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: html_tmLanguage,
  information_for_contributors: information_for_contributors$7,
  injections,
  name: name$a,
  patterns: patterns$9,
  repository: repository$9,
  scopeName: scopeName$9,
  version: version$7
}, Symbol.toStringTag, { value: "Module" }));
const information_for_contributors$6 = [
  "This file has been converted from https://github.com/microsoft/TypeScript-TmLanguage/blob/master/TypeScriptReact.tmLanguage",
  "If you want to provide a fix or improvement, please create a pull request against the original repository.",
  "Once accepted there, we are happy to receive an update request."
];
const version$6 = "https://github.com/microsoft/TypeScript-TmLanguage/commit/33d8371c344f0b54746586313a939f742f9bcd3a";
const name$9 = "javascript";
const scopeName$8 = "source.js";
const patterns$8 = [
  {
    include: "#directives"
  },
  {
    include: "#statements"
  },
  {
    include: "#shebang"
  }
];
const repository$8 = {
  shebang: {
    name: "comment.line.shebang.js",
    match: "\\A(#!).*(?=$)",
    captures: {
      "1": {
        name: "punctuation.definition.comment.js"
      }
    }
  },
  statements: {
    patterns: [
      {
        include: "#declaration"
      },
      {
        include: "#control-statement"
      },
      {
        include: "#after-operator-block-as-object-literal"
      },
      {
        include: "#decl-block"
      },
      {
        include: "#label"
      },
      {
        include: "#expression"
      },
      {
        include: "#punctuation-semicolon"
      },
      {
        include: "#string"
      },
      {
        include: "#comment"
      }
    ]
  },
  declaration: {
    patterns: [
      {
        include: "#decorator"
      },
      {
        include: "#var-expr"
      },
      {
        include: "#function-declaration"
      },
      {
        include: "#class-declaration"
      },
      {
        include: "#interface-declaration"
      },
      {
        include: "#enum-declaration"
      },
      {
        include: "#namespace-declaration"
      },
      {
        include: "#type-alias-declaration"
      },
      {
        include: "#import-equals-declaration"
      },
      {
        include: "#import-declaration"
      },
      {
        include: "#export-declaration"
      },
      {
        name: "storage.modifier.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(declare|export)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "control-statement": {
    patterns: [
      {
        include: "#switch-statement"
      },
      {
        include: "#for-loop"
      },
      {
        name: "keyword.control.trycatch.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(catch|finally|throw|try)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|goto)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "1": {
            name: "keyword.control.loop.js"
          },
          "2": {
            name: "entity.name.label.js"
          }
        }
      },
      {
        name: "keyword.control.loop.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|do|goto|while)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(return)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        beginCaptures: {
          "0": {
            name: "keyword.control.flow.js"
          }
        },
        end: "(?=[;}]|$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "keyword.control.switch.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default|switch)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        include: "#if-statement"
      },
      {
        name: "keyword.control.conditional.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(else|if)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.control.with.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(with)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.control.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(package)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.other.debugger.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(debugger)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  label: {
    patterns: [
      {
        begin: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)(?=\\s*\\{)",
        beginCaptures: {
          "1": {
            name: "entity.name.label.js"
          },
          "2": {
            name: "punctuation.separator.label.js"
          }
        },
        end: "(?<=\\})",
        patterns: [
          {
            include: "#decl-block"
          }
        ]
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)",
        captures: {
          "1": {
            name: "entity.name.label.js"
          },
          "2": {
            name: "punctuation.separator.label.js"
          }
        }
      }
    ]
  },
  expression: {
    patterns: [
      {
        include: "#expressionWithoutIdentifiers"
      },
      {
        include: "#identifiers"
      },
      {
        include: "#expressionPunctuations"
      }
    ]
  },
  expressionWithoutIdentifiers: {
    patterns: [
      {
        include: "#jsx"
      },
      {
        include: "#string"
      },
      {
        include: "#regex"
      },
      {
        include: "#comment"
      },
      {
        include: "#function-expression"
      },
      {
        include: "#class-expression"
      },
      {
        include: "#arrow-function"
      },
      {
        include: "#paren-expression-possibly-arrow"
      },
      {
        include: "#cast"
      },
      {
        include: "#ternary-expression"
      },
      {
        include: "#new-expr"
      },
      {
        include: "#instanceof-expr"
      },
      {
        include: "#object-literal"
      },
      {
        include: "#expression-operators"
      },
      {
        include: "#function-call"
      },
      {
        include: "#literal"
      },
      {
        include: "#support-objects"
      },
      {
        include: "#paren-expression"
      }
    ]
  },
  expressionPunctuations: {
    patterns: [
      {
        include: "#punctuation-comma"
      },
      {
        include: "#punctuation-accessor"
      }
    ]
  },
  decorator: {
    name: "meta.decorator.js",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))\\@",
    beginCaptures: {
      "0": {
        name: "punctuation.decorator.js"
      }
    },
    end: "(?=\\s)",
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "var-expr": {
    patterns: [
      {
        name: "meta.var.expr.js",
        begin: "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))",
        end: "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))|((?<!^let|[^\\._$[:alnum:]]let|^var|[^\\._$[:alnum:]]var)(?=\\s*$)))",
        patterns: [
          {
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*",
            beginCaptures: {
              "1": {
                name: "keyword.control.export.js"
              },
              "2": {
                name: "storage.modifier.js"
              },
              "3": {
                name: "storage.type.js"
              }
            },
            end: "(?=\\S)"
          },
          {
            include: "#destructuring-variable"
          },
          {
            include: "#var-single-variable"
          },
          {
            include: "#variable-initializer"
          },
          {
            include: "#comment"
          },
          {
            begin: "(,)\\s*((?!\\S)|(?=\\/\\/))",
            beginCaptures: {
              "1": {
                name: "punctuation.separator.comma.js"
              }
            },
            end: "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))",
            patterns: [
              {
                include: "#single-line-comment-consuming-line-ending"
              },
              {
                include: "#comment"
              },
              {
                include: "#destructuring-variable"
              },
              {
                include: "#var-single-variable"
              },
              {
                include: "#punctuation-comma"
              }
            ]
          },
          {
            include: "#punctuation-comma"
          }
        ]
      },
      {
        name: "meta.var.expr.js",
        begin: "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.js"
          },
          "2": {
            name: "storage.modifier.js"
          },
          "3": {
            name: "storage.type.js"
          }
        },
        end: "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))|((?<!^const|[^\\._$[:alnum:]]const)(?=\\s*$)))",
        patterns: [
          {
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*",
            beginCaptures: {
              "1": {
                name: "keyword.control.export.js"
              },
              "2": {
                name: "storage.modifier.js"
              },
              "3": {
                name: "storage.type.js"
              }
            },
            end: "(?=\\S)"
          },
          {
            include: "#destructuring-const"
          },
          {
            include: "#var-single-const"
          },
          {
            include: "#variable-initializer"
          },
          {
            include: "#comment"
          },
          {
            begin: "(,)\\s*((?!\\S)|(?=\\/\\/))",
            beginCaptures: {
              "1": {
                name: "punctuation.separator.comma.js"
              }
            },
            end: "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))",
            patterns: [
              {
                include: "#single-line-comment-consuming-line-ending"
              },
              {
                include: "#comment"
              },
              {
                include: "#destructuring-const"
              },
              {
                include: "#var-single-const"
              },
              {
                include: "#punctuation-comma"
              }
            ]
          },
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  },
  "var-single-variable": {
    patterns: [
      {
        name: "meta.var-single-variable.expr.js",
        begin: "(?x)([_$[:alpha:]][_$[:alnum:]]*)(\\!)?(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.js entity.name.function.js"
          },
          "2": {
            name: "keyword.operator.definiteassignment.js"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      },
      {
        name: "meta.var-single-variable.expr.js",
        begin: "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])(\\!)?",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.js variable.other.constant.js"
          },
          "2": {
            name: "keyword.operator.definiteassignment.js"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      },
      {
        name: "meta.var-single-variable.expr.js",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)(\\!)?",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.js variable.other.readwrite.js"
          },
          "2": {
            name: "keyword.operator.definiteassignment.js"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      }
    ]
  },
  "var-single-const": {
    patterns: [
      {
        name: "meta.var-single-variable.expr.js",
        begin: "(?x)([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.js variable.other.constant.js entity.name.function.js"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      },
      {
        name: "meta.var-single-variable.expr.js",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.js variable.other.constant.js"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      }
    ]
  },
  "var-single-variable-type-annotation": {
    patterns: [
      {
        include: "#type-annotation"
      },
      {
        include: "#string"
      },
      {
        include: "#comment"
      }
    ]
  },
  "destructuring-variable": {
    patterns: [
      {
        name: "meta.object-binding-pattern-variable.js",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#object-binding-pattern"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      },
      {
        name: "meta.array-binding-pattern-variable.js",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#array-binding-pattern"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      }
    ]
  },
  "destructuring-const": {
    patterns: [
      {
        name: "meta.object-binding-pattern-variable.js",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#object-binding-pattern-const"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      },
      {
        name: "meta.array-binding-pattern-variable.js",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#array-binding-pattern-const"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      }
    ]
  },
  "object-binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          },
          {
            include: "#binding-element"
          }
        ]
      },
      {
        include: "#object-binding-pattern"
      },
      {
        include: "#destructuring-variable-rest"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "object-binding-element-const": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          },
          {
            include: "#binding-element-const"
          }
        ]
      },
      {
        include: "#object-binding-pattern-const"
      },
      {
        include: "#destructuring-variable-rest-const"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "object-binding-element-propertyName": {
    begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
    end: "(:)",
    endCaptures: {
      "0": {
        name: "punctuation.destructuring.js"
      }
    },
    patterns: [
      {
        include: "#string"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#numeric-literal"
      },
      {
        name: "variable.object.property.js",
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  },
  "binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#regex"
      },
      {
        include: "#object-binding-pattern"
      },
      {
        include: "#array-binding-pattern"
      },
      {
        include: "#destructuring-variable-rest"
      },
      {
        include: "#variable-initializer"
      }
    ]
  },
  "binding-element-const": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#regex"
      },
      {
        include: "#object-binding-pattern-const"
      },
      {
        include: "#array-binding-pattern-const"
      },
      {
        include: "#destructuring-variable-rest-const"
      },
      {
        include: "#variable-initializer"
      }
    ]
  },
  "destructuring-variable-rest": {
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)",
    captures: {
      "1": {
        name: "keyword.operator.rest.js"
      },
      "2": {
        name: "meta.definition.variable.js variable.other.readwrite.js"
      }
    }
  },
  "destructuring-variable-rest-const": {
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)",
    captures: {
      "1": {
        name: "keyword.operator.rest.js"
      },
      "2": {
        name: "meta.definition.variable.js variable.other.constant.js"
      }
    }
  },
  "object-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.js"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.object.js"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.object.js"
      }
    },
    patterns: [
      {
        include: "#object-binding-element"
      }
    ]
  },
  "object-binding-pattern-const": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.js"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.object.js"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.object.js"
      }
    },
    patterns: [
      {
        include: "#object-binding-element-const"
      }
    ]
  },
  "array-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.js"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.array.js"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.array.js"
      }
    },
    patterns: [
      {
        include: "#binding-element"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "array-binding-pattern-const": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.js"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.array.js"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.array.js"
      }
    },
    patterns: [
      {
        include: "#binding-element-const"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "parameter-name": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)",
        captures: {
          "1": {
            name: "storage.modifier.js"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "1": {
            name: "storage.modifier.js"
          },
          "2": {
            name: "keyword.operator.rest.js"
          },
          "3": {
            name: "entity.name.function.js variable.language.this.js"
          },
          "4": {
            name: "entity.name.function.js"
          },
          "5": {
            name: "keyword.operator.optional.js"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)",
        captures: {
          "1": {
            name: "storage.modifier.js"
          },
          "2": {
            name: "keyword.operator.rest.js"
          },
          "3": {
            name: "variable.parameter.js variable.language.this.js"
          },
          "4": {
            name: "variable.parameter.js"
          },
          "5": {
            name: "keyword.operator.optional.js"
          }
        }
      }
    ]
  },
  "destructuring-parameter": {
    patterns: [
      {
        name: "meta.parameter.object-binding-pattern.js",
        begin: "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\{)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.rest.js"
          },
          "2": {
            name: "punctuation.definition.binding-pattern.object.js"
          }
        },
        end: "\\}",
        endCaptures: {
          "0": {
            name: "punctuation.definition.binding-pattern.object.js"
          }
        },
        patterns: [
          {
            include: "#parameter-object-binding-element"
          }
        ]
      },
      {
        name: "meta.paramter.array-binding-pattern.js",
        begin: "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\[)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.rest.js"
          },
          "2": {
            name: "punctuation.definition.binding-pattern.array.js"
          }
        },
        end: "\\]",
        endCaptures: {
          "0": {
            name: "punctuation.definition.binding-pattern.array.js"
          }
        },
        patterns: [
          {
            include: "#parameter-binding-element"
          },
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  },
  "parameter-object-binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          },
          {
            include: "#parameter-binding-element"
          }
        ]
      },
      {
        include: "#parameter-object-binding-pattern"
      },
      {
        include: "#destructuring-parameter-rest"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "parameter-binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#regex"
      },
      {
        include: "#parameter-object-binding-pattern"
      },
      {
        include: "#parameter-array-binding-pattern"
      },
      {
        include: "#destructuring-parameter-rest"
      },
      {
        include: "#variable-initializer"
      }
    ]
  },
  "destructuring-parameter-rest": {
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)",
    captures: {
      "1": {
        name: "keyword.operator.rest.js"
      },
      "2": {
        name: "variable.parameter.js"
      }
    }
  },
  "parameter-object-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.js"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.object.js"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.object.js"
      }
    },
    patterns: [
      {
        include: "#parameter-object-binding-element"
      }
    ]
  },
  "parameter-array-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.js"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.array.js"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.array.js"
      }
    },
    patterns: [
      {
        include: "#parameter-binding-element"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "field-declaration": {
    name: "meta.field.declaration.js",
    begin: "(?x)(?<!\\()(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s+)?(?=\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|\\}|$))",
    beginCaptures: {
      "1": {
        name: "storage.modifier.js"
      }
    },
    end: "(?x)(?=\\}|;|,|$|(^(?!\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|$))))|(?<=\\})",
    patterns: [
      {
        include: "#variable-initializer"
      },
      {
        include: "#type-annotation"
      },
      {
        include: "#string"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#comment"
      },
      {
        match: "(?x)(\\#?[_$[:alpha:]][_$[:alnum:]]*)(?:(\\?)|(\\!))?(?=\\s*\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "1": {
            name: "meta.definition.property.js entity.name.function.js"
          },
          "2": {
            name: "keyword.operator.optional.js"
          },
          "3": {
            name: "keyword.operator.definiteassignment.js"
          }
        }
      },
      {
        name: "meta.definition.property.js variable.object.property.js",
        match: "\\#?[_$[:alpha:]][_$[:alnum:]]*"
      },
      {
        name: "keyword.operator.optional.js",
        match: "\\?"
      },
      {
        name: "keyword.operator.definiteassignment.js",
        match: "\\!"
      }
    ]
  },
  "variable-initializer": {
    patterns: [
      {
        begin: "(?<!=|!)(=)(?!=)(?=\\s*\\S)(?!\\s*.*=>\\s*$)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.js"
          }
        },
        end: "(?=$|^|[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        begin: "(?<!=|!)(=)(?!=)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.js"
          }
        },
        end: "(?=[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))|(?=^\\s*$)|(?<=\\S)(?<!=)(?=\\s*$)",
        patterns: [
          {
            include: "#expression"
          }
        ]
      }
    ]
  },
  "function-declaration": {
    name: "meta.function.js",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js"
      },
      "2": {
        name: "storage.modifier.js"
      },
      "3": {
        name: "storage.modifier.async.js"
      },
      "4": {
        name: "storage.type.function.js"
      },
      "5": {
        name: "keyword.generator.asterisk.js"
      },
      "6": {
        name: "meta.definition.function.js entity.name.function.js"
      }
    },
    end: "(?=;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))|(?<=\\})",
    patterns: [
      {
        include: "#function-name"
      },
      {
        include: "#function-body"
      }
    ]
  },
  "function-expression": {
    name: "meta.function.expression.js",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*",
    beginCaptures: {
      "1": {
        name: "storage.modifier.async.js"
      },
      "2": {
        name: "storage.type.function.js"
      },
      "3": {
        name: "keyword.generator.asterisk.js"
      },
      "4": {
        name: "meta.definition.function.js entity.name.function.js"
      }
    },
    end: "(?=;)|(?<=\\})",
    patterns: [
      {
        include: "#function-name"
      },
      {
        include: "#single-line-comment-consuming-line-ending"
      },
      {
        include: "#function-body"
      }
    ]
  },
  "function-name": {
    name: "meta.definition.function.js entity.name.function.js",
    match: "[_$[:alpha:]][_$[:alnum:]]*"
  },
  "function-body": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#function-parameters"
      },
      {
        include: "#return-type"
      },
      {
        include: "#type-function-return-type"
      },
      {
        include: "#decl-block"
      },
      {
        name: "keyword.generator.asterisk.js",
        match: "\\*"
      }
    ]
  },
  "method-declaration": {
    patterns: [
      {
        name: "meta.method.declaration.js",
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?\\s*\\b(constructor)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        beginCaptures: {
          "1": {
            name: "storage.modifier.js"
          },
          "2": {
            name: "storage.modifier.js"
          },
          "3": {
            name: "storage.modifier.js"
          },
          "4": {
            name: "storage.modifier.async.js"
          },
          "5": {
            name: "storage.type.js"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#method-declaration-name"
          },
          {
            include: "#function-body"
          }
        ]
      },
      {
        name: "meta.method.declaration.js",
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:(?:\\s*\\b(new)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|(?:(\\*)\\s*)?)(?=\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
        beginCaptures: {
          "1": {
            name: "storage.modifier.js"
          },
          "2": {
            name: "storage.modifier.js"
          },
          "3": {
            name: "storage.modifier.js"
          },
          "4": {
            name: "storage.modifier.async.js"
          },
          "5": {
            name: "keyword.operator.new.js"
          },
          "6": {
            name: "keyword.generator.asterisk.js"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#method-declaration-name"
          },
          {
            include: "#function-body"
          }
        ]
      },
      {
        name: "meta.method.declaration.js",
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
        beginCaptures: {
          "1": {
            name: "storage.modifier.js"
          },
          "2": {
            name: "storage.modifier.js"
          },
          "3": {
            name: "storage.modifier.js"
          },
          "4": {
            name: "storage.modifier.async.js"
          },
          "5": {
            name: "storage.type.property.js"
          },
          "6": {
            name: "keyword.generator.asterisk.js"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#method-declaration-name"
          },
          {
            include: "#function-body"
          }
        ]
      }
    ]
  },
  "object-literal-method-declaration": {
    name: "meta.method.declaration.js",
    begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
    beginCaptures: {
      "1": {
        name: "storage.modifier.async.js"
      },
      "2": {
        name: "storage.type.property.js"
      },
      "3": {
        name: "keyword.generator.asterisk.js"
      }
    },
    end: "(?=\\}|;|,)|(?<=\\})",
    patterns: [
      {
        include: "#method-declaration-name"
      },
      {
        include: "#function-body"
      },
      {
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.js"
          },
          "2": {
            name: "storage.type.property.js"
          },
          "3": {
            name: "keyword.generator.asterisk.js"
          }
        },
        end: "(?=\\(|\\<)",
        patterns: [
          {
            include: "#method-declaration-name"
          }
        ]
      }
    ]
  },
  "method-declaration-name": {
    begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??)\\s*[\\(\\<])",
    end: "(?=\\(|\\<)",
    patterns: [
      {
        include: "#string"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#numeric-literal"
      },
      {
        name: "meta.definition.method.js entity.name.function.js",
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      },
      {
        name: "keyword.operator.optional.js",
        match: "\\?"
      }
    ]
  },
  "arrow-function": {
    patterns: [
      {
        name: "meta.arrow.js",
        match: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)\\s*(?==>)",
        captures: {
          "1": {
            name: "storage.modifier.async.js"
          },
          "2": {
            name: "variable.parameter.js"
          }
        }
      },
      {
        name: "meta.arrow.js",
        begin: "(?x) (?:\n  (?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\n)? ((?<![})!\\]])\\s*\n  (?=\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  )\n)",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.js"
          }
        },
        end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#type-parameters"
          },
          {
            include: "#function-parameters"
          },
          {
            include: "#arrow-return-type"
          },
          {
            include: "#possibly-arrow-return-type"
          }
        ]
      },
      {
        name: "meta.arrow.js",
        begin: "=>",
        beginCaptures: {
          "0": {
            name: "storage.type.function.arrow.js"
          }
        },
        end: "((?<=\\}|\\S)(?<!=>)|((?!\\{)(?=\\S)))(?!\\/[\\/\\*])",
        patterns: [
          {
            include: "#single-line-comment-consuming-line-ending"
          },
          {
            include: "#decl-block"
          },
          {
            include: "#expression"
          }
        ]
      }
    ]
  },
  "indexer-declaration": {
    name: "meta.indexer.declaration.js",
    begin: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=:)",
    beginCaptures: {
      "1": {
        name: "storage.modifier.js"
      },
      "2": {
        name: "meta.brace.square.js"
      },
      "3": {
        name: "variable.parameter.js"
      }
    },
    end: "(\\])\\s*(\\?\\s*)?|$",
    endCaptures: {
      "1": {
        name: "meta.brace.square.js"
      },
      "2": {
        name: "keyword.operator.optional.js"
      }
    },
    patterns: [
      {
        include: "#type-annotation"
      }
    ]
  },
  "indexer-mapped-type-declaration": {
    name: "meta.indexer.mappedtype.declaration.js",
    begin: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([+-])?(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s+(in)\\s+",
    beginCaptures: {
      "1": {
        name: "keyword.operator.type.modifier.js"
      },
      "2": {
        name: "storage.modifier.js"
      },
      "3": {
        name: "meta.brace.square.js"
      },
      "4": {
        name: "entity.name.type.js"
      },
      "5": {
        name: "keyword.operator.expression.in.js"
      }
    },
    end: "(\\])([+-])?\\s*(\\?\\s*)?|$",
    endCaptures: {
      "1": {
        name: "meta.brace.square.js"
      },
      "2": {
        name: "keyword.operator.type.modifier.js"
      },
      "3": {
        name: "keyword.operator.optional.js"
      }
    },
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+",
        captures: {
          "1": {
            name: "keyword.control.as.js"
          }
        }
      },
      {
        include: "#type"
      }
    ]
  },
  "function-parameters": {
    name: "meta.parameters.js",
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.parameters.begin.js"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "punctuation.definition.parameters.end.js"
      }
    },
    patterns: [
      {
        include: "#function-parameters-body"
      }
    ]
  },
  "function-parameters-body": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#decorator"
      },
      {
        include: "#destructuring-parameter"
      },
      {
        include: "#parameter-name"
      },
      {
        include: "#parameter-type-annotation"
      },
      {
        include: "#variable-initializer"
      },
      {
        name: "punctuation.separator.parameter.js",
        match: ","
      }
    ]
  },
  "class-declaration": {
    name: "meta.class.js",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(class)\\b(?=\\s+|/[/*])",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js"
      },
      "2": {
        name: "storage.modifier.js"
      },
      "3": {
        name: "storage.modifier.js"
      },
      "4": {
        name: "storage.type.class.js"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#class-declaration-or-expression-patterns"
      }
    ]
  },
  "class-expression": {
    name: "meta.class.js",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(class)\\b(?=\\s+|[<{]|\\/[\\/*])",
    beginCaptures: {
      "1": {
        name: "storage.modifier.js"
      },
      "2": {
        name: "storage.type.class.js"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#class-declaration-or-expression-patterns"
      }
    ]
  },
  "class-declaration-or-expression-patterns": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#class-or-interface-heritage"
      },
      {
        match: "[_$[:alpha:]][_$[:alnum:]]*",
        captures: {
          "0": {
            name: "entity.name.type.class.js"
          }
        }
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#class-or-interface-body"
      }
    ]
  },
  "interface-declaration": {
    name: "meta.interface.js",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(interface)\\b(?=\\s+|/[/*])",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js"
      },
      "2": {
        name: "storage.modifier.js"
      },
      "3": {
        name: "storage.modifier.js"
      },
      "4": {
        name: "storage.type.interface.js"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#class-or-interface-heritage"
      },
      {
        match: "[_$[:alpha:]][_$[:alnum:]]*",
        captures: {
          "0": {
            name: "entity.name.type.interface.js"
          }
        }
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#class-or-interface-body"
      }
    ]
  },
  "class-or-interface-heritage": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(extends|implements)\\b)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "storage.modifier.js"
      }
    },
    end: "(?=\\{)",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#class-or-interface-heritage"
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#expressionWithoutIdentifiers"
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s*\\??\\.\\s*[_$[:alpha:]][_$[:alnum:]]*)*\\s*)",
        captures: {
          "1": {
            name: "entity.name.type.module.js"
          },
          "2": {
            name: "punctuation.accessor.js"
          },
          "3": {
            name: "punctuation.accessor.optional.js"
          }
        }
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "entity.other.inherited-class.js"
          }
        }
      },
      {
        include: "#expressionPunctuations"
      }
    ]
  },
  "class-or-interface-body": {
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.js"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#decorator"
      },
      {
        begin: "(?<=:)\\s*",
        end: "(?=\\s|[;),}\\]:\\-\\+]|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        include: "#method-declaration"
      },
      {
        include: "#indexer-declaration"
      },
      {
        include: "#field-declaration"
      },
      {
        include: "#string"
      },
      {
        include: "#type-annotation"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#access-modifier"
      },
      {
        include: "#property-accessor"
      },
      {
        include: "#async-modifier"
      },
      {
        include: "#after-operator-block-as-object-literal"
      },
      {
        include: "#decl-block"
      },
      {
        include: "#expression"
      },
      {
        include: "#punctuation-comma"
      },
      {
        include: "#punctuation-semicolon"
      }
    ]
  },
  "access-modifier": {
    name: "storage.modifier.js",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(abstract|declare|override|public|protected|private|readonly|static)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "property-accessor": {
    name: "storage.type.property.js",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(get|set)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "async-modifier": {
    name: "storage.modifier.async.js",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(async)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "enum-declaration": {
    name: "meta.enum.declaration.js",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:\\b(const)\\s+)?\\b(enum)\\s+([_$[:alpha:]][_$[:alnum:]]*)",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js"
      },
      "2": {
        name: "storage.modifier.js"
      },
      "3": {
        name: "storage.modifier.js"
      },
      "4": {
        name: "storage.type.enum.js"
      },
      "5": {
        name: "entity.name.type.enum.js"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "\\{",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.block.js"
          }
        },
        end: "\\}",
        endCaptures: {
          "0": {
            name: "punctuation.definition.block.js"
          }
        },
        patterns: [
          {
            include: "#comment"
          },
          {
            begin: "([_$[:alpha:]][_$[:alnum:]]*)",
            beginCaptures: {
              "0": {
                name: "variable.other.enummember.js"
              }
            },
            end: "(?=,|\\}|$)",
            patterns: [
              {
                include: "#comment"
              },
              {
                include: "#variable-initializer"
              }
            ]
          },
          {
            begin: "(?=((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\])))",
            end: "(?=,|\\}|$)",
            patterns: [
              {
                include: "#string"
              },
              {
                include: "#array-literal"
              },
              {
                include: "#comment"
              },
              {
                include: "#variable-initializer"
              }
            ]
          },
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  },
  "namespace-declaration": {
    name: "meta.namespace.declaration.js",
    begin: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(namespace|module)\\s+(?=[_$[:alpha:]\"'`]))",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js"
      },
      "2": {
        name: "storage.modifier.js"
      },
      "3": {
        name: "storage.type.namespace.js"
      }
    },
    end: "(?<=\\})|(?=;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        name: "entity.name.type.module.js",
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      },
      {
        include: "#punctuation-accessor"
      },
      {
        include: "#decl-block"
      }
    ]
  },
  "type-alias-declaration": {
    name: "meta.type.declaration.js",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(type)\\b\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js"
      },
      "2": {
        name: "storage.modifier.js"
      },
      "3": {
        name: "storage.type.type.js"
      },
      "4": {
        name: "entity.name.type.alias.js"
      }
    },
    end: "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#type-parameters"
      },
      {
        begin: "(=)\\s*(intrinsic)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.js"
          },
          "2": {
            name: "keyword.control.intrinsic.js"
          }
        },
        end: "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        begin: "(=)\\s*",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.js"
          }
        },
        end: "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "import-equals-declaration": {
    patterns: [
      {
        name: "meta.import-equals.external.js",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(require)\\s*(\\()",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.js"
          },
          "2": {
            name: "storage.modifier.js"
          },
          "3": {
            name: "keyword.control.import.js"
          },
          "4": {
            name: "keyword.control.type.js"
          },
          "5": {
            name: "variable.other.readwrite.alias.js"
          },
          "6": {
            name: "keyword.operator.assignment.js"
          },
          "7": {
            name: "keyword.control.require.js"
          },
          "8": {
            name: "meta.brace.round.js"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.js"
          }
        },
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#string"
          }
        ]
      },
      {
        name: "meta.import-equals.internal.js",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(?!require\\b)",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.js"
          },
          "2": {
            name: "storage.modifier.js"
          },
          "3": {
            name: "keyword.control.import.js"
          },
          "4": {
            name: "keyword.control.type.js"
          },
          "5": {
            name: "variable.other.readwrite.alias.js"
          },
          "6": {
            name: "keyword.operator.assignment.js"
          }
        },
        end: "(?=;|$|^)",
        patterns: [
          {
            include: "#single-line-comment-consuming-line-ending"
          },
          {
            include: "#comment"
          },
          {
            match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))",
            captures: {
              "1": {
                name: "entity.name.type.module.js"
              },
              "2": {
                name: "punctuation.accessor.js"
              },
              "3": {
                name: "punctuation.accessor.optional.js"
              }
            }
          },
          {
            name: "variable.other.readwrite.js",
            match: "([_$[:alpha:]][_$[:alnum:]]*)"
          }
        ]
      }
    ]
  },
  "import-declaration": {
    name: "meta.import.js",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type)(?!\\s+from))?(?!\\s*[:\\(])(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js"
      },
      "2": {
        name: "storage.modifier.js"
      },
      "3": {
        name: "keyword.control.import.js"
      },
      "4": {
        name: "keyword.control.type.js"
      }
    },
    end: "(?<!^import|[^\\._$[:alnum:]]import)(?=;|$|^)",
    patterns: [
      {
        include: "#single-line-comment-consuming-line-ending"
      },
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        begin: `(?<=^import|[^\\._$[:alnum:]]import)(?!\\s*["'])`,
        end: "\\bfrom\\b",
        endCaptures: {
          "0": {
            name: "keyword.control.from.js"
          }
        },
        patterns: [
          {
            include: "#import-export-declaration"
          }
        ]
      },
      {
        include: "#import-export-declaration"
      }
    ]
  },
  "export-declaration": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)\\s+(as)\\s+(namespace)\\s+([_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "keyword.control.export.js"
          },
          "2": {
            name: "keyword.control.as.js"
          },
          "3": {
            name: "storage.type.namespace.js"
          },
          "4": {
            name: "entity.name.type.module.js"
          }
        }
      },
      {
        name: "meta.export.default.js",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?(?:(?:\\s*(=))|(?:\\s+(default)(?=\\s+)))",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.js"
          },
          "2": {
            name: "keyword.control.type.js"
          },
          "3": {
            name: "keyword.operator.assignment.js"
          },
          "4": {
            name: "keyword.control.default.js"
          }
        },
        end: "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#interface-declaration"
          },
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "meta.export.js",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?\\b(?!(\\$)|(\\s*:))((?=\\s*[\\{*])|((?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s|,))(?!\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b)))",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.js"
          },
          "2": {
            name: "keyword.control.type.js"
          }
        },
        end: "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#import-export-declaration"
          }
        ]
      }
    ]
  },
  "import-export-declaration": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#import-export-block"
      },
      {
        name: "keyword.control.from.js",
        match: "\\bfrom\\b"
      },
      {
        include: "#import-export-clause"
      }
    ]
  },
  "import-export-block": {
    name: "meta.block.js",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.js"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js"
      }
    },
    patterns: [
      {
        include: "#import-export-clause"
      }
    ]
  },
  "import-export-clause": {
    patterns: [
      {
        include: "#comment"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bdefault)|(\\*)|(\\b[_$[:alpha:]][_$[:alnum:]]*))\\s+(as)\\s+(?:(default(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|([_$[:alpha:]][_$[:alnum:]]*))",
        captures: {
          "1": {
            name: "keyword.control.default.js"
          },
          "2": {
            name: "constant.language.import-export-all.js"
          },
          "3": {
            name: "variable.other.readwrite.js"
          },
          "4": {
            name: "keyword.control.as.js"
          },
          "5": {
            name: "keyword.control.default.js"
          },
          "6": {
            name: "variable.other.readwrite.alias.js"
          }
        }
      },
      {
        include: "#punctuation-comma"
      },
      {
        name: "constant.language.import-export-all.js",
        match: "\\*"
      },
      {
        name: "keyword.control.default.js",
        match: "\\b(default)\\b"
      },
      {
        name: "variable.other.readwrite.alias.js",
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  },
  "switch-statement": {
    name: "switch-statement.expr.js",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bswitch\\s*\\()",
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        name: "switch-expression.expr.js",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(switch)\\s*(\\()",
        beginCaptures: {
          "1": {
            name: "keyword.control.switch.js"
          },
          "2": {
            name: "meta.brace.round.js"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.js"
          }
        },
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "switch-block.expr.js",
        begin: "\\{",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.block.js"
          }
        },
        end: "(?=\\})",
        patterns: [
          {
            name: "case-clause.expr.js",
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default(?=:))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
            beginCaptures: {
              "1": {
                name: "keyword.control.switch.js"
              }
            },
            end: "(?=:)",
            patterns: [
              {
                include: "#expression"
              }
            ]
          },
          {
            begin: "(:)\\s*(\\{)",
            beginCaptures: {
              "1": {
                name: "case-clause.expr.js punctuation.definition.section.case-statement.js"
              },
              "2": {
                name: "meta.block.js punctuation.definition.block.js"
              }
            },
            end: "\\}",
            endCaptures: {
              "0": {
                name: "meta.block.js punctuation.definition.block.js"
              }
            },
            contentName: "meta.block.js",
            patterns: [
              {
                include: "#statements"
              }
            ]
          },
          {
            match: "(:)",
            captures: {
              "0": {
                name: "case-clause.expr.js punctuation.definition.section.case-statement.js"
              }
            }
          },
          {
            include: "#statements"
          }
        ]
      }
    ]
  },
  "for-loop": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))for(?=((\\s+|(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*))await)?\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)?(\\())",
    beginCaptures: {
      "0": {
        name: "keyword.control.loop.js"
      }
    },
    end: "(?<=\\))",
    patterns: [
      {
        include: "#comment"
      },
      {
        name: "keyword.control.loop.js",
        match: "await"
      },
      {
        begin: "\\(",
        beginCaptures: {
          "0": {
            name: "meta.brace.round.js"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.js"
          }
        },
        patterns: [
          {
            include: "#var-expr"
          },
          {
            include: "#expression"
          },
          {
            include: "#punctuation-semicolon"
          }
        ]
      }
    ]
  },
  "if-statement": {
    patterns: [
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bif\\s*(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))\\s*(?!\\{))",
        end: "(?=;|$|\\})",
        patterns: [
          {
            include: "#comment"
          },
          {
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(if)\\s*(\\()",
            beginCaptures: {
              "1": {
                name: "keyword.control.conditional.js"
              },
              "2": {
                name: "meta.brace.round.js"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "meta.brace.round.js"
              }
            },
            patterns: [
              {
                include: "#expression"
              }
            ]
          },
          {
            name: "string.regexp.js",
            begin: "(?<=\\))\\s*\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))",
            beginCaptures: {
              "0": {
                name: "punctuation.definition.string.begin.js"
              }
            },
            end: "(/)([dgimsuy]*)",
            endCaptures: {
              "1": {
                name: "punctuation.definition.string.end.js"
              },
              "2": {
                name: "keyword.other.js"
              }
            },
            patterns: [
              {
                include: "#regexp"
              }
            ]
          },
          {
            include: "#statements"
          }
        ]
      }
    ]
  },
  "decl-block": {
    name: "meta.block.js",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.js"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js"
      }
    },
    patterns: [
      {
        include: "#statements"
      }
    ]
  },
  "after-operator-block-as-object-literal": {
    name: "meta.objectliteral.js",
    begin: "(?<!\\+\\+|--)(?<=[:=(,\\[?+!>]|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^yield|[^\\._$[:alnum:]]yield|^throw|[^\\._$[:alnum:]]throw|^in|[^\\._$[:alnum:]]in|^of|[^\\._$[:alnum:]]of|^typeof|[^\\._$[:alnum:]]typeof|&&|\\|\\||\\*)\\s*(\\{)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.block.js"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js"
      }
    },
    patterns: [
      {
        include: "#object-member"
      }
    ]
  },
  "object-literal": {
    name: "meta.objectliteral.js",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.js"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js"
      }
    },
    patterns: [
      {
        include: "#object-member"
      }
    ]
  },
  "object-member": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#object-literal-method-declaration"
      },
      {
        name: "meta.object.member.js meta.object-literal.key.js",
        begin: "(?=\\[)",
        end: "(?=:)|((?<=[\\]])(?=\\s*[\\(\\<]))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#array-literal"
          }
        ]
      },
      {
        name: "meta.object.member.js meta.object-literal.key.js",
        begin: "(?=[\\'\\\"\\`])",
        end: "(?=:)|((?<=[\\'\\\"\\`])(?=((\\s*[\\(\\<,}])|(\\s+(as)\\s+))))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#string"
          }
        ]
      },
      {
        name: "meta.object.member.js meta.object-literal.key.js",
        begin: "(?x)(?=(\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)))",
        end: "(?=:)|(?=\\s*([\\(\\<,}])|(\\s+as\\s+))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#numeric-literal"
          }
        ]
      },
      {
        name: "meta.method.declaration.js",
        begin: "(?<=[\\]\\'\\\"\\`])(?=\\s*[\\(\\<])",
        end: "(?=\\}|;|,)|(?<=\\})",
        patterns: [
          {
            include: "#function-body"
          }
        ]
      },
      {
        name: "meta.object.member.js",
        match: "(?![_$[:alpha:]])([[:digit:]]+)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)",
        captures: {
          "0": {
            name: "meta.object-literal.key.js"
          },
          "1": {
            name: "constant.numeric.decimal.js"
          }
        }
      },
      {
        name: "meta.object.member.js",
        match: "(?x)(?:([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/)*\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "0": {
            name: "meta.object-literal.key.js"
          },
          "1": {
            name: "entity.name.function.js"
          }
        }
      },
      {
        name: "meta.object.member.js",
        match: "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)",
        captures: {
          "0": {
            name: "meta.object-literal.key.js"
          }
        }
      },
      {
        name: "meta.object.member.js",
        begin: "\\.\\.\\.",
        beginCaptures: {
          "0": {
            name: "keyword.operator.spread.js"
          }
        },
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "meta.object.member.js",
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=,|\\}|$|\\/\\/|\\/\\*)",
        captures: {
          "1": {
            name: "variable.other.readwrite.js"
          }
        }
      },
      {
        name: "meta.object.member.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*([,}]|$))",
        captures: {
          "1": {
            name: "keyword.control.as.js"
          },
          "2": {
            name: "storage.modifier.js"
          }
        }
      },
      {
        name: "meta.object.member.js",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+",
        beginCaptures: {
          "1": {
            name: "keyword.control.as.js"
          }
        },
        end: "(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|^|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "meta.object.member.js",
        begin: "(?=[_$[:alpha:]][_$[:alnum:]]*\\s*=)",
        end: "(?=,|\\}|$|\\/\\/|\\/\\*)",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "meta.object.member.js",
        begin: ":",
        beginCaptures: {
          "0": {
            name: "meta.object-literal.key.js punctuation.separator.key-value.js"
          }
        },
        end: "(?=,|\\})",
        patterns: [
          {
            begin: "(?<=:)\\s*(async)?(?=\\s*(<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
            beginCaptures: {
              "1": {
                name: "storage.modifier.async.js"
              }
            },
            end: "(?<=\\))",
            patterns: [
              {
                include: "#type-parameters"
              },
              {
                begin: "\\(",
                beginCaptures: {
                  "0": {
                    name: "meta.brace.round.js"
                  }
                },
                end: "\\)",
                endCaptures: {
                  "0": {
                    name: "meta.brace.round.js"
                  }
                },
                patterns: [
                  {
                    include: "#expression-inside-possibly-arrow-parens"
                  }
                ]
              }
            ]
          },
          {
            begin: "(?<=:)\\s*(async)?\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
            beginCaptures: {
              "1": {
                name: "storage.modifier.async.js"
              },
              "2": {
                name: "meta.brace.round.js"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "meta.brace.round.js"
              }
            },
            patterns: [
              {
                include: "#expression-inside-possibly-arrow-parens"
              }
            ]
          },
          {
            begin: "(?<=:)\\s*(async)?\\s*(?=\\<\\s*$)",
            beginCaptures: {
              "1": {
                name: "storage.modifier.async.js"
              }
            },
            end: "(?<=\\>)",
            patterns: [
              {
                include: "#type-parameters"
              }
            ]
          },
          {
            begin: "(?<=\\>)\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
            beginCaptures: {
              "1": {
                name: "meta.brace.round.js"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "meta.brace.round.js"
              }
            },
            patterns: [
              {
                include: "#expression-inside-possibly-arrow-parens"
              }
            ]
          },
          {
            include: "#possibly-arrow-return-type"
          },
          {
            include: "#expression"
          }
        ]
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "ternary-expression": {
    begin: "(?!\\?\\.\\s*[^[:digit:]])(\\?)(?!\\?)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.ternary.js"
      }
    },
    end: "\\s*(:)",
    endCaptures: {
      "1": {
        name: "keyword.operator.ternary.js"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "function-call": {
    patterns: [
      {
        begin: "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())",
        end: "(?<=\\))(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())",
        patterns: [
          {
            name: "meta.function-call.js",
            begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))",
            end: "(?=\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())",
            patterns: [
              {
                include: "#function-call-target"
              }
            ]
          },
          {
            include: "#comment"
          },
          {
            include: "#function-call-optionals"
          },
          {
            include: "#type-arguments"
          },
          {
            include: "#paren-expression"
          }
        ]
      },
      {
        begin: "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))",
        end: "(?<=\\>)(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))",
        patterns: [
          {
            name: "meta.function-call.js",
            begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))",
            end: "(?=(<\\s*[\\{\\[\\(]\\s*$))",
            patterns: [
              {
                include: "#function-call-target"
              }
            ]
          },
          {
            include: "#comment"
          },
          {
            include: "#function-call-optionals"
          },
          {
            include: "#type-arguments"
          }
        ]
      }
    ]
  },
  "function-call-target": {
    patterns: [
      {
        include: "#support-function-call-identifiers"
      },
      {
        name: "entity.name.function.js",
        match: "(\\#?[_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  },
  "function-call-optionals": {
    patterns: [
      {
        name: "meta.function-call.js punctuation.accessor.optional.js",
        match: "\\?\\."
      },
      {
        name: "meta.function-call.js keyword.operator.definiteassignment.js",
        match: "\\!"
      }
    ]
  },
  "support-function-call-identifiers": {
    patterns: [
      {
        include: "#literal"
      },
      {
        include: "#support-objects"
      },
      {
        include: "#object-identifiers"
      },
      {
        include: "#punctuation-accessor"
      },
      {
        name: "keyword.operator.expression.import.js",
        match: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*[\\(]\\s*[\\\"\\'\\`]))"
      }
    ]
  },
  "new-expr": {
    name: "new.expr.js",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "keyword.operator.new.js"
      }
    },
    end: "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))",
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "instanceof-expr": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(instanceof)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "keyword.operator.expression.instanceof.js"
      }
    },
    end: "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|(([\\&\\~\\^\\|]\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s+instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))",
    patterns: [
      {
        include: "#type"
      }
    ]
  },
  "paren-expression-possibly-arrow": {
    patterns: [
      {
        begin: "(?<=[(=,])\\s*(async)?(?=\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.js"
          }
        },
        end: "(?<=\\))",
        patterns: [
          {
            include: "#paren-expression-possibly-arrow-with-typeparameters"
          }
        ]
      },
      {
        begin: "(?<=[(=,]|=>|^return|[^\\._$[:alnum:]]return)\\s*(async)?(?=\\s*((((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\()|(<))\\s*$)",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.js"
          }
        },
        end: "(?<=\\))",
        patterns: [
          {
            include: "#paren-expression-possibly-arrow-with-typeparameters"
          }
        ]
      },
      {
        include: "#possibly-arrow-return-type"
      }
    ]
  },
  "paren-expression-possibly-arrow-with-typeparameters": {
    patterns: [
      {
        include: "#type-parameters"
      },
      {
        begin: "\\(",
        beginCaptures: {
          "0": {
            name: "meta.brace.round.js"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.js"
          }
        },
        patterns: [
          {
            include: "#expression-inside-possibly-arrow-parens"
          }
        ]
      }
    ]
  },
  "expression-inside-possibly-arrow-parens": {
    patterns: [
      {
        include: "#expressionWithoutIdentifiers"
      },
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#decorator"
      },
      {
        include: "#destructuring-parameter"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)",
        captures: {
          "1": {
            name: "storage.modifier.js"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "1": {
            name: "storage.modifier.js"
          },
          "2": {
            name: "keyword.operator.rest.js"
          },
          "3": {
            name: "entity.name.function.js variable.language.this.js"
          },
          "4": {
            name: "entity.name.function.js"
          },
          "5": {
            name: "keyword.operator.optional.js"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*[:,]|$)",
        captures: {
          "1": {
            name: "storage.modifier.js"
          },
          "2": {
            name: "keyword.operator.rest.js"
          },
          "3": {
            name: "variable.parameter.js variable.language.this.js"
          },
          "4": {
            name: "variable.parameter.js"
          },
          "5": {
            name: "keyword.operator.optional.js"
          }
        }
      },
      {
        include: "#type-annotation"
      },
      {
        include: "#variable-initializer"
      },
      {
        name: "punctuation.separator.parameter.js",
        match: ","
      },
      {
        include: "#identifiers"
      },
      {
        include: "#expressionPunctuations"
      }
    ]
  },
  "paren-expression": {
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "meta.brace.round.js"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "meta.brace.round.js"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  cast: {
    patterns: [
      {
        include: "#jsx"
      }
    ]
  },
  "expression-operators": {
    patterns: [
      {
        name: "keyword.control.flow.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(await)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?=\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*\\*)",
        beginCaptures: {
          "1": {
            name: "keyword.control.flow.js"
          }
        },
        end: "\\*",
        endCaptures: {
          "0": {
            name: "keyword.generator.asterisk.js"
          }
        },
        patterns: [
          {
            include: "#comment"
          }
        ]
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?:\\s*(\\*))?",
        captures: {
          "1": {
            name: "keyword.control.flow.js"
          },
          "2": {
            name: "keyword.generator.asterisk.js"
          }
        }
      },
      {
        name: "keyword.operator.expression.delete.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))delete(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.expression.in.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))in(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()"
      },
      {
        name: "keyword.operator.expression.of.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))of(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()"
      },
      {
        name: "keyword.operator.expression.instanceof.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.new.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        include: "#typeof-operator"
      },
      {
        name: "keyword.operator.expression.void.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))void(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*($|[;,:})\\]]))",
        captures: {
          "1": {
            name: "keyword.control.as.js"
          },
          "2": {
            name: "storage.modifier.js"
          }
        }
      },
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+",
        beginCaptures: {
          "1": {
            name: "keyword.control.as.js"
          }
        },
        end: "(?=^|[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+)|(\\s+\\<))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "keyword.operator.spread.js",
        match: "\\.\\.\\."
      },
      {
        name: "keyword.operator.assignment.compound.js",
        match: "\\*=|(?<!\\()/=|%=|\\+=|\\-="
      },
      {
        name: "keyword.operator.assignment.compound.bitwise.js",
        match: "\\&=|\\^=|<<=|>>=|>>>=|\\|="
      },
      {
        name: "keyword.operator.bitwise.shift.js",
        match: "<<|>>>|>>"
      },
      {
        name: "keyword.operator.comparison.js",
        match: "===|!==|==|!="
      },
      {
        name: "keyword.operator.relational.js",
        match: "<=|>=|<>|<|>"
      },
      {
        match: "(?<=[_$[:alnum:]])(\\!)\\s*(?:(/=)|(?:(/)(?![/*])))",
        captures: {
          "1": {
            name: "keyword.operator.logical.js"
          },
          "2": {
            name: "keyword.operator.assignment.compound.js"
          },
          "3": {
            name: "keyword.operator.arithmetic.js"
          }
        }
      },
      {
        name: "keyword.operator.logical.js",
        match: "\\!|&&|\\|\\||\\?\\?"
      },
      {
        name: "keyword.operator.bitwise.js",
        match: "\\&|~|\\^|\\|"
      },
      {
        name: "keyword.operator.assignment.js",
        match: "\\="
      },
      {
        name: "keyword.operator.decrement.js",
        match: "--"
      },
      {
        name: "keyword.operator.increment.js",
        match: "\\+\\+"
      },
      {
        name: "keyword.operator.arithmetic.js",
        match: "%|\\*|/|-|\\+"
      },
      {
        begin: "(?<=[_$[:alnum:])\\]])\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)+(?:(/=)|(?:(/)(?![/*]))))",
        end: "(?:(/=)|(?:(/)(?!\\*([^\\*]|(\\*[^\\/]))*\\*\\/)))",
        endCaptures: {
          "1": {
            name: "keyword.operator.assignment.compound.js"
          },
          "2": {
            name: "keyword.operator.arithmetic.js"
          }
        },
        patterns: [
          {
            include: "#comment"
          }
        ]
      },
      {
        match: "(?<=[_$[:alnum:])\\]])\\s*(?:(/=)|(?:(/)(?![/*])))",
        captures: {
          "1": {
            name: "keyword.operator.assignment.compound.js"
          },
          "2": {
            name: "keyword.operator.arithmetic.js"
          }
        }
      }
    ]
  },
  "typeof-operator": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))typeof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "0": {
        name: "keyword.operator.expression.typeof.js"
      }
    },
    end: "(?=[,);}\\]=>:&|{\\?]|$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  literal: {
    patterns: [
      {
        include: "#numeric-literal"
      },
      {
        include: "#boolean-literal"
      },
      {
        include: "#null-literal"
      },
      {
        include: "#undefined-literal"
      },
      {
        include: "#numericConstant-literal"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#this-literal"
      },
      {
        include: "#super-literal"
      }
    ]
  },
  "array-literal": {
    name: "meta.array.literal.js",
    begin: "\\s*(\\[)",
    beginCaptures: {
      "1": {
        name: "meta.brace.square.js"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "meta.brace.square.js"
      }
    },
    patterns: [
      {
        include: "#expression"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "numeric-literal": {
    patterns: [
      {
        name: "constant.numeric.hex.js",
        match: "\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$)",
        captures: {
          "1": {
            name: "storage.type.numeric.bigint.js"
          }
        }
      },
      {
        name: "constant.numeric.binary.js",
        match: "\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$)",
        captures: {
          "1": {
            name: "storage.type.numeric.bigint.js"
          }
        }
      },
      {
        name: "constant.numeric.octal.js",
        match: "\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$)",
        captures: {
          "1": {
            name: "storage.type.numeric.bigint.js"
          }
        }
      },
      {
        match: "(?x)\n(?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)",
        captures: {
          "0": {
            name: "constant.numeric.decimal.js"
          },
          "1": {
            name: "meta.delimiter.decimal.period.js"
          },
          "2": {
            name: "storage.type.numeric.bigint.js"
          },
          "3": {
            name: "meta.delimiter.decimal.period.js"
          },
          "4": {
            name: "storage.type.numeric.bigint.js"
          },
          "5": {
            name: "meta.delimiter.decimal.period.js"
          },
          "6": {
            name: "storage.type.numeric.bigint.js"
          },
          "7": {
            name: "storage.type.numeric.bigint.js"
          },
          "8": {
            name: "meta.delimiter.decimal.period.js"
          },
          "9": {
            name: "storage.type.numeric.bigint.js"
          },
          "10": {
            name: "meta.delimiter.decimal.period.js"
          },
          "11": {
            name: "storage.type.numeric.bigint.js"
          },
          "12": {
            name: "meta.delimiter.decimal.period.js"
          },
          "13": {
            name: "storage.type.numeric.bigint.js"
          },
          "14": {
            name: "storage.type.numeric.bigint.js"
          }
        }
      }
    ]
  },
  "boolean-literal": {
    patterns: [
      {
        name: "constant.language.boolean.true.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))true(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "constant.language.boolean.false.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))false(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "null-literal": {
    name: "constant.language.null.js",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))null(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "this-literal": {
    name: "variable.language.this.js",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))this\\b(?!\\$)"
  },
  "super-literal": {
    name: "variable.language.super.js",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))super\\b(?!\\$)"
  },
  "undefined-literal": {
    name: "constant.language.undefined.js",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))undefined(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "numericConstant-literal": {
    patterns: [
      {
        name: "constant.language.nan.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))NaN(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "constant.language.infinity.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Infinity(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "support-objects": {
    patterns: [
      {
        name: "variable.language.arguments.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(arguments)\\b(?!\\$)"
      },
      {
        name: "support.class.builtin.js",
        match: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Array|ArrayBuffer|Atomics|BigInt|BigInt64Array|BigUint64Array|Boolean|DataView|Date|Float32Array\n  |Float64Array|Function|Generator|GeneratorFunction|Int8Array|Int16Array|Int32Array|Intl|Map|Number|Object|Proxy\n  |Reflect|RegExp|Set|SharedArrayBuffer|SIMD|String|Symbol|TypedArray\n  |Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|WeakMap|WeakSet)\\b(?!\\$)"
      },
      {
        name: "support.class.error.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))((Eval|Internal|Range|Reference|Syntax|Type|URI)?Error)\\b(?!\\$)"
      },
      {
        name: "support.class.promise.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Promise)\\b(?!\\$)"
      },
      {
        name: "support.function.js",
        match: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(clear(Interval|Timeout)|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|\n  isFinite|isNaN|parseFloat|parseInt|require|set(Interval|Timeout)|super|unescape|uneval)(?=\\s*\\()"
      },
      {
        match: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Math)(?:\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(?:\n  (abs|acos|acosh|asin|asinh|atan|atan2|atanh|cbrt|ceil|clz32|cos|cosh|exp|\n  expm1|floor|fround|hypot|imul|log|log10|log1p|log2|max|min|pow|random|\n  round|sign|sin|sinh|sqrt|tan|tanh|trunc)\n  |\n  (E|LN10|LN2|LOG10E|LOG2E|PI|SQRT1_2|SQRT2)))?\\b(?!\\$)",
        captures: {
          "1": {
            name: "support.constant.math.js"
          },
          "2": {
            name: "punctuation.accessor.js"
          },
          "3": {
            name: "punctuation.accessor.optional.js"
          },
          "4": {
            name: "support.function.math.js"
          },
          "5": {
            name: "support.constant.property.math.js"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(JSON)(?:\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(parse|stringify))?\\b(?!\\$)",
        captures: {
          "1": {
            name: "support.constant.json.js"
          },
          "2": {
            name: "punctuation.accessor.js"
          },
          "3": {
            name: "punctuation.accessor.optional.js"
          },
          "4": {
            name: "support.function.json.js"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(import)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(meta)\\b(?!\\$)",
        captures: {
          "1": {
            name: "keyword.control.import.js"
          },
          "2": {
            name: "punctuation.accessor.js"
          },
          "3": {
            name: "punctuation.accessor.optional.js"
          },
          "4": {
            name: "support.variable.property.importmeta.js"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(target)\\b(?!\\$)",
        captures: {
          "1": {
            name: "keyword.operator.new.js"
          },
          "2": {
            name: "punctuation.accessor.js"
          },
          "3": {
            name: "punctuation.accessor.optional.js"
          },
          "4": {
            name: "support.variable.property.target.js"
          }
        }
      },
      {
        match: "(?x) (?:(\\.)|(\\?\\.(?!\\s*[[:digit:]]))) \\s* (?:\n  (?:(constructor|length|prototype|__proto__)\\b(?!\\$|\\s*(<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\\())\n  |\n  (?:(EPSILON|MAX_SAFE_INTEGER|MAX_VALUE|MIN_SAFE_INTEGER|MIN_VALUE|NEGATIVE_INFINITY|POSITIVE_INFINITY)\\b(?!\\$)))",
        captures: {
          "1": {
            name: "punctuation.accessor.js"
          },
          "2": {
            name: "punctuation.accessor.optional.js"
          },
          "3": {
            name: "support.variable.property.js"
          },
          "4": {
            name: "support.constant.js"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(exports)|(module)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(exports|id|filename|loaded|parent|children))?)\\b(?!\\$)",
        captures: {
          "1": {
            name: "support.type.object.module.js"
          },
          "2": {
            name: "support.type.object.module.js"
          },
          "3": {
            name: "punctuation.accessor.js"
          },
          "4": {
            name: "punctuation.accessor.optional.js"
          },
          "5": {
            name: "support.type.object.module.js"
          }
        }
      }
    ]
  },
  identifiers: {
    patterns: [
      {
        include: "#object-identifiers"
      },
      {
        match: "(?x)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*)?([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n))",
        captures: {
          "1": {
            name: "punctuation.accessor.js"
          },
          "2": {
            name: "punctuation.accessor.optional.js"
          },
          "3": {
            name: "entity.name.function.js"
          }
        }
      },
      {
        match: "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])",
        captures: {
          "1": {
            name: "punctuation.accessor.js"
          },
          "2": {
            name: "punctuation.accessor.optional.js"
          },
          "3": {
            name: "variable.other.constant.property.js"
          }
        }
      },
      {
        match: "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "punctuation.accessor.js"
          },
          "2": {
            name: "punctuation.accessor.optional.js"
          },
          "3": {
            name: "variable.other.property.js"
          }
        }
      },
      {
        name: "variable.other.constant.js",
        match: "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])"
      },
      {
        name: "variable.other.readwrite.js",
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      }
    ]
  },
  "object-identifiers": {
    patterns: [
      {
        name: "support.class.js",
        match: "([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\\??\\.\\s*prototype\\b(?!\\$))"
      },
      {
        match: "(?x)(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(?:\n  (\\#?[[:upper:]][_$[:digit:][:upper:]]*) |\n  (\\#?[_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "punctuation.accessor.js"
          },
          "2": {
            name: "punctuation.accessor.optional.js"
          },
          "3": {
            name: "variable.other.constant.object.property.js"
          },
          "4": {
            name: "variable.other.object.property.js"
          }
        }
      },
      {
        match: "(?x)(?:\n  ([[:upper:]][_$[:digit:][:upper:]]*) |\n  ([_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "variable.other.constant.object.js"
          },
          "2": {
            name: "variable.other.object.js"
          }
        }
      }
    ]
  },
  "type-annotation": {
    patterns: [
      {
        name: "meta.type.annotation.js",
        begin: "(:)(?=\\s*\\S)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.js"
          }
        },
        end: "(?<![:|&])((?=$|^|[,);\\}\\]]|//)|(?==[^>])|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "meta.type.annotation.js",
        begin: "(:)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.js"
          }
        },
        end: "(?<![:|&])((?=[,);\\}\\]]|//)|(?==[^>])|(?=^\\s*$)|((?<=\\S)(?=\\s*$))|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))",
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "parameter-type-annotation": {
    patterns: [
      {
        name: "meta.type.annotation.js",
        begin: "(:)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.js"
          }
        },
        end: "(?=[,)])|(?==[^>])",
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "return-type": {
    patterns: [
      {
        name: "meta.return.type.js",
        begin: "(?<=\\))\\s*(:)(?=\\s*\\S)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.js"
          }
        },
        end: "(?<![:|&])(?=$|^|[{};,]|//)",
        patterns: [
          {
            include: "#return-type-core"
          }
        ]
      },
      {
        name: "meta.return.type.js",
        begin: "(?<=\\))\\s*(:)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.js"
          }
        },
        end: "(?<![:|&])((?=[{};,]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))",
        patterns: [
          {
            include: "#return-type-core"
          }
        ]
      }
    ]
  },
  "return-type-core": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?<=[:|&])(?=\\s*\\{)",
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        include: "#type-predicate-operator"
      },
      {
        include: "#type"
      }
    ]
  },
  "arrow-return-type": {
    name: "meta.return.type.arrow.js",
    begin: "(?<=\\))\\s*(:)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.type.annotation.js"
      }
    },
    end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))",
    patterns: [
      {
        include: "#arrow-return-type-body"
      }
    ]
  },
  "possibly-arrow-return-type": {
    begin: "(?<=\\)|^)\\s*(:)(?=\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*=>)",
    beginCaptures: {
      "1": {
        name: "meta.arrow.js meta.return.type.arrow.js keyword.operator.type.annotation.js"
      }
    },
    end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))",
    contentName: "meta.arrow.js meta.return.type.arrow.js",
    patterns: [
      {
        include: "#arrow-return-type-body"
      }
    ]
  },
  "arrow-return-type-body": {
    patterns: [
      {
        begin: "(?<=[:])(?=\\s*\\{)",
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        include: "#type-predicate-operator"
      },
      {
        include: "#type"
      }
    ]
  },
  "type-parameters": {
    name: "meta.type.parameters.js",
    begin: "(<)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.typeparameters.begin.js"
      }
    },
    end: "(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.typeparameters.end.js"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        name: "storage.modifier.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        include: "#type"
      },
      {
        include: "#punctuation-comma"
      },
      {
        name: "keyword.operator.assignment.js",
        match: "(=)(?!>)"
      }
    ]
  },
  "type-arguments": {
    name: "meta.type.parameters.js",
    begin: "\\<",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.typeparameters.begin.js"
      }
    },
    end: "\\>",
    endCaptures: {
      "0": {
        name: "punctuation.definition.typeparameters.end.js"
      }
    },
    patterns: [
      {
        include: "#type-arguments-body"
      }
    ]
  },
  "type-arguments-body": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(_)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "0": {
            name: "keyword.operator.type.js"
          }
        }
      },
      {
        include: "#type"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  type: {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#type-string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#type-primitive"
      },
      {
        include: "#type-builtin-literals"
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#type-tuple"
      },
      {
        include: "#type-object"
      },
      {
        include: "#type-conditional"
      },
      {
        include: "#type-operators"
      },
      {
        include: "#type-fn-type-parameters"
      },
      {
        include: "#type-paren-or-function-parameters"
      },
      {
        include: "#type-function-return-type"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*",
        captures: {
          "1": {
            name: "storage.modifier.js"
          }
        }
      },
      {
        include: "#type-name"
      }
    ]
  },
  "type-primitive": {
    name: "support.type.primitive.js",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(string|number|bigint|boolean|symbol|any|void|never|unknown)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "type-builtin-literals": {
    name: "support.type.builtin.js",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(this|true|false|undefined|null|object)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "type-tuple": {
    name: "meta.type.tuple.js",
    begin: "\\[",
    beginCaptures: {
      "0": {
        name: "meta.brace.square.js"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "meta.brace.square.js"
      }
    },
    patterns: [
      {
        name: "keyword.operator.rest.js",
        match: "\\.\\.\\."
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([_$[:alpha:]][_$[:alnum:]]*)\\s*(\\?)?\\s*(:)",
        captures: {
          "1": {
            name: "entity.name.label.js"
          },
          "2": {
            name: "keyword.operator.optional.js"
          },
          "3": {
            name: "punctuation.separator.label.js"
          }
        }
      },
      {
        include: "#type"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "type-object": {
    name: "meta.object.type.js",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.js"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#method-declaration"
      },
      {
        include: "#indexer-declaration"
      },
      {
        include: "#indexer-mapped-type-declaration"
      },
      {
        include: "#field-declaration"
      },
      {
        include: "#type-annotation"
      },
      {
        begin: "\\.\\.\\.",
        beginCaptures: {
          "0": {
            name: "keyword.operator.spread.js"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        include: "#punctuation-comma"
      },
      {
        include: "#punctuation-semicolon"
      },
      {
        include: "#type"
      }
    ]
  },
  "type-conditional": {
    patterns: [
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends)\\s+",
        beginCaptures: {
          "1": {
            name: "storage.modifier.js"
          }
        },
        end: "(?<=:)",
        patterns: [
          {
            begin: "\\?",
            beginCaptures: {
              "0": {
                name: "keyword.operator.ternary.js"
              }
            },
            end: ":",
            endCaptures: {
              "0": {
                name: "keyword.operator.ternary.js"
              }
            },
            patterns: [
              {
                include: "#type"
              }
            ]
          },
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "type-paren-or-function-parameters": {
    name: "meta.type.paren.cover.js",
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "meta.brace.round.js"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "meta.brace.round.js"
      }
    },
    patterns: [
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=\\s*(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))))",
        captures: {
          "1": {
            name: "storage.modifier.js"
          },
          "2": {
            name: "keyword.operator.rest.js"
          },
          "3": {
            name: "entity.name.function.js variable.language.this.js"
          },
          "4": {
            name: "entity.name.function.js"
          },
          "5": {
            name: "keyword.operator.optional.js"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=:)",
        captures: {
          "1": {
            name: "storage.modifier.js"
          },
          "2": {
            name: "keyword.operator.rest.js"
          },
          "3": {
            name: "variable.parameter.js variable.language.this.js"
          },
          "4": {
            name: "variable.parameter.js"
          },
          "5": {
            name: "keyword.operator.optional.js"
          }
        }
      },
      {
        include: "#type-annotation"
      },
      {
        name: "punctuation.separator.parameter.js",
        match: ","
      },
      {
        include: "#type"
      }
    ]
  },
  "type-fn-type-parameters": {
    patterns: [
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b(?=\\s*\\<)",
        beginCaptures: {
          "1": {
            name: "meta.type.constructor.js storage.modifier.js"
          },
          "2": {
            name: "meta.type.constructor.js keyword.control.new.js"
          }
        },
        end: "(?<=>)",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#type-parameters"
          }
        ]
      },
      {
        name: "meta.type.constructor.js",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b\\s*(?=\\()",
        beginCaptures: {
          "1": {
            name: "storage.modifier.js"
          },
          "2": {
            name: "keyword.control.new.js"
          }
        },
        end: "(?<=\\))",
        patterns: [
          {
            include: "#function-parameters"
          }
        ]
      },
      {
        name: "meta.type.function.js",
        begin: "(?x)(\n  (?=\n    [(]\\s*(\n      ([)]) |\n      (\\.\\.\\.) |\n      ([_$[:alnum:]]+\\s*(\n        ([:,?=])|\n        ([)]\\s*=>)\n      ))\n    )\n  )\n)",
        end: "(?<=\\))",
        patterns: [
          {
            include: "#function-parameters"
          }
        ]
      }
    ]
  },
  "type-function-return-type": {
    patterns: [
      {
        name: "meta.type.function.return.js",
        begin: "(=>)(?=\\s*\\S)",
        beginCaptures: {
          "1": {
            name: "storage.type.function.arrow.js"
          }
        },
        end: "(?<!=>)(?<![|&])(?=[,\\]\\)\\{\\}=;>:\\?]|//|$)",
        patterns: [
          {
            include: "#type-function-return-type-core"
          }
        ]
      },
      {
        name: "meta.type.function.return.js",
        begin: "=>",
        beginCaptures: {
          "0": {
            name: "storage.type.function.arrow.js"
          }
        },
        end: "(?<!=>)(?<![|&])((?=[,\\]\\)\\{\\}=;:\\?>]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))",
        patterns: [
          {
            include: "#type-function-return-type-core"
          }
        ]
      }
    ]
  },
  "type-function-return-type-core": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?<==>)(?=\\s*\\{)",
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        include: "#type-predicate-operator"
      },
      {
        include: "#type"
      }
    ]
  },
  "type-operators": {
    patterns: [
      {
        include: "#typeof-operator"
      },
      {
        begin: "([&|])(?=\\s*\\{)",
        beginCaptures: {
          "0": {
            name: "keyword.operator.type.js"
          }
        },
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        begin: "[&|]",
        beginCaptures: {
          "0": {
            name: "keyword.operator.type.js"
          }
        },
        end: "(?=\\S)"
      },
      {
        name: "keyword.operator.expression.keyof.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))keyof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.ternary.js",
        match: "(\\?|\\:)"
      },
      {
        name: "keyword.operator.expression.infer.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))infer(?=\\s+[_$[:alpha:]])"
      },
      {
        name: "keyword.operator.expression.import.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*\\()"
      }
    ]
  },
  "type-predicate-operator": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(asserts)\\s+)?(?!asserts)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s(is)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "1": {
            name: "keyword.operator.type.asserts.js"
          },
          "2": {
            name: "variable.parameter.js variable.language.this.js"
          },
          "3": {
            name: "variable.parameter.js"
          },
          "4": {
            name: "keyword.operator.expression.is.js"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(asserts)\\s+(?!is)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "1": {
            name: "keyword.operator.type.asserts.js"
          },
          "2": {
            name: "variable.parameter.js variable.language.this.js"
          },
          "3": {
            name: "variable.parameter.js"
          }
        }
      },
      {
        name: "keyword.operator.type.asserts.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))asserts(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.expression.is.js",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))is(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "type-name": {
    patterns: [
      {
        begin: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(<)",
        captures: {
          "1": {
            name: "entity.name.type.module.js"
          },
          "2": {
            name: "punctuation.accessor.js"
          },
          "3": {
            name: "punctuation.accessor.optional.js"
          },
          "4": {
            name: "meta.type.parameters.js punctuation.definition.typeparameters.begin.js"
          }
        },
        end: "(>)",
        endCaptures: {
          "1": {
            name: "meta.type.parameters.js punctuation.definition.typeparameters.end.js"
          }
        },
        contentName: "meta.type.parameters.js",
        patterns: [
          {
            include: "#type-arguments-body"
          }
        ]
      },
      {
        begin: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(<)",
        beginCaptures: {
          "1": {
            name: "entity.name.type.js"
          },
          "2": {
            name: "meta.type.parameters.js punctuation.definition.typeparameters.begin.js"
          }
        },
        end: "(>)",
        endCaptures: {
          "1": {
            name: "meta.type.parameters.js punctuation.definition.typeparameters.end.js"
          }
        },
        contentName: "meta.type.parameters.js",
        patterns: [
          {
            include: "#type-arguments-body"
          }
        ]
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))",
        captures: {
          "1": {
            name: "entity.name.type.module.js"
          },
          "2": {
            name: "punctuation.accessor.js"
          },
          "3": {
            name: "punctuation.accessor.optional.js"
          }
        }
      },
      {
        name: "entity.name.type.js",
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      }
    ]
  },
  "punctuation-comma": {
    name: "punctuation.separator.comma.js",
    match: ","
  },
  "punctuation-semicolon": {
    name: "punctuation.terminator.statement.js",
    match: ";"
  },
  "punctuation-accessor": {
    match: "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))",
    captures: {
      "1": {
        name: "punctuation.accessor.js"
      },
      "2": {
        name: "punctuation.accessor.optional.js"
      }
    }
  },
  string: {
    patterns: [
      {
        include: "#qstring-single"
      },
      {
        include: "#qstring-double"
      },
      {
        include: "#template"
      }
    ]
  },
  "qstring-double": {
    name: "string.quoted.double.js",
    begin: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.js"
      }
    },
    end: '(")|((?:[^\\\\\\n])$)',
    endCaptures: {
      "1": {
        name: "punctuation.definition.string.end.js"
      },
      "2": {
        name: "invalid.illegal.newline.js"
      }
    },
    patterns: [
      {
        include: "#string-character-escape"
      }
    ]
  },
  "qstring-single": {
    name: "string.quoted.single.js",
    begin: "'",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.js"
      }
    },
    end: "(\\')|((?:[^\\\\\\n])$)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.string.end.js"
      },
      "2": {
        name: "invalid.illegal.newline.js"
      }
    },
    patterns: [
      {
        include: "#string-character-escape"
      }
    ]
  },
  "string-character-escape": {
    name: "constant.character.escape.js",
    match: "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|u\\{[0-9A-Fa-f]+\\}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)"
  },
  template: {
    patterns: [
      {
        include: "#template-call"
      },
      {
        name: "string.template.js",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)?(`)",
        beginCaptures: {
          "1": {
            name: "entity.name.function.tagged-template.js"
          },
          "2": {
            name: "punctuation.definition.string.template.begin.js"
          }
        },
        end: "`",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.template.end.js"
          }
        },
        patterns: [
          {
            include: "#template-substitution-element"
          },
          {
            include: "#string-character-escape"
          }
        ]
      }
    ]
  },
  "template-call": {
    patterns: [
      {
        name: "string.template.js",
        begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*)(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)",
        end: "(?=`)",
        patterns: [
          {
            begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*))",
            end: "(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)",
            patterns: [
              {
                include: "#support-function-call-identifiers"
              },
              {
                name: "entity.name.function.tagged-template.js",
                match: "([_$[:alpha:]][_$[:alnum:]]*)"
              }
            ]
          },
          {
            include: "#type-arguments"
          }
        ]
      },
      {
        name: "string.template.js",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)?\\s*(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)`)",
        beginCaptures: {
          "1": {
            name: "entity.name.function.tagged-template.js"
          }
        },
        end: "(?=`)",
        patterns: [
          {
            include: "#type-arguments"
          }
        ]
      }
    ]
  },
  "template-substitution-element": {
    name: "meta.template.expression.js",
    begin: "\\$\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.begin.js"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.end.js"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ],
    contentName: "meta.embedded.line.js"
  },
  "type-string": {
    patterns: [
      {
        include: "#qstring-single"
      },
      {
        include: "#qstring-double"
      },
      {
        include: "#template-type"
      }
    ]
  },
  "template-type": {
    patterns: [
      {
        include: "#template-call"
      },
      {
        name: "string.template.js",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)?(`)",
        beginCaptures: {
          "1": {
            name: "entity.name.function.tagged-template.js"
          },
          "2": {
            name: "punctuation.definition.string.template.begin.js"
          }
        },
        end: "`",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.template.end.js"
          }
        },
        patterns: [
          {
            include: "#template-type-substitution-element"
          },
          {
            include: "#string-character-escape"
          }
        ]
      }
    ]
  },
  "template-type-substitution-element": {
    name: "meta.template.expression.js",
    begin: "\\$\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.begin.js"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.end.js"
      }
    },
    patterns: [
      {
        include: "#type"
      }
    ],
    contentName: "meta.embedded.line.js"
  },
  regex: {
    patterns: [
      {
        name: "string.regexp.js",
        begin: "(?<!\\+\\+|--|})(?<=[=(:,\\[?+!]|^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case|=>|&&|\\|\\||\\*\\/)\\s*(\\/)(?![\\/*])(?=(?:[^\\/\\\\\\[\\()]|\\\\.|\\[([^\\]\\\\]|\\\\.)+\\]|\\(([^\\)\\\\]|\\\\.)+\\))+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.string.begin.js"
          }
        },
        end: "(/)([dgimsuy]*)",
        endCaptures: {
          "1": {
            name: "punctuation.definition.string.end.js"
          },
          "2": {
            name: "keyword.other.js"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      },
      {
        name: "string.regexp.js",
        begin: "((?<![_$[:alnum:])\\]]|\\+\\+|--|}|\\*\\/)|((?<=^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case))\\s*)\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.js"
          }
        },
        end: "(/)([dgimsuy]*)",
        endCaptures: {
          "1": {
            name: "punctuation.definition.string.end.js"
          },
          "2": {
            name: "keyword.other.js"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      }
    ]
  },
  regexp: {
    patterns: [
      {
        name: "keyword.control.anchor.regexp",
        match: "\\\\[bB]|\\^|\\$"
      },
      {
        match: "\\\\[1-9]\\d*|\\\\k<([a-zA-Z_$][\\w$]*)>",
        captures: {
          "0": {
            name: "keyword.other.back-reference.regexp"
          },
          "1": {
            name: "variable.other.regexp"
          }
        }
      },
      {
        name: "keyword.operator.quantifier.regexp",
        match: "[?+*]|\\{(\\d+,\\d+|\\d+,|,\\d+|\\d+)\\}\\??"
      },
      {
        name: "keyword.operator.or.regexp",
        match: "\\|"
      },
      {
        name: "meta.group.assertion.regexp",
        begin: "(\\()((\\?=)|(\\?!)|(\\?<=)|(\\?<!))",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.group.regexp"
          },
          "2": {
            name: "punctuation.definition.group.assertion.regexp"
          },
          "3": {
            name: "meta.assertion.look-ahead.regexp"
          },
          "4": {
            name: "meta.assertion.negative-look-ahead.regexp"
          },
          "5": {
            name: "meta.assertion.look-behind.regexp"
          },
          "6": {
            name: "meta.assertion.negative-look-behind.regexp"
          }
        },
        end: "(\\))",
        endCaptures: {
          "1": {
            name: "punctuation.definition.group.regexp"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      },
      {
        name: "meta.group.regexp",
        begin: "\\((?:(\\?:)|(?:\\?<([a-zA-Z_$][\\w$]*)>))?",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.group.regexp"
          },
          "1": {
            name: "punctuation.definition.group.no-capture.regexp"
          },
          "2": {
            name: "variable.other.regexp"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.definition.group.regexp"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      },
      {
        name: "constant.other.character-class.set.regexp",
        begin: "(\\[)(\\^)?",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.character-class.regexp"
          },
          "2": {
            name: "keyword.operator.negation.regexp"
          }
        },
        end: "(\\])",
        endCaptures: {
          "1": {
            name: "punctuation.definition.character-class.regexp"
          }
        },
        patterns: [
          {
            name: "constant.other.character-class.range.regexp",
            match: "(?:.|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))\\-(?:[^\\]\\\\]|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))",
            captures: {
              "1": {
                name: "constant.character.numeric.regexp"
              },
              "2": {
                name: "constant.character.control.regexp"
              },
              "3": {
                name: "constant.character.escape.backslash.regexp"
              },
              "4": {
                name: "constant.character.numeric.regexp"
              },
              "5": {
                name: "constant.character.control.regexp"
              },
              "6": {
                name: "constant.character.escape.backslash.regexp"
              }
            }
          },
          {
            include: "#regex-character-class"
          }
        ]
      },
      {
        include: "#regex-character-class"
      }
    ]
  },
  "regex-character-class": {
    patterns: [
      {
        name: "constant.other.character-class.regexp",
        match: "\\\\[wWsSdDtrnvf]|\\."
      },
      {
        name: "constant.character.numeric.regexp",
        match: "\\\\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})"
      },
      {
        name: "constant.character.control.regexp",
        match: "\\\\c[A-Z]"
      },
      {
        name: "constant.character.escape.backslash.regexp",
        match: "\\\\."
      }
    ]
  },
  comment: {
    patterns: [
      {
        name: "comment.block.documentation.js",
        begin: "/\\*\\*(?!/)",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.comment.js"
          }
        },
        end: "\\*/",
        endCaptures: {
          "0": {
            name: "punctuation.definition.comment.js"
          }
        },
        patterns: [
          {
            include: "#docblock"
          }
        ]
      },
      {
        name: "comment.block.js",
        begin: "(/\\*)(?:\\s*((@)internal)(?=\\s|(\\*/)))?",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.comment.js"
          },
          "2": {
            name: "storage.type.internaldeclaration.js"
          },
          "3": {
            name: "punctuation.decorator.internaldeclaration.js"
          }
        },
        end: "\\*/",
        endCaptures: {
          "0": {
            name: "punctuation.definition.comment.js"
          }
        }
      },
      {
        begin: "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)",
        beginCaptures: {
          "1": {
            name: "punctuation.whitespace.comment.leading.js"
          },
          "2": {
            name: "comment.line.double-slash.js"
          },
          "3": {
            name: "punctuation.definition.comment.js"
          },
          "4": {
            name: "storage.type.internaldeclaration.js"
          },
          "5": {
            name: "punctuation.decorator.internaldeclaration.js"
          }
        },
        end: "(?=$)",
        contentName: "comment.line.double-slash.js"
      }
    ]
  },
  "single-line-comment-consuming-line-ending": {
    begin: "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)",
    beginCaptures: {
      "1": {
        name: "punctuation.whitespace.comment.leading.js"
      },
      "2": {
        name: "comment.line.double-slash.js"
      },
      "3": {
        name: "punctuation.definition.comment.js"
      },
      "4": {
        name: "storage.type.internaldeclaration.js"
      },
      "5": {
        name: "punctuation.decorator.internaldeclaration.js"
      }
    },
    end: "(?=^)",
    contentName: "comment.line.double-slash.js"
  },
  directives: {
    name: "comment.line.triple-slash.directive.js",
    begin: "^(///)\\s*(?=<(reference|amd-dependency|amd-module)(\\s+(path|types|no-default-lib|lib|name)\\s*=\\s*((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)))+\\s*/>\\s*$)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.comment.js"
      }
    },
    end: "(?=$)",
    patterns: [
      {
        name: "meta.tag.js",
        begin: "(<)(reference|amd-dependency|amd-module)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.directive.js"
          },
          "2": {
            name: "entity.name.tag.directive.js"
          }
        },
        end: "/>",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.directive.js"
          }
        },
        patterns: [
          {
            name: "entity.other.attribute-name.directive.js",
            match: "path|types|no-default-lib|lib|name"
          },
          {
            name: "keyword.operator.assignment.js",
            match: "="
          },
          {
            include: "#string"
          }
        ]
      }
    ]
  },
  docblock: {
    patterns: [
      {
        match: "(?x)\n((@)(?:access|api))\n\\s+\n(private|protected|public)\n\\b",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "constant.language.access-type.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)author)\n\\s+\n(\n  [^@\\s<>*/]\n  (?:[^@<>*/]|\\*[^/])*\n)\n(?:\n  \\s*\n  (<)\n  ([^>\\s]+)\n  (>)\n)?",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "entity.name.type.instance.jsdoc"
          },
          "4": {
            name: "punctuation.definition.bracket.angle.begin.jsdoc"
          },
          "5": {
            name: "constant.other.email.link.underline.jsdoc"
          },
          "6": {
            name: "punctuation.definition.bracket.angle.end.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)borrows) \\s+\n((?:[^@\\s*/]|\\*[^/])+)    # <that namepath>\n\\s+ (as) \\s+              # as\n((?:[^@\\s*/]|\\*[^/])+)    # <this namepath>",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "entity.name.type.instance.jsdoc"
          },
          "4": {
            name: "keyword.operator.control.jsdoc"
          },
          "5": {
            name: "entity.name.type.instance.jsdoc"
          }
        }
      },
      {
        name: "meta.example.jsdoc",
        begin: "((@)example)\\s+",
        end: "(?=@|\\*/)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        patterns: [
          {
            match: "^\\s\\*\\s+"
          },
          {
            contentName: "constant.other.description.jsdoc",
            begin: "\\G(<)caption(>)",
            beginCaptures: {
              "0": {
                name: "entity.name.tag.inline.jsdoc"
              },
              "1": {
                name: "punctuation.definition.bracket.angle.begin.jsdoc"
              },
              "2": {
                name: "punctuation.definition.bracket.angle.end.jsdoc"
              }
            },
            end: "(</)caption(>)|(?=\\*/)",
            endCaptures: {
              "0": {
                name: "entity.name.tag.inline.jsdoc"
              },
              "1": {
                name: "punctuation.definition.bracket.angle.begin.jsdoc"
              },
              "2": {
                name: "punctuation.definition.bracket.angle.end.jsdoc"
              }
            }
          },
          {
            match: "[^\\s@*](?:[^*]|\\*[^/])*",
            captures: {
              "0": {
                name: "source.embedded.js"
              }
            }
          }
        ]
      },
      {
        match: "(?x) ((@)kind) \\s+ (class|constant|event|external|file|function|member|mixin|module|namespace|typedef) \\b",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "constant.language.symbol-type.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)see)\n\\s+\n(?:\n  # URL\n  (\n    (?=https?://)\n    (?:[^\\s*]|\\*[^/])+\n  )\n  |\n  # JSDoc namepath\n  (\n    (?!\n      # Avoid matching bare URIs (also acceptable as links)\n      https?://\n      |\n      # Avoid matching {@inline tags}; we match those below\n      (?:\\[[^\\[\\]]*\\])? # Possible description [preceding]{@tag}\n      {@(?:link|linkcode|linkplain|tutorial)\\b\n    )\n    # Matched namepath\n    (?:[^@\\s*/]|\\*[^/])+\n  )\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.link.underline.jsdoc"
          },
          "4": {
            name: "entity.name.type.instance.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)template)\n\\s+\n# One or more valid identifiers\n(\n  [A-Za-z_$]         # First character: non-numeric word character\n  [\\w$.\\[\\]]*        # Rest of identifier\n  (?:                # Possible list of additional identifiers\n    \\s* , \\s*\n    [A-Za-z_$]\n    [\\w$.\\[\\]]*\n  )*\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n(\n  (@)\n  (?:arg|argument|const|constant|member|namespace|param|var)\n)\n\\s+\n(\n  [A-Za-z_$]\n  [\\w$.\\[\\]]*\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          }
        }
      },
      {
        begin: "((@)typedef)\\s+(?={)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])",
        patterns: [
          {
            include: "#jsdoctype"
          },
          {
            name: "entity.name.type.instance.jsdoc",
            match: "(?:[^@\\s*/]|\\*[^/])+"
          }
        ]
      },
      {
        begin: "((@)(?:arg|argument|const|constant|member|namespace|param|prop|property|var))\\s+(?={)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])",
        patterns: [
          {
            include: "#jsdoctype"
          },
          {
            name: "variable.other.jsdoc",
            match: "([A-Za-z_$][\\w$.\\[\\]]*)"
          },
          {
            name: "variable.other.jsdoc",
            match: `(?x)
(\\[)\\s*
[\\w$]+
(?:
  (?:\\[\\])?                                        # Foo[ ].bar properties within an array
  \\.                                                # Foo.Bar namespaced parameter
  [\\w$]+
)*
(?:
  \\s*
  (=)                                                # [foo=bar] Default parameter value
  \\s*
  (
    # The inner regexes are to stop the match early at */ and to not stop at escaped quotes
    (?>
      "(?:(?:\\*(?!/))|(?:\\\\(?!"))|[^*\\\\])*?" |                      # [foo="bar"] Double-quoted
      '(?:(?:\\*(?!/))|(?:\\\\(?!'))|[^*\\\\])*?' |                      # [foo='bar'] Single-quoted
      \\[ (?:(?:\\*(?!/))|[^*])*? \\] |                                # [foo=[1,2]] Array literal
      (?:(?:\\*(?!/))|\\s(?!\\s*\\])|\\[.*?(?:\\]|(?=\\*/))|[^*\\s\\[\\]])*   # Everything else
    )*
  )
)?
\\s*(?:(\\])((?:[^*\\s]|\\*[^\\s/])+)?|(?=\\*/))`,
            captures: {
              "1": {
                name: "punctuation.definition.optional-value.begin.bracket.square.jsdoc"
              },
              "2": {
                name: "keyword.operator.assignment.jsdoc"
              },
              "3": {
                name: "source.embedded.js"
              },
              "4": {
                name: "punctuation.definition.optional-value.end.bracket.square.jsdoc"
              },
              "5": {
                name: "invalid.illegal.syntax.jsdoc"
              }
            }
          }
        ]
      },
      {
        begin: "(?x)\n(\n  (@)\n  (?:define|enum|exception|export|extends|lends|implements|modifies\n  |namespace|private|protected|returns?|suppress|this|throws|type\n  |yields?)\n)\n\\s+(?={)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])",
        patterns: [
          {
            include: "#jsdoctype"
          }
        ]
      },
      {
        match: "(?x)\n(\n  (@)\n  (?:alias|augments|callback|constructs|emits|event|fires|exports?\n  |extends|external|function|func|host|lends|listens|interface|memberof!?\n  |method|module|mixes|mixin|name|requires|see|this|typedef|uses)\n)\n\\s+\n(\n  (?:\n    [^{}@\\s*] | \\*[^/]\n  )+\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "entity.name.type.instance.jsdoc"
          }
        }
      },
      {
        contentName: "variable.other.jsdoc",
        begin: `((@)(?:default(?:value)?|license|version))\\s+(([''"]))`,
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          },
          "4": {
            name: "punctuation.definition.string.begin.jsdoc"
          }
        },
        end: "(\\3)|(?=$|\\*/)",
        endCaptures: {
          "0": {
            name: "variable.other.jsdoc"
          },
          "1": {
            name: "punctuation.definition.string.end.jsdoc"
          }
        }
      },
      {
        match: "((@)(?:default(?:value)?|license|tutorial|variation|version))\\s+([^\\s*]+)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          }
        }
      },
      {
        name: "storage.type.class.jsdoc",
        match: "(?x) (@) (?:abstract|access|alias|api|arg|argument|async|attribute|augments|author|beta|borrows|bubbles |callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright |default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exception |exports?|extends|extension(?:_?for)?|external|externs|file|fileoverview|final|fires|for|func |function|generator|global|hideconstructor|host|ignore|implements|implicitCast|inherit[Dd]oc |inner|instance|interface|internal|kind|lends|license|listens|main|member|memberof!?|method |mixes|mixins?|modifies|module|name|namespace|noalias|nocollapse|nocompile|nosideeffects |override|overview|package|param|polymer(?:Behavior)?|preserve|private|prop|property|protected |public|read[Oo]nly|record|require[ds]|returns?|see|since|static|struct|submodule|summary |suppress|template|this|throws|todo|tutorial|type|typedef|unrestricted|uses|var|variation |version|virtual|writeOnce|yields?) \\b",
        captures: {
          "1": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        }
      },
      {
        include: "#inline-tags"
      },
      {
        match: "((@)(?:[_$[:alpha:]][_$[:alnum:]]*))(?=\\s+)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        }
      }
    ]
  },
  brackets: {
    patterns: [
      {
        begin: "{",
        end: "}|(?=\\*/)",
        patterns: [
          {
            include: "#brackets"
          }
        ]
      },
      {
        begin: "\\[",
        end: "\\]|(?=\\*/)",
        patterns: [
          {
            include: "#brackets"
          }
        ]
      }
    ]
  },
  "inline-tags": {
    patterns: [
      {
        name: "constant.other.description.jsdoc",
        match: "(\\[)[^\\]]+(\\])(?={@(?:link|linkcode|linkplain|tutorial))",
        captures: {
          "1": {
            name: "punctuation.definition.bracket.square.begin.jsdoc"
          },
          "2": {
            name: "punctuation.definition.bracket.square.end.jsdoc"
          }
        }
      },
      {
        name: "entity.name.type.instance.jsdoc",
        begin: "({)((@)(?:link(?:code|plain)?|tutorial))\\s*",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.bracket.curly.begin.jsdoc"
          },
          "2": {
            name: "storage.type.class.jsdoc"
          },
          "3": {
            name: "punctuation.definition.inline.tag.jsdoc"
          }
        },
        end: "}|(?=\\*/)",
        endCaptures: {
          "0": {
            name: "punctuation.definition.bracket.curly.end.jsdoc"
          }
        },
        patterns: [
          {
            match: "\\G((?=https?://)(?:[^|}\\s*]|\\*[/])+)(\\|)?",
            captures: {
              "1": {
                name: "variable.other.link.underline.jsdoc"
              },
              "2": {
                name: "punctuation.separator.pipe.jsdoc"
              }
            }
          },
          {
            match: "\\G((?:[^{}@\\s|*]|\\*[^/])+)(\\|)?",
            captures: {
              "1": {
                name: "variable.other.description.jsdoc"
              },
              "2": {
                name: "punctuation.separator.pipe.jsdoc"
              }
            }
          }
        ]
      }
    ]
  },
  jsdoctype: {
    patterns: [
      {
        contentName: "entity.name.type.instance.jsdoc",
        begin: "\\G({)",
        beginCaptures: {
          "0": {
            name: "entity.name.type.instance.jsdoc"
          },
          "1": {
            name: "punctuation.definition.bracket.curly.begin.jsdoc"
          }
        },
        end: "((}))\\s*|(?=\\*/)",
        endCaptures: {
          "1": {
            name: "entity.name.type.instance.jsdoc"
          },
          "2": {
            name: "punctuation.definition.bracket.curly.end.jsdoc"
          }
        },
        patterns: [
          {
            include: "#brackets"
          }
        ]
      }
    ]
  },
  jsx: {
    patterns: [
      {
        include: "#jsx-tag-without-attributes-in-expression"
      },
      {
        include: "#jsx-tag-in-expression"
      }
    ]
  },
  "jsx-tag-without-attributes-in-expression": {
    begin: "(?<!\\+\\+|--)(?<=[({\\[,?=>:*]|&&|\\|\\||\\?|\\*\\/|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^default|[^\\._$[:alnum:]]default|^yield|[^\\._$[:alnum:]]yield|^)\\s*(?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))",
    end: "(?!(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))",
    patterns: [
      {
        include: "#jsx-tag-without-attributes"
      }
    ]
  },
  "jsx-tag-without-attributes": {
    name: "meta.tag.without-attributes.js",
    begin: "(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>)",
    end: "(</)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.js"
      },
      "2": {
        name: "entity.name.tag.namespace.js"
      },
      "3": {
        name: "punctuation.separator.namespace.js"
      },
      "4": {
        name: "entity.name.tag.js"
      },
      "5": {
        name: "support.class.component.js"
      },
      "6": {
        name: "punctuation.definition.tag.end.js"
      }
    },
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.js"
      },
      "2": {
        name: "entity.name.tag.namespace.js"
      },
      "3": {
        name: "punctuation.separator.namespace.js"
      },
      "4": {
        name: "entity.name.tag.js"
      },
      "5": {
        name: "support.class.component.js"
      },
      "6": {
        name: "punctuation.definition.tag.end.js"
      }
    },
    contentName: "meta.jsx.children.js",
    patterns: [
      {
        include: "#jsx-children"
      }
    ]
  },
  "jsx-tag-in-expression": {
    begin: "(?x)\n  (?<!\\+\\+|--)(?<=[({\\[,?=>:*]|&&|\\|\\||\\?|\\*\\/|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^default|[^\\._$[:alnum:]]default|^yield|[^\\._$[:alnum:]]yield|^)\\s*\n  (?!<\\s*[_$[:alpha:]][_$[:alnum:]]*((\\s+extends\\s+[^=>])|,)) # look ahead is not type parameter of arrow\n  (?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))",
    end: "(?!(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))",
    patterns: [
      {
        include: "#jsx-tag"
      }
    ]
  },
  "jsx-tag": {
    name: "meta.tag.js",
    begin: "(?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))",
    end: "(/>)|(?:(</)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.js"
      },
      "2": {
        name: "punctuation.definition.tag.begin.js"
      },
      "3": {
        name: "entity.name.tag.namespace.js"
      },
      "4": {
        name: "punctuation.separator.namespace.js"
      },
      "5": {
        name: "entity.name.tag.js"
      },
      "6": {
        name: "support.class.component.js"
      },
      "7": {
        name: "punctuation.definition.tag.end.js"
      }
    },
    patterns: [
      {
        begin: "(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.js"
          },
          "2": {
            name: "entity.name.tag.namespace.js"
          },
          "3": {
            name: "punctuation.separator.namespace.js"
          },
          "4": {
            name: "entity.name.tag.js"
          },
          "5": {
            name: "support.class.component.js"
          }
        },
        end: "(?=[/]?>)",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#type-arguments"
          },
          {
            include: "#jsx-tag-attributes"
          }
        ]
      },
      {
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.js"
          }
        },
        end: "(?=</)",
        contentName: "meta.jsx.children.js",
        patterns: [
          {
            include: "#jsx-children"
          }
        ]
      }
    ]
  },
  "jsx-children": {
    patterns: [
      {
        include: "#jsx-tag-without-attributes"
      },
      {
        include: "#jsx-tag"
      },
      {
        include: "#jsx-evaluated-code"
      },
      {
        include: "#jsx-entities"
      }
    ]
  },
  "jsx-evaluated-code": {
    contentName: "meta.embedded.expression.js",
    begin: "\\{",
    end: "\\}",
    beginCaptures: {
      "0": {
        name: "punctuation.section.embedded.begin.js"
      }
    },
    endCaptures: {
      "0": {
        name: "punctuation.section.embedded.end.js"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "jsx-entities": {
    patterns: [
      {
        name: "constant.character.entity.js",
        match: "(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)",
        captures: {
          "1": {
            name: "punctuation.definition.entity.js"
          },
          "3": {
            name: "punctuation.definition.entity.js"
          }
        }
      },
      {
        name: "invalid.illegal.bad-ampersand.js",
        match: "&"
      }
    ]
  },
  "jsx-tag-attributes": {
    name: "meta.tag.attributes.js",
    begin: "\\s+",
    end: "(?=[/]?>)",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#jsx-tag-attribute-name"
      },
      {
        include: "#jsx-tag-attribute-assignment"
      },
      {
        include: "#jsx-string-double-quoted"
      },
      {
        include: "#jsx-string-single-quoted"
      },
      {
        include: "#jsx-evaluated-code"
      },
      {
        include: "#jsx-tag-attributes-illegal"
      }
    ]
  },
  "jsx-tag-attribute-name": {
    match: "(?x)\n  \\s*\n  (?:([_$[:alpha:]][-_$[:alnum:].]*)(:))?\n  ([_$[:alpha:]][-_$[:alnum:]]*)\n  (?=\\s|=|/?>|/\\*|//)",
    captures: {
      "1": {
        name: "entity.other.attribute-name.namespace.js"
      },
      "2": {
        name: "punctuation.separator.namespace.js"
      },
      "3": {
        name: "entity.other.attribute-name.js"
      }
    }
  },
  "jsx-tag-attribute-assignment": {
    name: "keyword.operator.assignment.js",
    match: `=(?=\\s*(?:'|"|{|/\\*|//|\\n))`
  },
  "jsx-string-double-quoted": {
    name: "string.quoted.double.js",
    begin: '"',
    end: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.js"
      }
    },
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.js"
      }
    },
    patterns: [
      {
        include: "#jsx-entities"
      }
    ]
  },
  "jsx-string-single-quoted": {
    name: "string.quoted.single.js",
    begin: "'",
    end: "'",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.js"
      }
    },
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.js"
      }
    },
    patterns: [
      {
        include: "#jsx-entities"
      }
    ]
  },
  "jsx-tag-attributes-illegal": {
    name: "invalid.illegal.attribute.js",
    match: "\\S+"
  }
};
const javascript_tmLanguage = {
  information_for_contributors: information_for_contributors$6,
  version: version$6,
  name: name$9,
  scopeName: scopeName$8,
  patterns: patterns$8,
  repository: repository$8
};
const __vite_glob_0_2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: javascript_tmLanguage,
  information_for_contributors: information_for_contributors$6,
  name: name$9,
  patterns: patterns$8,
  repository: repository$8,
  scopeName: scopeName$8,
  version: version$6
}, Symbol.toStringTag, { value: "Module" }));
const information_for_contributors$5 = [
  "This file has been converted from https://github.com/microsoft/vscode-JSON.tmLanguage/blob/master/JSON.tmLanguage",
  "If you want to provide a fix or improvement, please create a pull request against the original repository.",
  "Once accepted there, we are happy to receive an update request."
];
const version$5 = "https://github.com/microsoft/vscode-JSON.tmLanguage/commit/9bd83f1c252b375e957203f21793316203f61f70";
const name$8 = "json";
const scopeName$7 = "source.json";
const patterns$7 = [
  {
    include: "#value"
  }
];
const repository$7 = {
  array: {
    begin: "\\[",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.array.begin.json"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.array.end.json"
      }
    },
    name: "meta.structure.array.json",
    patterns: [
      {
        include: "#value"
      },
      {
        match: ",",
        name: "punctuation.separator.array.json"
      },
      {
        match: "[^\\s\\]]",
        name: "invalid.illegal.expected-array-separator.json"
      }
    ]
  },
  comments: {
    patterns: [
      {
        begin: "/\\*\\*(?!/)",
        captures: {
          "0": {
            name: "punctuation.definition.comment.json"
          }
        },
        end: "\\*/",
        name: "comment.block.documentation.json"
      },
      {
        begin: "/\\*",
        captures: {
          "0": {
            name: "punctuation.definition.comment.json"
          }
        },
        end: "\\*/",
        name: "comment.block.json"
      },
      {
        captures: {
          "1": {
            name: "punctuation.definition.comment.json"
          }
        },
        match: "(//).*$\\n?",
        name: "comment.line.double-slash.js"
      }
    ]
  },
  constant: {
    match: "\\b(?:true|false|null)\\b",
    name: "constant.language.json"
  },
  number: {
    match: "(?x)        # turn on extended mode\n  -?        # an optional minus\n  (?:\n    0       # a zero\n    |       # ...or...\n    [1-9]   # a 1-9 character\n    \\d*     # followed by zero or more digits\n  )\n  (?:\n    (?:\n      \\.    # a period\n      \\d+   # followed by one or more digits\n    )?\n    (?:\n      [eE]  # an e character\n      [+-]? # followed by an option +/-\n      \\d+   # followed by one or more digits\n    )?      # make exponent optional\n  )?        # make decimal portion optional",
    name: "constant.numeric.json"
  },
  object: {
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.dictionary.begin.json"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.dictionary.end.json"
      }
    },
    name: "meta.structure.dictionary.json",
    patterns: [
      {
        comment: "the JSON object key",
        include: "#objectkey"
      },
      {
        include: "#comments"
      },
      {
        begin: ":",
        beginCaptures: {
          "0": {
            name: "punctuation.separator.dictionary.key-value.json"
          }
        },
        end: "(,)|(?=\\})",
        endCaptures: {
          "1": {
            name: "punctuation.separator.dictionary.pair.json"
          }
        },
        name: "meta.structure.dictionary.value.json",
        patterns: [
          {
            comment: "the JSON object value",
            include: "#value"
          },
          {
            match: "[^\\s,]",
            name: "invalid.illegal.expected-dictionary-separator.json"
          }
        ]
      },
      {
        match: "[^\\s\\}]",
        name: "invalid.illegal.expected-dictionary-separator.json"
      }
    ]
  },
  string: {
    begin: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.json"
      }
    },
    end: '"',
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.json"
      }
    },
    name: "string.quoted.double.json",
    patterns: [
      {
        include: "#stringcontent"
      }
    ]
  },
  objectkey: {
    begin: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.support.type.property-name.begin.json"
      }
    },
    end: '"',
    endCaptures: {
      "0": {
        name: "punctuation.support.type.property-name.end.json"
      }
    },
    name: "string.json support.type.property-name.json",
    patterns: [
      {
        include: "#stringcontent"
      }
    ]
  },
  stringcontent: {
    patterns: [
      {
        match: '(?x)                # turn on extended mode\n  \\\\                # a literal backslash\n  (?:               # ...followed by...\n    ["\\\\/bfnrt]     # one of these characters\n    |               # ...or...\n    u               # a u\n    [0-9a-fA-F]{4}) # and four hex digits',
        name: "constant.character.escape.json"
      },
      {
        match: "\\\\.",
        name: "invalid.illegal.unrecognized-string-escape.json"
      }
    ]
  },
  value: {
    patterns: [
      {
        include: "#constant"
      },
      {
        include: "#number"
      },
      {
        include: "#string"
      },
      {
        include: "#array"
      },
      {
        include: "#object"
      },
      {
        include: "#comments"
      }
    ]
  }
};
const json_tmLanguage = {
  information_for_contributors: information_for_contributors$5,
  version: version$5,
  name: name$8,
  scopeName: scopeName$7,
  patterns: patterns$7,
  repository: repository$7
};
const __vite_glob_0_3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: json_tmLanguage,
  information_for_contributors: information_for_contributors$5,
  name: name$8,
  patterns: patterns$7,
  repository: repository$7,
  scopeName: scopeName$7,
  version: version$5
}, Symbol.toStringTag, { value: "Module" }));
const information_for_contributors$4 = [
  "This file has been converted from https://github.com/microsoft/vscode-JSON.tmLanguage/blob/master/JSON.tmLanguage",
  "If you want to provide a fix or improvement, please create a pull request against the original repository.",
  "Once accepted there, we are happy to receive an update request."
];
const version$4 = "https://github.com/microsoft/vscode-JSON.tmLanguage/commit/9bd83f1c252b375e957203f21793316203f61f70";
const name$7 = "jsonc";
const scopeName$6 = "source.json.comments";
const patterns$6 = [
  {
    include: "#value"
  }
];
const repository$6 = {
  array: {
    begin: "\\[",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.array.begin.json.comments"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.array.end.json.comments"
      }
    },
    name: "meta.structure.array.json.comments",
    patterns: [
      {
        include: "#value"
      },
      {
        match: ",",
        name: "punctuation.separator.array.json.comments"
      },
      {
        match: "[^\\s\\]]",
        name: "invalid.illegal.expected-array-separator.json.comments"
      }
    ]
  },
  comments: {
    patterns: [
      {
        begin: "/\\*\\*(?!/)",
        captures: {
          "0": {
            name: "punctuation.definition.comment.json.comments"
          }
        },
        end: "\\*/",
        name: "comment.block.documentation.json.comments"
      },
      {
        begin: "/\\*",
        captures: {
          "0": {
            name: "punctuation.definition.comment.json.comments"
          }
        },
        end: "\\*/",
        name: "comment.block.json.comments"
      },
      {
        captures: {
          "1": {
            name: "punctuation.definition.comment.json.comments"
          }
        },
        match: "(//).*$\\n?",
        name: "comment.line.double-slash.js"
      }
    ]
  },
  constant: {
    match: "\\b(?:true|false|null)\\b",
    name: "constant.language.json.comments"
  },
  number: {
    match: "(?x)        # turn on extended mode\n  -?        # an optional minus\n  (?:\n    0       # a zero\n    |       # ...or...\n    [1-9]   # a 1-9 character\n    \\d*     # followed by zero or more digits\n  )\n  (?:\n    (?:\n      \\.    # a period\n      \\d+   # followed by one or more digits\n    )?\n    (?:\n      [eE]  # an e character\n      [+-]? # followed by an option +/-\n      \\d+   # followed by one or more digits\n    )?      # make exponent optional\n  )?        # make decimal portion optional",
    name: "constant.numeric.json.comments"
  },
  object: {
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.dictionary.begin.json.comments"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.dictionary.end.json.comments"
      }
    },
    name: "meta.structure.dictionary.json.comments",
    patterns: [
      {
        comment: "the JSON object key",
        include: "#objectkey"
      },
      {
        include: "#comments"
      },
      {
        begin: ":",
        beginCaptures: {
          "0": {
            name: "punctuation.separator.dictionary.key-value.json.comments"
          }
        },
        end: "(,)|(?=\\})",
        endCaptures: {
          "1": {
            name: "punctuation.separator.dictionary.pair.json.comments"
          }
        },
        name: "meta.structure.dictionary.value.json.comments",
        patterns: [
          {
            comment: "the JSON object value",
            include: "#value"
          },
          {
            match: "[^\\s,]",
            name: "invalid.illegal.expected-dictionary-separator.json.comments"
          }
        ]
      },
      {
        match: "[^\\s\\}]",
        name: "invalid.illegal.expected-dictionary-separator.json.comments"
      }
    ]
  },
  string: {
    begin: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.json.comments"
      }
    },
    end: '"',
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.json.comments"
      }
    },
    name: "string.quoted.double.json.comments",
    patterns: [
      {
        include: "#stringcontent"
      }
    ]
  },
  objectkey: {
    begin: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.support.type.property-name.begin.json.comments"
      }
    },
    end: '"',
    endCaptures: {
      "0": {
        name: "punctuation.support.type.property-name.end.json.comments"
      }
    },
    name: "string.json.comments support.type.property-name.json.comments",
    patterns: [
      {
        include: "#stringcontent"
      }
    ]
  },
  stringcontent: {
    patterns: [
      {
        match: '(?x)                # turn on extended mode\n  \\\\                # a literal backslash\n  (?:               # ...followed by...\n    ["\\\\/bfnrt]     # one of these characters\n    |               # ...or...\n    u               # a u\n    [0-9a-fA-F]{4}) # and four hex digits',
        name: "constant.character.escape.json.comments"
      },
      {
        match: "\\\\.",
        name: "invalid.illegal.unrecognized-string-escape.json.comments"
      }
    ]
  },
  value: {
    patterns: [
      {
        include: "#constant"
      },
      {
        include: "#number"
      },
      {
        include: "#string"
      },
      {
        include: "#array"
      },
      {
        include: "#object"
      },
      {
        include: "#comments"
      }
    ]
  }
};
const jsonc_tmLanguage = {
  information_for_contributors: information_for_contributors$4,
  version: version$4,
  name: name$7,
  scopeName: scopeName$6,
  patterns: patterns$6,
  repository: repository$6
};
const __vite_glob_0_4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: jsonc_tmLanguage,
  information_for_contributors: information_for_contributors$4,
  name: name$7,
  patterns: patterns$6,
  repository: repository$6,
  scopeName: scopeName$6,
  version: version$4
}, Symbol.toStringTag, { value: "Module" }));
const information_for_contributors$3 = [
  "This file has been converted from https://github.com/microsoft/TypeScript-TmLanguage/blob/master/TypeScriptReact.tmLanguage",
  "If you want to provide a fix or improvement, please create a pull request against the original repository.",
  "Once accepted there, we are happy to receive an update request."
];
const version$3 = "https://github.com/microsoft/TypeScript-TmLanguage/commit/33d8371c344f0b54746586313a939f742f9bcd3a";
const name$6 = "jsx";
const scopeName$5 = "source.js.jsx";
const patterns$5 = [
  {
    include: "#directives"
  },
  {
    include: "#statements"
  },
  {
    include: "#shebang"
  }
];
const repository$5 = {
  shebang: {
    name: "comment.line.shebang.js.jsx",
    match: "\\A(#!).*(?=$)",
    captures: {
      "1": {
        name: "punctuation.definition.comment.js.jsx"
      }
    }
  },
  statements: {
    patterns: [
      {
        include: "#declaration"
      },
      {
        include: "#control-statement"
      },
      {
        include: "#after-operator-block-as-object-literal"
      },
      {
        include: "#decl-block"
      },
      {
        include: "#label"
      },
      {
        include: "#expression"
      },
      {
        include: "#punctuation-semicolon"
      },
      {
        include: "#string"
      },
      {
        include: "#comment"
      }
    ]
  },
  declaration: {
    patterns: [
      {
        include: "#decorator"
      },
      {
        include: "#var-expr"
      },
      {
        include: "#function-declaration"
      },
      {
        include: "#class-declaration"
      },
      {
        include: "#interface-declaration"
      },
      {
        include: "#enum-declaration"
      },
      {
        include: "#namespace-declaration"
      },
      {
        include: "#type-alias-declaration"
      },
      {
        include: "#import-equals-declaration"
      },
      {
        include: "#import-declaration"
      },
      {
        include: "#export-declaration"
      },
      {
        name: "storage.modifier.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(declare|export)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "control-statement": {
    patterns: [
      {
        include: "#switch-statement"
      },
      {
        include: "#for-loop"
      },
      {
        name: "keyword.control.trycatch.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(catch|finally|throw|try)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|goto)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "1": {
            name: "keyword.control.loop.js.jsx"
          },
          "2": {
            name: "entity.name.label.js.jsx"
          }
        }
      },
      {
        name: "keyword.control.loop.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|do|goto|while)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(return)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        beginCaptures: {
          "0": {
            name: "keyword.control.flow.js.jsx"
          }
        },
        end: "(?=[;}]|$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "keyword.control.switch.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default|switch)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        include: "#if-statement"
      },
      {
        name: "keyword.control.conditional.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(else|if)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.control.with.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(with)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.control.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(package)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.other.debugger.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(debugger)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  label: {
    patterns: [
      {
        begin: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)(?=\\s*\\{)",
        beginCaptures: {
          "1": {
            name: "entity.name.label.js.jsx"
          },
          "2": {
            name: "punctuation.separator.label.js.jsx"
          }
        },
        end: "(?<=\\})",
        patterns: [
          {
            include: "#decl-block"
          }
        ]
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)",
        captures: {
          "1": {
            name: "entity.name.label.js.jsx"
          },
          "2": {
            name: "punctuation.separator.label.js.jsx"
          }
        }
      }
    ]
  },
  expression: {
    patterns: [
      {
        include: "#expressionWithoutIdentifiers"
      },
      {
        include: "#identifiers"
      },
      {
        include: "#expressionPunctuations"
      }
    ]
  },
  expressionWithoutIdentifiers: {
    patterns: [
      {
        include: "#jsx"
      },
      {
        include: "#string"
      },
      {
        include: "#regex"
      },
      {
        include: "#comment"
      },
      {
        include: "#function-expression"
      },
      {
        include: "#class-expression"
      },
      {
        include: "#arrow-function"
      },
      {
        include: "#paren-expression-possibly-arrow"
      },
      {
        include: "#cast"
      },
      {
        include: "#ternary-expression"
      },
      {
        include: "#new-expr"
      },
      {
        include: "#instanceof-expr"
      },
      {
        include: "#object-literal"
      },
      {
        include: "#expression-operators"
      },
      {
        include: "#function-call"
      },
      {
        include: "#literal"
      },
      {
        include: "#support-objects"
      },
      {
        include: "#paren-expression"
      }
    ]
  },
  expressionPunctuations: {
    patterns: [
      {
        include: "#punctuation-comma"
      },
      {
        include: "#punctuation-accessor"
      }
    ]
  },
  decorator: {
    name: "meta.decorator.js.jsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))\\@",
    beginCaptures: {
      "0": {
        name: "punctuation.decorator.js.jsx"
      }
    },
    end: "(?=\\s)",
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "var-expr": {
    patterns: [
      {
        name: "meta.var.expr.js.jsx",
        begin: "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))",
        end: "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))|((?<!^let|[^\\._$[:alnum:]]let|^var|[^\\._$[:alnum:]]var)(?=\\s*$)))",
        patterns: [
          {
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*",
            beginCaptures: {
              "1": {
                name: "keyword.control.export.js.jsx"
              },
              "2": {
                name: "storage.modifier.js.jsx"
              },
              "3": {
                name: "storage.type.js.jsx"
              }
            },
            end: "(?=\\S)"
          },
          {
            include: "#destructuring-variable"
          },
          {
            include: "#var-single-variable"
          },
          {
            include: "#variable-initializer"
          },
          {
            include: "#comment"
          },
          {
            begin: "(,)\\s*((?!\\S)|(?=\\/\\/))",
            beginCaptures: {
              "1": {
                name: "punctuation.separator.comma.js.jsx"
              }
            },
            end: "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))",
            patterns: [
              {
                include: "#single-line-comment-consuming-line-ending"
              },
              {
                include: "#comment"
              },
              {
                include: "#destructuring-variable"
              },
              {
                include: "#var-single-variable"
              },
              {
                include: "#punctuation-comma"
              }
            ]
          },
          {
            include: "#punctuation-comma"
          }
        ]
      },
      {
        name: "meta.var.expr.js.jsx",
        begin: "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.js.jsx"
          },
          "2": {
            name: "storage.modifier.js.jsx"
          },
          "3": {
            name: "storage.type.js.jsx"
          }
        },
        end: "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))|((?<!^const|[^\\._$[:alnum:]]const)(?=\\s*$)))",
        patterns: [
          {
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*",
            beginCaptures: {
              "1": {
                name: "keyword.control.export.js.jsx"
              },
              "2": {
                name: "storage.modifier.js.jsx"
              },
              "3": {
                name: "storage.type.js.jsx"
              }
            },
            end: "(?=\\S)"
          },
          {
            include: "#destructuring-const"
          },
          {
            include: "#var-single-const"
          },
          {
            include: "#variable-initializer"
          },
          {
            include: "#comment"
          },
          {
            begin: "(,)\\s*((?!\\S)|(?=\\/\\/))",
            beginCaptures: {
              "1": {
                name: "punctuation.separator.comma.js.jsx"
              }
            },
            end: "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))",
            patterns: [
              {
                include: "#single-line-comment-consuming-line-ending"
              },
              {
                include: "#comment"
              },
              {
                include: "#destructuring-const"
              },
              {
                include: "#var-single-const"
              },
              {
                include: "#punctuation-comma"
              }
            ]
          },
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  },
  "var-single-variable": {
    patterns: [
      {
        name: "meta.var-single-variable.expr.js.jsx",
        begin: "(?x)([_$[:alpha:]][_$[:alnum:]]*)(\\!)?(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.js.jsx entity.name.function.js.jsx"
          },
          "2": {
            name: "keyword.operator.definiteassignment.js.jsx"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      },
      {
        name: "meta.var-single-variable.expr.js.jsx",
        begin: "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])(\\!)?",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.js.jsx variable.other.constant.js.jsx"
          },
          "2": {
            name: "keyword.operator.definiteassignment.js.jsx"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      },
      {
        name: "meta.var-single-variable.expr.js.jsx",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)(\\!)?",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.js.jsx variable.other.readwrite.js.jsx"
          },
          "2": {
            name: "keyword.operator.definiteassignment.js.jsx"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      }
    ]
  },
  "var-single-const": {
    patterns: [
      {
        name: "meta.var-single-variable.expr.js.jsx",
        begin: "(?x)([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.js.jsx variable.other.constant.js.jsx entity.name.function.js.jsx"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      },
      {
        name: "meta.var-single-variable.expr.js.jsx",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.js.jsx variable.other.constant.js.jsx"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      }
    ]
  },
  "var-single-variable-type-annotation": {
    patterns: [
      {
        include: "#type-annotation"
      },
      {
        include: "#string"
      },
      {
        include: "#comment"
      }
    ]
  },
  "destructuring-variable": {
    patterns: [
      {
        name: "meta.object-binding-pattern-variable.js.jsx",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#object-binding-pattern"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      },
      {
        name: "meta.array-binding-pattern-variable.js.jsx",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#array-binding-pattern"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      }
    ]
  },
  "destructuring-const": {
    patterns: [
      {
        name: "meta.object-binding-pattern-variable.js.jsx",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#object-binding-pattern-const"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      },
      {
        name: "meta.array-binding-pattern-variable.js.jsx",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#array-binding-pattern-const"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      }
    ]
  },
  "object-binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          },
          {
            include: "#binding-element"
          }
        ]
      },
      {
        include: "#object-binding-pattern"
      },
      {
        include: "#destructuring-variable-rest"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "object-binding-element-const": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          },
          {
            include: "#binding-element-const"
          }
        ]
      },
      {
        include: "#object-binding-pattern-const"
      },
      {
        include: "#destructuring-variable-rest-const"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "object-binding-element-propertyName": {
    begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
    end: "(:)",
    endCaptures: {
      "0": {
        name: "punctuation.destructuring.js.jsx"
      }
    },
    patterns: [
      {
        include: "#string"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#numeric-literal"
      },
      {
        name: "variable.object.property.js.jsx",
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  },
  "binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#regex"
      },
      {
        include: "#object-binding-pattern"
      },
      {
        include: "#array-binding-pattern"
      },
      {
        include: "#destructuring-variable-rest"
      },
      {
        include: "#variable-initializer"
      }
    ]
  },
  "binding-element-const": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#regex"
      },
      {
        include: "#object-binding-pattern-const"
      },
      {
        include: "#array-binding-pattern-const"
      },
      {
        include: "#destructuring-variable-rest-const"
      },
      {
        include: "#variable-initializer"
      }
    ]
  },
  "destructuring-variable-rest": {
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)",
    captures: {
      "1": {
        name: "keyword.operator.rest.js.jsx"
      },
      "2": {
        name: "meta.definition.variable.js.jsx variable.other.readwrite.js.jsx"
      }
    }
  },
  "destructuring-variable-rest-const": {
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)",
    captures: {
      "1": {
        name: "keyword.operator.rest.js.jsx"
      },
      "2": {
        name: "meta.definition.variable.js.jsx variable.other.constant.js.jsx"
      }
    }
  },
  "object-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.js.jsx"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.object.js.jsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.object.js.jsx"
      }
    },
    patterns: [
      {
        include: "#object-binding-element"
      }
    ]
  },
  "object-binding-pattern-const": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.js.jsx"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.object.js.jsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.object.js.jsx"
      }
    },
    patterns: [
      {
        include: "#object-binding-element-const"
      }
    ]
  },
  "array-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.js.jsx"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.array.js.jsx"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.array.js.jsx"
      }
    },
    patterns: [
      {
        include: "#binding-element"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "array-binding-pattern-const": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.js.jsx"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.array.js.jsx"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.array.js.jsx"
      }
    },
    patterns: [
      {
        include: "#binding-element-const"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "parameter-name": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)",
        captures: {
          "1": {
            name: "storage.modifier.js.jsx"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "1": {
            name: "storage.modifier.js.jsx"
          },
          "2": {
            name: "keyword.operator.rest.js.jsx"
          },
          "3": {
            name: "entity.name.function.js.jsx variable.language.this.js.jsx"
          },
          "4": {
            name: "entity.name.function.js.jsx"
          },
          "5": {
            name: "keyword.operator.optional.js.jsx"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)",
        captures: {
          "1": {
            name: "storage.modifier.js.jsx"
          },
          "2": {
            name: "keyword.operator.rest.js.jsx"
          },
          "3": {
            name: "variable.parameter.js.jsx variable.language.this.js.jsx"
          },
          "4": {
            name: "variable.parameter.js.jsx"
          },
          "5": {
            name: "keyword.operator.optional.js.jsx"
          }
        }
      }
    ]
  },
  "destructuring-parameter": {
    patterns: [
      {
        name: "meta.parameter.object-binding-pattern.js.jsx",
        begin: "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\{)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.rest.js.jsx"
          },
          "2": {
            name: "punctuation.definition.binding-pattern.object.js.jsx"
          }
        },
        end: "\\}",
        endCaptures: {
          "0": {
            name: "punctuation.definition.binding-pattern.object.js.jsx"
          }
        },
        patterns: [
          {
            include: "#parameter-object-binding-element"
          }
        ]
      },
      {
        name: "meta.paramter.array-binding-pattern.js.jsx",
        begin: "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\[)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.rest.js.jsx"
          },
          "2": {
            name: "punctuation.definition.binding-pattern.array.js.jsx"
          }
        },
        end: "\\]",
        endCaptures: {
          "0": {
            name: "punctuation.definition.binding-pattern.array.js.jsx"
          }
        },
        patterns: [
          {
            include: "#parameter-binding-element"
          },
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  },
  "parameter-object-binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          },
          {
            include: "#parameter-binding-element"
          }
        ]
      },
      {
        include: "#parameter-object-binding-pattern"
      },
      {
        include: "#destructuring-parameter-rest"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "parameter-binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#regex"
      },
      {
        include: "#parameter-object-binding-pattern"
      },
      {
        include: "#parameter-array-binding-pattern"
      },
      {
        include: "#destructuring-parameter-rest"
      },
      {
        include: "#variable-initializer"
      }
    ]
  },
  "destructuring-parameter-rest": {
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)",
    captures: {
      "1": {
        name: "keyword.operator.rest.js.jsx"
      },
      "2": {
        name: "variable.parameter.js.jsx"
      }
    }
  },
  "parameter-object-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.js.jsx"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.object.js.jsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.object.js.jsx"
      }
    },
    patterns: [
      {
        include: "#parameter-object-binding-element"
      }
    ]
  },
  "parameter-array-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.js.jsx"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.array.js.jsx"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.array.js.jsx"
      }
    },
    patterns: [
      {
        include: "#parameter-binding-element"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "field-declaration": {
    name: "meta.field.declaration.js.jsx",
    begin: "(?x)(?<!\\()(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s+)?(?=\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|\\}|$))",
    beginCaptures: {
      "1": {
        name: "storage.modifier.js.jsx"
      }
    },
    end: "(?x)(?=\\}|;|,|$|(^(?!\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|$))))|(?<=\\})",
    patterns: [
      {
        include: "#variable-initializer"
      },
      {
        include: "#type-annotation"
      },
      {
        include: "#string"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#comment"
      },
      {
        match: "(?x)(\\#?[_$[:alpha:]][_$[:alnum:]]*)(?:(\\?)|(\\!))?(?=\\s*\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "1": {
            name: "meta.definition.property.js.jsx entity.name.function.js.jsx"
          },
          "2": {
            name: "keyword.operator.optional.js.jsx"
          },
          "3": {
            name: "keyword.operator.definiteassignment.js.jsx"
          }
        }
      },
      {
        name: "meta.definition.property.js.jsx variable.object.property.js.jsx",
        match: "\\#?[_$[:alpha:]][_$[:alnum:]]*"
      },
      {
        name: "keyword.operator.optional.js.jsx",
        match: "\\?"
      },
      {
        name: "keyword.operator.definiteassignment.js.jsx",
        match: "\\!"
      }
    ]
  },
  "variable-initializer": {
    patterns: [
      {
        begin: "(?<!=|!)(=)(?!=)(?=\\s*\\S)(?!\\s*.*=>\\s*$)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.js.jsx"
          }
        },
        end: "(?=$|^|[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        begin: "(?<!=|!)(=)(?!=)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.js.jsx"
          }
        },
        end: "(?=[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))|(?=^\\s*$)|(?<=\\S)(?<!=)(?=\\s*$)",
        patterns: [
          {
            include: "#expression"
          }
        ]
      }
    ]
  },
  "function-declaration": {
    name: "meta.function.js.jsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js.jsx"
      },
      "2": {
        name: "storage.modifier.js.jsx"
      },
      "3": {
        name: "storage.modifier.async.js.jsx"
      },
      "4": {
        name: "storage.type.function.js.jsx"
      },
      "5": {
        name: "keyword.generator.asterisk.js.jsx"
      },
      "6": {
        name: "meta.definition.function.js.jsx entity.name.function.js.jsx"
      }
    },
    end: "(?=;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))|(?<=\\})",
    patterns: [
      {
        include: "#function-name"
      },
      {
        include: "#function-body"
      }
    ]
  },
  "function-expression": {
    name: "meta.function.expression.js.jsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*",
    beginCaptures: {
      "1": {
        name: "storage.modifier.async.js.jsx"
      },
      "2": {
        name: "storage.type.function.js.jsx"
      },
      "3": {
        name: "keyword.generator.asterisk.js.jsx"
      },
      "4": {
        name: "meta.definition.function.js.jsx entity.name.function.js.jsx"
      }
    },
    end: "(?=;)|(?<=\\})",
    patterns: [
      {
        include: "#function-name"
      },
      {
        include: "#single-line-comment-consuming-line-ending"
      },
      {
        include: "#function-body"
      }
    ]
  },
  "function-name": {
    name: "meta.definition.function.js.jsx entity.name.function.js.jsx",
    match: "[_$[:alpha:]][_$[:alnum:]]*"
  },
  "function-body": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#function-parameters"
      },
      {
        include: "#return-type"
      },
      {
        include: "#type-function-return-type"
      },
      {
        include: "#decl-block"
      },
      {
        name: "keyword.generator.asterisk.js.jsx",
        match: "\\*"
      }
    ]
  },
  "method-declaration": {
    patterns: [
      {
        name: "meta.method.declaration.js.jsx",
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?\\s*\\b(constructor)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        beginCaptures: {
          "1": {
            name: "storage.modifier.js.jsx"
          },
          "2": {
            name: "storage.modifier.js.jsx"
          },
          "3": {
            name: "storage.modifier.js.jsx"
          },
          "4": {
            name: "storage.modifier.async.js.jsx"
          },
          "5": {
            name: "storage.type.js.jsx"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#method-declaration-name"
          },
          {
            include: "#function-body"
          }
        ]
      },
      {
        name: "meta.method.declaration.js.jsx",
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:(?:\\s*\\b(new)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|(?:(\\*)\\s*)?)(?=\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
        beginCaptures: {
          "1": {
            name: "storage.modifier.js.jsx"
          },
          "2": {
            name: "storage.modifier.js.jsx"
          },
          "3": {
            name: "storage.modifier.js.jsx"
          },
          "4": {
            name: "storage.modifier.async.js.jsx"
          },
          "5": {
            name: "keyword.operator.new.js.jsx"
          },
          "6": {
            name: "keyword.generator.asterisk.js.jsx"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#method-declaration-name"
          },
          {
            include: "#function-body"
          }
        ]
      },
      {
        name: "meta.method.declaration.js.jsx",
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
        beginCaptures: {
          "1": {
            name: "storage.modifier.js.jsx"
          },
          "2": {
            name: "storage.modifier.js.jsx"
          },
          "3": {
            name: "storage.modifier.js.jsx"
          },
          "4": {
            name: "storage.modifier.async.js.jsx"
          },
          "5": {
            name: "storage.type.property.js.jsx"
          },
          "6": {
            name: "keyword.generator.asterisk.js.jsx"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#method-declaration-name"
          },
          {
            include: "#function-body"
          }
        ]
      }
    ]
  },
  "object-literal-method-declaration": {
    name: "meta.method.declaration.js.jsx",
    begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
    beginCaptures: {
      "1": {
        name: "storage.modifier.async.js.jsx"
      },
      "2": {
        name: "storage.type.property.js.jsx"
      },
      "3": {
        name: "keyword.generator.asterisk.js.jsx"
      }
    },
    end: "(?=\\}|;|,)|(?<=\\})",
    patterns: [
      {
        include: "#method-declaration-name"
      },
      {
        include: "#function-body"
      },
      {
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.js.jsx"
          },
          "2": {
            name: "storage.type.property.js.jsx"
          },
          "3": {
            name: "keyword.generator.asterisk.js.jsx"
          }
        },
        end: "(?=\\(|\\<)",
        patterns: [
          {
            include: "#method-declaration-name"
          }
        ]
      }
    ]
  },
  "method-declaration-name": {
    begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??)\\s*[\\(\\<])",
    end: "(?=\\(|\\<)",
    patterns: [
      {
        include: "#string"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#numeric-literal"
      },
      {
        name: "meta.definition.method.js.jsx entity.name.function.js.jsx",
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      },
      {
        name: "keyword.operator.optional.js.jsx",
        match: "\\?"
      }
    ]
  },
  "arrow-function": {
    patterns: [
      {
        name: "meta.arrow.js.jsx",
        match: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)\\s*(?==>)",
        captures: {
          "1": {
            name: "storage.modifier.async.js.jsx"
          },
          "2": {
            name: "variable.parameter.js.jsx"
          }
        }
      },
      {
        name: "meta.arrow.js.jsx",
        begin: "(?x) (?:\n  (?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\n)? ((?<![})!\\]])\\s*\n  (?=\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  )\n)",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.js.jsx"
          }
        },
        end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#type-parameters"
          },
          {
            include: "#function-parameters"
          },
          {
            include: "#arrow-return-type"
          },
          {
            include: "#possibly-arrow-return-type"
          }
        ]
      },
      {
        name: "meta.arrow.js.jsx",
        begin: "=>",
        beginCaptures: {
          "0": {
            name: "storage.type.function.arrow.js.jsx"
          }
        },
        end: "((?<=\\}|\\S)(?<!=>)|((?!\\{)(?=\\S)))(?!\\/[\\/\\*])",
        patterns: [
          {
            include: "#single-line-comment-consuming-line-ending"
          },
          {
            include: "#decl-block"
          },
          {
            include: "#expression"
          }
        ]
      }
    ]
  },
  "indexer-declaration": {
    name: "meta.indexer.declaration.js.jsx",
    begin: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=:)",
    beginCaptures: {
      "1": {
        name: "storage.modifier.js.jsx"
      },
      "2": {
        name: "meta.brace.square.js.jsx"
      },
      "3": {
        name: "variable.parameter.js.jsx"
      }
    },
    end: "(\\])\\s*(\\?\\s*)?|$",
    endCaptures: {
      "1": {
        name: "meta.brace.square.js.jsx"
      },
      "2": {
        name: "keyword.operator.optional.js.jsx"
      }
    },
    patterns: [
      {
        include: "#type-annotation"
      }
    ]
  },
  "indexer-mapped-type-declaration": {
    name: "meta.indexer.mappedtype.declaration.js.jsx",
    begin: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([+-])?(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s+(in)\\s+",
    beginCaptures: {
      "1": {
        name: "keyword.operator.type.modifier.js.jsx"
      },
      "2": {
        name: "storage.modifier.js.jsx"
      },
      "3": {
        name: "meta.brace.square.js.jsx"
      },
      "4": {
        name: "entity.name.type.js.jsx"
      },
      "5": {
        name: "keyword.operator.expression.in.js.jsx"
      }
    },
    end: "(\\])([+-])?\\s*(\\?\\s*)?|$",
    endCaptures: {
      "1": {
        name: "meta.brace.square.js.jsx"
      },
      "2": {
        name: "keyword.operator.type.modifier.js.jsx"
      },
      "3": {
        name: "keyword.operator.optional.js.jsx"
      }
    },
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+",
        captures: {
          "1": {
            name: "keyword.control.as.js.jsx"
          }
        }
      },
      {
        include: "#type"
      }
    ]
  },
  "function-parameters": {
    name: "meta.parameters.js.jsx",
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.parameters.begin.js.jsx"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "punctuation.definition.parameters.end.js.jsx"
      }
    },
    patterns: [
      {
        include: "#function-parameters-body"
      }
    ]
  },
  "function-parameters-body": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#decorator"
      },
      {
        include: "#destructuring-parameter"
      },
      {
        include: "#parameter-name"
      },
      {
        include: "#parameter-type-annotation"
      },
      {
        include: "#variable-initializer"
      },
      {
        name: "punctuation.separator.parameter.js.jsx",
        match: ","
      }
    ]
  },
  "class-declaration": {
    name: "meta.class.js.jsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(class)\\b(?=\\s+|/[/*])",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js.jsx"
      },
      "2": {
        name: "storage.modifier.js.jsx"
      },
      "3": {
        name: "storage.modifier.js.jsx"
      },
      "4": {
        name: "storage.type.class.js.jsx"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#class-declaration-or-expression-patterns"
      }
    ]
  },
  "class-expression": {
    name: "meta.class.js.jsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(class)\\b(?=\\s+|[<{]|\\/[\\/*])",
    beginCaptures: {
      "1": {
        name: "storage.modifier.js.jsx"
      },
      "2": {
        name: "storage.type.class.js.jsx"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#class-declaration-or-expression-patterns"
      }
    ]
  },
  "class-declaration-or-expression-patterns": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#class-or-interface-heritage"
      },
      {
        match: "[_$[:alpha:]][_$[:alnum:]]*",
        captures: {
          "0": {
            name: "entity.name.type.class.js.jsx"
          }
        }
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#class-or-interface-body"
      }
    ]
  },
  "interface-declaration": {
    name: "meta.interface.js.jsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(interface)\\b(?=\\s+|/[/*])",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js.jsx"
      },
      "2": {
        name: "storage.modifier.js.jsx"
      },
      "3": {
        name: "storage.modifier.js.jsx"
      },
      "4": {
        name: "storage.type.interface.js.jsx"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#class-or-interface-heritage"
      },
      {
        match: "[_$[:alpha:]][_$[:alnum:]]*",
        captures: {
          "0": {
            name: "entity.name.type.interface.js.jsx"
          }
        }
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#class-or-interface-body"
      }
    ]
  },
  "class-or-interface-heritage": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(extends|implements)\\b)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "storage.modifier.js.jsx"
      }
    },
    end: "(?=\\{)",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#class-or-interface-heritage"
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#expressionWithoutIdentifiers"
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s*\\??\\.\\s*[_$[:alpha:]][_$[:alnum:]]*)*\\s*)",
        captures: {
          "1": {
            name: "entity.name.type.module.js.jsx"
          },
          "2": {
            name: "punctuation.accessor.js.jsx"
          },
          "3": {
            name: "punctuation.accessor.optional.js.jsx"
          }
        }
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "entity.other.inherited-class.js.jsx"
          }
        }
      },
      {
        include: "#expressionPunctuations"
      }
    ]
  },
  "class-or-interface-body": {
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#decorator"
      },
      {
        begin: "(?<=:)\\s*",
        end: "(?=\\s|[;),}\\]:\\-\\+]|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        include: "#method-declaration"
      },
      {
        include: "#indexer-declaration"
      },
      {
        include: "#field-declaration"
      },
      {
        include: "#string"
      },
      {
        include: "#type-annotation"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#access-modifier"
      },
      {
        include: "#property-accessor"
      },
      {
        include: "#async-modifier"
      },
      {
        include: "#after-operator-block-as-object-literal"
      },
      {
        include: "#decl-block"
      },
      {
        include: "#expression"
      },
      {
        include: "#punctuation-comma"
      },
      {
        include: "#punctuation-semicolon"
      }
    ]
  },
  "access-modifier": {
    name: "storage.modifier.js.jsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(abstract|declare|override|public|protected|private|readonly|static)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "property-accessor": {
    name: "storage.type.property.js.jsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(get|set)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "async-modifier": {
    name: "storage.modifier.async.js.jsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(async)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "enum-declaration": {
    name: "meta.enum.declaration.js.jsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:\\b(const)\\s+)?\\b(enum)\\s+([_$[:alpha:]][_$[:alnum:]]*)",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js.jsx"
      },
      "2": {
        name: "storage.modifier.js.jsx"
      },
      "3": {
        name: "storage.modifier.js.jsx"
      },
      "4": {
        name: "storage.type.enum.js.jsx"
      },
      "5": {
        name: "entity.name.type.enum.js.jsx"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "\\{",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.block.js.jsx"
          }
        },
        end: "\\}",
        endCaptures: {
          "0": {
            name: "punctuation.definition.block.js.jsx"
          }
        },
        patterns: [
          {
            include: "#comment"
          },
          {
            begin: "([_$[:alpha:]][_$[:alnum:]]*)",
            beginCaptures: {
              "0": {
                name: "variable.other.enummember.js.jsx"
              }
            },
            end: "(?=,|\\}|$)",
            patterns: [
              {
                include: "#comment"
              },
              {
                include: "#variable-initializer"
              }
            ]
          },
          {
            begin: "(?=((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\])))",
            end: "(?=,|\\}|$)",
            patterns: [
              {
                include: "#string"
              },
              {
                include: "#array-literal"
              },
              {
                include: "#comment"
              },
              {
                include: "#variable-initializer"
              }
            ]
          },
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  },
  "namespace-declaration": {
    name: "meta.namespace.declaration.js.jsx",
    begin: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(namespace|module)\\s+(?=[_$[:alpha:]\"'`]))",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js.jsx"
      },
      "2": {
        name: "storage.modifier.js.jsx"
      },
      "3": {
        name: "storage.type.namespace.js.jsx"
      }
    },
    end: "(?<=\\})|(?=;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        name: "entity.name.type.module.js.jsx",
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      },
      {
        include: "#punctuation-accessor"
      },
      {
        include: "#decl-block"
      }
    ]
  },
  "type-alias-declaration": {
    name: "meta.type.declaration.js.jsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(type)\\b\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js.jsx"
      },
      "2": {
        name: "storage.modifier.js.jsx"
      },
      "3": {
        name: "storage.type.type.js.jsx"
      },
      "4": {
        name: "entity.name.type.alias.js.jsx"
      }
    },
    end: "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#type-parameters"
      },
      {
        begin: "(=)\\s*(intrinsic)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.js.jsx"
          },
          "2": {
            name: "keyword.control.intrinsic.js.jsx"
          }
        },
        end: "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        begin: "(=)\\s*",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.js.jsx"
          }
        },
        end: "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "import-equals-declaration": {
    patterns: [
      {
        name: "meta.import-equals.external.js.jsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(require)\\s*(\\()",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.js.jsx"
          },
          "2": {
            name: "storage.modifier.js.jsx"
          },
          "3": {
            name: "keyword.control.import.js.jsx"
          },
          "4": {
            name: "keyword.control.type.js.jsx"
          },
          "5": {
            name: "variable.other.readwrite.alias.js.jsx"
          },
          "6": {
            name: "keyword.operator.assignment.js.jsx"
          },
          "7": {
            name: "keyword.control.require.js.jsx"
          },
          "8": {
            name: "meta.brace.round.js.jsx"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.js.jsx"
          }
        },
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#string"
          }
        ]
      },
      {
        name: "meta.import-equals.internal.js.jsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(?!require\\b)",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.js.jsx"
          },
          "2": {
            name: "storage.modifier.js.jsx"
          },
          "3": {
            name: "keyword.control.import.js.jsx"
          },
          "4": {
            name: "keyword.control.type.js.jsx"
          },
          "5": {
            name: "variable.other.readwrite.alias.js.jsx"
          },
          "6": {
            name: "keyword.operator.assignment.js.jsx"
          }
        },
        end: "(?=;|$|^)",
        patterns: [
          {
            include: "#single-line-comment-consuming-line-ending"
          },
          {
            include: "#comment"
          },
          {
            match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))",
            captures: {
              "1": {
                name: "entity.name.type.module.js.jsx"
              },
              "2": {
                name: "punctuation.accessor.js.jsx"
              },
              "3": {
                name: "punctuation.accessor.optional.js.jsx"
              }
            }
          },
          {
            name: "variable.other.readwrite.js.jsx",
            match: "([_$[:alpha:]][_$[:alnum:]]*)"
          }
        ]
      }
    ]
  },
  "import-declaration": {
    name: "meta.import.js.jsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type)(?!\\s+from))?(?!\\s*[:\\(])(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.js.jsx"
      },
      "2": {
        name: "storage.modifier.js.jsx"
      },
      "3": {
        name: "keyword.control.import.js.jsx"
      },
      "4": {
        name: "keyword.control.type.js.jsx"
      }
    },
    end: "(?<!^import|[^\\._$[:alnum:]]import)(?=;|$|^)",
    patterns: [
      {
        include: "#single-line-comment-consuming-line-ending"
      },
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        begin: `(?<=^import|[^\\._$[:alnum:]]import)(?!\\s*["'])`,
        end: "\\bfrom\\b",
        endCaptures: {
          "0": {
            name: "keyword.control.from.js.jsx"
          }
        },
        patterns: [
          {
            include: "#import-export-declaration"
          }
        ]
      },
      {
        include: "#import-export-declaration"
      }
    ]
  },
  "export-declaration": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)\\s+(as)\\s+(namespace)\\s+([_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "keyword.control.export.js.jsx"
          },
          "2": {
            name: "keyword.control.as.js.jsx"
          },
          "3": {
            name: "storage.type.namespace.js.jsx"
          },
          "4": {
            name: "entity.name.type.module.js.jsx"
          }
        }
      },
      {
        name: "meta.export.default.js.jsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?(?:(?:\\s*(=))|(?:\\s+(default)(?=\\s+)))",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.js.jsx"
          },
          "2": {
            name: "keyword.control.type.js.jsx"
          },
          "3": {
            name: "keyword.operator.assignment.js.jsx"
          },
          "4": {
            name: "keyword.control.default.js.jsx"
          }
        },
        end: "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#interface-declaration"
          },
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "meta.export.js.jsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?\\b(?!(\\$)|(\\s*:))((?=\\s*[\\{*])|((?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s|,))(?!\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b)))",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.js.jsx"
          },
          "2": {
            name: "keyword.control.type.js.jsx"
          }
        },
        end: "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#import-export-declaration"
          }
        ]
      }
    ]
  },
  "import-export-declaration": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#import-export-block"
      },
      {
        name: "keyword.control.from.js.jsx",
        match: "\\bfrom\\b"
      },
      {
        include: "#import-export-clause"
      }
    ]
  },
  "import-export-block": {
    name: "meta.block.js.jsx",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    patterns: [
      {
        include: "#import-export-clause"
      }
    ]
  },
  "import-export-clause": {
    patterns: [
      {
        include: "#comment"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bdefault)|(\\*)|(\\b[_$[:alpha:]][_$[:alnum:]]*))\\s+(as)\\s+(?:(default(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|([_$[:alpha:]][_$[:alnum:]]*))",
        captures: {
          "1": {
            name: "keyword.control.default.js.jsx"
          },
          "2": {
            name: "constant.language.import-export-all.js.jsx"
          },
          "3": {
            name: "variable.other.readwrite.js.jsx"
          },
          "4": {
            name: "keyword.control.as.js.jsx"
          },
          "5": {
            name: "keyword.control.default.js.jsx"
          },
          "6": {
            name: "variable.other.readwrite.alias.js.jsx"
          }
        }
      },
      {
        include: "#punctuation-comma"
      },
      {
        name: "constant.language.import-export-all.js.jsx",
        match: "\\*"
      },
      {
        name: "keyword.control.default.js.jsx",
        match: "\\b(default)\\b"
      },
      {
        name: "variable.other.readwrite.alias.js.jsx",
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  },
  "switch-statement": {
    name: "switch-statement.expr.js.jsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bswitch\\s*\\()",
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        name: "switch-expression.expr.js.jsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(switch)\\s*(\\()",
        beginCaptures: {
          "1": {
            name: "keyword.control.switch.js.jsx"
          },
          "2": {
            name: "meta.brace.round.js.jsx"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.js.jsx"
          }
        },
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "switch-block.expr.js.jsx",
        begin: "\\{",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.block.js.jsx"
          }
        },
        end: "(?=\\})",
        patterns: [
          {
            name: "case-clause.expr.js.jsx",
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default(?=:))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
            beginCaptures: {
              "1": {
                name: "keyword.control.switch.js.jsx"
              }
            },
            end: "(?=:)",
            patterns: [
              {
                include: "#expression"
              }
            ]
          },
          {
            begin: "(:)\\s*(\\{)",
            beginCaptures: {
              "1": {
                name: "case-clause.expr.js.jsx punctuation.definition.section.case-statement.js.jsx"
              },
              "2": {
                name: "meta.block.js.jsx punctuation.definition.block.js.jsx"
              }
            },
            end: "\\}",
            endCaptures: {
              "0": {
                name: "meta.block.js.jsx punctuation.definition.block.js.jsx"
              }
            },
            contentName: "meta.block.js.jsx",
            patterns: [
              {
                include: "#statements"
              }
            ]
          },
          {
            match: "(:)",
            captures: {
              "0": {
                name: "case-clause.expr.js.jsx punctuation.definition.section.case-statement.js.jsx"
              }
            }
          },
          {
            include: "#statements"
          }
        ]
      }
    ]
  },
  "for-loop": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))for(?=((\\s+|(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*))await)?\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)?(\\())",
    beginCaptures: {
      "0": {
        name: "keyword.control.loop.js.jsx"
      }
    },
    end: "(?<=\\))",
    patterns: [
      {
        include: "#comment"
      },
      {
        name: "keyword.control.loop.js.jsx",
        match: "await"
      },
      {
        begin: "\\(",
        beginCaptures: {
          "0": {
            name: "meta.brace.round.js.jsx"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.js.jsx"
          }
        },
        patterns: [
          {
            include: "#var-expr"
          },
          {
            include: "#expression"
          },
          {
            include: "#punctuation-semicolon"
          }
        ]
      }
    ]
  },
  "if-statement": {
    patterns: [
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bif\\s*(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))\\s*(?!\\{))",
        end: "(?=;|$|\\})",
        patterns: [
          {
            include: "#comment"
          },
          {
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(if)\\s*(\\()",
            beginCaptures: {
              "1": {
                name: "keyword.control.conditional.js.jsx"
              },
              "2": {
                name: "meta.brace.round.js.jsx"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "meta.brace.round.js.jsx"
              }
            },
            patterns: [
              {
                include: "#expression"
              }
            ]
          },
          {
            name: "string.regexp.js.jsx",
            begin: "(?<=\\))\\s*\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))",
            beginCaptures: {
              "0": {
                name: "punctuation.definition.string.begin.js.jsx"
              }
            },
            end: "(/)([dgimsuy]*)",
            endCaptures: {
              "1": {
                name: "punctuation.definition.string.end.js.jsx"
              },
              "2": {
                name: "keyword.other.js.jsx"
              }
            },
            patterns: [
              {
                include: "#regexp"
              }
            ]
          },
          {
            include: "#statements"
          }
        ]
      }
    ]
  },
  "decl-block": {
    name: "meta.block.js.jsx",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    patterns: [
      {
        include: "#statements"
      }
    ]
  },
  "after-operator-block-as-object-literal": {
    name: "meta.objectliteral.js.jsx",
    begin: "(?<!\\+\\+|--)(?<=[:=(,\\[?+!>]|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^yield|[^\\._$[:alnum:]]yield|^throw|[^\\._$[:alnum:]]throw|^in|[^\\._$[:alnum:]]in|^of|[^\\._$[:alnum:]]of|^typeof|[^\\._$[:alnum:]]typeof|&&|\\|\\||\\*)\\s*(\\{)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    patterns: [
      {
        include: "#object-member"
      }
    ]
  },
  "object-literal": {
    name: "meta.objectliteral.js.jsx",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    patterns: [
      {
        include: "#object-member"
      }
    ]
  },
  "object-member": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#object-literal-method-declaration"
      },
      {
        name: "meta.object.member.js.jsx meta.object-literal.key.js.jsx",
        begin: "(?=\\[)",
        end: "(?=:)|((?<=[\\]])(?=\\s*[\\(\\<]))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#array-literal"
          }
        ]
      },
      {
        name: "meta.object.member.js.jsx meta.object-literal.key.js.jsx",
        begin: "(?=[\\'\\\"\\`])",
        end: "(?=:)|((?<=[\\'\\\"\\`])(?=((\\s*[\\(\\<,}])|(\\s+(as)\\s+))))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#string"
          }
        ]
      },
      {
        name: "meta.object.member.js.jsx meta.object-literal.key.js.jsx",
        begin: "(?x)(?=(\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)))",
        end: "(?=:)|(?=\\s*([\\(\\<,}])|(\\s+as\\s+))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#numeric-literal"
          }
        ]
      },
      {
        name: "meta.method.declaration.js.jsx",
        begin: "(?<=[\\]\\'\\\"\\`])(?=\\s*[\\(\\<])",
        end: "(?=\\}|;|,)|(?<=\\})",
        patterns: [
          {
            include: "#function-body"
          }
        ]
      },
      {
        name: "meta.object.member.js.jsx",
        match: "(?![_$[:alpha:]])([[:digit:]]+)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)",
        captures: {
          "0": {
            name: "meta.object-literal.key.js.jsx"
          },
          "1": {
            name: "constant.numeric.decimal.js.jsx"
          }
        }
      },
      {
        name: "meta.object.member.js.jsx",
        match: "(?x)(?:([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/)*\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "0": {
            name: "meta.object-literal.key.js.jsx"
          },
          "1": {
            name: "entity.name.function.js.jsx"
          }
        }
      },
      {
        name: "meta.object.member.js.jsx",
        match: "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)",
        captures: {
          "0": {
            name: "meta.object-literal.key.js.jsx"
          }
        }
      },
      {
        name: "meta.object.member.js.jsx",
        begin: "\\.\\.\\.",
        beginCaptures: {
          "0": {
            name: "keyword.operator.spread.js.jsx"
          }
        },
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "meta.object.member.js.jsx",
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=,|\\}|$|\\/\\/|\\/\\*)",
        captures: {
          "1": {
            name: "variable.other.readwrite.js.jsx"
          }
        }
      },
      {
        name: "meta.object.member.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*([,}]|$))",
        captures: {
          "1": {
            name: "keyword.control.as.js.jsx"
          },
          "2": {
            name: "storage.modifier.js.jsx"
          }
        }
      },
      {
        name: "meta.object.member.js.jsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+",
        beginCaptures: {
          "1": {
            name: "keyword.control.as.js.jsx"
          }
        },
        end: "(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|^|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "meta.object.member.js.jsx",
        begin: "(?=[_$[:alpha:]][_$[:alnum:]]*\\s*=)",
        end: "(?=,|\\}|$|\\/\\/|\\/\\*)",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "meta.object.member.js.jsx",
        begin: ":",
        beginCaptures: {
          "0": {
            name: "meta.object-literal.key.js.jsx punctuation.separator.key-value.js.jsx"
          }
        },
        end: "(?=,|\\})",
        patterns: [
          {
            begin: "(?<=:)\\s*(async)?(?=\\s*(<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
            beginCaptures: {
              "1": {
                name: "storage.modifier.async.js.jsx"
              }
            },
            end: "(?<=\\))",
            patterns: [
              {
                include: "#type-parameters"
              },
              {
                begin: "\\(",
                beginCaptures: {
                  "0": {
                    name: "meta.brace.round.js.jsx"
                  }
                },
                end: "\\)",
                endCaptures: {
                  "0": {
                    name: "meta.brace.round.js.jsx"
                  }
                },
                patterns: [
                  {
                    include: "#expression-inside-possibly-arrow-parens"
                  }
                ]
              }
            ]
          },
          {
            begin: "(?<=:)\\s*(async)?\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
            beginCaptures: {
              "1": {
                name: "storage.modifier.async.js.jsx"
              },
              "2": {
                name: "meta.brace.round.js.jsx"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "meta.brace.round.js.jsx"
              }
            },
            patterns: [
              {
                include: "#expression-inside-possibly-arrow-parens"
              }
            ]
          },
          {
            begin: "(?<=:)\\s*(async)?\\s*(?=\\<\\s*$)",
            beginCaptures: {
              "1": {
                name: "storage.modifier.async.js.jsx"
              }
            },
            end: "(?<=\\>)",
            patterns: [
              {
                include: "#type-parameters"
              }
            ]
          },
          {
            begin: "(?<=\\>)\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
            beginCaptures: {
              "1": {
                name: "meta.brace.round.js.jsx"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "meta.brace.round.js.jsx"
              }
            },
            patterns: [
              {
                include: "#expression-inside-possibly-arrow-parens"
              }
            ]
          },
          {
            include: "#possibly-arrow-return-type"
          },
          {
            include: "#expression"
          }
        ]
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "ternary-expression": {
    begin: "(?!\\?\\.\\s*[^[:digit:]])(\\?)(?!\\?)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.ternary.js.jsx"
      }
    },
    end: "\\s*(:)",
    endCaptures: {
      "1": {
        name: "keyword.operator.ternary.js.jsx"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "function-call": {
    patterns: [
      {
        begin: "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())",
        end: "(?<=\\))(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())",
        patterns: [
          {
            name: "meta.function-call.js.jsx",
            begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))",
            end: "(?=\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())",
            patterns: [
              {
                include: "#function-call-target"
              }
            ]
          },
          {
            include: "#comment"
          },
          {
            include: "#function-call-optionals"
          },
          {
            include: "#type-arguments"
          },
          {
            include: "#paren-expression"
          }
        ]
      },
      {
        begin: "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))",
        end: "(?<=\\>)(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))",
        patterns: [
          {
            name: "meta.function-call.js.jsx",
            begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))",
            end: "(?=(<\\s*[\\{\\[\\(]\\s*$))",
            patterns: [
              {
                include: "#function-call-target"
              }
            ]
          },
          {
            include: "#comment"
          },
          {
            include: "#function-call-optionals"
          },
          {
            include: "#type-arguments"
          }
        ]
      }
    ]
  },
  "function-call-target": {
    patterns: [
      {
        include: "#support-function-call-identifiers"
      },
      {
        name: "entity.name.function.js.jsx",
        match: "(\\#?[_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  },
  "function-call-optionals": {
    patterns: [
      {
        name: "meta.function-call.js.jsx punctuation.accessor.optional.js.jsx",
        match: "\\?\\."
      },
      {
        name: "meta.function-call.js.jsx keyword.operator.definiteassignment.js.jsx",
        match: "\\!"
      }
    ]
  },
  "support-function-call-identifiers": {
    patterns: [
      {
        include: "#literal"
      },
      {
        include: "#support-objects"
      },
      {
        include: "#object-identifiers"
      },
      {
        include: "#punctuation-accessor"
      },
      {
        name: "keyword.operator.expression.import.js.jsx",
        match: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*[\\(]\\s*[\\\"\\'\\`]))"
      }
    ]
  },
  "new-expr": {
    name: "new.expr.js.jsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "keyword.operator.new.js.jsx"
      }
    },
    end: "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))",
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "instanceof-expr": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(instanceof)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "keyword.operator.expression.instanceof.js.jsx"
      }
    },
    end: "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|(([\\&\\~\\^\\|]\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s+instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))",
    patterns: [
      {
        include: "#type"
      }
    ]
  },
  "paren-expression-possibly-arrow": {
    patterns: [
      {
        begin: "(?<=[(=,])\\s*(async)?(?=\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.js.jsx"
          }
        },
        end: "(?<=\\))",
        patterns: [
          {
            include: "#paren-expression-possibly-arrow-with-typeparameters"
          }
        ]
      },
      {
        begin: "(?<=[(=,]|=>|^return|[^\\._$[:alnum:]]return)\\s*(async)?(?=\\s*((((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\()|(<))\\s*$)",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.js.jsx"
          }
        },
        end: "(?<=\\))",
        patterns: [
          {
            include: "#paren-expression-possibly-arrow-with-typeparameters"
          }
        ]
      },
      {
        include: "#possibly-arrow-return-type"
      }
    ]
  },
  "paren-expression-possibly-arrow-with-typeparameters": {
    patterns: [
      {
        include: "#type-parameters"
      },
      {
        begin: "\\(",
        beginCaptures: {
          "0": {
            name: "meta.brace.round.js.jsx"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.js.jsx"
          }
        },
        patterns: [
          {
            include: "#expression-inside-possibly-arrow-parens"
          }
        ]
      }
    ]
  },
  "expression-inside-possibly-arrow-parens": {
    patterns: [
      {
        include: "#expressionWithoutIdentifiers"
      },
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#decorator"
      },
      {
        include: "#destructuring-parameter"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)",
        captures: {
          "1": {
            name: "storage.modifier.js.jsx"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "1": {
            name: "storage.modifier.js.jsx"
          },
          "2": {
            name: "keyword.operator.rest.js.jsx"
          },
          "3": {
            name: "entity.name.function.js.jsx variable.language.this.js.jsx"
          },
          "4": {
            name: "entity.name.function.js.jsx"
          },
          "5": {
            name: "keyword.operator.optional.js.jsx"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*[:,]|$)",
        captures: {
          "1": {
            name: "storage.modifier.js.jsx"
          },
          "2": {
            name: "keyword.operator.rest.js.jsx"
          },
          "3": {
            name: "variable.parameter.js.jsx variable.language.this.js.jsx"
          },
          "4": {
            name: "variable.parameter.js.jsx"
          },
          "5": {
            name: "keyword.operator.optional.js.jsx"
          }
        }
      },
      {
        include: "#type-annotation"
      },
      {
        include: "#variable-initializer"
      },
      {
        name: "punctuation.separator.parameter.js.jsx",
        match: ","
      },
      {
        include: "#identifiers"
      },
      {
        include: "#expressionPunctuations"
      }
    ]
  },
  "paren-expression": {
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "meta.brace.round.js.jsx"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "meta.brace.round.js.jsx"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  cast: {
    patterns: [
      {
        include: "#jsx"
      }
    ]
  },
  "expression-operators": {
    patterns: [
      {
        name: "keyword.control.flow.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(await)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?=\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*\\*)",
        beginCaptures: {
          "1": {
            name: "keyword.control.flow.js.jsx"
          }
        },
        end: "\\*",
        endCaptures: {
          "0": {
            name: "keyword.generator.asterisk.js.jsx"
          }
        },
        patterns: [
          {
            include: "#comment"
          }
        ]
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?:\\s*(\\*))?",
        captures: {
          "1": {
            name: "keyword.control.flow.js.jsx"
          },
          "2": {
            name: "keyword.generator.asterisk.js.jsx"
          }
        }
      },
      {
        name: "keyword.operator.expression.delete.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))delete(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.expression.in.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))in(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()"
      },
      {
        name: "keyword.operator.expression.of.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))of(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()"
      },
      {
        name: "keyword.operator.expression.instanceof.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.new.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        include: "#typeof-operator"
      },
      {
        name: "keyword.operator.expression.void.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))void(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*($|[;,:})\\]]))",
        captures: {
          "1": {
            name: "keyword.control.as.js.jsx"
          },
          "2": {
            name: "storage.modifier.js.jsx"
          }
        }
      },
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+",
        beginCaptures: {
          "1": {
            name: "keyword.control.as.js.jsx"
          }
        },
        end: "(?=^|[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+)|(\\s+\\<))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "keyword.operator.spread.js.jsx",
        match: "\\.\\.\\."
      },
      {
        name: "keyword.operator.assignment.compound.js.jsx",
        match: "\\*=|(?<!\\()/=|%=|\\+=|\\-="
      },
      {
        name: "keyword.operator.assignment.compound.bitwise.js.jsx",
        match: "\\&=|\\^=|<<=|>>=|>>>=|\\|="
      },
      {
        name: "keyword.operator.bitwise.shift.js.jsx",
        match: "<<|>>>|>>"
      },
      {
        name: "keyword.operator.comparison.js.jsx",
        match: "===|!==|==|!="
      },
      {
        name: "keyword.operator.relational.js.jsx",
        match: "<=|>=|<>|<|>"
      },
      {
        match: "(?<=[_$[:alnum:]])(\\!)\\s*(?:(/=)|(?:(/)(?![/*])))",
        captures: {
          "1": {
            name: "keyword.operator.logical.js.jsx"
          },
          "2": {
            name: "keyword.operator.assignment.compound.js.jsx"
          },
          "3": {
            name: "keyword.operator.arithmetic.js.jsx"
          }
        }
      },
      {
        name: "keyword.operator.logical.js.jsx",
        match: "\\!|&&|\\|\\||\\?\\?"
      },
      {
        name: "keyword.operator.bitwise.js.jsx",
        match: "\\&|~|\\^|\\|"
      },
      {
        name: "keyword.operator.assignment.js.jsx",
        match: "\\="
      },
      {
        name: "keyword.operator.decrement.js.jsx",
        match: "--"
      },
      {
        name: "keyword.operator.increment.js.jsx",
        match: "\\+\\+"
      },
      {
        name: "keyword.operator.arithmetic.js.jsx",
        match: "%|\\*|/|-|\\+"
      },
      {
        begin: "(?<=[_$[:alnum:])\\]])\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)+(?:(/=)|(?:(/)(?![/*]))))",
        end: "(?:(/=)|(?:(/)(?!\\*([^\\*]|(\\*[^\\/]))*\\*\\/)))",
        endCaptures: {
          "1": {
            name: "keyword.operator.assignment.compound.js.jsx"
          },
          "2": {
            name: "keyword.operator.arithmetic.js.jsx"
          }
        },
        patterns: [
          {
            include: "#comment"
          }
        ]
      },
      {
        match: "(?<=[_$[:alnum:])\\]])\\s*(?:(/=)|(?:(/)(?![/*])))",
        captures: {
          "1": {
            name: "keyword.operator.assignment.compound.js.jsx"
          },
          "2": {
            name: "keyword.operator.arithmetic.js.jsx"
          }
        }
      }
    ]
  },
  "typeof-operator": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))typeof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "0": {
        name: "keyword.operator.expression.typeof.js.jsx"
      }
    },
    end: "(?=[,);}\\]=>:&|{\\?]|$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  literal: {
    patterns: [
      {
        include: "#numeric-literal"
      },
      {
        include: "#boolean-literal"
      },
      {
        include: "#null-literal"
      },
      {
        include: "#undefined-literal"
      },
      {
        include: "#numericConstant-literal"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#this-literal"
      },
      {
        include: "#super-literal"
      }
    ]
  },
  "array-literal": {
    name: "meta.array.literal.js.jsx",
    begin: "\\s*(\\[)",
    beginCaptures: {
      "1": {
        name: "meta.brace.square.js.jsx"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "meta.brace.square.js.jsx"
      }
    },
    patterns: [
      {
        include: "#expression"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "numeric-literal": {
    patterns: [
      {
        name: "constant.numeric.hex.js.jsx",
        match: "\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$)",
        captures: {
          "1": {
            name: "storage.type.numeric.bigint.js.jsx"
          }
        }
      },
      {
        name: "constant.numeric.binary.js.jsx",
        match: "\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$)",
        captures: {
          "1": {
            name: "storage.type.numeric.bigint.js.jsx"
          }
        }
      },
      {
        name: "constant.numeric.octal.js.jsx",
        match: "\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$)",
        captures: {
          "1": {
            name: "storage.type.numeric.bigint.js.jsx"
          }
        }
      },
      {
        match: "(?x)\n(?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)",
        captures: {
          "0": {
            name: "constant.numeric.decimal.js.jsx"
          },
          "1": {
            name: "meta.delimiter.decimal.period.js.jsx"
          },
          "2": {
            name: "storage.type.numeric.bigint.js.jsx"
          },
          "3": {
            name: "meta.delimiter.decimal.period.js.jsx"
          },
          "4": {
            name: "storage.type.numeric.bigint.js.jsx"
          },
          "5": {
            name: "meta.delimiter.decimal.period.js.jsx"
          },
          "6": {
            name: "storage.type.numeric.bigint.js.jsx"
          },
          "7": {
            name: "storage.type.numeric.bigint.js.jsx"
          },
          "8": {
            name: "meta.delimiter.decimal.period.js.jsx"
          },
          "9": {
            name: "storage.type.numeric.bigint.js.jsx"
          },
          "10": {
            name: "meta.delimiter.decimal.period.js.jsx"
          },
          "11": {
            name: "storage.type.numeric.bigint.js.jsx"
          },
          "12": {
            name: "meta.delimiter.decimal.period.js.jsx"
          },
          "13": {
            name: "storage.type.numeric.bigint.js.jsx"
          },
          "14": {
            name: "storage.type.numeric.bigint.js.jsx"
          }
        }
      }
    ]
  },
  "boolean-literal": {
    patterns: [
      {
        name: "constant.language.boolean.true.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))true(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "constant.language.boolean.false.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))false(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "null-literal": {
    name: "constant.language.null.js.jsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))null(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "this-literal": {
    name: "variable.language.this.js.jsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))this\\b(?!\\$)"
  },
  "super-literal": {
    name: "variable.language.super.js.jsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))super\\b(?!\\$)"
  },
  "undefined-literal": {
    name: "constant.language.undefined.js.jsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))undefined(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "numericConstant-literal": {
    patterns: [
      {
        name: "constant.language.nan.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))NaN(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "constant.language.infinity.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Infinity(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "support-objects": {
    patterns: [
      {
        name: "variable.language.arguments.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(arguments)\\b(?!\\$)"
      },
      {
        name: "support.class.builtin.js.jsx",
        match: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Array|ArrayBuffer|Atomics|BigInt|BigInt64Array|BigUint64Array|Boolean|DataView|Date|Float32Array\n  |Float64Array|Function|Generator|GeneratorFunction|Int8Array|Int16Array|Int32Array|Intl|Map|Number|Object|Proxy\n  |Reflect|RegExp|Set|SharedArrayBuffer|SIMD|String|Symbol|TypedArray\n  |Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|WeakMap|WeakSet)\\b(?!\\$)"
      },
      {
        name: "support.class.error.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))((Eval|Internal|Range|Reference|Syntax|Type|URI)?Error)\\b(?!\\$)"
      },
      {
        name: "support.class.promise.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Promise)\\b(?!\\$)"
      },
      {
        name: "support.function.js.jsx",
        match: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(clear(Interval|Timeout)|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|\n  isFinite|isNaN|parseFloat|parseInt|require|set(Interval|Timeout)|super|unescape|uneval)(?=\\s*\\()"
      },
      {
        match: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Math)(?:\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(?:\n  (abs|acos|acosh|asin|asinh|atan|atan2|atanh|cbrt|ceil|clz32|cos|cosh|exp|\n  expm1|floor|fround|hypot|imul|log|log10|log1p|log2|max|min|pow|random|\n  round|sign|sin|sinh|sqrt|tan|tanh|trunc)\n  |\n  (E|LN10|LN2|LOG10E|LOG2E|PI|SQRT1_2|SQRT2)))?\\b(?!\\$)",
        captures: {
          "1": {
            name: "support.constant.math.js.jsx"
          },
          "2": {
            name: "punctuation.accessor.js.jsx"
          },
          "3": {
            name: "punctuation.accessor.optional.js.jsx"
          },
          "4": {
            name: "support.function.math.js.jsx"
          },
          "5": {
            name: "support.constant.property.math.js.jsx"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(JSON)(?:\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(parse|stringify))?\\b(?!\\$)",
        captures: {
          "1": {
            name: "support.constant.json.js.jsx"
          },
          "2": {
            name: "punctuation.accessor.js.jsx"
          },
          "3": {
            name: "punctuation.accessor.optional.js.jsx"
          },
          "4": {
            name: "support.function.json.js.jsx"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(import)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(meta)\\b(?!\\$)",
        captures: {
          "1": {
            name: "keyword.control.import.js.jsx"
          },
          "2": {
            name: "punctuation.accessor.js.jsx"
          },
          "3": {
            name: "punctuation.accessor.optional.js.jsx"
          },
          "4": {
            name: "support.variable.property.importmeta.js.jsx"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(target)\\b(?!\\$)",
        captures: {
          "1": {
            name: "keyword.operator.new.js.jsx"
          },
          "2": {
            name: "punctuation.accessor.js.jsx"
          },
          "3": {
            name: "punctuation.accessor.optional.js.jsx"
          },
          "4": {
            name: "support.variable.property.target.js.jsx"
          }
        }
      },
      {
        match: "(?x) (?:(\\.)|(\\?\\.(?!\\s*[[:digit:]]))) \\s* (?:\n  (?:(constructor|length|prototype|__proto__)\\b(?!\\$|\\s*(<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\\())\n  |\n  (?:(EPSILON|MAX_SAFE_INTEGER|MAX_VALUE|MIN_SAFE_INTEGER|MIN_VALUE|NEGATIVE_INFINITY|POSITIVE_INFINITY)\\b(?!\\$)))",
        captures: {
          "1": {
            name: "punctuation.accessor.js.jsx"
          },
          "2": {
            name: "punctuation.accessor.optional.js.jsx"
          },
          "3": {
            name: "support.variable.property.js.jsx"
          },
          "4": {
            name: "support.constant.js.jsx"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(exports)|(module)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(exports|id|filename|loaded|parent|children))?)\\b(?!\\$)",
        captures: {
          "1": {
            name: "support.type.object.module.js.jsx"
          },
          "2": {
            name: "support.type.object.module.js.jsx"
          },
          "3": {
            name: "punctuation.accessor.js.jsx"
          },
          "4": {
            name: "punctuation.accessor.optional.js.jsx"
          },
          "5": {
            name: "support.type.object.module.js.jsx"
          }
        }
      }
    ]
  },
  identifiers: {
    patterns: [
      {
        include: "#object-identifiers"
      },
      {
        match: "(?x)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*)?([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n))",
        captures: {
          "1": {
            name: "punctuation.accessor.js.jsx"
          },
          "2": {
            name: "punctuation.accessor.optional.js.jsx"
          },
          "3": {
            name: "entity.name.function.js.jsx"
          }
        }
      },
      {
        match: "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])",
        captures: {
          "1": {
            name: "punctuation.accessor.js.jsx"
          },
          "2": {
            name: "punctuation.accessor.optional.js.jsx"
          },
          "3": {
            name: "variable.other.constant.property.js.jsx"
          }
        }
      },
      {
        match: "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "punctuation.accessor.js.jsx"
          },
          "2": {
            name: "punctuation.accessor.optional.js.jsx"
          },
          "3": {
            name: "variable.other.property.js.jsx"
          }
        }
      },
      {
        name: "variable.other.constant.js.jsx",
        match: "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])"
      },
      {
        name: "variable.other.readwrite.js.jsx",
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      }
    ]
  },
  "object-identifiers": {
    patterns: [
      {
        name: "support.class.js.jsx",
        match: "([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\\??\\.\\s*prototype\\b(?!\\$))"
      },
      {
        match: "(?x)(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(?:\n  (\\#?[[:upper:]][_$[:digit:][:upper:]]*) |\n  (\\#?[_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "punctuation.accessor.js.jsx"
          },
          "2": {
            name: "punctuation.accessor.optional.js.jsx"
          },
          "3": {
            name: "variable.other.constant.object.property.js.jsx"
          },
          "4": {
            name: "variable.other.object.property.js.jsx"
          }
        }
      },
      {
        match: "(?x)(?:\n  ([[:upper:]][_$[:digit:][:upper:]]*) |\n  ([_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "variable.other.constant.object.js.jsx"
          },
          "2": {
            name: "variable.other.object.js.jsx"
          }
        }
      }
    ]
  },
  "type-annotation": {
    patterns: [
      {
        name: "meta.type.annotation.js.jsx",
        begin: "(:)(?=\\s*\\S)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.js.jsx"
          }
        },
        end: "(?<![:|&])((?=$|^|[,);\\}\\]]|//)|(?==[^>])|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "meta.type.annotation.js.jsx",
        begin: "(:)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.js.jsx"
          }
        },
        end: "(?<![:|&])((?=[,);\\}\\]]|//)|(?==[^>])|(?=^\\s*$)|((?<=\\S)(?=\\s*$))|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))",
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "parameter-type-annotation": {
    patterns: [
      {
        name: "meta.type.annotation.js.jsx",
        begin: "(:)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.js.jsx"
          }
        },
        end: "(?=[,)])|(?==[^>])",
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "return-type": {
    patterns: [
      {
        name: "meta.return.type.js.jsx",
        begin: "(?<=\\))\\s*(:)(?=\\s*\\S)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.js.jsx"
          }
        },
        end: "(?<![:|&])(?=$|^|[{};,]|//)",
        patterns: [
          {
            include: "#return-type-core"
          }
        ]
      },
      {
        name: "meta.return.type.js.jsx",
        begin: "(?<=\\))\\s*(:)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.js.jsx"
          }
        },
        end: "(?<![:|&])((?=[{};,]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))",
        patterns: [
          {
            include: "#return-type-core"
          }
        ]
      }
    ]
  },
  "return-type-core": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?<=[:|&])(?=\\s*\\{)",
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        include: "#type-predicate-operator"
      },
      {
        include: "#type"
      }
    ]
  },
  "arrow-return-type": {
    name: "meta.return.type.arrow.js.jsx",
    begin: "(?<=\\))\\s*(:)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.type.annotation.js.jsx"
      }
    },
    end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))",
    patterns: [
      {
        include: "#arrow-return-type-body"
      }
    ]
  },
  "possibly-arrow-return-type": {
    begin: "(?<=\\)|^)\\s*(:)(?=\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*=>)",
    beginCaptures: {
      "1": {
        name: "meta.arrow.js.jsx meta.return.type.arrow.js.jsx keyword.operator.type.annotation.js.jsx"
      }
    },
    end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))",
    contentName: "meta.arrow.js.jsx meta.return.type.arrow.js.jsx",
    patterns: [
      {
        include: "#arrow-return-type-body"
      }
    ]
  },
  "arrow-return-type-body": {
    patterns: [
      {
        begin: "(?<=[:])(?=\\s*\\{)",
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        include: "#type-predicate-operator"
      },
      {
        include: "#type"
      }
    ]
  },
  "type-parameters": {
    name: "meta.type.parameters.js.jsx",
    begin: "(<)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.typeparameters.begin.js.jsx"
      }
    },
    end: "(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.typeparameters.end.js.jsx"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        name: "storage.modifier.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        include: "#type"
      },
      {
        include: "#punctuation-comma"
      },
      {
        name: "keyword.operator.assignment.js.jsx",
        match: "(=)(?!>)"
      }
    ]
  },
  "type-arguments": {
    name: "meta.type.parameters.js.jsx",
    begin: "\\<",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.typeparameters.begin.js.jsx"
      }
    },
    end: "\\>",
    endCaptures: {
      "0": {
        name: "punctuation.definition.typeparameters.end.js.jsx"
      }
    },
    patterns: [
      {
        include: "#type-arguments-body"
      }
    ]
  },
  "type-arguments-body": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(_)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "0": {
            name: "keyword.operator.type.js.jsx"
          }
        }
      },
      {
        include: "#type"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  type: {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#type-string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#type-primitive"
      },
      {
        include: "#type-builtin-literals"
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#type-tuple"
      },
      {
        include: "#type-object"
      },
      {
        include: "#type-conditional"
      },
      {
        include: "#type-operators"
      },
      {
        include: "#type-fn-type-parameters"
      },
      {
        include: "#type-paren-or-function-parameters"
      },
      {
        include: "#type-function-return-type"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*",
        captures: {
          "1": {
            name: "storage.modifier.js.jsx"
          }
        }
      },
      {
        include: "#type-name"
      }
    ]
  },
  "type-primitive": {
    name: "support.type.primitive.js.jsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(string|number|bigint|boolean|symbol|any|void|never|unknown)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "type-builtin-literals": {
    name: "support.type.builtin.js.jsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(this|true|false|undefined|null|object)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "type-tuple": {
    name: "meta.type.tuple.js.jsx",
    begin: "\\[",
    beginCaptures: {
      "0": {
        name: "meta.brace.square.js.jsx"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "meta.brace.square.js.jsx"
      }
    },
    patterns: [
      {
        name: "keyword.operator.rest.js.jsx",
        match: "\\.\\.\\."
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([_$[:alpha:]][_$[:alnum:]]*)\\s*(\\?)?\\s*(:)",
        captures: {
          "1": {
            name: "entity.name.label.js.jsx"
          },
          "2": {
            name: "keyword.operator.optional.js.jsx"
          },
          "3": {
            name: "punctuation.separator.label.js.jsx"
          }
        }
      },
      {
        include: "#type"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "type-object": {
    name: "meta.object.type.js.jsx",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.js.jsx"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#method-declaration"
      },
      {
        include: "#indexer-declaration"
      },
      {
        include: "#indexer-mapped-type-declaration"
      },
      {
        include: "#field-declaration"
      },
      {
        include: "#type-annotation"
      },
      {
        begin: "\\.\\.\\.",
        beginCaptures: {
          "0": {
            name: "keyword.operator.spread.js.jsx"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        include: "#punctuation-comma"
      },
      {
        include: "#punctuation-semicolon"
      },
      {
        include: "#type"
      }
    ]
  },
  "type-conditional": {
    patterns: [
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends)\\s+",
        beginCaptures: {
          "1": {
            name: "storage.modifier.js.jsx"
          }
        },
        end: "(?<=:)",
        patterns: [
          {
            begin: "\\?",
            beginCaptures: {
              "0": {
                name: "keyword.operator.ternary.js.jsx"
              }
            },
            end: ":",
            endCaptures: {
              "0": {
                name: "keyword.operator.ternary.js.jsx"
              }
            },
            patterns: [
              {
                include: "#type"
              }
            ]
          },
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "type-paren-or-function-parameters": {
    name: "meta.type.paren.cover.js.jsx",
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "meta.brace.round.js.jsx"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "meta.brace.round.js.jsx"
      }
    },
    patterns: [
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=\\s*(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))))",
        captures: {
          "1": {
            name: "storage.modifier.js.jsx"
          },
          "2": {
            name: "keyword.operator.rest.js.jsx"
          },
          "3": {
            name: "entity.name.function.js.jsx variable.language.this.js.jsx"
          },
          "4": {
            name: "entity.name.function.js.jsx"
          },
          "5": {
            name: "keyword.operator.optional.js.jsx"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=:)",
        captures: {
          "1": {
            name: "storage.modifier.js.jsx"
          },
          "2": {
            name: "keyword.operator.rest.js.jsx"
          },
          "3": {
            name: "variable.parameter.js.jsx variable.language.this.js.jsx"
          },
          "4": {
            name: "variable.parameter.js.jsx"
          },
          "5": {
            name: "keyword.operator.optional.js.jsx"
          }
        }
      },
      {
        include: "#type-annotation"
      },
      {
        name: "punctuation.separator.parameter.js.jsx",
        match: ","
      },
      {
        include: "#type"
      }
    ]
  },
  "type-fn-type-parameters": {
    patterns: [
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b(?=\\s*\\<)",
        beginCaptures: {
          "1": {
            name: "meta.type.constructor.js.jsx storage.modifier.js.jsx"
          },
          "2": {
            name: "meta.type.constructor.js.jsx keyword.control.new.js.jsx"
          }
        },
        end: "(?<=>)",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#type-parameters"
          }
        ]
      },
      {
        name: "meta.type.constructor.js.jsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b\\s*(?=\\()",
        beginCaptures: {
          "1": {
            name: "storage.modifier.js.jsx"
          },
          "2": {
            name: "keyword.control.new.js.jsx"
          }
        },
        end: "(?<=\\))",
        patterns: [
          {
            include: "#function-parameters"
          }
        ]
      },
      {
        name: "meta.type.function.js.jsx",
        begin: "(?x)(\n  (?=\n    [(]\\s*(\n      ([)]) |\n      (\\.\\.\\.) |\n      ([_$[:alnum:]]+\\s*(\n        ([:,?=])|\n        ([)]\\s*=>)\n      ))\n    )\n  )\n)",
        end: "(?<=\\))",
        patterns: [
          {
            include: "#function-parameters"
          }
        ]
      }
    ]
  },
  "type-function-return-type": {
    patterns: [
      {
        name: "meta.type.function.return.js.jsx",
        begin: "(=>)(?=\\s*\\S)",
        beginCaptures: {
          "1": {
            name: "storage.type.function.arrow.js.jsx"
          }
        },
        end: "(?<!=>)(?<![|&])(?=[,\\]\\)\\{\\}=;>:\\?]|//|$)",
        patterns: [
          {
            include: "#type-function-return-type-core"
          }
        ]
      },
      {
        name: "meta.type.function.return.js.jsx",
        begin: "=>",
        beginCaptures: {
          "0": {
            name: "storage.type.function.arrow.js.jsx"
          }
        },
        end: "(?<!=>)(?<![|&])((?=[,\\]\\)\\{\\}=;:\\?>]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))",
        patterns: [
          {
            include: "#type-function-return-type-core"
          }
        ]
      }
    ]
  },
  "type-function-return-type-core": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?<==>)(?=\\s*\\{)",
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        include: "#type-predicate-operator"
      },
      {
        include: "#type"
      }
    ]
  },
  "type-operators": {
    patterns: [
      {
        include: "#typeof-operator"
      },
      {
        begin: "([&|])(?=\\s*\\{)",
        beginCaptures: {
          "0": {
            name: "keyword.operator.type.js.jsx"
          }
        },
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        begin: "[&|]",
        beginCaptures: {
          "0": {
            name: "keyword.operator.type.js.jsx"
          }
        },
        end: "(?=\\S)"
      },
      {
        name: "keyword.operator.expression.keyof.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))keyof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.ternary.js.jsx",
        match: "(\\?|\\:)"
      },
      {
        name: "keyword.operator.expression.infer.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))infer(?=\\s+[_$[:alpha:]])"
      },
      {
        name: "keyword.operator.expression.import.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*\\()"
      }
    ]
  },
  "type-predicate-operator": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(asserts)\\s+)?(?!asserts)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s(is)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "1": {
            name: "keyword.operator.type.asserts.js.jsx"
          },
          "2": {
            name: "variable.parameter.js.jsx variable.language.this.js.jsx"
          },
          "3": {
            name: "variable.parameter.js.jsx"
          },
          "4": {
            name: "keyword.operator.expression.is.js.jsx"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(asserts)\\s+(?!is)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "1": {
            name: "keyword.operator.type.asserts.js.jsx"
          },
          "2": {
            name: "variable.parameter.js.jsx variable.language.this.js.jsx"
          },
          "3": {
            name: "variable.parameter.js.jsx"
          }
        }
      },
      {
        name: "keyword.operator.type.asserts.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))asserts(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.expression.is.js.jsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))is(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "type-name": {
    patterns: [
      {
        begin: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(<)",
        captures: {
          "1": {
            name: "entity.name.type.module.js.jsx"
          },
          "2": {
            name: "punctuation.accessor.js.jsx"
          },
          "3": {
            name: "punctuation.accessor.optional.js.jsx"
          },
          "4": {
            name: "meta.type.parameters.js.jsx punctuation.definition.typeparameters.begin.js.jsx"
          }
        },
        end: "(>)",
        endCaptures: {
          "1": {
            name: "meta.type.parameters.js.jsx punctuation.definition.typeparameters.end.js.jsx"
          }
        },
        contentName: "meta.type.parameters.js.jsx",
        patterns: [
          {
            include: "#type-arguments-body"
          }
        ]
      },
      {
        begin: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(<)",
        beginCaptures: {
          "1": {
            name: "entity.name.type.js.jsx"
          },
          "2": {
            name: "meta.type.parameters.js.jsx punctuation.definition.typeparameters.begin.js.jsx"
          }
        },
        end: "(>)",
        endCaptures: {
          "1": {
            name: "meta.type.parameters.js.jsx punctuation.definition.typeparameters.end.js.jsx"
          }
        },
        contentName: "meta.type.parameters.js.jsx",
        patterns: [
          {
            include: "#type-arguments-body"
          }
        ]
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))",
        captures: {
          "1": {
            name: "entity.name.type.module.js.jsx"
          },
          "2": {
            name: "punctuation.accessor.js.jsx"
          },
          "3": {
            name: "punctuation.accessor.optional.js.jsx"
          }
        }
      },
      {
        name: "entity.name.type.js.jsx",
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      }
    ]
  },
  "punctuation-comma": {
    name: "punctuation.separator.comma.js.jsx",
    match: ","
  },
  "punctuation-semicolon": {
    name: "punctuation.terminator.statement.js.jsx",
    match: ";"
  },
  "punctuation-accessor": {
    match: "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))",
    captures: {
      "1": {
        name: "punctuation.accessor.js.jsx"
      },
      "2": {
        name: "punctuation.accessor.optional.js.jsx"
      }
    }
  },
  string: {
    patterns: [
      {
        include: "#qstring-single"
      },
      {
        include: "#qstring-double"
      },
      {
        include: "#template"
      }
    ]
  },
  "qstring-double": {
    name: "string.quoted.double.js.jsx",
    begin: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.js.jsx"
      }
    },
    end: '(")|((?:[^\\\\\\n])$)',
    endCaptures: {
      "1": {
        name: "punctuation.definition.string.end.js.jsx"
      },
      "2": {
        name: "invalid.illegal.newline.js.jsx"
      }
    },
    patterns: [
      {
        include: "#string-character-escape"
      }
    ]
  },
  "qstring-single": {
    name: "string.quoted.single.js.jsx",
    begin: "'",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.js.jsx"
      }
    },
    end: "(\\')|((?:[^\\\\\\n])$)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.string.end.js.jsx"
      },
      "2": {
        name: "invalid.illegal.newline.js.jsx"
      }
    },
    patterns: [
      {
        include: "#string-character-escape"
      }
    ]
  },
  "string-character-escape": {
    name: "constant.character.escape.js.jsx",
    match: "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|u\\{[0-9A-Fa-f]+\\}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)"
  },
  template: {
    patterns: [
      {
        include: "#template-call"
      },
      {
        name: "string.template.js.jsx",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)?(`)",
        beginCaptures: {
          "1": {
            name: "entity.name.function.tagged-template.js.jsx"
          },
          "2": {
            name: "punctuation.definition.string.template.begin.js.jsx"
          }
        },
        end: "`",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.template.end.js.jsx"
          }
        },
        patterns: [
          {
            include: "#template-substitution-element"
          },
          {
            include: "#string-character-escape"
          }
        ]
      }
    ]
  },
  "template-call": {
    patterns: [
      {
        name: "string.template.js.jsx",
        begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*)(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)",
        end: "(?=`)",
        patterns: [
          {
            begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*))",
            end: "(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)",
            patterns: [
              {
                include: "#support-function-call-identifiers"
              },
              {
                name: "entity.name.function.tagged-template.js.jsx",
                match: "([_$[:alpha:]][_$[:alnum:]]*)"
              }
            ]
          },
          {
            include: "#type-arguments"
          }
        ]
      },
      {
        name: "string.template.js.jsx",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)?\\s*(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)`)",
        beginCaptures: {
          "1": {
            name: "entity.name.function.tagged-template.js.jsx"
          }
        },
        end: "(?=`)",
        patterns: [
          {
            include: "#type-arguments"
          }
        ]
      }
    ]
  },
  "template-substitution-element": {
    name: "meta.template.expression.js.jsx",
    begin: "\\$\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.begin.js.jsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.end.js.jsx"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ],
    contentName: "meta.embedded.line.js.jsx"
  },
  "type-string": {
    patterns: [
      {
        include: "#qstring-single"
      },
      {
        include: "#qstring-double"
      },
      {
        include: "#template-type"
      }
    ]
  },
  "template-type": {
    patterns: [
      {
        include: "#template-call"
      },
      {
        name: "string.template.js.jsx",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)?(`)",
        beginCaptures: {
          "1": {
            name: "entity.name.function.tagged-template.js.jsx"
          },
          "2": {
            name: "punctuation.definition.string.template.begin.js.jsx"
          }
        },
        end: "`",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.template.end.js.jsx"
          }
        },
        patterns: [
          {
            include: "#template-type-substitution-element"
          },
          {
            include: "#string-character-escape"
          }
        ]
      }
    ]
  },
  "template-type-substitution-element": {
    name: "meta.template.expression.js.jsx",
    begin: "\\$\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.begin.js.jsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.end.js.jsx"
      }
    },
    patterns: [
      {
        include: "#type"
      }
    ],
    contentName: "meta.embedded.line.js.jsx"
  },
  regex: {
    patterns: [
      {
        name: "string.regexp.js.jsx",
        begin: "(?<!\\+\\+|--|})(?<=[=(:,\\[?+!]|^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case|=>|&&|\\|\\||\\*\\/)\\s*(\\/)(?![\\/*])(?=(?:[^\\/\\\\\\[\\()]|\\\\.|\\[([^\\]\\\\]|\\\\.)+\\]|\\(([^\\)\\\\]|\\\\.)+\\))+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.string.begin.js.jsx"
          }
        },
        end: "(/)([dgimsuy]*)",
        endCaptures: {
          "1": {
            name: "punctuation.definition.string.end.js.jsx"
          },
          "2": {
            name: "keyword.other.js.jsx"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      },
      {
        name: "string.regexp.js.jsx",
        begin: "((?<![_$[:alnum:])\\]]|\\+\\+|--|}|\\*\\/)|((?<=^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case))\\s*)\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.js.jsx"
          }
        },
        end: "(/)([dgimsuy]*)",
        endCaptures: {
          "1": {
            name: "punctuation.definition.string.end.js.jsx"
          },
          "2": {
            name: "keyword.other.js.jsx"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      }
    ]
  },
  regexp: {
    patterns: [
      {
        name: "keyword.control.anchor.regexp",
        match: "\\\\[bB]|\\^|\\$"
      },
      {
        match: "\\\\[1-9]\\d*|\\\\k<([a-zA-Z_$][\\w$]*)>",
        captures: {
          "0": {
            name: "keyword.other.back-reference.regexp"
          },
          "1": {
            name: "variable.other.regexp"
          }
        }
      },
      {
        name: "keyword.operator.quantifier.regexp",
        match: "[?+*]|\\{(\\d+,\\d+|\\d+,|,\\d+|\\d+)\\}\\??"
      },
      {
        name: "keyword.operator.or.regexp",
        match: "\\|"
      },
      {
        name: "meta.group.assertion.regexp",
        begin: "(\\()((\\?=)|(\\?!)|(\\?<=)|(\\?<!))",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.group.regexp"
          },
          "2": {
            name: "punctuation.definition.group.assertion.regexp"
          },
          "3": {
            name: "meta.assertion.look-ahead.regexp"
          },
          "4": {
            name: "meta.assertion.negative-look-ahead.regexp"
          },
          "5": {
            name: "meta.assertion.look-behind.regexp"
          },
          "6": {
            name: "meta.assertion.negative-look-behind.regexp"
          }
        },
        end: "(\\))",
        endCaptures: {
          "1": {
            name: "punctuation.definition.group.regexp"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      },
      {
        name: "meta.group.regexp",
        begin: "\\((?:(\\?:)|(?:\\?<([a-zA-Z_$][\\w$]*)>))?",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.group.regexp"
          },
          "1": {
            name: "punctuation.definition.group.no-capture.regexp"
          },
          "2": {
            name: "variable.other.regexp"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.definition.group.regexp"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      },
      {
        name: "constant.other.character-class.set.regexp",
        begin: "(\\[)(\\^)?",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.character-class.regexp"
          },
          "2": {
            name: "keyword.operator.negation.regexp"
          }
        },
        end: "(\\])",
        endCaptures: {
          "1": {
            name: "punctuation.definition.character-class.regexp"
          }
        },
        patterns: [
          {
            name: "constant.other.character-class.range.regexp",
            match: "(?:.|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))\\-(?:[^\\]\\\\]|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))",
            captures: {
              "1": {
                name: "constant.character.numeric.regexp"
              },
              "2": {
                name: "constant.character.control.regexp"
              },
              "3": {
                name: "constant.character.escape.backslash.regexp"
              },
              "4": {
                name: "constant.character.numeric.regexp"
              },
              "5": {
                name: "constant.character.control.regexp"
              },
              "6": {
                name: "constant.character.escape.backslash.regexp"
              }
            }
          },
          {
            include: "#regex-character-class"
          }
        ]
      },
      {
        include: "#regex-character-class"
      }
    ]
  },
  "regex-character-class": {
    patterns: [
      {
        name: "constant.other.character-class.regexp",
        match: "\\\\[wWsSdDtrnvf]|\\."
      },
      {
        name: "constant.character.numeric.regexp",
        match: "\\\\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})"
      },
      {
        name: "constant.character.control.regexp",
        match: "\\\\c[A-Z]"
      },
      {
        name: "constant.character.escape.backslash.regexp",
        match: "\\\\."
      }
    ]
  },
  comment: {
    patterns: [
      {
        name: "comment.block.documentation.js.jsx",
        begin: "/\\*\\*(?!/)",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.comment.js.jsx"
          }
        },
        end: "\\*/",
        endCaptures: {
          "0": {
            name: "punctuation.definition.comment.js.jsx"
          }
        },
        patterns: [
          {
            include: "#docblock"
          }
        ]
      },
      {
        name: "comment.block.js.jsx",
        begin: "(/\\*)(?:\\s*((@)internal)(?=\\s|(\\*/)))?",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.comment.js.jsx"
          },
          "2": {
            name: "storage.type.internaldeclaration.js.jsx"
          },
          "3": {
            name: "punctuation.decorator.internaldeclaration.js.jsx"
          }
        },
        end: "\\*/",
        endCaptures: {
          "0": {
            name: "punctuation.definition.comment.js.jsx"
          }
        }
      },
      {
        begin: "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)",
        beginCaptures: {
          "1": {
            name: "punctuation.whitespace.comment.leading.js.jsx"
          },
          "2": {
            name: "comment.line.double-slash.js.jsx"
          },
          "3": {
            name: "punctuation.definition.comment.js.jsx"
          },
          "4": {
            name: "storage.type.internaldeclaration.js.jsx"
          },
          "5": {
            name: "punctuation.decorator.internaldeclaration.js.jsx"
          }
        },
        end: "(?=$)",
        contentName: "comment.line.double-slash.js.jsx"
      }
    ]
  },
  "single-line-comment-consuming-line-ending": {
    begin: "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)",
    beginCaptures: {
      "1": {
        name: "punctuation.whitespace.comment.leading.js.jsx"
      },
      "2": {
        name: "comment.line.double-slash.js.jsx"
      },
      "3": {
        name: "punctuation.definition.comment.js.jsx"
      },
      "4": {
        name: "storage.type.internaldeclaration.js.jsx"
      },
      "5": {
        name: "punctuation.decorator.internaldeclaration.js.jsx"
      }
    },
    end: "(?=^)",
    contentName: "comment.line.double-slash.js.jsx"
  },
  directives: {
    name: "comment.line.triple-slash.directive.js.jsx",
    begin: "^(///)\\s*(?=<(reference|amd-dependency|amd-module)(\\s+(path|types|no-default-lib|lib|name)\\s*=\\s*((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)))+\\s*/>\\s*$)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.comment.js.jsx"
      }
    },
    end: "(?=$)",
    patterns: [
      {
        name: "meta.tag.js.jsx",
        begin: "(<)(reference|amd-dependency|amd-module)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.directive.js.jsx"
          },
          "2": {
            name: "entity.name.tag.directive.js.jsx"
          }
        },
        end: "/>",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.directive.js.jsx"
          }
        },
        patterns: [
          {
            name: "entity.other.attribute-name.directive.js.jsx",
            match: "path|types|no-default-lib|lib|name"
          },
          {
            name: "keyword.operator.assignment.js.jsx",
            match: "="
          },
          {
            include: "#string"
          }
        ]
      }
    ]
  },
  docblock: {
    patterns: [
      {
        match: "(?x)\n((@)(?:access|api))\n\\s+\n(private|protected|public)\n\\b",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "constant.language.access-type.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)author)\n\\s+\n(\n  [^@\\s<>*/]\n  (?:[^@<>*/]|\\*[^/])*\n)\n(?:\n  \\s*\n  (<)\n  ([^>\\s]+)\n  (>)\n)?",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "entity.name.type.instance.jsdoc"
          },
          "4": {
            name: "punctuation.definition.bracket.angle.begin.jsdoc"
          },
          "5": {
            name: "constant.other.email.link.underline.jsdoc"
          },
          "6": {
            name: "punctuation.definition.bracket.angle.end.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)borrows) \\s+\n((?:[^@\\s*/]|\\*[^/])+)    # <that namepath>\n\\s+ (as) \\s+              # as\n((?:[^@\\s*/]|\\*[^/])+)    # <this namepath>",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "entity.name.type.instance.jsdoc"
          },
          "4": {
            name: "keyword.operator.control.jsdoc"
          },
          "5": {
            name: "entity.name.type.instance.jsdoc"
          }
        }
      },
      {
        name: "meta.example.jsdoc",
        begin: "((@)example)\\s+",
        end: "(?=@|\\*/)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        patterns: [
          {
            match: "^\\s\\*\\s+"
          },
          {
            contentName: "constant.other.description.jsdoc",
            begin: "\\G(<)caption(>)",
            beginCaptures: {
              "0": {
                name: "entity.name.tag.inline.jsdoc"
              },
              "1": {
                name: "punctuation.definition.bracket.angle.begin.jsdoc"
              },
              "2": {
                name: "punctuation.definition.bracket.angle.end.jsdoc"
              }
            },
            end: "(</)caption(>)|(?=\\*/)",
            endCaptures: {
              "0": {
                name: "entity.name.tag.inline.jsdoc"
              },
              "1": {
                name: "punctuation.definition.bracket.angle.begin.jsdoc"
              },
              "2": {
                name: "punctuation.definition.bracket.angle.end.jsdoc"
              }
            }
          },
          {
            match: "[^\\s@*](?:[^*]|\\*[^/])*",
            captures: {
              "0": {
                name: "source.embedded.js.jsx"
              }
            }
          }
        ]
      },
      {
        match: "(?x) ((@)kind) \\s+ (class|constant|event|external|file|function|member|mixin|module|namespace|typedef) \\b",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "constant.language.symbol-type.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)see)\n\\s+\n(?:\n  # URL\n  (\n    (?=https?://)\n    (?:[^\\s*]|\\*[^/])+\n  )\n  |\n  # JSDoc namepath\n  (\n    (?!\n      # Avoid matching bare URIs (also acceptable as links)\n      https?://\n      |\n      # Avoid matching {@inline tags}; we match those below\n      (?:\\[[^\\[\\]]*\\])? # Possible description [preceding]{@tag}\n      {@(?:link|linkcode|linkplain|tutorial)\\b\n    )\n    # Matched namepath\n    (?:[^@\\s*/]|\\*[^/])+\n  )\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.link.underline.jsdoc"
          },
          "4": {
            name: "entity.name.type.instance.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)template)\n\\s+\n# One or more valid identifiers\n(\n  [A-Za-z_$]         # First character: non-numeric word character\n  [\\w$.\\[\\]]*        # Rest of identifier\n  (?:                # Possible list of additional identifiers\n    \\s* , \\s*\n    [A-Za-z_$]\n    [\\w$.\\[\\]]*\n  )*\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n(\n  (@)\n  (?:arg|argument|const|constant|member|namespace|param|var)\n)\n\\s+\n(\n  [A-Za-z_$]\n  [\\w$.\\[\\]]*\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          }
        }
      },
      {
        begin: "((@)typedef)\\s+(?={)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])",
        patterns: [
          {
            include: "#jsdoctype"
          },
          {
            name: "entity.name.type.instance.jsdoc",
            match: "(?:[^@\\s*/]|\\*[^/])+"
          }
        ]
      },
      {
        begin: "((@)(?:arg|argument|const|constant|member|namespace|param|prop|property|var))\\s+(?={)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])",
        patterns: [
          {
            include: "#jsdoctype"
          },
          {
            name: "variable.other.jsdoc",
            match: "([A-Za-z_$][\\w$.\\[\\]]*)"
          },
          {
            name: "variable.other.jsdoc",
            match: `(?x)
(\\[)\\s*
[\\w$]+
(?:
  (?:\\[\\])?                                        # Foo[ ].bar properties within an array
  \\.                                                # Foo.Bar namespaced parameter
  [\\w$]+
)*
(?:
  \\s*
  (=)                                                # [foo=bar] Default parameter value
  \\s*
  (
    # The inner regexes are to stop the match early at */ and to not stop at escaped quotes
    (?>
      "(?:(?:\\*(?!/))|(?:\\\\(?!"))|[^*\\\\])*?" |                      # [foo="bar"] Double-quoted
      '(?:(?:\\*(?!/))|(?:\\\\(?!'))|[^*\\\\])*?' |                      # [foo='bar'] Single-quoted
      \\[ (?:(?:\\*(?!/))|[^*])*? \\] |                                # [foo=[1,2]] Array literal
      (?:(?:\\*(?!/))|\\s(?!\\s*\\])|\\[.*?(?:\\]|(?=\\*/))|[^*\\s\\[\\]])*   # Everything else
    )*
  )
)?
\\s*(?:(\\])((?:[^*\\s]|\\*[^\\s/])+)?|(?=\\*/))`,
            captures: {
              "1": {
                name: "punctuation.definition.optional-value.begin.bracket.square.jsdoc"
              },
              "2": {
                name: "keyword.operator.assignment.jsdoc"
              },
              "3": {
                name: "source.embedded.js.jsx"
              },
              "4": {
                name: "punctuation.definition.optional-value.end.bracket.square.jsdoc"
              },
              "5": {
                name: "invalid.illegal.syntax.jsdoc"
              }
            }
          }
        ]
      },
      {
        begin: "(?x)\n(\n  (@)\n  (?:define|enum|exception|export|extends|lends|implements|modifies\n  |namespace|private|protected|returns?|suppress|this|throws|type\n  |yields?)\n)\n\\s+(?={)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])",
        patterns: [
          {
            include: "#jsdoctype"
          }
        ]
      },
      {
        match: "(?x)\n(\n  (@)\n  (?:alias|augments|callback|constructs|emits|event|fires|exports?\n  |extends|external|function|func|host|lends|listens|interface|memberof!?\n  |method|module|mixes|mixin|name|requires|see|this|typedef|uses)\n)\n\\s+\n(\n  (?:\n    [^{}@\\s*] | \\*[^/]\n  )+\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "entity.name.type.instance.jsdoc"
          }
        }
      },
      {
        contentName: "variable.other.jsdoc",
        begin: `((@)(?:default(?:value)?|license|version))\\s+(([''"]))`,
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          },
          "4": {
            name: "punctuation.definition.string.begin.jsdoc"
          }
        },
        end: "(\\3)|(?=$|\\*/)",
        endCaptures: {
          "0": {
            name: "variable.other.jsdoc"
          },
          "1": {
            name: "punctuation.definition.string.end.jsdoc"
          }
        }
      },
      {
        match: "((@)(?:default(?:value)?|license|tutorial|variation|version))\\s+([^\\s*]+)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          }
        }
      },
      {
        name: "storage.type.class.jsdoc",
        match: "(?x) (@) (?:abstract|access|alias|api|arg|argument|async|attribute|augments|author|beta|borrows|bubbles |callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright |default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exception |exports?|extends|extension(?:_?for)?|external|externs|file|fileoverview|final|fires|for|func |function|generator|global|hideconstructor|host|ignore|implements|implicitCast|inherit[Dd]oc |inner|instance|interface|internal|kind|lends|license|listens|main|member|memberof!?|method |mixes|mixins?|modifies|module|name|namespace|noalias|nocollapse|nocompile|nosideeffects |override|overview|package|param|polymer(?:Behavior)?|preserve|private|prop|property|protected |public|read[Oo]nly|record|require[ds]|returns?|see|since|static|struct|submodule|summary |suppress|template|this|throws|todo|tutorial|type|typedef|unrestricted|uses|var|variation |version|virtual|writeOnce|yields?) \\b",
        captures: {
          "1": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        }
      },
      {
        include: "#inline-tags"
      },
      {
        match: "((@)(?:[_$[:alpha:]][_$[:alnum:]]*))(?=\\s+)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        }
      }
    ]
  },
  brackets: {
    patterns: [
      {
        begin: "{",
        end: "}|(?=\\*/)",
        patterns: [
          {
            include: "#brackets"
          }
        ]
      },
      {
        begin: "\\[",
        end: "\\]|(?=\\*/)",
        patterns: [
          {
            include: "#brackets"
          }
        ]
      }
    ]
  },
  "inline-tags": {
    patterns: [
      {
        name: "constant.other.description.jsdoc",
        match: "(\\[)[^\\]]+(\\])(?={@(?:link|linkcode|linkplain|tutorial))",
        captures: {
          "1": {
            name: "punctuation.definition.bracket.square.begin.jsdoc"
          },
          "2": {
            name: "punctuation.definition.bracket.square.end.jsdoc"
          }
        }
      },
      {
        name: "entity.name.type.instance.jsdoc",
        begin: "({)((@)(?:link(?:code|plain)?|tutorial))\\s*",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.bracket.curly.begin.jsdoc"
          },
          "2": {
            name: "storage.type.class.jsdoc"
          },
          "3": {
            name: "punctuation.definition.inline.tag.jsdoc"
          }
        },
        end: "}|(?=\\*/)",
        endCaptures: {
          "0": {
            name: "punctuation.definition.bracket.curly.end.jsdoc"
          }
        },
        patterns: [
          {
            match: "\\G((?=https?://)(?:[^|}\\s*]|\\*[/])+)(\\|)?",
            captures: {
              "1": {
                name: "variable.other.link.underline.jsdoc"
              },
              "2": {
                name: "punctuation.separator.pipe.jsdoc"
              }
            }
          },
          {
            match: "\\G((?:[^{}@\\s|*]|\\*[^/])+)(\\|)?",
            captures: {
              "1": {
                name: "variable.other.description.jsdoc"
              },
              "2": {
                name: "punctuation.separator.pipe.jsdoc"
              }
            }
          }
        ]
      }
    ]
  },
  jsdoctype: {
    patterns: [
      {
        contentName: "entity.name.type.instance.jsdoc",
        begin: "\\G({)",
        beginCaptures: {
          "0": {
            name: "entity.name.type.instance.jsdoc"
          },
          "1": {
            name: "punctuation.definition.bracket.curly.begin.jsdoc"
          }
        },
        end: "((}))\\s*|(?=\\*/)",
        endCaptures: {
          "1": {
            name: "entity.name.type.instance.jsdoc"
          },
          "2": {
            name: "punctuation.definition.bracket.curly.end.jsdoc"
          }
        },
        patterns: [
          {
            include: "#brackets"
          }
        ]
      }
    ]
  },
  jsx: {
    patterns: [
      {
        include: "#jsx-tag-without-attributes-in-expression"
      },
      {
        include: "#jsx-tag-in-expression"
      }
    ]
  },
  "jsx-tag-without-attributes-in-expression": {
    begin: "(?<!\\+\\+|--)(?<=[({\\[,?=>:*]|&&|\\|\\||\\?|\\*\\/|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^default|[^\\._$[:alnum:]]default|^yield|[^\\._$[:alnum:]]yield|^)\\s*(?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))",
    end: "(?!(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))",
    patterns: [
      {
        include: "#jsx-tag-without-attributes"
      }
    ]
  },
  "jsx-tag-without-attributes": {
    name: "meta.tag.without-attributes.js.jsx",
    begin: "(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>)",
    end: "(</)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.js.jsx"
      },
      "2": {
        name: "entity.name.tag.namespace.js.jsx"
      },
      "3": {
        name: "punctuation.separator.namespace.js.jsx"
      },
      "4": {
        name: "entity.name.tag.js.jsx"
      },
      "5": {
        name: "support.class.component.js.jsx"
      },
      "6": {
        name: "punctuation.definition.tag.end.js.jsx"
      }
    },
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.js.jsx"
      },
      "2": {
        name: "entity.name.tag.namespace.js.jsx"
      },
      "3": {
        name: "punctuation.separator.namespace.js.jsx"
      },
      "4": {
        name: "entity.name.tag.js.jsx"
      },
      "5": {
        name: "support.class.component.js.jsx"
      },
      "6": {
        name: "punctuation.definition.tag.end.js.jsx"
      }
    },
    contentName: "meta.jsx.children.js.jsx",
    patterns: [
      {
        include: "#jsx-children"
      }
    ]
  },
  "jsx-tag-in-expression": {
    begin: "(?x)\n  (?<!\\+\\+|--)(?<=[({\\[,?=>:*]|&&|\\|\\||\\?|\\*\\/|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^default|[^\\._$[:alnum:]]default|^yield|[^\\._$[:alnum:]]yield|^)\\s*\n  (?!<\\s*[_$[:alpha:]][_$[:alnum:]]*((\\s+extends\\s+[^=>])|,)) # look ahead is not type parameter of arrow\n  (?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))",
    end: "(?!(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))",
    patterns: [
      {
        include: "#jsx-tag"
      }
    ]
  },
  "jsx-tag": {
    name: "meta.tag.js.jsx",
    begin: "(?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))",
    end: "(/>)|(?:(</)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.js.jsx"
      },
      "2": {
        name: "punctuation.definition.tag.begin.js.jsx"
      },
      "3": {
        name: "entity.name.tag.namespace.js.jsx"
      },
      "4": {
        name: "punctuation.separator.namespace.js.jsx"
      },
      "5": {
        name: "entity.name.tag.js.jsx"
      },
      "6": {
        name: "support.class.component.js.jsx"
      },
      "7": {
        name: "punctuation.definition.tag.end.js.jsx"
      }
    },
    patterns: [
      {
        begin: "(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.js.jsx"
          },
          "2": {
            name: "entity.name.tag.namespace.js.jsx"
          },
          "3": {
            name: "punctuation.separator.namespace.js.jsx"
          },
          "4": {
            name: "entity.name.tag.js.jsx"
          },
          "5": {
            name: "support.class.component.js.jsx"
          }
        },
        end: "(?=[/]?>)",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#type-arguments"
          },
          {
            include: "#jsx-tag-attributes"
          }
        ]
      },
      {
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.js.jsx"
          }
        },
        end: "(?=</)",
        contentName: "meta.jsx.children.js.jsx",
        patterns: [
          {
            include: "#jsx-children"
          }
        ]
      }
    ]
  },
  "jsx-children": {
    patterns: [
      {
        include: "#jsx-tag-without-attributes"
      },
      {
        include: "#jsx-tag"
      },
      {
        include: "#jsx-evaluated-code"
      },
      {
        include: "#jsx-entities"
      }
    ]
  },
  "jsx-evaluated-code": {
    contentName: "meta.embedded.expression.js.jsx",
    begin: "\\{",
    end: "\\}",
    beginCaptures: {
      "0": {
        name: "punctuation.section.embedded.begin.js.jsx"
      }
    },
    endCaptures: {
      "0": {
        name: "punctuation.section.embedded.end.js.jsx"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "jsx-entities": {
    patterns: [
      {
        name: "constant.character.entity.js.jsx",
        match: "(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)",
        captures: {
          "1": {
            name: "punctuation.definition.entity.js.jsx"
          },
          "3": {
            name: "punctuation.definition.entity.js.jsx"
          }
        }
      },
      {
        name: "invalid.illegal.bad-ampersand.js.jsx",
        match: "&"
      }
    ]
  },
  "jsx-tag-attributes": {
    name: "meta.tag.attributes.js.jsx",
    begin: "\\s+",
    end: "(?=[/]?>)",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#jsx-tag-attribute-name"
      },
      {
        include: "#jsx-tag-attribute-assignment"
      },
      {
        include: "#jsx-string-double-quoted"
      },
      {
        include: "#jsx-string-single-quoted"
      },
      {
        include: "#jsx-evaluated-code"
      },
      {
        include: "#jsx-tag-attributes-illegal"
      }
    ]
  },
  "jsx-tag-attribute-name": {
    match: "(?x)\n  \\s*\n  (?:([_$[:alpha:]][-_$[:alnum:].]*)(:))?\n  ([_$[:alpha:]][-_$[:alnum:]]*)\n  (?=\\s|=|/?>|/\\*|//)",
    captures: {
      "1": {
        name: "entity.other.attribute-name.namespace.js.jsx"
      },
      "2": {
        name: "punctuation.separator.namespace.js.jsx"
      },
      "3": {
        name: "entity.other.attribute-name.js.jsx"
      }
    }
  },
  "jsx-tag-attribute-assignment": {
    name: "keyword.operator.assignment.js.jsx",
    match: `=(?=\\s*(?:'|"|{|/\\*|//|\\n))`
  },
  "jsx-string-double-quoted": {
    name: "string.quoted.double.js.jsx",
    begin: '"',
    end: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.js.jsx"
      }
    },
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.js.jsx"
      }
    },
    patterns: [
      {
        include: "#jsx-entities"
      }
    ]
  },
  "jsx-string-single-quoted": {
    name: "string.quoted.single.js.jsx",
    begin: "'",
    end: "'",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.js.jsx"
      }
    },
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.js.jsx"
      }
    },
    patterns: [
      {
        include: "#jsx-entities"
      }
    ]
  },
  "jsx-tag-attributes-illegal": {
    name: "invalid.illegal.attribute.js.jsx",
    match: "\\S+"
  }
};
const jsx_tmLanguage = {
  information_for_contributors: information_for_contributors$3,
  version: version$3,
  name: name$6,
  scopeName: scopeName$5,
  patterns: patterns$5,
  repository: repository$5
};
const __vite_glob_0_5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: jsx_tmLanguage,
  information_for_contributors: information_for_contributors$3,
  name: name$6,
  patterns: patterns$5,
  repository: repository$5,
  scopeName: scopeName$5,
  version: version$3
}, Symbol.toStringTag, { value: "Module" }));
const information_for_contributors$2 = [
  "This file has been converted from https://github.com/microsoft/TypeScript-TmLanguage/blob/master/TypeScriptReact.tmLanguage",
  "If you want to provide a fix or improvement, please create a pull request against the original repository.",
  "Once accepted there, we are happy to receive an update request."
];
const version$2 = "https://github.com/microsoft/TypeScript-TmLanguage/commit/33d8371c344f0b54746586313a939f742f9bcd3a";
const name$5 = "tsx";
const scopeName$4 = "source.tsx";
const patterns$4 = [
  {
    include: "#directives"
  },
  {
    include: "#statements"
  },
  {
    include: "#shebang"
  }
];
const repository$4 = {
  shebang: {
    name: "comment.line.shebang.tsx",
    match: "\\A(#!).*(?=$)",
    captures: {
      "1": {
        name: "punctuation.definition.comment.tsx"
      }
    }
  },
  statements: {
    patterns: [
      {
        include: "#declaration"
      },
      {
        include: "#control-statement"
      },
      {
        include: "#after-operator-block-as-object-literal"
      },
      {
        include: "#decl-block"
      },
      {
        include: "#label"
      },
      {
        include: "#expression"
      },
      {
        include: "#punctuation-semicolon"
      },
      {
        include: "#string"
      },
      {
        include: "#comment"
      }
    ]
  },
  declaration: {
    patterns: [
      {
        include: "#decorator"
      },
      {
        include: "#var-expr"
      },
      {
        include: "#function-declaration"
      },
      {
        include: "#class-declaration"
      },
      {
        include: "#interface-declaration"
      },
      {
        include: "#enum-declaration"
      },
      {
        include: "#namespace-declaration"
      },
      {
        include: "#type-alias-declaration"
      },
      {
        include: "#import-equals-declaration"
      },
      {
        include: "#import-declaration"
      },
      {
        include: "#export-declaration"
      },
      {
        name: "storage.modifier.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(declare|export)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "control-statement": {
    patterns: [
      {
        include: "#switch-statement"
      },
      {
        include: "#for-loop"
      },
      {
        name: "keyword.control.trycatch.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(catch|finally|throw|try)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|goto)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "1": {
            name: "keyword.control.loop.tsx"
          },
          "2": {
            name: "entity.name.label.tsx"
          }
        }
      },
      {
        name: "keyword.control.loop.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|do|goto|while)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(return)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        beginCaptures: {
          "0": {
            name: "keyword.control.flow.tsx"
          }
        },
        end: "(?=[;}]|$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "keyword.control.switch.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default|switch)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        include: "#if-statement"
      },
      {
        name: "keyword.control.conditional.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(else|if)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.control.with.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(with)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.control.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(package)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.other.debugger.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(debugger)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  label: {
    patterns: [
      {
        begin: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)(?=\\s*\\{)",
        beginCaptures: {
          "1": {
            name: "entity.name.label.tsx"
          },
          "2": {
            name: "punctuation.separator.label.tsx"
          }
        },
        end: "(?<=\\})",
        patterns: [
          {
            include: "#decl-block"
          }
        ]
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)",
        captures: {
          "1": {
            name: "entity.name.label.tsx"
          },
          "2": {
            name: "punctuation.separator.label.tsx"
          }
        }
      }
    ]
  },
  expression: {
    patterns: [
      {
        include: "#expressionWithoutIdentifiers"
      },
      {
        include: "#identifiers"
      },
      {
        include: "#expressionPunctuations"
      }
    ]
  },
  expressionWithoutIdentifiers: {
    patterns: [
      {
        include: "#jsx"
      },
      {
        include: "#string"
      },
      {
        include: "#regex"
      },
      {
        include: "#comment"
      },
      {
        include: "#function-expression"
      },
      {
        include: "#class-expression"
      },
      {
        include: "#arrow-function"
      },
      {
        include: "#paren-expression-possibly-arrow"
      },
      {
        include: "#cast"
      },
      {
        include: "#ternary-expression"
      },
      {
        include: "#new-expr"
      },
      {
        include: "#instanceof-expr"
      },
      {
        include: "#object-literal"
      },
      {
        include: "#expression-operators"
      },
      {
        include: "#function-call"
      },
      {
        include: "#literal"
      },
      {
        include: "#support-objects"
      },
      {
        include: "#paren-expression"
      }
    ]
  },
  expressionPunctuations: {
    patterns: [
      {
        include: "#punctuation-comma"
      },
      {
        include: "#punctuation-accessor"
      }
    ]
  },
  decorator: {
    name: "meta.decorator.tsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))\\@",
    beginCaptures: {
      "0": {
        name: "punctuation.decorator.tsx"
      }
    },
    end: "(?=\\s)",
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "var-expr": {
    patterns: [
      {
        name: "meta.var.expr.tsx",
        begin: "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))",
        end: "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))|((?<!^let|[^\\._$[:alnum:]]let|^var|[^\\._$[:alnum:]]var)(?=\\s*$)))",
        patterns: [
          {
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*",
            beginCaptures: {
              "1": {
                name: "keyword.control.export.tsx"
              },
              "2": {
                name: "storage.modifier.tsx"
              },
              "3": {
                name: "storage.type.tsx"
              }
            },
            end: "(?=\\S)"
          },
          {
            include: "#destructuring-variable"
          },
          {
            include: "#var-single-variable"
          },
          {
            include: "#variable-initializer"
          },
          {
            include: "#comment"
          },
          {
            begin: "(,)\\s*((?!\\S)|(?=\\/\\/))",
            beginCaptures: {
              "1": {
                name: "punctuation.separator.comma.tsx"
              }
            },
            end: "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))",
            patterns: [
              {
                include: "#single-line-comment-consuming-line-ending"
              },
              {
                include: "#comment"
              },
              {
                include: "#destructuring-variable"
              },
              {
                include: "#var-single-variable"
              },
              {
                include: "#punctuation-comma"
              }
            ]
          },
          {
            include: "#punctuation-comma"
          }
        ]
      },
      {
        name: "meta.var.expr.tsx",
        begin: "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.tsx"
          },
          "2": {
            name: "storage.modifier.tsx"
          },
          "3": {
            name: "storage.type.tsx"
          }
        },
        end: "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))|((?<!^const|[^\\._$[:alnum:]]const)(?=\\s*$)))",
        patterns: [
          {
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*",
            beginCaptures: {
              "1": {
                name: "keyword.control.export.tsx"
              },
              "2": {
                name: "storage.modifier.tsx"
              },
              "3": {
                name: "storage.type.tsx"
              }
            },
            end: "(?=\\S)"
          },
          {
            include: "#destructuring-const"
          },
          {
            include: "#var-single-const"
          },
          {
            include: "#variable-initializer"
          },
          {
            include: "#comment"
          },
          {
            begin: "(,)\\s*((?!\\S)|(?=\\/\\/))",
            beginCaptures: {
              "1": {
                name: "punctuation.separator.comma.tsx"
              }
            },
            end: "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))",
            patterns: [
              {
                include: "#single-line-comment-consuming-line-ending"
              },
              {
                include: "#comment"
              },
              {
                include: "#destructuring-const"
              },
              {
                include: "#var-single-const"
              },
              {
                include: "#punctuation-comma"
              }
            ]
          },
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  },
  "var-single-variable": {
    patterns: [
      {
        name: "meta.var-single-variable.expr.tsx",
        begin: "(?x)([_$[:alpha:]][_$[:alnum:]]*)(\\!)?(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.tsx entity.name.function.tsx"
          },
          "2": {
            name: "keyword.operator.definiteassignment.tsx"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      },
      {
        name: "meta.var-single-variable.expr.tsx",
        begin: "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])(\\!)?",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.tsx variable.other.constant.tsx"
          },
          "2": {
            name: "keyword.operator.definiteassignment.tsx"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      },
      {
        name: "meta.var-single-variable.expr.tsx",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)(\\!)?",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.tsx variable.other.readwrite.tsx"
          },
          "2": {
            name: "keyword.operator.definiteassignment.tsx"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      }
    ]
  },
  "var-single-const": {
    patterns: [
      {
        name: "meta.var-single-variable.expr.tsx",
        begin: "(?x)([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.tsx variable.other.constant.tsx entity.name.function.tsx"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      },
      {
        name: "meta.var-single-variable.expr.tsx",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.tsx variable.other.constant.tsx"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      }
    ]
  },
  "var-single-variable-type-annotation": {
    patterns: [
      {
        include: "#type-annotation"
      },
      {
        include: "#string"
      },
      {
        include: "#comment"
      }
    ]
  },
  "destructuring-variable": {
    patterns: [
      {
        name: "meta.object-binding-pattern-variable.tsx",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#object-binding-pattern"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      },
      {
        name: "meta.array-binding-pattern-variable.tsx",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#array-binding-pattern"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      }
    ]
  },
  "destructuring-const": {
    patterns: [
      {
        name: "meta.object-binding-pattern-variable.tsx",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#object-binding-pattern-const"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      },
      {
        name: "meta.array-binding-pattern-variable.tsx",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#array-binding-pattern-const"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      }
    ]
  },
  "object-binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          },
          {
            include: "#binding-element"
          }
        ]
      },
      {
        include: "#object-binding-pattern"
      },
      {
        include: "#destructuring-variable-rest"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "object-binding-element-const": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          },
          {
            include: "#binding-element-const"
          }
        ]
      },
      {
        include: "#object-binding-pattern-const"
      },
      {
        include: "#destructuring-variable-rest-const"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "object-binding-element-propertyName": {
    begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
    end: "(:)",
    endCaptures: {
      "0": {
        name: "punctuation.destructuring.tsx"
      }
    },
    patterns: [
      {
        include: "#string"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#numeric-literal"
      },
      {
        name: "variable.object.property.tsx",
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  },
  "binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#regex"
      },
      {
        include: "#object-binding-pattern"
      },
      {
        include: "#array-binding-pattern"
      },
      {
        include: "#destructuring-variable-rest"
      },
      {
        include: "#variable-initializer"
      }
    ]
  },
  "binding-element-const": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#regex"
      },
      {
        include: "#object-binding-pattern-const"
      },
      {
        include: "#array-binding-pattern-const"
      },
      {
        include: "#destructuring-variable-rest-const"
      },
      {
        include: "#variable-initializer"
      }
    ]
  },
  "destructuring-variable-rest": {
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)",
    captures: {
      "1": {
        name: "keyword.operator.rest.tsx"
      },
      "2": {
        name: "meta.definition.variable.tsx variable.other.readwrite.tsx"
      }
    }
  },
  "destructuring-variable-rest-const": {
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)",
    captures: {
      "1": {
        name: "keyword.operator.rest.tsx"
      },
      "2": {
        name: "meta.definition.variable.tsx variable.other.constant.tsx"
      }
    }
  },
  "object-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.tsx"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.object.tsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.object.tsx"
      }
    },
    patterns: [
      {
        include: "#object-binding-element"
      }
    ]
  },
  "object-binding-pattern-const": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.tsx"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.object.tsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.object.tsx"
      }
    },
    patterns: [
      {
        include: "#object-binding-element-const"
      }
    ]
  },
  "array-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.tsx"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.array.tsx"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.array.tsx"
      }
    },
    patterns: [
      {
        include: "#binding-element"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "array-binding-pattern-const": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.tsx"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.array.tsx"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.array.tsx"
      }
    },
    patterns: [
      {
        include: "#binding-element-const"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "parameter-name": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)",
        captures: {
          "1": {
            name: "storage.modifier.tsx"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "1": {
            name: "storage.modifier.tsx"
          },
          "2": {
            name: "keyword.operator.rest.tsx"
          },
          "3": {
            name: "entity.name.function.tsx variable.language.this.tsx"
          },
          "4": {
            name: "entity.name.function.tsx"
          },
          "5": {
            name: "keyword.operator.optional.tsx"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)",
        captures: {
          "1": {
            name: "storage.modifier.tsx"
          },
          "2": {
            name: "keyword.operator.rest.tsx"
          },
          "3": {
            name: "variable.parameter.tsx variable.language.this.tsx"
          },
          "4": {
            name: "variable.parameter.tsx"
          },
          "5": {
            name: "keyword.operator.optional.tsx"
          }
        }
      }
    ]
  },
  "destructuring-parameter": {
    patterns: [
      {
        name: "meta.parameter.object-binding-pattern.tsx",
        begin: "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\{)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.rest.tsx"
          },
          "2": {
            name: "punctuation.definition.binding-pattern.object.tsx"
          }
        },
        end: "\\}",
        endCaptures: {
          "0": {
            name: "punctuation.definition.binding-pattern.object.tsx"
          }
        },
        patterns: [
          {
            include: "#parameter-object-binding-element"
          }
        ]
      },
      {
        name: "meta.paramter.array-binding-pattern.tsx",
        begin: "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\[)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.rest.tsx"
          },
          "2": {
            name: "punctuation.definition.binding-pattern.array.tsx"
          }
        },
        end: "\\]",
        endCaptures: {
          "0": {
            name: "punctuation.definition.binding-pattern.array.tsx"
          }
        },
        patterns: [
          {
            include: "#parameter-binding-element"
          },
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  },
  "parameter-object-binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          },
          {
            include: "#parameter-binding-element"
          }
        ]
      },
      {
        include: "#parameter-object-binding-pattern"
      },
      {
        include: "#destructuring-parameter-rest"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "parameter-binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#regex"
      },
      {
        include: "#parameter-object-binding-pattern"
      },
      {
        include: "#parameter-array-binding-pattern"
      },
      {
        include: "#destructuring-parameter-rest"
      },
      {
        include: "#variable-initializer"
      }
    ]
  },
  "destructuring-parameter-rest": {
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)",
    captures: {
      "1": {
        name: "keyword.operator.rest.tsx"
      },
      "2": {
        name: "variable.parameter.tsx"
      }
    }
  },
  "parameter-object-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.tsx"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.object.tsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.object.tsx"
      }
    },
    patterns: [
      {
        include: "#parameter-object-binding-element"
      }
    ]
  },
  "parameter-array-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.tsx"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.array.tsx"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.array.tsx"
      }
    },
    patterns: [
      {
        include: "#parameter-binding-element"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "field-declaration": {
    name: "meta.field.declaration.tsx",
    begin: "(?x)(?<!\\()(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s+)?(?=\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|\\}|$))",
    beginCaptures: {
      "1": {
        name: "storage.modifier.tsx"
      }
    },
    end: "(?x)(?=\\}|;|,|$|(^(?!\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|$))))|(?<=\\})",
    patterns: [
      {
        include: "#variable-initializer"
      },
      {
        include: "#type-annotation"
      },
      {
        include: "#string"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#comment"
      },
      {
        match: "(?x)(\\#?[_$[:alpha:]][_$[:alnum:]]*)(?:(\\?)|(\\!))?(?=\\s*\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "1": {
            name: "meta.definition.property.tsx entity.name.function.tsx"
          },
          "2": {
            name: "keyword.operator.optional.tsx"
          },
          "3": {
            name: "keyword.operator.definiteassignment.tsx"
          }
        }
      },
      {
        name: "meta.definition.property.tsx variable.object.property.tsx",
        match: "\\#?[_$[:alpha:]][_$[:alnum:]]*"
      },
      {
        name: "keyword.operator.optional.tsx",
        match: "\\?"
      },
      {
        name: "keyword.operator.definiteassignment.tsx",
        match: "\\!"
      }
    ]
  },
  "variable-initializer": {
    patterns: [
      {
        begin: "(?<!=|!)(=)(?!=)(?=\\s*\\S)(?!\\s*.*=>\\s*$)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.tsx"
          }
        },
        end: "(?=$|^|[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        begin: "(?<!=|!)(=)(?!=)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.tsx"
          }
        },
        end: "(?=[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))|(?=^\\s*$)|(?<=\\S)(?<!=)(?=\\s*$)",
        patterns: [
          {
            include: "#expression"
          }
        ]
      }
    ]
  },
  "function-declaration": {
    name: "meta.function.tsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.tsx"
      },
      "2": {
        name: "storage.modifier.tsx"
      },
      "3": {
        name: "storage.modifier.async.tsx"
      },
      "4": {
        name: "storage.type.function.tsx"
      },
      "5": {
        name: "keyword.generator.asterisk.tsx"
      },
      "6": {
        name: "meta.definition.function.tsx entity.name.function.tsx"
      }
    },
    end: "(?=;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))|(?<=\\})",
    patterns: [
      {
        include: "#function-name"
      },
      {
        include: "#function-body"
      }
    ]
  },
  "function-expression": {
    name: "meta.function.expression.tsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*",
    beginCaptures: {
      "1": {
        name: "storage.modifier.async.tsx"
      },
      "2": {
        name: "storage.type.function.tsx"
      },
      "3": {
        name: "keyword.generator.asterisk.tsx"
      },
      "4": {
        name: "meta.definition.function.tsx entity.name.function.tsx"
      }
    },
    end: "(?=;)|(?<=\\})",
    patterns: [
      {
        include: "#function-name"
      },
      {
        include: "#single-line-comment-consuming-line-ending"
      },
      {
        include: "#function-body"
      }
    ]
  },
  "function-name": {
    name: "meta.definition.function.tsx entity.name.function.tsx",
    match: "[_$[:alpha:]][_$[:alnum:]]*"
  },
  "function-body": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#function-parameters"
      },
      {
        include: "#return-type"
      },
      {
        include: "#type-function-return-type"
      },
      {
        include: "#decl-block"
      },
      {
        name: "keyword.generator.asterisk.tsx",
        match: "\\*"
      }
    ]
  },
  "method-declaration": {
    patterns: [
      {
        name: "meta.method.declaration.tsx",
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?\\s*\\b(constructor)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        beginCaptures: {
          "1": {
            name: "storage.modifier.tsx"
          },
          "2": {
            name: "storage.modifier.tsx"
          },
          "3": {
            name: "storage.modifier.tsx"
          },
          "4": {
            name: "storage.modifier.async.tsx"
          },
          "5": {
            name: "storage.type.tsx"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#method-declaration-name"
          },
          {
            include: "#function-body"
          }
        ]
      },
      {
        name: "meta.method.declaration.tsx",
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:(?:\\s*\\b(new)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|(?:(\\*)\\s*)?)(?=\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
        beginCaptures: {
          "1": {
            name: "storage.modifier.tsx"
          },
          "2": {
            name: "storage.modifier.tsx"
          },
          "3": {
            name: "storage.modifier.tsx"
          },
          "4": {
            name: "storage.modifier.async.tsx"
          },
          "5": {
            name: "keyword.operator.new.tsx"
          },
          "6": {
            name: "keyword.generator.asterisk.tsx"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#method-declaration-name"
          },
          {
            include: "#function-body"
          }
        ]
      },
      {
        name: "meta.method.declaration.tsx",
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
        beginCaptures: {
          "1": {
            name: "storage.modifier.tsx"
          },
          "2": {
            name: "storage.modifier.tsx"
          },
          "3": {
            name: "storage.modifier.tsx"
          },
          "4": {
            name: "storage.modifier.async.tsx"
          },
          "5": {
            name: "storage.type.property.tsx"
          },
          "6": {
            name: "keyword.generator.asterisk.tsx"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#method-declaration-name"
          },
          {
            include: "#function-body"
          }
        ]
      }
    ]
  },
  "object-literal-method-declaration": {
    name: "meta.method.declaration.tsx",
    begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
    beginCaptures: {
      "1": {
        name: "storage.modifier.async.tsx"
      },
      "2": {
        name: "storage.type.property.tsx"
      },
      "3": {
        name: "keyword.generator.asterisk.tsx"
      }
    },
    end: "(?=\\}|;|,)|(?<=\\})",
    patterns: [
      {
        include: "#method-declaration-name"
      },
      {
        include: "#function-body"
      },
      {
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.tsx"
          },
          "2": {
            name: "storage.type.property.tsx"
          },
          "3": {
            name: "keyword.generator.asterisk.tsx"
          }
        },
        end: "(?=\\(|\\<)",
        patterns: [
          {
            include: "#method-declaration-name"
          }
        ]
      }
    ]
  },
  "method-declaration-name": {
    begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??)\\s*[\\(\\<])",
    end: "(?=\\(|\\<)",
    patterns: [
      {
        include: "#string"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#numeric-literal"
      },
      {
        name: "meta.definition.method.tsx entity.name.function.tsx",
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      },
      {
        name: "keyword.operator.optional.tsx",
        match: "\\?"
      }
    ]
  },
  "arrow-function": {
    patterns: [
      {
        name: "meta.arrow.tsx",
        match: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)\\s*(?==>)",
        captures: {
          "1": {
            name: "storage.modifier.async.tsx"
          },
          "2": {
            name: "variable.parameter.tsx"
          }
        }
      },
      {
        name: "meta.arrow.tsx",
        begin: "(?x) (?:\n  (?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\n)? ((?<![})!\\]])\\s*\n  (?=\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  )\n)",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.tsx"
          }
        },
        end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#type-parameters"
          },
          {
            include: "#function-parameters"
          },
          {
            include: "#arrow-return-type"
          },
          {
            include: "#possibly-arrow-return-type"
          }
        ]
      },
      {
        name: "meta.arrow.tsx",
        begin: "=>",
        beginCaptures: {
          "0": {
            name: "storage.type.function.arrow.tsx"
          }
        },
        end: "((?<=\\}|\\S)(?<!=>)|((?!\\{)(?=\\S)))(?!\\/[\\/\\*])",
        patterns: [
          {
            include: "#single-line-comment-consuming-line-ending"
          },
          {
            include: "#decl-block"
          },
          {
            include: "#expression"
          }
        ]
      }
    ]
  },
  "indexer-declaration": {
    name: "meta.indexer.declaration.tsx",
    begin: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=:)",
    beginCaptures: {
      "1": {
        name: "storage.modifier.tsx"
      },
      "2": {
        name: "meta.brace.square.tsx"
      },
      "3": {
        name: "variable.parameter.tsx"
      }
    },
    end: "(\\])\\s*(\\?\\s*)?|$",
    endCaptures: {
      "1": {
        name: "meta.brace.square.tsx"
      },
      "2": {
        name: "keyword.operator.optional.tsx"
      }
    },
    patterns: [
      {
        include: "#type-annotation"
      }
    ]
  },
  "indexer-mapped-type-declaration": {
    name: "meta.indexer.mappedtype.declaration.tsx",
    begin: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([+-])?(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s+(in)\\s+",
    beginCaptures: {
      "1": {
        name: "keyword.operator.type.modifier.tsx"
      },
      "2": {
        name: "storage.modifier.tsx"
      },
      "3": {
        name: "meta.brace.square.tsx"
      },
      "4": {
        name: "entity.name.type.tsx"
      },
      "5": {
        name: "keyword.operator.expression.in.tsx"
      }
    },
    end: "(\\])([+-])?\\s*(\\?\\s*)?|$",
    endCaptures: {
      "1": {
        name: "meta.brace.square.tsx"
      },
      "2": {
        name: "keyword.operator.type.modifier.tsx"
      },
      "3": {
        name: "keyword.operator.optional.tsx"
      }
    },
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+",
        captures: {
          "1": {
            name: "keyword.control.as.tsx"
          }
        }
      },
      {
        include: "#type"
      }
    ]
  },
  "function-parameters": {
    name: "meta.parameters.tsx",
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.parameters.begin.tsx"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "punctuation.definition.parameters.end.tsx"
      }
    },
    patterns: [
      {
        include: "#function-parameters-body"
      }
    ]
  },
  "function-parameters-body": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#decorator"
      },
      {
        include: "#destructuring-parameter"
      },
      {
        include: "#parameter-name"
      },
      {
        include: "#parameter-type-annotation"
      },
      {
        include: "#variable-initializer"
      },
      {
        name: "punctuation.separator.parameter.tsx",
        match: ","
      }
    ]
  },
  "class-declaration": {
    name: "meta.class.tsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(class)\\b(?=\\s+|/[/*])",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.tsx"
      },
      "2": {
        name: "storage.modifier.tsx"
      },
      "3": {
        name: "storage.modifier.tsx"
      },
      "4": {
        name: "storage.type.class.tsx"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#class-declaration-or-expression-patterns"
      }
    ]
  },
  "class-expression": {
    name: "meta.class.tsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(class)\\b(?=\\s+|[<{]|\\/[\\/*])",
    beginCaptures: {
      "1": {
        name: "storage.modifier.tsx"
      },
      "2": {
        name: "storage.type.class.tsx"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#class-declaration-or-expression-patterns"
      }
    ]
  },
  "class-declaration-or-expression-patterns": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#class-or-interface-heritage"
      },
      {
        match: "[_$[:alpha:]][_$[:alnum:]]*",
        captures: {
          "0": {
            name: "entity.name.type.class.tsx"
          }
        }
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#class-or-interface-body"
      }
    ]
  },
  "interface-declaration": {
    name: "meta.interface.tsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(interface)\\b(?=\\s+|/[/*])",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.tsx"
      },
      "2": {
        name: "storage.modifier.tsx"
      },
      "3": {
        name: "storage.modifier.tsx"
      },
      "4": {
        name: "storage.type.interface.tsx"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#class-or-interface-heritage"
      },
      {
        match: "[_$[:alpha:]][_$[:alnum:]]*",
        captures: {
          "0": {
            name: "entity.name.type.interface.tsx"
          }
        }
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#class-or-interface-body"
      }
    ]
  },
  "class-or-interface-heritage": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(extends|implements)\\b)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "storage.modifier.tsx"
      }
    },
    end: "(?=\\{)",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#class-or-interface-heritage"
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#expressionWithoutIdentifiers"
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s*\\??\\.\\s*[_$[:alpha:]][_$[:alnum:]]*)*\\s*)",
        captures: {
          "1": {
            name: "entity.name.type.module.tsx"
          },
          "2": {
            name: "punctuation.accessor.tsx"
          },
          "3": {
            name: "punctuation.accessor.optional.tsx"
          }
        }
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "entity.other.inherited-class.tsx"
          }
        }
      },
      {
        include: "#expressionPunctuations"
      }
    ]
  },
  "class-or-interface-body": {
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.tsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.tsx"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#decorator"
      },
      {
        begin: "(?<=:)\\s*",
        end: "(?=\\s|[;),}\\]:\\-\\+]|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        include: "#method-declaration"
      },
      {
        include: "#indexer-declaration"
      },
      {
        include: "#field-declaration"
      },
      {
        include: "#string"
      },
      {
        include: "#type-annotation"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#access-modifier"
      },
      {
        include: "#property-accessor"
      },
      {
        include: "#async-modifier"
      },
      {
        include: "#after-operator-block-as-object-literal"
      },
      {
        include: "#decl-block"
      },
      {
        include: "#expression"
      },
      {
        include: "#punctuation-comma"
      },
      {
        include: "#punctuation-semicolon"
      }
    ]
  },
  "access-modifier": {
    name: "storage.modifier.tsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(abstract|declare|override|public|protected|private|readonly|static)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "property-accessor": {
    name: "storage.type.property.tsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(get|set)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "async-modifier": {
    name: "storage.modifier.async.tsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(async)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "enum-declaration": {
    name: "meta.enum.declaration.tsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:\\b(const)\\s+)?\\b(enum)\\s+([_$[:alpha:]][_$[:alnum:]]*)",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.tsx"
      },
      "2": {
        name: "storage.modifier.tsx"
      },
      "3": {
        name: "storage.modifier.tsx"
      },
      "4": {
        name: "storage.type.enum.tsx"
      },
      "5": {
        name: "entity.name.type.enum.tsx"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "\\{",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.block.tsx"
          }
        },
        end: "\\}",
        endCaptures: {
          "0": {
            name: "punctuation.definition.block.tsx"
          }
        },
        patterns: [
          {
            include: "#comment"
          },
          {
            begin: "([_$[:alpha:]][_$[:alnum:]]*)",
            beginCaptures: {
              "0": {
                name: "variable.other.enummember.tsx"
              }
            },
            end: "(?=,|\\}|$)",
            patterns: [
              {
                include: "#comment"
              },
              {
                include: "#variable-initializer"
              }
            ]
          },
          {
            begin: "(?=((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\])))",
            end: "(?=,|\\}|$)",
            patterns: [
              {
                include: "#string"
              },
              {
                include: "#array-literal"
              },
              {
                include: "#comment"
              },
              {
                include: "#variable-initializer"
              }
            ]
          },
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  },
  "namespace-declaration": {
    name: "meta.namespace.declaration.tsx",
    begin: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(namespace|module)\\s+(?=[_$[:alpha:]\"'`]))",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.tsx"
      },
      "2": {
        name: "storage.modifier.tsx"
      },
      "3": {
        name: "storage.type.namespace.tsx"
      }
    },
    end: "(?<=\\})|(?=;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        name: "entity.name.type.module.tsx",
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      },
      {
        include: "#punctuation-accessor"
      },
      {
        include: "#decl-block"
      }
    ]
  },
  "type-alias-declaration": {
    name: "meta.type.declaration.tsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(type)\\b\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.tsx"
      },
      "2": {
        name: "storage.modifier.tsx"
      },
      "3": {
        name: "storage.type.type.tsx"
      },
      "4": {
        name: "entity.name.type.alias.tsx"
      }
    },
    end: "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#type-parameters"
      },
      {
        begin: "(=)\\s*(intrinsic)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.tsx"
          },
          "2": {
            name: "keyword.control.intrinsic.tsx"
          }
        },
        end: "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        begin: "(=)\\s*",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.tsx"
          }
        },
        end: "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "import-equals-declaration": {
    patterns: [
      {
        name: "meta.import-equals.external.tsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(require)\\s*(\\()",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.tsx"
          },
          "2": {
            name: "storage.modifier.tsx"
          },
          "3": {
            name: "keyword.control.import.tsx"
          },
          "4": {
            name: "keyword.control.type.tsx"
          },
          "5": {
            name: "variable.other.readwrite.alias.tsx"
          },
          "6": {
            name: "keyword.operator.assignment.tsx"
          },
          "7": {
            name: "keyword.control.require.tsx"
          },
          "8": {
            name: "meta.brace.round.tsx"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.tsx"
          }
        },
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#string"
          }
        ]
      },
      {
        name: "meta.import-equals.internal.tsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(?!require\\b)",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.tsx"
          },
          "2": {
            name: "storage.modifier.tsx"
          },
          "3": {
            name: "keyword.control.import.tsx"
          },
          "4": {
            name: "keyword.control.type.tsx"
          },
          "5": {
            name: "variable.other.readwrite.alias.tsx"
          },
          "6": {
            name: "keyword.operator.assignment.tsx"
          }
        },
        end: "(?=;|$|^)",
        patterns: [
          {
            include: "#single-line-comment-consuming-line-ending"
          },
          {
            include: "#comment"
          },
          {
            match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))",
            captures: {
              "1": {
                name: "entity.name.type.module.tsx"
              },
              "2": {
                name: "punctuation.accessor.tsx"
              },
              "3": {
                name: "punctuation.accessor.optional.tsx"
              }
            }
          },
          {
            name: "variable.other.readwrite.tsx",
            match: "([_$[:alpha:]][_$[:alnum:]]*)"
          }
        ]
      }
    ]
  },
  "import-declaration": {
    name: "meta.import.tsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type)(?!\\s+from))?(?!\\s*[:\\(])(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.tsx"
      },
      "2": {
        name: "storage.modifier.tsx"
      },
      "3": {
        name: "keyword.control.import.tsx"
      },
      "4": {
        name: "keyword.control.type.tsx"
      }
    },
    end: "(?<!^import|[^\\._$[:alnum:]]import)(?=;|$|^)",
    patterns: [
      {
        include: "#single-line-comment-consuming-line-ending"
      },
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        begin: `(?<=^import|[^\\._$[:alnum:]]import)(?!\\s*["'])`,
        end: "\\bfrom\\b",
        endCaptures: {
          "0": {
            name: "keyword.control.from.tsx"
          }
        },
        patterns: [
          {
            include: "#import-export-declaration"
          }
        ]
      },
      {
        include: "#import-export-declaration"
      }
    ]
  },
  "export-declaration": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)\\s+(as)\\s+(namespace)\\s+([_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "keyword.control.export.tsx"
          },
          "2": {
            name: "keyword.control.as.tsx"
          },
          "3": {
            name: "storage.type.namespace.tsx"
          },
          "4": {
            name: "entity.name.type.module.tsx"
          }
        }
      },
      {
        name: "meta.export.default.tsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?(?:(?:\\s*(=))|(?:\\s+(default)(?=\\s+)))",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.tsx"
          },
          "2": {
            name: "keyword.control.type.tsx"
          },
          "3": {
            name: "keyword.operator.assignment.tsx"
          },
          "4": {
            name: "keyword.control.default.tsx"
          }
        },
        end: "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#interface-declaration"
          },
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "meta.export.tsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?\\b(?!(\\$)|(\\s*:))((?=\\s*[\\{*])|((?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s|,))(?!\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b)))",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.tsx"
          },
          "2": {
            name: "keyword.control.type.tsx"
          }
        },
        end: "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#import-export-declaration"
          }
        ]
      }
    ]
  },
  "import-export-declaration": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#import-export-block"
      },
      {
        name: "keyword.control.from.tsx",
        match: "\\bfrom\\b"
      },
      {
        include: "#import-export-clause"
      }
    ]
  },
  "import-export-block": {
    name: "meta.block.tsx",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.tsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.tsx"
      }
    },
    patterns: [
      {
        include: "#import-export-clause"
      }
    ]
  },
  "import-export-clause": {
    patterns: [
      {
        include: "#comment"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bdefault)|(\\*)|(\\b[_$[:alpha:]][_$[:alnum:]]*))\\s+(as)\\s+(?:(default(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|([_$[:alpha:]][_$[:alnum:]]*))",
        captures: {
          "1": {
            name: "keyword.control.default.tsx"
          },
          "2": {
            name: "constant.language.import-export-all.tsx"
          },
          "3": {
            name: "variable.other.readwrite.tsx"
          },
          "4": {
            name: "keyword.control.as.tsx"
          },
          "5": {
            name: "keyword.control.default.tsx"
          },
          "6": {
            name: "variable.other.readwrite.alias.tsx"
          }
        }
      },
      {
        include: "#punctuation-comma"
      },
      {
        name: "constant.language.import-export-all.tsx",
        match: "\\*"
      },
      {
        name: "keyword.control.default.tsx",
        match: "\\b(default)\\b"
      },
      {
        name: "variable.other.readwrite.alias.tsx",
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  },
  "switch-statement": {
    name: "switch-statement.expr.tsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bswitch\\s*\\()",
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.tsx"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        name: "switch-expression.expr.tsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(switch)\\s*(\\()",
        beginCaptures: {
          "1": {
            name: "keyword.control.switch.tsx"
          },
          "2": {
            name: "meta.brace.round.tsx"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.tsx"
          }
        },
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "switch-block.expr.tsx",
        begin: "\\{",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.block.tsx"
          }
        },
        end: "(?=\\})",
        patterns: [
          {
            name: "case-clause.expr.tsx",
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default(?=:))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
            beginCaptures: {
              "1": {
                name: "keyword.control.switch.tsx"
              }
            },
            end: "(?=:)",
            patterns: [
              {
                include: "#expression"
              }
            ]
          },
          {
            begin: "(:)\\s*(\\{)",
            beginCaptures: {
              "1": {
                name: "case-clause.expr.tsx punctuation.definition.section.case-statement.tsx"
              },
              "2": {
                name: "meta.block.tsx punctuation.definition.block.tsx"
              }
            },
            end: "\\}",
            endCaptures: {
              "0": {
                name: "meta.block.tsx punctuation.definition.block.tsx"
              }
            },
            contentName: "meta.block.tsx",
            patterns: [
              {
                include: "#statements"
              }
            ]
          },
          {
            match: "(:)",
            captures: {
              "0": {
                name: "case-clause.expr.tsx punctuation.definition.section.case-statement.tsx"
              }
            }
          },
          {
            include: "#statements"
          }
        ]
      }
    ]
  },
  "for-loop": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))for(?=((\\s+|(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*))await)?\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)?(\\())",
    beginCaptures: {
      "0": {
        name: "keyword.control.loop.tsx"
      }
    },
    end: "(?<=\\))",
    patterns: [
      {
        include: "#comment"
      },
      {
        name: "keyword.control.loop.tsx",
        match: "await"
      },
      {
        begin: "\\(",
        beginCaptures: {
          "0": {
            name: "meta.brace.round.tsx"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.tsx"
          }
        },
        patterns: [
          {
            include: "#var-expr"
          },
          {
            include: "#expression"
          },
          {
            include: "#punctuation-semicolon"
          }
        ]
      }
    ]
  },
  "if-statement": {
    patterns: [
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bif\\s*(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))\\s*(?!\\{))",
        end: "(?=;|$|\\})",
        patterns: [
          {
            include: "#comment"
          },
          {
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(if)\\s*(\\()",
            beginCaptures: {
              "1": {
                name: "keyword.control.conditional.tsx"
              },
              "2": {
                name: "meta.brace.round.tsx"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "meta.brace.round.tsx"
              }
            },
            patterns: [
              {
                include: "#expression"
              }
            ]
          },
          {
            name: "string.regexp.tsx",
            begin: "(?<=\\))\\s*\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))",
            beginCaptures: {
              "0": {
                name: "punctuation.definition.string.begin.tsx"
              }
            },
            end: "(/)([dgimsuy]*)",
            endCaptures: {
              "1": {
                name: "punctuation.definition.string.end.tsx"
              },
              "2": {
                name: "keyword.other.tsx"
              }
            },
            patterns: [
              {
                include: "#regexp"
              }
            ]
          },
          {
            include: "#statements"
          }
        ]
      }
    ]
  },
  "decl-block": {
    name: "meta.block.tsx",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.tsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.tsx"
      }
    },
    patterns: [
      {
        include: "#statements"
      }
    ]
  },
  "after-operator-block-as-object-literal": {
    name: "meta.objectliteral.tsx",
    begin: "(?<!\\+\\+|--)(?<=[:=(,\\[?+!>]|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^yield|[^\\._$[:alnum:]]yield|^throw|[^\\._$[:alnum:]]throw|^in|[^\\._$[:alnum:]]in|^of|[^\\._$[:alnum:]]of|^typeof|[^\\._$[:alnum:]]typeof|&&|\\|\\||\\*)\\s*(\\{)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.block.tsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.tsx"
      }
    },
    patterns: [
      {
        include: "#object-member"
      }
    ]
  },
  "object-literal": {
    name: "meta.objectliteral.tsx",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.tsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.tsx"
      }
    },
    patterns: [
      {
        include: "#object-member"
      }
    ]
  },
  "object-member": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#object-literal-method-declaration"
      },
      {
        name: "meta.object.member.tsx meta.object-literal.key.tsx",
        begin: "(?=\\[)",
        end: "(?=:)|((?<=[\\]])(?=\\s*[\\(\\<]))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#array-literal"
          }
        ]
      },
      {
        name: "meta.object.member.tsx meta.object-literal.key.tsx",
        begin: "(?=[\\'\\\"\\`])",
        end: "(?=:)|((?<=[\\'\\\"\\`])(?=((\\s*[\\(\\<,}])|(\\s+(as)\\s+))))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#string"
          }
        ]
      },
      {
        name: "meta.object.member.tsx meta.object-literal.key.tsx",
        begin: "(?x)(?=(\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)))",
        end: "(?=:)|(?=\\s*([\\(\\<,}])|(\\s+as\\s+))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#numeric-literal"
          }
        ]
      },
      {
        name: "meta.method.declaration.tsx",
        begin: "(?<=[\\]\\'\\\"\\`])(?=\\s*[\\(\\<])",
        end: "(?=\\}|;|,)|(?<=\\})",
        patterns: [
          {
            include: "#function-body"
          }
        ]
      },
      {
        name: "meta.object.member.tsx",
        match: "(?![_$[:alpha:]])([[:digit:]]+)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)",
        captures: {
          "0": {
            name: "meta.object-literal.key.tsx"
          },
          "1": {
            name: "constant.numeric.decimal.tsx"
          }
        }
      },
      {
        name: "meta.object.member.tsx",
        match: "(?x)(?:([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/)*\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "0": {
            name: "meta.object-literal.key.tsx"
          },
          "1": {
            name: "entity.name.function.tsx"
          }
        }
      },
      {
        name: "meta.object.member.tsx",
        match: "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)",
        captures: {
          "0": {
            name: "meta.object-literal.key.tsx"
          }
        }
      },
      {
        name: "meta.object.member.tsx",
        begin: "\\.\\.\\.",
        beginCaptures: {
          "0": {
            name: "keyword.operator.spread.tsx"
          }
        },
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "meta.object.member.tsx",
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=,|\\}|$|\\/\\/|\\/\\*)",
        captures: {
          "1": {
            name: "variable.other.readwrite.tsx"
          }
        }
      },
      {
        name: "meta.object.member.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*([,}]|$))",
        captures: {
          "1": {
            name: "keyword.control.as.tsx"
          },
          "2": {
            name: "storage.modifier.tsx"
          }
        }
      },
      {
        name: "meta.object.member.tsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+",
        beginCaptures: {
          "1": {
            name: "keyword.control.as.tsx"
          }
        },
        end: "(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|^|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "meta.object.member.tsx",
        begin: "(?=[_$[:alpha:]][_$[:alnum:]]*\\s*=)",
        end: "(?=,|\\}|$|\\/\\/|\\/\\*)",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "meta.object.member.tsx",
        begin: ":",
        beginCaptures: {
          "0": {
            name: "meta.object-literal.key.tsx punctuation.separator.key-value.tsx"
          }
        },
        end: "(?=,|\\})",
        patterns: [
          {
            begin: "(?<=:)\\s*(async)?(?=\\s*(<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
            beginCaptures: {
              "1": {
                name: "storage.modifier.async.tsx"
              }
            },
            end: "(?<=\\))",
            patterns: [
              {
                include: "#type-parameters"
              },
              {
                begin: "\\(",
                beginCaptures: {
                  "0": {
                    name: "meta.brace.round.tsx"
                  }
                },
                end: "\\)",
                endCaptures: {
                  "0": {
                    name: "meta.brace.round.tsx"
                  }
                },
                patterns: [
                  {
                    include: "#expression-inside-possibly-arrow-parens"
                  }
                ]
              }
            ]
          },
          {
            begin: "(?<=:)\\s*(async)?\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
            beginCaptures: {
              "1": {
                name: "storage.modifier.async.tsx"
              },
              "2": {
                name: "meta.brace.round.tsx"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "meta.brace.round.tsx"
              }
            },
            patterns: [
              {
                include: "#expression-inside-possibly-arrow-parens"
              }
            ]
          },
          {
            begin: "(?<=:)\\s*(async)?\\s*(?=\\<\\s*$)",
            beginCaptures: {
              "1": {
                name: "storage.modifier.async.tsx"
              }
            },
            end: "(?<=\\>)",
            patterns: [
              {
                include: "#type-parameters"
              }
            ]
          },
          {
            begin: "(?<=\\>)\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
            beginCaptures: {
              "1": {
                name: "meta.brace.round.tsx"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "meta.brace.round.tsx"
              }
            },
            patterns: [
              {
                include: "#expression-inside-possibly-arrow-parens"
              }
            ]
          },
          {
            include: "#possibly-arrow-return-type"
          },
          {
            include: "#expression"
          }
        ]
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "ternary-expression": {
    begin: "(?!\\?\\.\\s*[^[:digit:]])(\\?)(?!\\?)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.ternary.tsx"
      }
    },
    end: "\\s*(:)",
    endCaptures: {
      "1": {
        name: "keyword.operator.ternary.tsx"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "function-call": {
    patterns: [
      {
        begin: "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())",
        end: "(?<=\\))(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())",
        patterns: [
          {
            name: "meta.function-call.tsx",
            begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))",
            end: "(?=\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())",
            patterns: [
              {
                include: "#function-call-target"
              }
            ]
          },
          {
            include: "#comment"
          },
          {
            include: "#function-call-optionals"
          },
          {
            include: "#type-arguments"
          },
          {
            include: "#paren-expression"
          }
        ]
      },
      {
        begin: "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))",
        end: "(?<=\\>)(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))",
        patterns: [
          {
            name: "meta.function-call.tsx",
            begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))",
            end: "(?=(<\\s*[\\{\\[\\(]\\s*$))",
            patterns: [
              {
                include: "#function-call-target"
              }
            ]
          },
          {
            include: "#comment"
          },
          {
            include: "#function-call-optionals"
          },
          {
            include: "#type-arguments"
          }
        ]
      }
    ]
  },
  "function-call-target": {
    patterns: [
      {
        include: "#support-function-call-identifiers"
      },
      {
        name: "entity.name.function.tsx",
        match: "(\\#?[_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  },
  "function-call-optionals": {
    patterns: [
      {
        name: "meta.function-call.tsx punctuation.accessor.optional.tsx",
        match: "\\?\\."
      },
      {
        name: "meta.function-call.tsx keyword.operator.definiteassignment.tsx",
        match: "\\!"
      }
    ]
  },
  "support-function-call-identifiers": {
    patterns: [
      {
        include: "#literal"
      },
      {
        include: "#support-objects"
      },
      {
        include: "#object-identifiers"
      },
      {
        include: "#punctuation-accessor"
      },
      {
        name: "keyword.operator.expression.import.tsx",
        match: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*[\\(]\\s*[\\\"\\'\\`]))"
      }
    ]
  },
  "new-expr": {
    name: "new.expr.tsx",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "keyword.operator.new.tsx"
      }
    },
    end: "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))",
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "instanceof-expr": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(instanceof)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "keyword.operator.expression.instanceof.tsx"
      }
    },
    end: "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|(([\\&\\~\\^\\|]\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s+instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))",
    patterns: [
      {
        include: "#type"
      }
    ]
  },
  "paren-expression-possibly-arrow": {
    patterns: [
      {
        begin: "(?<=[(=,])\\s*(async)?(?=\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.tsx"
          }
        },
        end: "(?<=\\))",
        patterns: [
          {
            include: "#paren-expression-possibly-arrow-with-typeparameters"
          }
        ]
      },
      {
        begin: "(?<=[(=,]|=>|^return|[^\\._$[:alnum:]]return)\\s*(async)?(?=\\s*((((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\()|(<))\\s*$)",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.tsx"
          }
        },
        end: "(?<=\\))",
        patterns: [
          {
            include: "#paren-expression-possibly-arrow-with-typeparameters"
          }
        ]
      },
      {
        include: "#possibly-arrow-return-type"
      }
    ]
  },
  "paren-expression-possibly-arrow-with-typeparameters": {
    patterns: [
      {
        include: "#type-parameters"
      },
      {
        begin: "\\(",
        beginCaptures: {
          "0": {
            name: "meta.brace.round.tsx"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.tsx"
          }
        },
        patterns: [
          {
            include: "#expression-inside-possibly-arrow-parens"
          }
        ]
      }
    ]
  },
  "expression-inside-possibly-arrow-parens": {
    patterns: [
      {
        include: "#expressionWithoutIdentifiers"
      },
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#decorator"
      },
      {
        include: "#destructuring-parameter"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)",
        captures: {
          "1": {
            name: "storage.modifier.tsx"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "1": {
            name: "storage.modifier.tsx"
          },
          "2": {
            name: "keyword.operator.rest.tsx"
          },
          "3": {
            name: "entity.name.function.tsx variable.language.this.tsx"
          },
          "4": {
            name: "entity.name.function.tsx"
          },
          "5": {
            name: "keyword.operator.optional.tsx"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*[:,]|$)",
        captures: {
          "1": {
            name: "storage.modifier.tsx"
          },
          "2": {
            name: "keyword.operator.rest.tsx"
          },
          "3": {
            name: "variable.parameter.tsx variable.language.this.tsx"
          },
          "4": {
            name: "variable.parameter.tsx"
          },
          "5": {
            name: "keyword.operator.optional.tsx"
          }
        }
      },
      {
        include: "#type-annotation"
      },
      {
        include: "#variable-initializer"
      },
      {
        name: "punctuation.separator.parameter.tsx",
        match: ","
      },
      {
        include: "#identifiers"
      },
      {
        include: "#expressionPunctuations"
      }
    ]
  },
  "paren-expression": {
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "meta.brace.round.tsx"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "meta.brace.round.tsx"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  cast: {
    patterns: [
      {
        include: "#jsx"
      }
    ]
  },
  "expression-operators": {
    patterns: [
      {
        name: "keyword.control.flow.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(await)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?=\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*\\*)",
        beginCaptures: {
          "1": {
            name: "keyword.control.flow.tsx"
          }
        },
        end: "\\*",
        endCaptures: {
          "0": {
            name: "keyword.generator.asterisk.tsx"
          }
        },
        patterns: [
          {
            include: "#comment"
          }
        ]
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?:\\s*(\\*))?",
        captures: {
          "1": {
            name: "keyword.control.flow.tsx"
          },
          "2": {
            name: "keyword.generator.asterisk.tsx"
          }
        }
      },
      {
        name: "keyword.operator.expression.delete.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))delete(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.expression.in.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))in(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()"
      },
      {
        name: "keyword.operator.expression.of.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))of(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()"
      },
      {
        name: "keyword.operator.expression.instanceof.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.new.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        include: "#typeof-operator"
      },
      {
        name: "keyword.operator.expression.void.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))void(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*($|[;,:})\\]]))",
        captures: {
          "1": {
            name: "keyword.control.as.tsx"
          },
          "2": {
            name: "storage.modifier.tsx"
          }
        }
      },
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+",
        beginCaptures: {
          "1": {
            name: "keyword.control.as.tsx"
          }
        },
        end: "(?=^|[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+)|(\\s+\\<))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "keyword.operator.spread.tsx",
        match: "\\.\\.\\."
      },
      {
        name: "keyword.operator.assignment.compound.tsx",
        match: "\\*=|(?<!\\()/=|%=|\\+=|\\-="
      },
      {
        name: "keyword.operator.assignment.compound.bitwise.tsx",
        match: "\\&=|\\^=|<<=|>>=|>>>=|\\|="
      },
      {
        name: "keyword.operator.bitwise.shift.tsx",
        match: "<<|>>>|>>"
      },
      {
        name: "keyword.operator.comparison.tsx",
        match: "===|!==|==|!="
      },
      {
        name: "keyword.operator.relational.tsx",
        match: "<=|>=|<>|<|>"
      },
      {
        match: "(?<=[_$[:alnum:]])(\\!)\\s*(?:(/=)|(?:(/)(?![/*])))",
        captures: {
          "1": {
            name: "keyword.operator.logical.tsx"
          },
          "2": {
            name: "keyword.operator.assignment.compound.tsx"
          },
          "3": {
            name: "keyword.operator.arithmetic.tsx"
          }
        }
      },
      {
        name: "keyword.operator.logical.tsx",
        match: "\\!|&&|\\|\\||\\?\\?"
      },
      {
        name: "keyword.operator.bitwise.tsx",
        match: "\\&|~|\\^|\\|"
      },
      {
        name: "keyword.operator.assignment.tsx",
        match: "\\="
      },
      {
        name: "keyword.operator.decrement.tsx",
        match: "--"
      },
      {
        name: "keyword.operator.increment.tsx",
        match: "\\+\\+"
      },
      {
        name: "keyword.operator.arithmetic.tsx",
        match: "%|\\*|/|-|\\+"
      },
      {
        begin: "(?<=[_$[:alnum:])\\]])\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)+(?:(/=)|(?:(/)(?![/*]))))",
        end: "(?:(/=)|(?:(/)(?!\\*([^\\*]|(\\*[^\\/]))*\\*\\/)))",
        endCaptures: {
          "1": {
            name: "keyword.operator.assignment.compound.tsx"
          },
          "2": {
            name: "keyword.operator.arithmetic.tsx"
          }
        },
        patterns: [
          {
            include: "#comment"
          }
        ]
      },
      {
        match: "(?<=[_$[:alnum:])\\]])\\s*(?:(/=)|(?:(/)(?![/*])))",
        captures: {
          "1": {
            name: "keyword.operator.assignment.compound.tsx"
          },
          "2": {
            name: "keyword.operator.arithmetic.tsx"
          }
        }
      }
    ]
  },
  "typeof-operator": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))typeof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "0": {
        name: "keyword.operator.expression.typeof.tsx"
      }
    },
    end: "(?=[,);}\\]=>:&|{\\?]|$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  literal: {
    patterns: [
      {
        include: "#numeric-literal"
      },
      {
        include: "#boolean-literal"
      },
      {
        include: "#null-literal"
      },
      {
        include: "#undefined-literal"
      },
      {
        include: "#numericConstant-literal"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#this-literal"
      },
      {
        include: "#super-literal"
      }
    ]
  },
  "array-literal": {
    name: "meta.array.literal.tsx",
    begin: "\\s*(\\[)",
    beginCaptures: {
      "1": {
        name: "meta.brace.square.tsx"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "meta.brace.square.tsx"
      }
    },
    patterns: [
      {
        include: "#expression"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "numeric-literal": {
    patterns: [
      {
        name: "constant.numeric.hex.tsx",
        match: "\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$)",
        captures: {
          "1": {
            name: "storage.type.numeric.bigint.tsx"
          }
        }
      },
      {
        name: "constant.numeric.binary.tsx",
        match: "\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$)",
        captures: {
          "1": {
            name: "storage.type.numeric.bigint.tsx"
          }
        }
      },
      {
        name: "constant.numeric.octal.tsx",
        match: "\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$)",
        captures: {
          "1": {
            name: "storage.type.numeric.bigint.tsx"
          }
        }
      },
      {
        match: "(?x)\n(?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)",
        captures: {
          "0": {
            name: "constant.numeric.decimal.tsx"
          },
          "1": {
            name: "meta.delimiter.decimal.period.tsx"
          },
          "2": {
            name: "storage.type.numeric.bigint.tsx"
          },
          "3": {
            name: "meta.delimiter.decimal.period.tsx"
          },
          "4": {
            name: "storage.type.numeric.bigint.tsx"
          },
          "5": {
            name: "meta.delimiter.decimal.period.tsx"
          },
          "6": {
            name: "storage.type.numeric.bigint.tsx"
          },
          "7": {
            name: "storage.type.numeric.bigint.tsx"
          },
          "8": {
            name: "meta.delimiter.decimal.period.tsx"
          },
          "9": {
            name: "storage.type.numeric.bigint.tsx"
          },
          "10": {
            name: "meta.delimiter.decimal.period.tsx"
          },
          "11": {
            name: "storage.type.numeric.bigint.tsx"
          },
          "12": {
            name: "meta.delimiter.decimal.period.tsx"
          },
          "13": {
            name: "storage.type.numeric.bigint.tsx"
          },
          "14": {
            name: "storage.type.numeric.bigint.tsx"
          }
        }
      }
    ]
  },
  "boolean-literal": {
    patterns: [
      {
        name: "constant.language.boolean.true.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))true(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "constant.language.boolean.false.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))false(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "null-literal": {
    name: "constant.language.null.tsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))null(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "this-literal": {
    name: "variable.language.this.tsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))this\\b(?!\\$)"
  },
  "super-literal": {
    name: "variable.language.super.tsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))super\\b(?!\\$)"
  },
  "undefined-literal": {
    name: "constant.language.undefined.tsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))undefined(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "numericConstant-literal": {
    patterns: [
      {
        name: "constant.language.nan.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))NaN(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "constant.language.infinity.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Infinity(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "support-objects": {
    patterns: [
      {
        name: "variable.language.arguments.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(arguments)\\b(?!\\$)"
      },
      {
        name: "support.class.builtin.tsx",
        match: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Array|ArrayBuffer|Atomics|BigInt|BigInt64Array|BigUint64Array|Boolean|DataView|Date|Float32Array\n  |Float64Array|Function|Generator|GeneratorFunction|Int8Array|Int16Array|Int32Array|Intl|Map|Number|Object|Proxy\n  |Reflect|RegExp|Set|SharedArrayBuffer|SIMD|String|Symbol|TypedArray\n  |Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|WeakMap|WeakSet)\\b(?!\\$)"
      },
      {
        name: "support.class.error.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))((Eval|Internal|Range|Reference|Syntax|Type|URI)?Error)\\b(?!\\$)"
      },
      {
        name: "support.class.promise.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Promise)\\b(?!\\$)"
      },
      {
        name: "support.function.tsx",
        match: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(clear(Interval|Timeout)|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|\n  isFinite|isNaN|parseFloat|parseInt|require|set(Interval|Timeout)|super|unescape|uneval)(?=\\s*\\()"
      },
      {
        match: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Math)(?:\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(?:\n  (abs|acos|acosh|asin|asinh|atan|atan2|atanh|cbrt|ceil|clz32|cos|cosh|exp|\n  expm1|floor|fround|hypot|imul|log|log10|log1p|log2|max|min|pow|random|\n  round|sign|sin|sinh|sqrt|tan|tanh|trunc)\n  |\n  (E|LN10|LN2|LOG10E|LOG2E|PI|SQRT1_2|SQRT2)))?\\b(?!\\$)",
        captures: {
          "1": {
            name: "support.constant.math.tsx"
          },
          "2": {
            name: "punctuation.accessor.tsx"
          },
          "3": {
            name: "punctuation.accessor.optional.tsx"
          },
          "4": {
            name: "support.function.math.tsx"
          },
          "5": {
            name: "support.constant.property.math.tsx"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(JSON)(?:\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(parse|stringify))?\\b(?!\\$)",
        captures: {
          "1": {
            name: "support.constant.json.tsx"
          },
          "2": {
            name: "punctuation.accessor.tsx"
          },
          "3": {
            name: "punctuation.accessor.optional.tsx"
          },
          "4": {
            name: "support.function.json.tsx"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(import)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(meta)\\b(?!\\$)",
        captures: {
          "1": {
            name: "keyword.control.import.tsx"
          },
          "2": {
            name: "punctuation.accessor.tsx"
          },
          "3": {
            name: "punctuation.accessor.optional.tsx"
          },
          "4": {
            name: "support.variable.property.importmeta.tsx"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(target)\\b(?!\\$)",
        captures: {
          "1": {
            name: "keyword.operator.new.tsx"
          },
          "2": {
            name: "punctuation.accessor.tsx"
          },
          "3": {
            name: "punctuation.accessor.optional.tsx"
          },
          "4": {
            name: "support.variable.property.target.tsx"
          }
        }
      },
      {
        match: "(?x) (?:(\\.)|(\\?\\.(?!\\s*[[:digit:]]))) \\s* (?:\n  (?:(constructor|length|prototype|__proto__)\\b(?!\\$|\\s*(<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\\())\n  |\n  (?:(EPSILON|MAX_SAFE_INTEGER|MAX_VALUE|MIN_SAFE_INTEGER|MIN_VALUE|NEGATIVE_INFINITY|POSITIVE_INFINITY)\\b(?!\\$)))",
        captures: {
          "1": {
            name: "punctuation.accessor.tsx"
          },
          "2": {
            name: "punctuation.accessor.optional.tsx"
          },
          "3": {
            name: "support.variable.property.tsx"
          },
          "4": {
            name: "support.constant.tsx"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(exports)|(module)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(exports|id|filename|loaded|parent|children))?)\\b(?!\\$)",
        captures: {
          "1": {
            name: "support.type.object.module.tsx"
          },
          "2": {
            name: "support.type.object.module.tsx"
          },
          "3": {
            name: "punctuation.accessor.tsx"
          },
          "4": {
            name: "punctuation.accessor.optional.tsx"
          },
          "5": {
            name: "support.type.object.module.tsx"
          }
        }
      }
    ]
  },
  identifiers: {
    patterns: [
      {
        include: "#object-identifiers"
      },
      {
        match: "(?x)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*)?([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n(\n  [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                                              # < typeparam extends\n) |\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n))",
        captures: {
          "1": {
            name: "punctuation.accessor.tsx"
          },
          "2": {
            name: "punctuation.accessor.optional.tsx"
          },
          "3": {
            name: "entity.name.function.tsx"
          }
        }
      },
      {
        match: "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])",
        captures: {
          "1": {
            name: "punctuation.accessor.tsx"
          },
          "2": {
            name: "punctuation.accessor.optional.tsx"
          },
          "3": {
            name: "variable.other.constant.property.tsx"
          }
        }
      },
      {
        match: "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "punctuation.accessor.tsx"
          },
          "2": {
            name: "punctuation.accessor.optional.tsx"
          },
          "3": {
            name: "variable.other.property.tsx"
          }
        }
      },
      {
        name: "variable.other.constant.tsx",
        match: "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])"
      },
      {
        name: "variable.other.readwrite.tsx",
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      }
    ]
  },
  "object-identifiers": {
    patterns: [
      {
        name: "support.class.tsx",
        match: "([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\\??\\.\\s*prototype\\b(?!\\$))"
      },
      {
        match: "(?x)(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(?:\n  (\\#?[[:upper:]][_$[:digit:][:upper:]]*) |\n  (\\#?[_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "punctuation.accessor.tsx"
          },
          "2": {
            name: "punctuation.accessor.optional.tsx"
          },
          "3": {
            name: "variable.other.constant.object.property.tsx"
          },
          "4": {
            name: "variable.other.object.property.tsx"
          }
        }
      },
      {
        match: "(?x)(?:\n  ([[:upper:]][_$[:digit:][:upper:]]*) |\n  ([_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "variable.other.constant.object.tsx"
          },
          "2": {
            name: "variable.other.object.tsx"
          }
        }
      }
    ]
  },
  "type-annotation": {
    patterns: [
      {
        name: "meta.type.annotation.tsx",
        begin: "(:)(?=\\s*\\S)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.tsx"
          }
        },
        end: "(?<![:|&])((?=$|^|[,);\\}\\]]|//)|(?==[^>])|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "meta.type.annotation.tsx",
        begin: "(:)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.tsx"
          }
        },
        end: "(?<![:|&])((?=[,);\\}\\]]|//)|(?==[^>])|(?=^\\s*$)|((?<=\\S)(?=\\s*$))|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))",
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "parameter-type-annotation": {
    patterns: [
      {
        name: "meta.type.annotation.tsx",
        begin: "(:)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.tsx"
          }
        },
        end: "(?=[,)])|(?==[^>])",
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "return-type": {
    patterns: [
      {
        name: "meta.return.type.tsx",
        begin: "(?<=\\))\\s*(:)(?=\\s*\\S)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.tsx"
          }
        },
        end: "(?<![:|&])(?=$|^|[{};,]|//)",
        patterns: [
          {
            include: "#return-type-core"
          }
        ]
      },
      {
        name: "meta.return.type.tsx",
        begin: "(?<=\\))\\s*(:)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.tsx"
          }
        },
        end: "(?<![:|&])((?=[{};,]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))",
        patterns: [
          {
            include: "#return-type-core"
          }
        ]
      }
    ]
  },
  "return-type-core": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?<=[:|&])(?=\\s*\\{)",
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        include: "#type-predicate-operator"
      },
      {
        include: "#type"
      }
    ]
  },
  "arrow-return-type": {
    name: "meta.return.type.arrow.tsx",
    begin: "(?<=\\))\\s*(:)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.type.annotation.tsx"
      }
    },
    end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))",
    patterns: [
      {
        include: "#arrow-return-type-body"
      }
    ]
  },
  "possibly-arrow-return-type": {
    begin: "(?<=\\)|^)\\s*(:)(?=\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*=>)",
    beginCaptures: {
      "1": {
        name: "meta.arrow.tsx meta.return.type.arrow.tsx keyword.operator.type.annotation.tsx"
      }
    },
    end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))",
    contentName: "meta.arrow.tsx meta.return.type.arrow.tsx",
    patterns: [
      {
        include: "#arrow-return-type-body"
      }
    ]
  },
  "arrow-return-type-body": {
    patterns: [
      {
        begin: "(?<=[:])(?=\\s*\\{)",
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        include: "#type-predicate-operator"
      },
      {
        include: "#type"
      }
    ]
  },
  "type-parameters": {
    name: "meta.type.parameters.tsx",
    begin: "(<)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.typeparameters.begin.tsx"
      }
    },
    end: "(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.typeparameters.end.tsx"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        name: "storage.modifier.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        include: "#type"
      },
      {
        include: "#punctuation-comma"
      },
      {
        name: "keyword.operator.assignment.tsx",
        match: "(=)(?!>)"
      }
    ]
  },
  "type-arguments": {
    name: "meta.type.parameters.tsx",
    begin: "\\<",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.typeparameters.begin.tsx"
      }
    },
    end: "\\>",
    endCaptures: {
      "0": {
        name: "punctuation.definition.typeparameters.end.tsx"
      }
    },
    patterns: [
      {
        include: "#type-arguments-body"
      }
    ]
  },
  "type-arguments-body": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(_)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "0": {
            name: "keyword.operator.type.tsx"
          }
        }
      },
      {
        include: "#type"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  type: {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#type-string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#type-primitive"
      },
      {
        include: "#type-builtin-literals"
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#type-tuple"
      },
      {
        include: "#type-object"
      },
      {
        include: "#type-conditional"
      },
      {
        include: "#type-operators"
      },
      {
        include: "#type-fn-type-parameters"
      },
      {
        include: "#type-paren-or-function-parameters"
      },
      {
        include: "#type-function-return-type"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*",
        captures: {
          "1": {
            name: "storage.modifier.tsx"
          }
        }
      },
      {
        include: "#type-name"
      }
    ]
  },
  "type-primitive": {
    name: "support.type.primitive.tsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(string|number|bigint|boolean|symbol|any|void|never|unknown)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "type-builtin-literals": {
    name: "support.type.builtin.tsx",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(this|true|false|undefined|null|object)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "type-tuple": {
    name: "meta.type.tuple.tsx",
    begin: "\\[",
    beginCaptures: {
      "0": {
        name: "meta.brace.square.tsx"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "meta.brace.square.tsx"
      }
    },
    patterns: [
      {
        name: "keyword.operator.rest.tsx",
        match: "\\.\\.\\."
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([_$[:alpha:]][_$[:alnum:]]*)\\s*(\\?)?\\s*(:)",
        captures: {
          "1": {
            name: "entity.name.label.tsx"
          },
          "2": {
            name: "keyword.operator.optional.tsx"
          },
          "3": {
            name: "punctuation.separator.label.tsx"
          }
        }
      },
      {
        include: "#type"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "type-object": {
    name: "meta.object.type.tsx",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.tsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.tsx"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#method-declaration"
      },
      {
        include: "#indexer-declaration"
      },
      {
        include: "#indexer-mapped-type-declaration"
      },
      {
        include: "#field-declaration"
      },
      {
        include: "#type-annotation"
      },
      {
        begin: "\\.\\.\\.",
        beginCaptures: {
          "0": {
            name: "keyword.operator.spread.tsx"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        include: "#punctuation-comma"
      },
      {
        include: "#punctuation-semicolon"
      },
      {
        include: "#type"
      }
    ]
  },
  "type-conditional": {
    patterns: [
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends)\\s+",
        beginCaptures: {
          "1": {
            name: "storage.modifier.tsx"
          }
        },
        end: "(?<=:)",
        patterns: [
          {
            begin: "\\?",
            beginCaptures: {
              "0": {
                name: "keyword.operator.ternary.tsx"
              }
            },
            end: ":",
            endCaptures: {
              "0": {
                name: "keyword.operator.ternary.tsx"
              }
            },
            patterns: [
              {
                include: "#type"
              }
            ]
          },
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "type-paren-or-function-parameters": {
    name: "meta.type.paren.cover.tsx",
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "meta.brace.round.tsx"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "meta.brace.round.tsx"
      }
    },
    patterns: [
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=\\s*(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|([\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))))",
        captures: {
          "1": {
            name: "storage.modifier.tsx"
          },
          "2": {
            name: "keyword.operator.rest.tsx"
          },
          "3": {
            name: "entity.name.function.tsx variable.language.this.tsx"
          },
          "4": {
            name: "entity.name.function.tsx"
          },
          "5": {
            name: "keyword.operator.optional.tsx"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=:)",
        captures: {
          "1": {
            name: "storage.modifier.tsx"
          },
          "2": {
            name: "keyword.operator.rest.tsx"
          },
          "3": {
            name: "variable.parameter.tsx variable.language.this.tsx"
          },
          "4": {
            name: "variable.parameter.tsx"
          },
          "5": {
            name: "keyword.operator.optional.tsx"
          }
        }
      },
      {
        include: "#type-annotation"
      },
      {
        name: "punctuation.separator.parameter.tsx",
        match: ","
      },
      {
        include: "#type"
      }
    ]
  },
  "type-fn-type-parameters": {
    patterns: [
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b(?=\\s*\\<)",
        beginCaptures: {
          "1": {
            name: "meta.type.constructor.tsx storage.modifier.tsx"
          },
          "2": {
            name: "meta.type.constructor.tsx keyword.control.new.tsx"
          }
        },
        end: "(?<=>)",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#type-parameters"
          }
        ]
      },
      {
        name: "meta.type.constructor.tsx",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b\\s*(?=\\()",
        beginCaptures: {
          "1": {
            name: "storage.modifier.tsx"
          },
          "2": {
            name: "keyword.control.new.tsx"
          }
        },
        end: "(?<=\\))",
        patterns: [
          {
            include: "#function-parameters"
          }
        ]
      },
      {
        name: "meta.type.function.tsx",
        begin: "(?x)(\n  (?=\n    [(]\\s*(\n      ([)]) |\n      (\\.\\.\\.) |\n      ([_$[:alnum:]]+\\s*(\n        ([:,?=])|\n        ([)]\\s*=>)\n      ))\n    )\n  )\n)",
        end: "(?<=\\))",
        patterns: [
          {
            include: "#function-parameters"
          }
        ]
      }
    ]
  },
  "type-function-return-type": {
    patterns: [
      {
        name: "meta.type.function.return.tsx",
        begin: "(=>)(?=\\s*\\S)",
        beginCaptures: {
          "1": {
            name: "storage.type.function.arrow.tsx"
          }
        },
        end: "(?<!=>)(?<![|&])(?=[,\\]\\)\\{\\}=;>:\\?]|//|$)",
        patterns: [
          {
            include: "#type-function-return-type-core"
          }
        ]
      },
      {
        name: "meta.type.function.return.tsx",
        begin: "=>",
        beginCaptures: {
          "0": {
            name: "storage.type.function.arrow.tsx"
          }
        },
        end: "(?<!=>)(?<![|&])((?=[,\\]\\)\\{\\}=;:\\?>]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))",
        patterns: [
          {
            include: "#type-function-return-type-core"
          }
        ]
      }
    ]
  },
  "type-function-return-type-core": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?<==>)(?=\\s*\\{)",
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        include: "#type-predicate-operator"
      },
      {
        include: "#type"
      }
    ]
  },
  "type-operators": {
    patterns: [
      {
        include: "#typeof-operator"
      },
      {
        begin: "([&|])(?=\\s*\\{)",
        beginCaptures: {
          "0": {
            name: "keyword.operator.type.tsx"
          }
        },
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        begin: "[&|]",
        beginCaptures: {
          "0": {
            name: "keyword.operator.type.tsx"
          }
        },
        end: "(?=\\S)"
      },
      {
        name: "keyword.operator.expression.keyof.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))keyof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.ternary.tsx",
        match: "(\\?|\\:)"
      },
      {
        name: "keyword.operator.expression.infer.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))infer(?=\\s+[_$[:alpha:]])"
      },
      {
        name: "keyword.operator.expression.import.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*\\()"
      }
    ]
  },
  "type-predicate-operator": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(asserts)\\s+)?(?!asserts)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s(is)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "1": {
            name: "keyword.operator.type.asserts.tsx"
          },
          "2": {
            name: "variable.parameter.tsx variable.language.this.tsx"
          },
          "3": {
            name: "variable.parameter.tsx"
          },
          "4": {
            name: "keyword.operator.expression.is.tsx"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(asserts)\\s+(?!is)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "1": {
            name: "keyword.operator.type.asserts.tsx"
          },
          "2": {
            name: "variable.parameter.tsx variable.language.this.tsx"
          },
          "3": {
            name: "variable.parameter.tsx"
          }
        }
      },
      {
        name: "keyword.operator.type.asserts.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))asserts(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.expression.is.tsx",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))is(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "type-name": {
    patterns: [
      {
        begin: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(<)",
        captures: {
          "1": {
            name: "entity.name.type.module.tsx"
          },
          "2": {
            name: "punctuation.accessor.tsx"
          },
          "3": {
            name: "punctuation.accessor.optional.tsx"
          },
          "4": {
            name: "meta.type.parameters.tsx punctuation.definition.typeparameters.begin.tsx"
          }
        },
        end: "(>)",
        endCaptures: {
          "1": {
            name: "meta.type.parameters.tsx punctuation.definition.typeparameters.end.tsx"
          }
        },
        contentName: "meta.type.parameters.tsx",
        patterns: [
          {
            include: "#type-arguments-body"
          }
        ]
      },
      {
        begin: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(<)",
        beginCaptures: {
          "1": {
            name: "entity.name.type.tsx"
          },
          "2": {
            name: "meta.type.parameters.tsx punctuation.definition.typeparameters.begin.tsx"
          }
        },
        end: "(>)",
        endCaptures: {
          "1": {
            name: "meta.type.parameters.tsx punctuation.definition.typeparameters.end.tsx"
          }
        },
        contentName: "meta.type.parameters.tsx",
        patterns: [
          {
            include: "#type-arguments-body"
          }
        ]
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))",
        captures: {
          "1": {
            name: "entity.name.type.module.tsx"
          },
          "2": {
            name: "punctuation.accessor.tsx"
          },
          "3": {
            name: "punctuation.accessor.optional.tsx"
          }
        }
      },
      {
        name: "entity.name.type.tsx",
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      }
    ]
  },
  "punctuation-comma": {
    name: "punctuation.separator.comma.tsx",
    match: ","
  },
  "punctuation-semicolon": {
    name: "punctuation.terminator.statement.tsx",
    match: ";"
  },
  "punctuation-accessor": {
    match: "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))",
    captures: {
      "1": {
        name: "punctuation.accessor.tsx"
      },
      "2": {
        name: "punctuation.accessor.optional.tsx"
      }
    }
  },
  string: {
    patterns: [
      {
        include: "#qstring-single"
      },
      {
        include: "#qstring-double"
      },
      {
        include: "#template"
      }
    ]
  },
  "qstring-double": {
    name: "string.quoted.double.tsx",
    begin: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.tsx"
      }
    },
    end: '(")|((?:[^\\\\\\n])$)',
    endCaptures: {
      "1": {
        name: "punctuation.definition.string.end.tsx"
      },
      "2": {
        name: "invalid.illegal.newline.tsx"
      }
    },
    patterns: [
      {
        include: "#string-character-escape"
      }
    ]
  },
  "qstring-single": {
    name: "string.quoted.single.tsx",
    begin: "'",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.tsx"
      }
    },
    end: "(\\')|((?:[^\\\\\\n])$)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.string.end.tsx"
      },
      "2": {
        name: "invalid.illegal.newline.tsx"
      }
    },
    patterns: [
      {
        include: "#string-character-escape"
      }
    ]
  },
  "string-character-escape": {
    name: "constant.character.escape.tsx",
    match: "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|u\\{[0-9A-Fa-f]+\\}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)"
  },
  template: {
    patterns: [
      {
        include: "#template-call"
      },
      {
        name: "string.template.tsx",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)?(`)",
        beginCaptures: {
          "1": {
            name: "entity.name.function.tagged-template.tsx"
          },
          "2": {
            name: "punctuation.definition.string.template.begin.tsx"
          }
        },
        end: "`",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.template.end.tsx"
          }
        },
        patterns: [
          {
            include: "#template-substitution-element"
          },
          {
            include: "#string-character-escape"
          }
        ]
      }
    ]
  },
  "template-call": {
    patterns: [
      {
        name: "string.template.tsx",
        begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*)(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)",
        end: "(?=`)",
        patterns: [
          {
            begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*))",
            end: "(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)",
            patterns: [
              {
                include: "#support-function-call-identifiers"
              },
              {
                name: "entity.name.function.tagged-template.tsx",
                match: "([_$[:alpha:]][_$[:alnum:]]*)"
              }
            ]
          },
          {
            include: "#type-arguments"
          }
        ]
      },
      {
        name: "string.template.tsx",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)?\\s*(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)`)",
        beginCaptures: {
          "1": {
            name: "entity.name.function.tagged-template.tsx"
          }
        },
        end: "(?=`)",
        patterns: [
          {
            include: "#type-arguments"
          }
        ]
      }
    ]
  },
  "template-substitution-element": {
    name: "meta.template.expression.tsx",
    begin: "\\$\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.begin.tsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.end.tsx"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ],
    contentName: "meta.embedded.line.tsx"
  },
  "type-string": {
    patterns: [
      {
        include: "#qstring-single"
      },
      {
        include: "#qstring-double"
      },
      {
        include: "#template-type"
      }
    ]
  },
  "template-type": {
    patterns: [
      {
        include: "#template-call"
      },
      {
        name: "string.template.tsx",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)?(`)",
        beginCaptures: {
          "1": {
            name: "entity.name.function.tagged-template.tsx"
          },
          "2": {
            name: "punctuation.definition.string.template.begin.tsx"
          }
        },
        end: "`",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.template.end.tsx"
          }
        },
        patterns: [
          {
            include: "#template-type-substitution-element"
          },
          {
            include: "#string-character-escape"
          }
        ]
      }
    ]
  },
  "template-type-substitution-element": {
    name: "meta.template.expression.tsx",
    begin: "\\$\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.begin.tsx"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.end.tsx"
      }
    },
    patterns: [
      {
        include: "#type"
      }
    ],
    contentName: "meta.embedded.line.tsx"
  },
  regex: {
    patterns: [
      {
        name: "string.regexp.tsx",
        begin: "(?<!\\+\\+|--|})(?<=[=(:,\\[?+!]|^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case|=>|&&|\\|\\||\\*\\/)\\s*(\\/)(?![\\/*])(?=(?:[^\\/\\\\\\[\\()]|\\\\.|\\[([^\\]\\\\]|\\\\.)+\\]|\\(([^\\)\\\\]|\\\\.)+\\))+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.string.begin.tsx"
          }
        },
        end: "(/)([dgimsuy]*)",
        endCaptures: {
          "1": {
            name: "punctuation.definition.string.end.tsx"
          },
          "2": {
            name: "keyword.other.tsx"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      },
      {
        name: "string.regexp.tsx",
        begin: "((?<![_$[:alnum:])\\]]|\\+\\+|--|}|\\*\\/)|((?<=^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case))\\s*)\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.tsx"
          }
        },
        end: "(/)([dgimsuy]*)",
        endCaptures: {
          "1": {
            name: "punctuation.definition.string.end.tsx"
          },
          "2": {
            name: "keyword.other.tsx"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      }
    ]
  },
  regexp: {
    patterns: [
      {
        name: "keyword.control.anchor.regexp",
        match: "\\\\[bB]|\\^|\\$"
      },
      {
        match: "\\\\[1-9]\\d*|\\\\k<([a-zA-Z_$][\\w$]*)>",
        captures: {
          "0": {
            name: "keyword.other.back-reference.regexp"
          },
          "1": {
            name: "variable.other.regexp"
          }
        }
      },
      {
        name: "keyword.operator.quantifier.regexp",
        match: "[?+*]|\\{(\\d+,\\d+|\\d+,|,\\d+|\\d+)\\}\\??"
      },
      {
        name: "keyword.operator.or.regexp",
        match: "\\|"
      },
      {
        name: "meta.group.assertion.regexp",
        begin: "(\\()((\\?=)|(\\?!)|(\\?<=)|(\\?<!))",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.group.regexp"
          },
          "2": {
            name: "punctuation.definition.group.assertion.regexp"
          },
          "3": {
            name: "meta.assertion.look-ahead.regexp"
          },
          "4": {
            name: "meta.assertion.negative-look-ahead.regexp"
          },
          "5": {
            name: "meta.assertion.look-behind.regexp"
          },
          "6": {
            name: "meta.assertion.negative-look-behind.regexp"
          }
        },
        end: "(\\))",
        endCaptures: {
          "1": {
            name: "punctuation.definition.group.regexp"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      },
      {
        name: "meta.group.regexp",
        begin: "\\((?:(\\?:)|(?:\\?<([a-zA-Z_$][\\w$]*)>))?",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.group.regexp"
          },
          "1": {
            name: "punctuation.definition.group.no-capture.regexp"
          },
          "2": {
            name: "variable.other.regexp"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.definition.group.regexp"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      },
      {
        name: "constant.other.character-class.set.regexp",
        begin: "(\\[)(\\^)?",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.character-class.regexp"
          },
          "2": {
            name: "keyword.operator.negation.regexp"
          }
        },
        end: "(\\])",
        endCaptures: {
          "1": {
            name: "punctuation.definition.character-class.regexp"
          }
        },
        patterns: [
          {
            name: "constant.other.character-class.range.regexp",
            match: "(?:.|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))\\-(?:[^\\]\\\\]|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))",
            captures: {
              "1": {
                name: "constant.character.numeric.regexp"
              },
              "2": {
                name: "constant.character.control.regexp"
              },
              "3": {
                name: "constant.character.escape.backslash.regexp"
              },
              "4": {
                name: "constant.character.numeric.regexp"
              },
              "5": {
                name: "constant.character.control.regexp"
              },
              "6": {
                name: "constant.character.escape.backslash.regexp"
              }
            }
          },
          {
            include: "#regex-character-class"
          }
        ]
      },
      {
        include: "#regex-character-class"
      }
    ]
  },
  "regex-character-class": {
    patterns: [
      {
        name: "constant.other.character-class.regexp",
        match: "\\\\[wWsSdDtrnvf]|\\."
      },
      {
        name: "constant.character.numeric.regexp",
        match: "\\\\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})"
      },
      {
        name: "constant.character.control.regexp",
        match: "\\\\c[A-Z]"
      },
      {
        name: "constant.character.escape.backslash.regexp",
        match: "\\\\."
      }
    ]
  },
  comment: {
    patterns: [
      {
        name: "comment.block.documentation.tsx",
        begin: "/\\*\\*(?!/)",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.comment.tsx"
          }
        },
        end: "\\*/",
        endCaptures: {
          "0": {
            name: "punctuation.definition.comment.tsx"
          }
        },
        patterns: [
          {
            include: "#docblock"
          }
        ]
      },
      {
        name: "comment.block.tsx",
        begin: "(/\\*)(?:\\s*((@)internal)(?=\\s|(\\*/)))?",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.comment.tsx"
          },
          "2": {
            name: "storage.type.internaldeclaration.tsx"
          },
          "3": {
            name: "punctuation.decorator.internaldeclaration.tsx"
          }
        },
        end: "\\*/",
        endCaptures: {
          "0": {
            name: "punctuation.definition.comment.tsx"
          }
        }
      },
      {
        begin: "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)",
        beginCaptures: {
          "1": {
            name: "punctuation.whitespace.comment.leading.tsx"
          },
          "2": {
            name: "comment.line.double-slash.tsx"
          },
          "3": {
            name: "punctuation.definition.comment.tsx"
          },
          "4": {
            name: "storage.type.internaldeclaration.tsx"
          },
          "5": {
            name: "punctuation.decorator.internaldeclaration.tsx"
          }
        },
        end: "(?=$)",
        contentName: "comment.line.double-slash.tsx"
      }
    ]
  },
  "single-line-comment-consuming-line-ending": {
    begin: "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)",
    beginCaptures: {
      "1": {
        name: "punctuation.whitespace.comment.leading.tsx"
      },
      "2": {
        name: "comment.line.double-slash.tsx"
      },
      "3": {
        name: "punctuation.definition.comment.tsx"
      },
      "4": {
        name: "storage.type.internaldeclaration.tsx"
      },
      "5": {
        name: "punctuation.decorator.internaldeclaration.tsx"
      }
    },
    end: "(?=^)",
    contentName: "comment.line.double-slash.tsx"
  },
  directives: {
    name: "comment.line.triple-slash.directive.tsx",
    begin: "^(///)\\s*(?=<(reference|amd-dependency|amd-module)(\\s+(path|types|no-default-lib|lib|name)\\s*=\\s*((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)))+\\s*/>\\s*$)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.comment.tsx"
      }
    },
    end: "(?=$)",
    patterns: [
      {
        name: "meta.tag.tsx",
        begin: "(<)(reference|amd-dependency|amd-module)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.directive.tsx"
          },
          "2": {
            name: "entity.name.tag.directive.tsx"
          }
        },
        end: "/>",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.directive.tsx"
          }
        },
        patterns: [
          {
            name: "entity.other.attribute-name.directive.tsx",
            match: "path|types|no-default-lib|lib|name"
          },
          {
            name: "keyword.operator.assignment.tsx",
            match: "="
          },
          {
            include: "#string"
          }
        ]
      }
    ]
  },
  docblock: {
    patterns: [
      {
        match: "(?x)\n((@)(?:access|api))\n\\s+\n(private|protected|public)\n\\b",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "constant.language.access-type.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)author)\n\\s+\n(\n  [^@\\s<>*/]\n  (?:[^@<>*/]|\\*[^/])*\n)\n(?:\n  \\s*\n  (<)\n  ([^>\\s]+)\n  (>)\n)?",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "entity.name.type.instance.jsdoc"
          },
          "4": {
            name: "punctuation.definition.bracket.angle.begin.jsdoc"
          },
          "5": {
            name: "constant.other.email.link.underline.jsdoc"
          },
          "6": {
            name: "punctuation.definition.bracket.angle.end.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)borrows) \\s+\n((?:[^@\\s*/]|\\*[^/])+)    # <that namepath>\n\\s+ (as) \\s+              # as\n((?:[^@\\s*/]|\\*[^/])+)    # <this namepath>",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "entity.name.type.instance.jsdoc"
          },
          "4": {
            name: "keyword.operator.control.jsdoc"
          },
          "5": {
            name: "entity.name.type.instance.jsdoc"
          }
        }
      },
      {
        name: "meta.example.jsdoc",
        begin: "((@)example)\\s+",
        end: "(?=@|\\*/)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        patterns: [
          {
            match: "^\\s\\*\\s+"
          },
          {
            contentName: "constant.other.description.jsdoc",
            begin: "\\G(<)caption(>)",
            beginCaptures: {
              "0": {
                name: "entity.name.tag.inline.jsdoc"
              },
              "1": {
                name: "punctuation.definition.bracket.angle.begin.jsdoc"
              },
              "2": {
                name: "punctuation.definition.bracket.angle.end.jsdoc"
              }
            },
            end: "(</)caption(>)|(?=\\*/)",
            endCaptures: {
              "0": {
                name: "entity.name.tag.inline.jsdoc"
              },
              "1": {
                name: "punctuation.definition.bracket.angle.begin.jsdoc"
              },
              "2": {
                name: "punctuation.definition.bracket.angle.end.jsdoc"
              }
            }
          },
          {
            match: "[^\\s@*](?:[^*]|\\*[^/])*",
            captures: {
              "0": {
                name: "source.embedded.tsx"
              }
            }
          }
        ]
      },
      {
        match: "(?x) ((@)kind) \\s+ (class|constant|event|external|file|function|member|mixin|module|namespace|typedef) \\b",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "constant.language.symbol-type.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)see)\n\\s+\n(?:\n  # URL\n  (\n    (?=https?://)\n    (?:[^\\s*]|\\*[^/])+\n  )\n  |\n  # JSDoc namepath\n  (\n    (?!\n      # Avoid matching bare URIs (also acceptable as links)\n      https?://\n      |\n      # Avoid matching {@inline tags}; we match those below\n      (?:\\[[^\\[\\]]*\\])? # Possible description [preceding]{@tag}\n      {@(?:link|linkcode|linkplain|tutorial)\\b\n    )\n    # Matched namepath\n    (?:[^@\\s*/]|\\*[^/])+\n  )\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.link.underline.jsdoc"
          },
          "4": {
            name: "entity.name.type.instance.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)template)\n\\s+\n# One or more valid identifiers\n(\n  [A-Za-z_$]         # First character: non-numeric word character\n  [\\w$.\\[\\]]*        # Rest of identifier\n  (?:                # Possible list of additional identifiers\n    \\s* , \\s*\n    [A-Za-z_$]\n    [\\w$.\\[\\]]*\n  )*\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n(\n  (@)\n  (?:arg|argument|const|constant|member|namespace|param|var)\n)\n\\s+\n(\n  [A-Za-z_$]\n  [\\w$.\\[\\]]*\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          }
        }
      },
      {
        begin: "((@)typedef)\\s+(?={)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])",
        patterns: [
          {
            include: "#jsdoctype"
          },
          {
            name: "entity.name.type.instance.jsdoc",
            match: "(?:[^@\\s*/]|\\*[^/])+"
          }
        ]
      },
      {
        begin: "((@)(?:arg|argument|const|constant|member|namespace|param|prop|property|var))\\s+(?={)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])",
        patterns: [
          {
            include: "#jsdoctype"
          },
          {
            name: "variable.other.jsdoc",
            match: "([A-Za-z_$][\\w$.\\[\\]]*)"
          },
          {
            name: "variable.other.jsdoc",
            match: `(?x)
(\\[)\\s*
[\\w$]+
(?:
  (?:\\[\\])?                                        # Foo[ ].bar properties within an array
  \\.                                                # Foo.Bar namespaced parameter
  [\\w$]+
)*
(?:
  \\s*
  (=)                                                # [foo=bar] Default parameter value
  \\s*
  (
    # The inner regexes are to stop the match early at */ and to not stop at escaped quotes
    (?>
      "(?:(?:\\*(?!/))|(?:\\\\(?!"))|[^*\\\\])*?" |                      # [foo="bar"] Double-quoted
      '(?:(?:\\*(?!/))|(?:\\\\(?!'))|[^*\\\\])*?' |                      # [foo='bar'] Single-quoted
      \\[ (?:(?:\\*(?!/))|[^*])*? \\] |                                # [foo=[1,2]] Array literal
      (?:(?:\\*(?!/))|\\s(?!\\s*\\])|\\[.*?(?:\\]|(?=\\*/))|[^*\\s\\[\\]])*   # Everything else
    )*
  )
)?
\\s*(?:(\\])((?:[^*\\s]|\\*[^\\s/])+)?|(?=\\*/))`,
            captures: {
              "1": {
                name: "punctuation.definition.optional-value.begin.bracket.square.jsdoc"
              },
              "2": {
                name: "keyword.operator.assignment.jsdoc"
              },
              "3": {
                name: "source.embedded.tsx"
              },
              "4": {
                name: "punctuation.definition.optional-value.end.bracket.square.jsdoc"
              },
              "5": {
                name: "invalid.illegal.syntax.jsdoc"
              }
            }
          }
        ]
      },
      {
        begin: "(?x)\n(\n  (@)\n  (?:define|enum|exception|export|extends|lends|implements|modifies\n  |namespace|private|protected|returns?|suppress|this|throws|type\n  |yields?)\n)\n\\s+(?={)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])",
        patterns: [
          {
            include: "#jsdoctype"
          }
        ]
      },
      {
        match: "(?x)\n(\n  (@)\n  (?:alias|augments|callback|constructs|emits|event|fires|exports?\n  |extends|external|function|func|host|lends|listens|interface|memberof!?\n  |method|module|mixes|mixin|name|requires|see|this|typedef|uses)\n)\n\\s+\n(\n  (?:\n    [^{}@\\s*] | \\*[^/]\n  )+\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "entity.name.type.instance.jsdoc"
          }
        }
      },
      {
        contentName: "variable.other.jsdoc",
        begin: `((@)(?:default(?:value)?|license|version))\\s+(([''"]))`,
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          },
          "4": {
            name: "punctuation.definition.string.begin.jsdoc"
          }
        },
        end: "(\\3)|(?=$|\\*/)",
        endCaptures: {
          "0": {
            name: "variable.other.jsdoc"
          },
          "1": {
            name: "punctuation.definition.string.end.jsdoc"
          }
        }
      },
      {
        match: "((@)(?:default(?:value)?|license|tutorial|variation|version))\\s+([^\\s*]+)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          }
        }
      },
      {
        name: "storage.type.class.jsdoc",
        match: "(?x) (@) (?:abstract|access|alias|api|arg|argument|async|attribute|augments|author|beta|borrows|bubbles |callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright |default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exception |exports?|extends|extension(?:_?for)?|external|externs|file|fileoverview|final|fires|for|func |function|generator|global|hideconstructor|host|ignore|implements|implicitCast|inherit[Dd]oc |inner|instance|interface|internal|kind|lends|license|listens|main|member|memberof!?|method |mixes|mixins?|modifies|module|name|namespace|noalias|nocollapse|nocompile|nosideeffects |override|overview|package|param|polymer(?:Behavior)?|preserve|private|prop|property|protected |public|read[Oo]nly|record|require[ds]|returns?|see|since|static|struct|submodule|summary |suppress|template|this|throws|todo|tutorial|type|typedef|unrestricted|uses|var|variation |version|virtual|writeOnce|yields?) \\b",
        captures: {
          "1": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        }
      },
      {
        include: "#inline-tags"
      },
      {
        match: "((@)(?:[_$[:alpha:]][_$[:alnum:]]*))(?=\\s+)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        }
      }
    ]
  },
  brackets: {
    patterns: [
      {
        begin: "{",
        end: "}|(?=\\*/)",
        patterns: [
          {
            include: "#brackets"
          }
        ]
      },
      {
        begin: "\\[",
        end: "\\]|(?=\\*/)",
        patterns: [
          {
            include: "#brackets"
          }
        ]
      }
    ]
  },
  "inline-tags": {
    patterns: [
      {
        name: "constant.other.description.jsdoc",
        match: "(\\[)[^\\]]+(\\])(?={@(?:link|linkcode|linkplain|tutorial))",
        captures: {
          "1": {
            name: "punctuation.definition.bracket.square.begin.jsdoc"
          },
          "2": {
            name: "punctuation.definition.bracket.square.end.jsdoc"
          }
        }
      },
      {
        name: "entity.name.type.instance.jsdoc",
        begin: "({)((@)(?:link(?:code|plain)?|tutorial))\\s*",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.bracket.curly.begin.jsdoc"
          },
          "2": {
            name: "storage.type.class.jsdoc"
          },
          "3": {
            name: "punctuation.definition.inline.tag.jsdoc"
          }
        },
        end: "}|(?=\\*/)",
        endCaptures: {
          "0": {
            name: "punctuation.definition.bracket.curly.end.jsdoc"
          }
        },
        patterns: [
          {
            match: "\\G((?=https?://)(?:[^|}\\s*]|\\*[/])+)(\\|)?",
            captures: {
              "1": {
                name: "variable.other.link.underline.jsdoc"
              },
              "2": {
                name: "punctuation.separator.pipe.jsdoc"
              }
            }
          },
          {
            match: "\\G((?:[^{}@\\s|*]|\\*[^/])+)(\\|)?",
            captures: {
              "1": {
                name: "variable.other.description.jsdoc"
              },
              "2": {
                name: "punctuation.separator.pipe.jsdoc"
              }
            }
          }
        ]
      }
    ]
  },
  jsdoctype: {
    patterns: [
      {
        contentName: "entity.name.type.instance.jsdoc",
        begin: "\\G({)",
        beginCaptures: {
          "0": {
            name: "entity.name.type.instance.jsdoc"
          },
          "1": {
            name: "punctuation.definition.bracket.curly.begin.jsdoc"
          }
        },
        end: "((}))\\s*|(?=\\*/)",
        endCaptures: {
          "1": {
            name: "entity.name.type.instance.jsdoc"
          },
          "2": {
            name: "punctuation.definition.bracket.curly.end.jsdoc"
          }
        },
        patterns: [
          {
            include: "#brackets"
          }
        ]
      }
    ]
  },
  jsx: {
    patterns: [
      {
        include: "#jsx-tag-without-attributes-in-expression"
      },
      {
        include: "#jsx-tag-in-expression"
      }
    ]
  },
  "jsx-tag-without-attributes-in-expression": {
    begin: "(?<!\\+\\+|--)(?<=[({\\[,?=>:*]|&&|\\|\\||\\?|\\*\\/|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^default|[^\\._$[:alnum:]]default|^yield|[^\\._$[:alnum:]]yield|^)\\s*(?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))",
    end: "(?!(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))",
    patterns: [
      {
        include: "#jsx-tag-without-attributes"
      }
    ]
  },
  "jsx-tag-without-attributes": {
    name: "meta.tag.without-attributes.tsx",
    begin: "(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>)",
    end: "(</)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.tsx"
      },
      "2": {
        name: "entity.name.tag.namespace.tsx"
      },
      "3": {
        name: "punctuation.separator.namespace.tsx"
      },
      "4": {
        name: "entity.name.tag.tsx"
      },
      "5": {
        name: "support.class.component.tsx"
      },
      "6": {
        name: "punctuation.definition.tag.end.tsx"
      }
    },
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.tsx"
      },
      "2": {
        name: "entity.name.tag.namespace.tsx"
      },
      "3": {
        name: "punctuation.separator.namespace.tsx"
      },
      "4": {
        name: "entity.name.tag.tsx"
      },
      "5": {
        name: "support.class.component.tsx"
      },
      "6": {
        name: "punctuation.definition.tag.end.tsx"
      }
    },
    contentName: "meta.jsx.children.tsx",
    patterns: [
      {
        include: "#jsx-children"
      }
    ]
  },
  "jsx-tag-in-expression": {
    begin: "(?x)\n  (?<!\\+\\+|--)(?<=[({\\[,?=>:*]|&&|\\|\\||\\?|\\*\\/|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^default|[^\\._$[:alnum:]]default|^yield|[^\\._$[:alnum:]]yield|^)\\s*\n  (?!<\\s*[_$[:alpha:]][_$[:alnum:]]*((\\s+extends\\s+[^=>])|,)) # look ahead is not type parameter of arrow\n  (?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))",
    end: "(?!(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))",
    patterns: [
      {
        include: "#jsx-tag"
      }
    ]
  },
  "jsx-tag": {
    name: "meta.tag.tsx",
    begin: "(?=(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>))",
    end: "(/>)|(?:(</)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))?\\s*(>))",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.tsx"
      },
      "2": {
        name: "punctuation.definition.tag.begin.tsx"
      },
      "3": {
        name: "entity.name.tag.namespace.tsx"
      },
      "4": {
        name: "punctuation.separator.namespace.tsx"
      },
      "5": {
        name: "entity.name.tag.tsx"
      },
      "6": {
        name: "support.class.component.tsx"
      },
      "7": {
        name: "punctuation.definition.tag.end.tsx"
      }
    },
    patterns: [
      {
        begin: "(<)\\s*(?:([_$[:alpha:]][-_$[:alnum:].]*)(?<!\\.|-)(:))?((?:[a-z][a-z0-9]*|([_$[:alpha:]][-_$[:alnum:].]*))(?<!\\.|-))(?=((<\\s*)|(\\s+))(?!\\?)|\\/?>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.begin.tsx"
          },
          "2": {
            name: "entity.name.tag.namespace.tsx"
          },
          "3": {
            name: "punctuation.separator.namespace.tsx"
          },
          "4": {
            name: "entity.name.tag.tsx"
          },
          "5": {
            name: "support.class.component.tsx"
          }
        },
        end: "(?=[/]?>)",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#type-arguments"
          },
          {
            include: "#jsx-tag-attributes"
          }
        ]
      },
      {
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.tsx"
          }
        },
        end: "(?=</)",
        contentName: "meta.jsx.children.tsx",
        patterns: [
          {
            include: "#jsx-children"
          }
        ]
      }
    ]
  },
  "jsx-children": {
    patterns: [
      {
        include: "#jsx-tag-without-attributes"
      },
      {
        include: "#jsx-tag"
      },
      {
        include: "#jsx-evaluated-code"
      },
      {
        include: "#jsx-entities"
      }
    ]
  },
  "jsx-evaluated-code": {
    contentName: "meta.embedded.expression.tsx",
    begin: "\\{",
    end: "\\}",
    beginCaptures: {
      "0": {
        name: "punctuation.section.embedded.begin.tsx"
      }
    },
    endCaptures: {
      "0": {
        name: "punctuation.section.embedded.end.tsx"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "jsx-entities": {
    patterns: [
      {
        name: "constant.character.entity.tsx",
        match: "(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)",
        captures: {
          "1": {
            name: "punctuation.definition.entity.tsx"
          },
          "3": {
            name: "punctuation.definition.entity.tsx"
          }
        }
      },
      {
        name: "invalid.illegal.bad-ampersand.tsx",
        match: "&"
      }
    ]
  },
  "jsx-tag-attributes": {
    name: "meta.tag.attributes.tsx",
    begin: "\\s+",
    end: "(?=[/]?>)",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#jsx-tag-attribute-name"
      },
      {
        include: "#jsx-tag-attribute-assignment"
      },
      {
        include: "#jsx-string-double-quoted"
      },
      {
        include: "#jsx-string-single-quoted"
      },
      {
        include: "#jsx-evaluated-code"
      },
      {
        include: "#jsx-tag-attributes-illegal"
      }
    ]
  },
  "jsx-tag-attribute-name": {
    match: "(?x)\n  \\s*\n  (?:([_$[:alpha:]][-_$[:alnum:].]*)(:))?\n  ([_$[:alpha:]][-_$[:alnum:]]*)\n  (?=\\s|=|/?>|/\\*|//)",
    captures: {
      "1": {
        name: "entity.other.attribute-name.namespace.tsx"
      },
      "2": {
        name: "punctuation.separator.namespace.tsx"
      },
      "3": {
        name: "entity.other.attribute-name.tsx"
      }
    }
  },
  "jsx-tag-attribute-assignment": {
    name: "keyword.operator.assignment.tsx",
    match: `=(?=\\s*(?:'|"|{|/\\*|//|\\n))`
  },
  "jsx-string-double-quoted": {
    name: "string.quoted.double.tsx",
    begin: '"',
    end: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.tsx"
      }
    },
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.tsx"
      }
    },
    patterns: [
      {
        include: "#jsx-entities"
      }
    ]
  },
  "jsx-string-single-quoted": {
    name: "string.quoted.single.tsx",
    begin: "'",
    end: "'",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.tsx"
      }
    },
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.tsx"
      }
    },
    patterns: [
      {
        include: "#jsx-entities"
      }
    ]
  },
  "jsx-tag-attributes-illegal": {
    name: "invalid.illegal.attribute.tsx",
    match: "\\S+"
  }
};
const tsx_tmLanguage = {
  information_for_contributors: information_for_contributors$2,
  version: version$2,
  name: name$5,
  scopeName: scopeName$4,
  patterns: patterns$4,
  repository: repository$4
};
const __vite_glob_0_6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: tsx_tmLanguage,
  information_for_contributors: information_for_contributors$2,
  name: name$5,
  patterns: patterns$4,
  repository: repository$4,
  scopeName: scopeName$4,
  version: version$2
}, Symbol.toStringTag, { value: "Module" }));
const information_for_contributors$1 = [
  "This file has been converted from https://github.com/microsoft/TypeScript-TmLanguage/blob/master/TypeScript.tmLanguage",
  "If you want to provide a fix or improvement, please create a pull request against the original repository.",
  "Once accepted there, we are happy to receive an update request."
];
const version$1 = "https://github.com/microsoft/TypeScript-TmLanguage/commit/33d8371c344f0b54746586313a939f742f9bcd3a";
const name$4 = "typescript";
const scopeName$3 = "source.ts";
const patterns$3 = [
  {
    include: "#directives"
  },
  {
    include: "#statements"
  },
  {
    include: "#shebang"
  }
];
const repository$3 = {
  shebang: {
    name: "comment.line.shebang.ts",
    match: "\\A(#!).*(?=$)",
    captures: {
      "1": {
        name: "punctuation.definition.comment.ts"
      }
    }
  },
  statements: {
    patterns: [
      {
        include: "#declaration"
      },
      {
        include: "#control-statement"
      },
      {
        include: "#after-operator-block-as-object-literal"
      },
      {
        include: "#decl-block"
      },
      {
        include: "#label"
      },
      {
        include: "#expression"
      },
      {
        include: "#punctuation-semicolon"
      },
      {
        include: "#string"
      },
      {
        include: "#comment"
      }
    ]
  },
  declaration: {
    patterns: [
      {
        include: "#decorator"
      },
      {
        include: "#var-expr"
      },
      {
        include: "#function-declaration"
      },
      {
        include: "#class-declaration"
      },
      {
        include: "#interface-declaration"
      },
      {
        include: "#enum-declaration"
      },
      {
        include: "#namespace-declaration"
      },
      {
        include: "#type-alias-declaration"
      },
      {
        include: "#import-equals-declaration"
      },
      {
        include: "#import-declaration"
      },
      {
        include: "#export-declaration"
      },
      {
        name: "storage.modifier.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(declare|export)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "control-statement": {
    patterns: [
      {
        include: "#switch-statement"
      },
      {
        include: "#for-loop"
      },
      {
        name: "keyword.control.trycatch.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(catch|finally|throw|try)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|goto)\\s+([_$[:alpha:]][_$[:alnum:]]*)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "1": {
            name: "keyword.control.loop.ts"
          },
          "2": {
            name: "entity.name.label.ts"
          }
        }
      },
      {
        name: "keyword.control.loop.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(break|continue|do|goto|while)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(return)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        beginCaptures: {
          "0": {
            name: "keyword.control.flow.ts"
          }
        },
        end: "(?=[;}]|$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "keyword.control.switch.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default|switch)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        include: "#if-statement"
      },
      {
        name: "keyword.control.conditional.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(else|if)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.control.with.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(with)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.control.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(package)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.other.debugger.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(debugger)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  label: {
    patterns: [
      {
        begin: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)(?=\\s*\\{)",
        beginCaptures: {
          "1": {
            name: "entity.name.label.ts"
          },
          "2": {
            name: "punctuation.separator.label.ts"
          }
        },
        end: "(?<=\\})",
        patterns: [
          {
            include: "#decl-block"
          }
        ]
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(:)",
        captures: {
          "1": {
            name: "entity.name.label.ts"
          },
          "2": {
            name: "punctuation.separator.label.ts"
          }
        }
      }
    ]
  },
  expression: {
    patterns: [
      {
        include: "#expressionWithoutIdentifiers"
      },
      {
        include: "#identifiers"
      },
      {
        include: "#expressionPunctuations"
      }
    ]
  },
  expressionWithoutIdentifiers: {
    patterns: [
      {
        include: "#string"
      },
      {
        include: "#regex"
      },
      {
        include: "#comment"
      },
      {
        include: "#function-expression"
      },
      {
        include: "#class-expression"
      },
      {
        include: "#arrow-function"
      },
      {
        include: "#paren-expression-possibly-arrow"
      },
      {
        include: "#cast"
      },
      {
        include: "#ternary-expression"
      },
      {
        include: "#new-expr"
      },
      {
        include: "#instanceof-expr"
      },
      {
        include: "#object-literal"
      },
      {
        include: "#expression-operators"
      },
      {
        include: "#function-call"
      },
      {
        include: "#literal"
      },
      {
        include: "#support-objects"
      },
      {
        include: "#paren-expression"
      }
    ]
  },
  expressionPunctuations: {
    patterns: [
      {
        include: "#punctuation-comma"
      },
      {
        include: "#punctuation-accessor"
      }
    ]
  },
  decorator: {
    name: "meta.decorator.ts",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))\\@",
    beginCaptures: {
      "0": {
        name: "punctuation.decorator.ts"
      }
    },
    end: "(?=\\s)",
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "var-expr": {
    patterns: [
      {
        name: "meta.var.expr.ts",
        begin: "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))",
        end: "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))|((?<!^let|[^\\._$[:alnum:]]let|^var|[^\\._$[:alnum:]]var)(?=\\s*$)))",
        patterns: [
          {
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(var|let)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*",
            beginCaptures: {
              "1": {
                name: "keyword.control.export.ts"
              },
              "2": {
                name: "storage.modifier.ts"
              },
              "3": {
                name: "storage.type.ts"
              }
            },
            end: "(?=\\S)"
          },
          {
            include: "#destructuring-variable"
          },
          {
            include: "#var-single-variable"
          },
          {
            include: "#variable-initializer"
          },
          {
            include: "#comment"
          },
          {
            begin: "(,)\\s*((?!\\S)|(?=\\/\\/))",
            beginCaptures: {
              "1": {
                name: "punctuation.separator.comma.ts"
              }
            },
            end: "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))",
            patterns: [
              {
                include: "#single-line-comment-consuming-line-ending"
              },
              {
                include: "#comment"
              },
              {
                include: "#destructuring-variable"
              },
              {
                include: "#var-single-variable"
              },
              {
                include: "#punctuation-comma"
              }
            ]
          },
          {
            include: "#punctuation-comma"
          }
        ]
      },
      {
        name: "meta.var.expr.ts",
        begin: "(?=(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.ts"
          },
          "2": {
            name: "storage.modifier.ts"
          },
          "3": {
            name: "storage.type.ts"
          }
        },
        end: "(?!(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))((?=;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))|((?<!^const|[^\\._$[:alnum:]]const)(?=\\s*$)))",
        patterns: [
          {
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(const(?!\\s+enum\\b))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*",
            beginCaptures: {
              "1": {
                name: "keyword.control.export.ts"
              },
              "2": {
                name: "storage.modifier.ts"
              },
              "3": {
                name: "storage.type.ts"
              }
            },
            end: "(?=\\S)"
          },
          {
            include: "#destructuring-const"
          },
          {
            include: "#var-single-const"
          },
          {
            include: "#variable-initializer"
          },
          {
            include: "#comment"
          },
          {
            begin: "(,)\\s*((?!\\S)|(?=\\/\\/))",
            beginCaptures: {
              "1": {
                name: "punctuation.separator.comma.ts"
              }
            },
            end: "(?<!,)(((?==|;|}|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$)))",
            patterns: [
              {
                include: "#single-line-comment-consuming-line-ending"
              },
              {
                include: "#comment"
              },
              {
                include: "#destructuring-const"
              },
              {
                include: "#var-single-const"
              },
              {
                include: "#punctuation-comma"
              }
            ]
          },
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  },
  "var-single-variable": {
    patterns: [
      {
        name: "meta.var-single-variable.expr.ts",
        begin: "(?x)([_$[:alpha:]][_$[:alnum:]]*)(\\!)?(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.ts entity.name.function.ts"
          },
          "2": {
            name: "keyword.operator.definiteassignment.ts"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      },
      {
        name: "meta.var-single-variable.expr.ts",
        begin: "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])(\\!)?",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.ts variable.other.constant.ts"
          },
          "2": {
            name: "keyword.operator.definiteassignment.ts"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      },
      {
        name: "meta.var-single-variable.expr.ts",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)(\\!)?",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.ts variable.other.readwrite.ts"
          },
          "2": {
            name: "keyword.operator.definiteassignment.ts"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      }
    ]
  },
  "var-single-const": {
    patterns: [
      {
        name: "meta.var-single-variable.expr.ts",
        begin: "(?x)([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.ts variable.other.constant.ts entity.name.function.ts"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      },
      {
        name: "meta.var-single-variable.expr.ts",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)",
        beginCaptures: {
          "1": {
            name: "meta.definition.variable.ts variable.other.constant.ts"
          }
        },
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      }
    ]
  },
  "var-single-variable-type-annotation": {
    patterns: [
      {
        include: "#type-annotation"
      },
      {
        include: "#string"
      },
      {
        include: "#comment"
      }
    ]
  },
  "destructuring-variable": {
    patterns: [
      {
        name: "meta.object-binding-pattern-variable.ts",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#object-binding-pattern"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      },
      {
        name: "meta.array-binding-pattern-variable.ts",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#array-binding-pattern"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      }
    ]
  },
  "destructuring-const": {
    patterns: [
      {
        name: "meta.object-binding-pattern-variable.ts",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\{)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#object-binding-pattern-const"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      },
      {
        name: "meta.array-binding-pattern-variable.ts",
        begin: "(?<!=|:|^of|[^\\._$[:alnum:]]of|^in|[^\\._$[:alnum:]]in)\\s*(?=\\[)",
        end: "(?=$|^|[;,=}]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#array-binding-pattern-const"
          },
          {
            include: "#type-annotation"
          },
          {
            include: "#comment"
          }
        ]
      }
    ]
  },
  "object-binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          },
          {
            include: "#binding-element"
          }
        ]
      },
      {
        include: "#object-binding-pattern"
      },
      {
        include: "#destructuring-variable-rest"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "object-binding-element-const": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          },
          {
            include: "#binding-element-const"
          }
        ]
      },
      {
        include: "#object-binding-pattern-const"
      },
      {
        include: "#destructuring-variable-rest-const"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "object-binding-element-propertyName": {
    begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
    end: "(:)",
    endCaptures: {
      "0": {
        name: "punctuation.destructuring.ts"
      }
    },
    patterns: [
      {
        include: "#string"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#numeric-literal"
      },
      {
        name: "variable.object.property.ts",
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  },
  "binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#regex"
      },
      {
        include: "#object-binding-pattern"
      },
      {
        include: "#array-binding-pattern"
      },
      {
        include: "#destructuring-variable-rest"
      },
      {
        include: "#variable-initializer"
      }
    ]
  },
  "binding-element-const": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#regex"
      },
      {
        include: "#object-binding-pattern-const"
      },
      {
        include: "#array-binding-pattern-const"
      },
      {
        include: "#destructuring-variable-rest-const"
      },
      {
        include: "#variable-initializer"
      }
    ]
  },
  "destructuring-variable-rest": {
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)",
    captures: {
      "1": {
        name: "keyword.operator.rest.ts"
      },
      "2": {
        name: "meta.definition.variable.ts variable.other.readwrite.ts"
      }
    }
  },
  "destructuring-variable-rest-const": {
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)",
    captures: {
      "1": {
        name: "keyword.operator.rest.ts"
      },
      "2": {
        name: "meta.definition.variable.ts variable.other.constant.ts"
      }
    }
  },
  "object-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.ts"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.object.ts"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.object.ts"
      }
    },
    patterns: [
      {
        include: "#object-binding-element"
      }
    ]
  },
  "object-binding-pattern-const": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.ts"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.object.ts"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.object.ts"
      }
    },
    patterns: [
      {
        include: "#object-binding-element-const"
      }
    ]
  },
  "array-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.ts"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.array.ts"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.array.ts"
      }
    },
    patterns: [
      {
        include: "#binding-element"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "array-binding-pattern-const": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.ts"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.array.ts"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.array.ts"
      }
    },
    patterns: [
      {
        include: "#binding-element-const"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "parameter-name": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)",
        captures: {
          "1": {
            name: "storage.modifier.ts"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "1": {
            name: "storage.modifier.ts"
          },
          "2": {
            name: "keyword.operator.rest.ts"
          },
          "3": {
            name: "entity.name.function.ts variable.language.this.ts"
          },
          "4": {
            name: "entity.name.function.ts"
          },
          "5": {
            name: "keyword.operator.optional.ts"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)",
        captures: {
          "1": {
            name: "storage.modifier.ts"
          },
          "2": {
            name: "keyword.operator.rest.ts"
          },
          "3": {
            name: "variable.parameter.ts variable.language.this.ts"
          },
          "4": {
            name: "variable.parameter.ts"
          },
          "5": {
            name: "keyword.operator.optional.ts"
          }
        }
      }
    ]
  },
  "destructuring-parameter": {
    patterns: [
      {
        name: "meta.parameter.object-binding-pattern.ts",
        begin: "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\{)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.rest.ts"
          },
          "2": {
            name: "punctuation.definition.binding-pattern.object.ts"
          }
        },
        end: "\\}",
        endCaptures: {
          "0": {
            name: "punctuation.definition.binding-pattern.object.ts"
          }
        },
        patterns: [
          {
            include: "#parameter-object-binding-element"
          }
        ]
      },
      {
        name: "meta.paramter.array-binding-pattern.ts",
        begin: "(?<!=|:)\\s*(?:(\\.\\.\\.)\\s*)?(\\[)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.rest.ts"
          },
          "2": {
            name: "punctuation.definition.binding-pattern.array.ts"
          }
        },
        end: "\\]",
        endCaptures: {
          "0": {
            name: "punctuation.definition.binding-pattern.array.ts"
          }
        },
        patterns: [
          {
            include: "#parameter-binding-element"
          },
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  },
  "parameter-object-binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))",
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          },
          {
            include: "#parameter-binding-element"
          }
        ]
      },
      {
        include: "#parameter-object-binding-pattern"
      },
      {
        include: "#destructuring-parameter-rest"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "parameter-binding-element": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#regex"
      },
      {
        include: "#parameter-object-binding-pattern"
      },
      {
        include: "#parameter-array-binding-pattern"
      },
      {
        include: "#destructuring-parameter-rest"
      },
      {
        include: "#variable-initializer"
      }
    ]
  },
  "destructuring-parameter-rest": {
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)",
    captures: {
      "1": {
        name: "keyword.operator.rest.ts"
      },
      "2": {
        name: "variable.parameter.ts"
      }
    }
  },
  "parameter-object-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.ts"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.object.ts"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.object.ts"
      }
    },
    patterns: [
      {
        include: "#parameter-object-binding-element"
      }
    ]
  },
  "parameter-array-binding-pattern": {
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.rest.ts"
      },
      "2": {
        name: "punctuation.definition.binding-pattern.array.ts"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.binding-pattern.array.ts"
      }
    },
    patterns: [
      {
        include: "#parameter-binding-element"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "field-declaration": {
    name: "meta.field.declaration.ts",
    begin: "(?x)(?<!\\()(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s+)?(?=\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|\\}|$))",
    beginCaptures: {
      "1": {
        name: "storage.modifier.ts"
      }
    },
    end: "(?x)(?=\\}|;|,|$|(^(?!\\s*((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|(\\#?[_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(?:(?:(\\?)|(\\!))\\s*)?(=|:|;|,|$))))|(?<=\\})",
    patterns: [
      {
        include: "#variable-initializer"
      },
      {
        include: "#type-annotation"
      },
      {
        include: "#string"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#comment"
      },
      {
        match: "(?x)(\\#?[_$[:alpha:]][_$[:alnum:]]*)(?:(\\?)|(\\!))?(?=\\s*\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "1": {
            name: "meta.definition.property.ts entity.name.function.ts"
          },
          "2": {
            name: "keyword.operator.optional.ts"
          },
          "3": {
            name: "keyword.operator.definiteassignment.ts"
          }
        }
      },
      {
        name: "meta.definition.property.ts variable.object.property.ts",
        match: "\\#?[_$[:alpha:]][_$[:alnum:]]*"
      },
      {
        name: "keyword.operator.optional.ts",
        match: "\\?"
      },
      {
        name: "keyword.operator.definiteassignment.ts",
        match: "\\!"
      }
    ]
  },
  "variable-initializer": {
    patterns: [
      {
        begin: "(?<!=|!)(=)(?!=)(?=\\s*\\S)(?!\\s*.*=>\\s*$)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.ts"
          }
        },
        end: "(?=$|^|[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        begin: "(?<!=|!)(=)(?!=)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.ts"
          }
        },
        end: "(?=[,);}\\]]|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(of|in)\\s+))|(?=^\\s*$)|(?<=\\S)(?<!=)(?=\\s*$)",
        patterns: [
          {
            include: "#expression"
          }
        ]
      }
    ]
  },
  "function-declaration": {
    name: "meta.function.ts",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.ts"
      },
      "2": {
        name: "storage.modifier.ts"
      },
      "3": {
        name: "storage.modifier.async.ts"
      },
      "4": {
        name: "storage.type.function.ts"
      },
      "5": {
        name: "keyword.generator.asterisk.ts"
      },
      "6": {
        name: "meta.definition.function.ts entity.name.function.ts"
      }
    },
    end: "(?=;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))|(?<=\\})",
    patterns: [
      {
        include: "#function-name"
      },
      {
        include: "#function-body"
      }
    ]
  },
  "function-expression": {
    name: "meta.function.expression.ts",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*",
    beginCaptures: {
      "1": {
        name: "storage.modifier.async.ts"
      },
      "2": {
        name: "storage.type.function.ts"
      },
      "3": {
        name: "keyword.generator.asterisk.ts"
      },
      "4": {
        name: "meta.definition.function.ts entity.name.function.ts"
      }
    },
    end: "(?=;)|(?<=\\})",
    patterns: [
      {
        include: "#function-name"
      },
      {
        include: "#single-line-comment-consuming-line-ending"
      },
      {
        include: "#function-body"
      }
    ]
  },
  "function-name": {
    name: "meta.definition.function.ts entity.name.function.ts",
    match: "[_$[:alpha:]][_$[:alnum:]]*"
  },
  "function-body": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#function-parameters"
      },
      {
        include: "#return-type"
      },
      {
        include: "#type-function-return-type"
      },
      {
        include: "#decl-block"
      },
      {
        name: "keyword.generator.asterisk.ts",
        match: "\\*"
      }
    ]
  },
  "method-declaration": {
    patterns: [
      {
        name: "meta.method.declaration.ts",
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?\\s*\\b(constructor)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        beginCaptures: {
          "1": {
            name: "storage.modifier.ts"
          },
          "2": {
            name: "storage.modifier.ts"
          },
          "3": {
            name: "storage.modifier.ts"
          },
          "4": {
            name: "storage.modifier.async.ts"
          },
          "5": {
            name: "storage.type.ts"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#method-declaration-name"
          },
          {
            include: "#function-body"
          }
        ]
      },
      {
        name: "meta.method.declaration.ts",
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:(?:\\s*\\b(new)\\b(?!:)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|(?:(\\*)\\s*)?)(?=\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
        beginCaptures: {
          "1": {
            name: "storage.modifier.ts"
          },
          "2": {
            name: "storage.modifier.ts"
          },
          "3": {
            name: "storage.modifier.ts"
          },
          "4": {
            name: "storage.modifier.async.ts"
          },
          "5": {
            name: "keyword.operator.new.ts"
          },
          "6": {
            name: "keyword.generator.asterisk.ts"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#method-declaration-name"
          },
          {
            include: "#function-body"
          }
        ]
      },
      {
        name: "meta.method.declaration.ts",
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(override)\\s+)?(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
        beginCaptures: {
          "1": {
            name: "storage.modifier.ts"
          },
          "2": {
            name: "storage.modifier.ts"
          },
          "3": {
            name: "storage.modifier.ts"
          },
          "4": {
            name: "storage.modifier.async.ts"
          },
          "5": {
            name: "storage.type.property.ts"
          },
          "6": {
            name: "keyword.generator.asterisk.ts"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#method-declaration-name"
          },
          {
            include: "#function-body"
          }
        ]
      }
    ]
  },
  "object-literal-method-declaration": {
    name: "meta.method.declaration.ts",
    begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
    beginCaptures: {
      "1": {
        name: "storage.modifier.async.ts"
      },
      "2": {
        name: "storage.type.property.ts"
      },
      "3": {
        name: "keyword.generator.asterisk.ts"
      }
    },
    end: "(?=\\}|;|,)|(?<=\\})",
    patterns: [
      {
        include: "#method-declaration-name"
      },
      {
        include: "#function-body"
      },
      {
        begin: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=\\s*(((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?[\\(])",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.ts"
          },
          "2": {
            name: "storage.type.property.ts"
          },
          "3": {
            name: "keyword.generator.asterisk.ts"
          }
        },
        end: "(?=\\(|\\<)",
        patterns: [
          {
            include: "#method-declaration-name"
          }
        ]
      }
    ]
  },
  "method-declaration-name": {
    begin: "(?x)(?=((\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$))|([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??)\\s*[\\(\\<])",
    end: "(?=\\(|\\<)",
    patterns: [
      {
        include: "#string"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#numeric-literal"
      },
      {
        name: "meta.definition.method.ts entity.name.function.ts",
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      },
      {
        name: "keyword.operator.optional.ts",
        match: "\\?"
      }
    ]
  },
  "arrow-function": {
    patterns: [
      {
        name: "meta.arrow.ts",
        match: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)\\s*(?==>)",
        captures: {
          "1": {
            name: "storage.modifier.async.ts"
          },
          "2": {
            name: "variable.parameter.ts"
          }
        }
      },
      {
        name: "meta.arrow.ts",
        begin: "(?x) (?:\n  (?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(\\basync)\n)? ((?<![})!\\]])\\s*\n  (?=\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  )\n)",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.ts"
          }
        },
        end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#type-parameters"
          },
          {
            include: "#function-parameters"
          },
          {
            include: "#arrow-return-type"
          },
          {
            include: "#possibly-arrow-return-type"
          }
        ]
      },
      {
        name: "meta.arrow.ts",
        begin: "=>",
        beginCaptures: {
          "0": {
            name: "storage.type.function.arrow.ts"
          }
        },
        end: "((?<=\\}|\\S)(?<!=>)|((?!\\{)(?=\\S)))(?!\\/[\\/\\*])",
        patterns: [
          {
            include: "#single-line-comment-consuming-line-ending"
          },
          {
            include: "#decl-block"
          },
          {
            include: "#expression"
          }
        ]
      }
    ]
  },
  "indexer-declaration": {
    name: "meta.indexer.declaration.ts",
    begin: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=:)",
    beginCaptures: {
      "1": {
        name: "storage.modifier.ts"
      },
      "2": {
        name: "meta.brace.square.ts"
      },
      "3": {
        name: "variable.parameter.ts"
      }
    },
    end: "(\\])\\s*(\\?\\s*)?|$",
    endCaptures: {
      "1": {
        name: "meta.brace.square.ts"
      },
      "2": {
        name: "keyword.operator.optional.ts"
      }
    },
    patterns: [
      {
        include: "#type-annotation"
      }
    ]
  },
  "indexer-mapped-type-declaration": {
    name: "meta.indexer.mappedtype.declaration.ts",
    begin: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([+-])?(readonly)\\s*)?\\s*(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s+(in)\\s+",
    beginCaptures: {
      "1": {
        name: "keyword.operator.type.modifier.ts"
      },
      "2": {
        name: "storage.modifier.ts"
      },
      "3": {
        name: "meta.brace.square.ts"
      },
      "4": {
        name: "entity.name.type.ts"
      },
      "5": {
        name: "keyword.operator.expression.in.ts"
      }
    },
    end: "(\\])([+-])?\\s*(\\?\\s*)?|$",
    endCaptures: {
      "1": {
        name: "meta.brace.square.ts"
      },
      "2": {
        name: "keyword.operator.type.modifier.ts"
      },
      "3": {
        name: "keyword.operator.optional.ts"
      }
    },
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+",
        captures: {
          "1": {
            name: "keyword.control.as.ts"
          }
        }
      },
      {
        include: "#type"
      }
    ]
  },
  "function-parameters": {
    name: "meta.parameters.ts",
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.parameters.begin.ts"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "punctuation.definition.parameters.end.ts"
      }
    },
    patterns: [
      {
        include: "#function-parameters-body"
      }
    ]
  },
  "function-parameters-body": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#decorator"
      },
      {
        include: "#destructuring-parameter"
      },
      {
        include: "#parameter-name"
      },
      {
        include: "#parameter-type-annotation"
      },
      {
        include: "#variable-initializer"
      },
      {
        name: "punctuation.separator.parameter.ts",
        match: ","
      }
    ]
  },
  "class-declaration": {
    name: "meta.class.ts",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(class)\\b(?=\\s+|/[/*])",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.ts"
      },
      "2": {
        name: "storage.modifier.ts"
      },
      "3": {
        name: "storage.modifier.ts"
      },
      "4": {
        name: "storage.type.class.ts"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#class-declaration-or-expression-patterns"
      }
    ]
  },
  "class-expression": {
    name: "meta.class.ts",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(class)\\b(?=\\s+|[<{]|\\/[\\/*])",
    beginCaptures: {
      "1": {
        name: "storage.modifier.ts"
      },
      "2": {
        name: "storage.type.class.ts"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#class-declaration-or-expression-patterns"
      }
    ]
  },
  "class-declaration-or-expression-patterns": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#class-or-interface-heritage"
      },
      {
        match: "[_$[:alpha:]][_$[:alnum:]]*",
        captures: {
          "0": {
            name: "entity.name.type.class.ts"
          }
        }
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#class-or-interface-body"
      }
    ]
  },
  "interface-declaration": {
    name: "meta.interface.ts",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(?:(abstract)\\s+)?\\b(interface)\\b(?=\\s+|/[/*])",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.ts"
      },
      "2": {
        name: "storage.modifier.ts"
      },
      "3": {
        name: "storage.modifier.ts"
      },
      "4": {
        name: "storage.type.interface.ts"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#class-or-interface-heritage"
      },
      {
        match: "[_$[:alpha:]][_$[:alnum:]]*",
        captures: {
          "0": {
            name: "entity.name.type.interface.ts"
          }
        }
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#class-or-interface-body"
      }
    ]
  },
  "class-or-interface-heritage": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:\\b(extends|implements)\\b)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "storage.modifier.ts"
      }
    },
    end: "(?=\\{)",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#class-or-interface-heritage"
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#expressionWithoutIdentifiers"
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s*\\??\\.\\s*[_$[:alpha:]][_$[:alnum:]]*)*\\s*)",
        captures: {
          "1": {
            name: "entity.name.type.module.ts"
          },
          "2": {
            name: "punctuation.accessor.ts"
          },
          "3": {
            name: "punctuation.accessor.optional.ts"
          }
        }
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "entity.other.inherited-class.ts"
          }
        }
      },
      {
        include: "#expressionPunctuations"
      }
    ]
  },
  "class-or-interface-body": {
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.ts"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.ts"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#decorator"
      },
      {
        begin: "(?<=:)\\s*",
        end: "(?=\\s|[;),}\\]:\\-\\+]|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        include: "#method-declaration"
      },
      {
        include: "#indexer-declaration"
      },
      {
        include: "#field-declaration"
      },
      {
        include: "#string"
      },
      {
        include: "#type-annotation"
      },
      {
        include: "#variable-initializer"
      },
      {
        include: "#access-modifier"
      },
      {
        include: "#property-accessor"
      },
      {
        include: "#async-modifier"
      },
      {
        include: "#after-operator-block-as-object-literal"
      },
      {
        include: "#decl-block"
      },
      {
        include: "#expression"
      },
      {
        include: "#punctuation-comma"
      },
      {
        include: "#punctuation-semicolon"
      }
    ]
  },
  "access-modifier": {
    name: "storage.modifier.ts",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(abstract|declare|override|public|protected|private|readonly|static)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "property-accessor": {
    name: "storage.type.property.ts",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(get|set)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "async-modifier": {
    name: "storage.modifier.async.ts",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(async)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "enum-declaration": {
    name: "meta.enum.declaration.ts",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?(?:\\b(const)\\s+)?\\b(enum)\\s+([_$[:alpha:]][_$[:alnum:]]*)",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.ts"
      },
      "2": {
        name: "storage.modifier.ts"
      },
      "3": {
        name: "storage.modifier.ts"
      },
      "4": {
        name: "storage.type.enum.ts"
      },
      "5": {
        name: "entity.name.type.enum.ts"
      }
    },
    end: "(?<=\\})",
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "\\{",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.block.ts"
          }
        },
        end: "\\}",
        endCaptures: {
          "0": {
            name: "punctuation.definition.block.ts"
          }
        },
        patterns: [
          {
            include: "#comment"
          },
          {
            begin: "([_$[:alpha:]][_$[:alnum:]]*)",
            beginCaptures: {
              "0": {
                name: "variable.other.enummember.ts"
              }
            },
            end: "(?=,|\\}|$)",
            patterns: [
              {
                include: "#comment"
              },
              {
                include: "#variable-initializer"
              }
            ]
          },
          {
            begin: "(?=((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\])))",
            end: "(?=,|\\}|$)",
            patterns: [
              {
                include: "#string"
              },
              {
                include: "#array-literal"
              },
              {
                include: "#comment"
              },
              {
                include: "#variable-initializer"
              }
            ]
          },
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  },
  "namespace-declaration": {
    name: "meta.namespace.declaration.ts",
    begin: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(namespace|module)\\s+(?=[_$[:alpha:]\"'`]))",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.ts"
      },
      "2": {
        name: "storage.modifier.ts"
      },
      "3": {
        name: "storage.type.namespace.ts"
      }
    },
    end: "(?<=\\})|(?=;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        name: "entity.name.type.module.ts",
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      },
      {
        include: "#punctuation-accessor"
      },
      {
        include: "#decl-block"
      }
    ]
  },
  "type-alias-declaration": {
    name: "meta.type.declaration.ts",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(type)\\b\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.ts"
      },
      "2": {
        name: "storage.modifier.ts"
      },
      "3": {
        name: "storage.type.type.ts"
      },
      "4": {
        name: "entity.name.type.alias.ts"
      }
    },
    end: "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#type-parameters"
      },
      {
        begin: "(=)\\s*(intrinsic)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.ts"
          },
          "2": {
            name: "keyword.control.intrinsic.ts"
          }
        },
        end: "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        begin: "(=)\\s*",
        beginCaptures: {
          "1": {
            name: "keyword.operator.assignment.ts"
          }
        },
        end: "(?=\\}|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "import-equals-declaration": {
    patterns: [
      {
        name: "meta.import-equals.external.ts",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(require)\\s*(\\()",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.ts"
          },
          "2": {
            name: "storage.modifier.ts"
          },
          "3": {
            name: "keyword.control.import.ts"
          },
          "4": {
            name: "keyword.control.type.ts"
          },
          "5": {
            name: "variable.other.readwrite.alias.ts"
          },
          "6": {
            name: "keyword.operator.assignment.ts"
          },
          "7": {
            name: "keyword.control.require.ts"
          },
          "8": {
            name: "meta.brace.round.ts"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.ts"
          }
        },
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#string"
          }
        ]
      },
      {
        name: "meta.import-equals.internal.ts",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type))?\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(?!require\\b)",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.ts"
          },
          "2": {
            name: "storage.modifier.ts"
          },
          "3": {
            name: "keyword.control.import.ts"
          },
          "4": {
            name: "keyword.control.type.ts"
          },
          "5": {
            name: "variable.other.readwrite.alias.ts"
          },
          "6": {
            name: "keyword.operator.assignment.ts"
          }
        },
        end: "(?=;|$|^)",
        patterns: [
          {
            include: "#single-line-comment-consuming-line-ending"
          },
          {
            include: "#comment"
          },
          {
            match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))",
            captures: {
              "1": {
                name: "entity.name.type.module.ts"
              },
              "2": {
                name: "punctuation.accessor.ts"
              },
              "3": {
                name: "punctuation.accessor.optional.ts"
              }
            }
          },
          {
            name: "variable.other.readwrite.ts",
            match: "([_$[:alpha:]][_$[:alnum:]]*)"
          }
        ]
      }
    ]
  },
  "import-declaration": {
    name: "meta.import.ts",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bexport)\\s+)?(?:(\\bdeclare)\\s+)?\\b(import)(?:\\s+(type)(?!\\s+from))?(?!\\s*[:\\(])(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "keyword.control.export.ts"
      },
      "2": {
        name: "storage.modifier.ts"
      },
      "3": {
        name: "keyword.control.import.ts"
      },
      "4": {
        name: "keyword.control.type.ts"
      }
    },
    end: "(?<!^import|[^\\._$[:alnum:]]import)(?=;|$|^)",
    patterns: [
      {
        include: "#single-line-comment-consuming-line-ending"
      },
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        begin: `(?<=^import|[^\\._$[:alnum:]]import)(?!\\s*["'])`,
        end: "\\bfrom\\b",
        endCaptures: {
          "0": {
            name: "keyword.control.from.ts"
          }
        },
        patterns: [
          {
            include: "#import-export-declaration"
          }
        ]
      },
      {
        include: "#import-export-declaration"
      }
    ]
  },
  "export-declaration": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)\\s+(as)\\s+(namespace)\\s+([_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "keyword.control.export.ts"
          },
          "2": {
            name: "keyword.control.as.ts"
          },
          "3": {
            name: "storage.type.namespace.ts"
          },
          "4": {
            name: "entity.name.type.module.ts"
          }
        }
      },
      {
        name: "meta.export.default.ts",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?(?:(?:\\s*(=))|(?:\\s+(default)(?=\\s+)))",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.ts"
          },
          "2": {
            name: "keyword.control.type.ts"
          },
          "3": {
            name: "keyword.operator.assignment.ts"
          },
          "4": {
            name: "keyword.control.default.ts"
          }
        },
        end: "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#interface-declaration"
          },
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "meta.export.ts",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(export)(?:\\s+(type))?\\b(?!(\\$)|(\\s*:))((?=\\s*[\\{*])|((?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s|,))(?!\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b)))",
        beginCaptures: {
          "1": {
            name: "keyword.control.export.ts"
          },
          "2": {
            name: "keyword.control.type.ts"
          }
        },
        end: "(?=$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
        patterns: [
          {
            include: "#import-export-declaration"
          }
        ]
      }
    ]
  },
  "import-export-declaration": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#import-export-block"
      },
      {
        name: "keyword.control.from.ts",
        match: "\\bfrom\\b"
      },
      {
        include: "#import-export-clause"
      }
    ]
  },
  "import-export-block": {
    name: "meta.block.ts",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.ts"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.ts"
      }
    },
    patterns: [
      {
        include: "#import-export-clause"
      }
    ]
  },
  "import-export-clause": {
    patterns: [
      {
        include: "#comment"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(\\bdefault)|(\\*)|(\\b[_$[:alpha:]][_$[:alnum:]]*))\\s+(as)\\s+(?:(default(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|([_$[:alpha:]][_$[:alnum:]]*))",
        captures: {
          "1": {
            name: "keyword.control.default.ts"
          },
          "2": {
            name: "constant.language.import-export-all.ts"
          },
          "3": {
            name: "variable.other.readwrite.ts"
          },
          "4": {
            name: "keyword.control.as.ts"
          },
          "5": {
            name: "keyword.control.default.ts"
          },
          "6": {
            name: "variable.other.readwrite.alias.ts"
          }
        }
      },
      {
        include: "#punctuation-comma"
      },
      {
        name: "constant.language.import-export-all.ts",
        match: "\\*"
      },
      {
        name: "keyword.control.default.ts",
        match: "\\b(default)\\b"
      },
      {
        name: "variable.other.readwrite.alias.ts",
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  },
  "switch-statement": {
    name: "switch-statement.expr.ts",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bswitch\\s*\\()",
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.ts"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        name: "switch-expression.expr.ts",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(switch)\\s*(\\()",
        beginCaptures: {
          "1": {
            name: "keyword.control.switch.ts"
          },
          "2": {
            name: "meta.brace.round.ts"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.ts"
          }
        },
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "switch-block.expr.ts",
        begin: "\\{",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.block.ts"
          }
        },
        end: "(?=\\})",
        patterns: [
          {
            name: "case-clause.expr.ts",
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(case|default(?=:))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
            beginCaptures: {
              "1": {
                name: "keyword.control.switch.ts"
              }
            },
            end: "(?=:)",
            patterns: [
              {
                include: "#expression"
              }
            ]
          },
          {
            begin: "(:)\\s*(\\{)",
            beginCaptures: {
              "1": {
                name: "case-clause.expr.ts punctuation.definition.section.case-statement.ts"
              },
              "2": {
                name: "meta.block.ts punctuation.definition.block.ts"
              }
            },
            end: "\\}",
            endCaptures: {
              "0": {
                name: "meta.block.ts punctuation.definition.block.ts"
              }
            },
            contentName: "meta.block.ts",
            patterns: [
              {
                include: "#statements"
              }
            ]
          },
          {
            match: "(:)",
            captures: {
              "0": {
                name: "case-clause.expr.ts punctuation.definition.section.case-statement.ts"
              }
            }
          },
          {
            include: "#statements"
          }
        ]
      }
    ]
  },
  "for-loop": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))for(?=((\\s+|(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*))await)?\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)?(\\())",
    beginCaptures: {
      "0": {
        name: "keyword.control.loop.ts"
      }
    },
    end: "(?<=\\))",
    patterns: [
      {
        include: "#comment"
      },
      {
        name: "keyword.control.loop.ts",
        match: "await"
      },
      {
        begin: "\\(",
        beginCaptures: {
          "0": {
            name: "meta.brace.round.ts"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.ts"
          }
        },
        patterns: [
          {
            include: "#var-expr"
          },
          {
            include: "#expression"
          },
          {
            include: "#punctuation-semicolon"
          }
        ]
      }
    ]
  },
  "if-statement": {
    patterns: [
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?=\\bif\\s*(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))\\s*(?!\\{))",
        end: "(?=;|$|\\})",
        patterns: [
          {
            include: "#comment"
          },
          {
            begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(if)\\s*(\\()",
            beginCaptures: {
              "1": {
                name: "keyword.control.conditional.ts"
              },
              "2": {
                name: "meta.brace.round.ts"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "meta.brace.round.ts"
              }
            },
            patterns: [
              {
                include: "#expression"
              }
            ]
          },
          {
            name: "string.regexp.ts",
            begin: "(?<=\\))\\s*\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))",
            beginCaptures: {
              "0": {
                name: "punctuation.definition.string.begin.ts"
              }
            },
            end: "(/)([dgimsuy]*)",
            endCaptures: {
              "1": {
                name: "punctuation.definition.string.end.ts"
              },
              "2": {
                name: "keyword.other.ts"
              }
            },
            patterns: [
              {
                include: "#regexp"
              }
            ]
          },
          {
            include: "#statements"
          }
        ]
      }
    ]
  },
  "decl-block": {
    name: "meta.block.ts",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.ts"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.ts"
      }
    },
    patterns: [
      {
        include: "#statements"
      }
    ]
  },
  "after-operator-block-as-object-literal": {
    name: "meta.objectliteral.ts",
    begin: "(?<!\\+\\+|--)(?<=[:=(,\\[?+!>]|^await|[^\\._$[:alnum:]]await|^return|[^\\._$[:alnum:]]return|^yield|[^\\._$[:alnum:]]yield|^throw|[^\\._$[:alnum:]]throw|^in|[^\\._$[:alnum:]]in|^of|[^\\._$[:alnum:]]of|^typeof|[^\\._$[:alnum:]]typeof|&&|\\|\\||\\*)\\s*(\\{)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.block.ts"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.ts"
      }
    },
    patterns: [
      {
        include: "#object-member"
      }
    ]
  },
  "object-literal": {
    name: "meta.objectliteral.ts",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.ts"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.ts"
      }
    },
    patterns: [
      {
        include: "#object-member"
      }
    ]
  },
  "object-member": {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#object-literal-method-declaration"
      },
      {
        name: "meta.object.member.ts meta.object-literal.key.ts",
        begin: "(?=\\[)",
        end: "(?=:)|((?<=[\\]])(?=\\s*[\\(\\<]))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#array-literal"
          }
        ]
      },
      {
        name: "meta.object.member.ts meta.object-literal.key.ts",
        begin: "(?=[\\'\\\"\\`])",
        end: "(?=:)|((?<=[\\'\\\"\\`])(?=((\\s*[\\(\\<,}])|(\\s+(as)\\s+))))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#string"
          }
        ]
      },
      {
        name: "meta.object.member.ts meta.object-literal.key.ts",
        begin: "(?x)(?=(\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$))|(\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$))|((?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)))",
        end: "(?=:)|(?=\\s*([\\(\\<,}])|(\\s+as\\s+))",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#numeric-literal"
          }
        ]
      },
      {
        name: "meta.method.declaration.ts",
        begin: "(?<=[\\]\\'\\\"\\`])(?=\\s*[\\(\\<])",
        end: "(?=\\}|;|,)|(?<=\\})",
        patterns: [
          {
            include: "#function-body"
          }
        ]
      },
      {
        name: "meta.object.member.ts",
        match: "(?![_$[:alpha:]])([[:digit:]]+)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)",
        captures: {
          "0": {
            name: "meta.object-literal.key.ts"
          },
          "1": {
            name: "constant.numeric.decimal.ts"
          }
        }
      },
      {
        name: "meta.object.member.ts",
        match: "(?x)(?:([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:(\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/)*\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "0": {
            name: "meta.object-literal.key.ts"
          },
          "1": {
            name: "entity.name.function.ts"
          }
        }
      },
      {
        name: "meta.object.member.ts",
        match: "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*:)",
        captures: {
          "0": {
            name: "meta.object-literal.key.ts"
          }
        }
      },
      {
        name: "meta.object.member.ts",
        begin: "\\.\\.\\.",
        beginCaptures: {
          "0": {
            name: "keyword.operator.spread.ts"
          }
        },
        end: "(?=,|\\})",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "meta.object.member.ts",
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=,|\\}|$|\\/\\/|\\/\\*)",
        captures: {
          "1": {
            name: "variable.other.readwrite.ts"
          }
        }
      },
      {
        name: "meta.object.member.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*([,}]|$))",
        captures: {
          "1": {
            name: "keyword.control.as.ts"
          },
          "2": {
            name: "storage.modifier.ts"
          }
        }
      },
      {
        name: "meta.object.member.ts",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+",
        beginCaptures: {
          "1": {
            name: "keyword.control.as.ts"
          }
        },
        end: "(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|^|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "meta.object.member.ts",
        begin: "(?=[_$[:alpha:]][_$[:alnum:]]*\\s*=)",
        end: "(?=,|\\}|$|\\/\\/|\\/\\*)",
        patterns: [
          {
            include: "#expression"
          }
        ]
      },
      {
        name: "meta.object.member.ts",
        begin: ":",
        beginCaptures: {
          "0": {
            name: "meta.object-literal.key.ts punctuation.separator.key-value.ts"
          }
        },
        end: "(?=,|\\})",
        patterns: [
          {
            begin: "(?<=:)\\s*(async)?(?=\\s*(<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
            beginCaptures: {
              "1": {
                name: "storage.modifier.async.ts"
              }
            },
            end: "(?<=\\))",
            patterns: [
              {
                include: "#type-parameters"
              },
              {
                begin: "\\(",
                beginCaptures: {
                  "0": {
                    name: "meta.brace.round.ts"
                  }
                },
                end: "\\)",
                endCaptures: {
                  "0": {
                    name: "meta.brace.round.ts"
                  }
                },
                patterns: [
                  {
                    include: "#expression-inside-possibly-arrow-parens"
                  }
                ]
              }
            ]
          },
          {
            begin: "(?<=:)\\s*(async)?\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
            beginCaptures: {
              "1": {
                name: "storage.modifier.async.ts"
              },
              "2": {
                name: "meta.brace.round.ts"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "meta.brace.round.ts"
              }
            },
            patterns: [
              {
                include: "#expression-inside-possibly-arrow-parens"
              }
            ]
          },
          {
            begin: "(?<=:)\\s*(async)?\\s*(?=\\<\\s*$)",
            beginCaptures: {
              "1": {
                name: "storage.modifier.async.ts"
              }
            },
            end: "(?<=\\>)",
            patterns: [
              {
                include: "#type-parameters"
              }
            ]
          },
          {
            begin: "(?<=\\>)\\s*(\\()(?=\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
            beginCaptures: {
              "1": {
                name: "meta.brace.round.ts"
              }
            },
            end: "\\)",
            endCaptures: {
              "0": {
                name: "meta.brace.round.ts"
              }
            },
            patterns: [
              {
                include: "#expression-inside-possibly-arrow-parens"
              }
            ]
          },
          {
            include: "#possibly-arrow-return-type"
          },
          {
            include: "#expression"
          }
        ]
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "ternary-expression": {
    begin: "(?!\\?\\.\\s*[^[:digit:]])(\\?)(?!\\?)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.ternary.ts"
      }
    },
    end: "\\s*(:)",
    endCaptures: {
      "1": {
        name: "keyword.operator.ternary.ts"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "function-call": {
    patterns: [
      {
        begin: "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())",
        end: "(?<=\\))(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())",
        patterns: [
          {
            name: "meta.function-call.ts",
            begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))",
            end: "(?=\\s*(?:(\\?\\.\\s*)|(\\!))?((<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?\\())",
            patterns: [
              {
                include: "#function-call-target"
              }
            ]
          },
          {
            include: "#comment"
          },
          {
            include: "#function-call-optionals"
          },
          {
            include: "#type-arguments"
          },
          {
            include: "#paren-expression"
          }
        ]
      },
      {
        begin: "(?=(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))",
        end: "(?<=\\>)(?!(((([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))|(?<=[\\)]))(<\\s*[\\{\\[\\(]\\s*$))",
        patterns: [
          {
            name: "meta.function-call.ts",
            begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)(\\s*\\??\\.\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*))*)|(\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*))",
            end: "(?=(<\\s*[\\{\\[\\(]\\s*$))",
            patterns: [
              {
                include: "#function-call-target"
              }
            ]
          },
          {
            include: "#comment"
          },
          {
            include: "#function-call-optionals"
          },
          {
            include: "#type-arguments"
          }
        ]
      }
    ]
  },
  "function-call-target": {
    patterns: [
      {
        include: "#support-function-call-identifiers"
      },
      {
        name: "entity.name.function.ts",
        match: "(\\#?[_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  },
  "function-call-optionals": {
    patterns: [
      {
        name: "meta.function-call.ts punctuation.accessor.optional.ts",
        match: "\\?\\."
      },
      {
        name: "meta.function-call.ts keyword.operator.definiteassignment.ts",
        match: "\\!"
      }
    ]
  },
  "support-function-call-identifiers": {
    patterns: [
      {
        include: "#literal"
      },
      {
        include: "#support-objects"
      },
      {
        include: "#object-identifiers"
      },
      {
        include: "#punctuation-accessor"
      },
      {
        name: "keyword.operator.expression.import.ts",
        match: "(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*[\\(]\\s*[\\\"\\'\\`]))"
      }
    ]
  },
  "new-expr": {
    name: "new.expr.ts",
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "keyword.operator.new.ts"
      }
    },
    end: "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))",
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  "instanceof-expr": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(instanceof)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "1": {
        name: "keyword.operator.expression.instanceof.ts"
      }
    },
    end: "(?<=\\))|(?=[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|(([\\&\\~\\^\\|]\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s+instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.)))|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))function((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))",
    patterns: [
      {
        include: "#type"
      }
    ]
  },
  "paren-expression-possibly-arrow": {
    patterns: [
      {
        begin: "(?<=[(=,])\\s*(async)?(?=\\s*((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\(\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.ts"
          }
        },
        end: "(?<=\\))",
        patterns: [
          {
            include: "#paren-expression-possibly-arrow-with-typeparameters"
          }
        ]
      },
      {
        begin: "(?<=[(=,]|=>|^return|[^\\._$[:alnum:]]return)\\s*(async)?(?=\\s*((((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*))?\\()|(<))\\s*$)",
        beginCaptures: {
          "1": {
            name: "storage.modifier.async.ts"
          }
        },
        end: "(?<=\\))",
        patterns: [
          {
            include: "#paren-expression-possibly-arrow-with-typeparameters"
          }
        ]
      },
      {
        include: "#possibly-arrow-return-type"
      }
    ]
  },
  "paren-expression-possibly-arrow-with-typeparameters": {
    patterns: [
      {
        include: "#type-parameters"
      },
      {
        begin: "\\(",
        beginCaptures: {
          "0": {
            name: "meta.brace.round.ts"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "meta.brace.round.ts"
          }
        },
        patterns: [
          {
            include: "#expression-inside-possibly-arrow-parens"
          }
        ]
      }
    ]
  },
  "expression-inside-possibly-arrow-parens": {
    patterns: [
      {
        include: "#expressionWithoutIdentifiers"
      },
      {
        include: "#comment"
      },
      {
        include: "#string"
      },
      {
        include: "#decorator"
      },
      {
        include: "#destructuring-parameter"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|protected|private|readonly)\\s+(?=(override|public|protected|private|readonly)\\s+)",
        captures: {
          "1": {
            name: "storage.modifier.ts"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*\n# function assignment |\n(=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)) |\n# typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>\n(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))) |\n(:\\s*(=>|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(<[^<>]*>)|[^<>(),=])+=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n)))",
        captures: {
          "1": {
            name: "storage.modifier.ts"
          },
          "2": {
            name: "keyword.operator.rest.ts"
          },
          "3": {
            name: "entity.name.function.ts variable.language.this.ts"
          },
          "4": {
            name: "entity.name.function.ts"
          },
          "5": {
            name: "keyword.operator.optional.ts"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(override|public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*(\\??)(?=\\s*[:,]|$)",
        captures: {
          "1": {
            name: "storage.modifier.ts"
          },
          "2": {
            name: "keyword.operator.rest.ts"
          },
          "3": {
            name: "variable.parameter.ts variable.language.this.ts"
          },
          "4": {
            name: "variable.parameter.ts"
          },
          "5": {
            name: "keyword.operator.optional.ts"
          }
        }
      },
      {
        include: "#type-annotation"
      },
      {
        include: "#variable-initializer"
      },
      {
        name: "punctuation.separator.parameter.ts",
        match: ","
      },
      {
        include: "#identifiers"
      },
      {
        include: "#expressionPunctuations"
      }
    ]
  },
  "paren-expression": {
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "meta.brace.round.ts"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "meta.brace.round.ts"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  cast: {
    patterns: [
      {
        name: "cast.expr.ts",
        match: "\\s*(<)\\s*(const)\\s*(>)",
        captures: {
          "1": {
            name: "meta.brace.angle.ts"
          },
          "2": {
            name: "storage.modifier.ts"
          },
          "3": {
            name: "meta.brace.angle.ts"
          }
        }
      },
      {
        name: "cast.expr.ts",
        begin: "(?:(?<!\\+\\+|--)(?<=^return|[^\\._$[:alnum:]]return|^throw|[^\\._$[:alnum:]]throw|^yield|[^\\._$[:alnum:]]yield|^await|[^\\._$[:alnum:]]await|^default|[^\\._$[:alnum:]]default|[=(,:>*?\\&\\|\\^]|[^_$[:alnum:]](?:\\+\\+|\\-\\-)|[^\\+]\\+|[^\\-]\\-))\\s*(<)(?!<?\\=)(?!\\s*$)",
        beginCaptures: {
          "1": {
            name: "meta.brace.angle.ts"
          }
        },
        end: "(\\>)",
        endCaptures: {
          "1": {
            name: "meta.brace.angle.ts"
          }
        },
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "cast.expr.ts",
        begin: "(?:(?<=^))\\s*(<)(?=[_$[:alpha:]][_$[:alnum:]]*\\s*>)",
        beginCaptures: {
          "1": {
            name: "meta.brace.angle.ts"
          }
        },
        end: "(\\>)",
        endCaptures: {
          "1": {
            name: "meta.brace.angle.ts"
          }
        },
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "expression-operators": {
    patterns: [
      {
        name: "keyword.control.flow.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(await)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?=\\s*\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*\\*)",
        beginCaptures: {
          "1": {
            name: "keyword.control.flow.ts"
          }
        },
        end: "\\*",
        endCaptures: {
          "0": {
            name: "keyword.generator.asterisk.ts"
          }
        },
        patterns: [
          {
            include: "#comment"
          }
        ]
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(yield)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?:\\s*(\\*))?",
        captures: {
          "1": {
            name: "keyword.control.flow.ts"
          },
          "2": {
            name: "keyword.generator.asterisk.ts"
          }
        }
      },
      {
        name: "keyword.operator.expression.delete.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))delete(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.expression.in.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))in(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()"
      },
      {
        name: "keyword.operator.expression.of.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))of(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))(?!\\()"
      },
      {
        name: "keyword.operator.expression.instanceof.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))instanceof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.new.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))new(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        include: "#typeof-operator"
      },
      {
        name: "keyword.operator.expression.void.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))void(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+(const)(?=\\s*($|[;,:})\\]]))",
        captures: {
          "1": {
            name: "keyword.control.as.ts"
          },
          "2": {
            name: "storage.modifier.ts"
          }
        }
      },
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+",
        beginCaptures: {
          "1": {
            name: "keyword.control.as.ts"
          }
        },
        end: "(?=^|[;),}\\]:?\\-\\+\\>]|\\|\\||\\&\\&|\\!\\=\\=|$|((?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(as)\\s+)|(\\s+\\<))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "keyword.operator.spread.ts",
        match: "\\.\\.\\."
      },
      {
        name: "keyword.operator.assignment.compound.ts",
        match: "\\*=|(?<!\\()/=|%=|\\+=|\\-="
      },
      {
        name: "keyword.operator.assignment.compound.bitwise.ts",
        match: "\\&=|\\^=|<<=|>>=|>>>=|\\|="
      },
      {
        name: "keyword.operator.bitwise.shift.ts",
        match: "<<|>>>|>>"
      },
      {
        name: "keyword.operator.comparison.ts",
        match: "===|!==|==|!="
      },
      {
        name: "keyword.operator.relational.ts",
        match: "<=|>=|<>|<|>"
      },
      {
        match: "(?<=[_$[:alnum:]])(\\!)\\s*(?:(/=)|(?:(/)(?![/*])))",
        captures: {
          "1": {
            name: "keyword.operator.logical.ts"
          },
          "2": {
            name: "keyword.operator.assignment.compound.ts"
          },
          "3": {
            name: "keyword.operator.arithmetic.ts"
          }
        }
      },
      {
        name: "keyword.operator.logical.ts",
        match: "\\!|&&|\\|\\||\\?\\?"
      },
      {
        name: "keyword.operator.bitwise.ts",
        match: "\\&|~|\\^|\\|"
      },
      {
        name: "keyword.operator.assignment.ts",
        match: "\\="
      },
      {
        name: "keyword.operator.decrement.ts",
        match: "--"
      },
      {
        name: "keyword.operator.increment.ts",
        match: "\\+\\+"
      },
      {
        name: "keyword.operator.arithmetic.ts",
        match: "%|\\*|/|-|\\+"
      },
      {
        begin: "(?<=[_$[:alnum:])\\]])\\s*(?=(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)+(?:(/=)|(?:(/)(?![/*]))))",
        end: "(?:(/=)|(?:(/)(?!\\*([^\\*]|(\\*[^\\/]))*\\*\\/)))",
        endCaptures: {
          "1": {
            name: "keyword.operator.assignment.compound.ts"
          },
          "2": {
            name: "keyword.operator.arithmetic.ts"
          }
        },
        patterns: [
          {
            include: "#comment"
          }
        ]
      },
      {
        match: "(?<=[_$[:alnum:])\\]])\\s*(?:(/=)|(?:(/)(?![/*])))",
        captures: {
          "1": {
            name: "keyword.operator.assignment.compound.ts"
          },
          "2": {
            name: "keyword.operator.arithmetic.ts"
          }
        }
      }
    ]
  },
  "typeof-operator": {
    begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))typeof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
    beginCaptures: {
      "0": {
        name: "keyword.operator.expression.typeof.ts"
      }
    },
    end: "(?=[,);}\\]=>:&|{\\?]|$|;|^\\s*$|(?:^\\s*(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\\b))",
    patterns: [
      {
        include: "#expression"
      }
    ]
  },
  literal: {
    patterns: [
      {
        include: "#numeric-literal"
      },
      {
        include: "#boolean-literal"
      },
      {
        include: "#null-literal"
      },
      {
        include: "#undefined-literal"
      },
      {
        include: "#numericConstant-literal"
      },
      {
        include: "#array-literal"
      },
      {
        include: "#this-literal"
      },
      {
        include: "#super-literal"
      }
    ]
  },
  "array-literal": {
    name: "meta.array.literal.ts",
    begin: "\\s*(\\[)",
    beginCaptures: {
      "1": {
        name: "meta.brace.square.ts"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "meta.brace.square.ts"
      }
    },
    patterns: [
      {
        include: "#expression"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "numeric-literal": {
    patterns: [
      {
        name: "constant.numeric.hex.ts",
        match: "\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$)",
        captures: {
          "1": {
            name: "storage.type.numeric.bigint.ts"
          }
        }
      },
      {
        name: "constant.numeric.binary.ts",
        match: "\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$)",
        captures: {
          "1": {
            name: "storage.type.numeric.bigint.ts"
          }
        }
      },
      {
        name: "constant.numeric.octal.ts",
        match: "\\b(?<!\\$)0(?:o|O)?[0-7][0-7_]*(n)?\\b(?!\\$)",
        captures: {
          "1": {
            name: "storage.type.numeric.bigint.ts"
          }
        }
      },
      {
        match: "(?x)\n(?<!\\$)(?:\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)| # 1.1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # 1.E+3\n  (?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|             # .1E+3\n  (?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|                 # 1E+3\n  (?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|                      # 1.1\n  (?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|                                  # 1.\n  (?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|                                  # .1\n  (?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))                                 # 1\n)(?!\\$)",
        captures: {
          "0": {
            name: "constant.numeric.decimal.ts"
          },
          "1": {
            name: "meta.delimiter.decimal.period.ts"
          },
          "2": {
            name: "storage.type.numeric.bigint.ts"
          },
          "3": {
            name: "meta.delimiter.decimal.period.ts"
          },
          "4": {
            name: "storage.type.numeric.bigint.ts"
          },
          "5": {
            name: "meta.delimiter.decimal.period.ts"
          },
          "6": {
            name: "storage.type.numeric.bigint.ts"
          },
          "7": {
            name: "storage.type.numeric.bigint.ts"
          },
          "8": {
            name: "meta.delimiter.decimal.period.ts"
          },
          "9": {
            name: "storage.type.numeric.bigint.ts"
          },
          "10": {
            name: "meta.delimiter.decimal.period.ts"
          },
          "11": {
            name: "storage.type.numeric.bigint.ts"
          },
          "12": {
            name: "meta.delimiter.decimal.period.ts"
          },
          "13": {
            name: "storage.type.numeric.bigint.ts"
          },
          "14": {
            name: "storage.type.numeric.bigint.ts"
          }
        }
      }
    ]
  },
  "boolean-literal": {
    patterns: [
      {
        name: "constant.language.boolean.true.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))true(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "constant.language.boolean.false.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))false(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "null-literal": {
    name: "constant.language.null.ts",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))null(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "this-literal": {
    name: "variable.language.this.ts",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))this\\b(?!\\$)"
  },
  "super-literal": {
    name: "variable.language.super.ts",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))super\\b(?!\\$)"
  },
  "undefined-literal": {
    name: "constant.language.undefined.ts",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))undefined(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "numericConstant-literal": {
    patterns: [
      {
        name: "constant.language.nan.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))NaN(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "constant.language.infinity.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Infinity(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "support-objects": {
    patterns: [
      {
        name: "variable.language.arguments.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(arguments)\\b(?!\\$)"
      },
      {
        name: "support.class.builtin.ts",
        match: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Array|ArrayBuffer|Atomics|BigInt|BigInt64Array|BigUint64Array|Boolean|DataView|Date|Float32Array\n  |Float64Array|Function|Generator|GeneratorFunction|Int8Array|Int16Array|Int32Array|Intl|Map|Number|Object|Proxy\n  |Reflect|RegExp|Set|SharedArrayBuffer|SIMD|String|Symbol|TypedArray\n  |Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|WeakMap|WeakSet)\\b(?!\\$)"
      },
      {
        name: "support.class.error.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))((Eval|Internal|Range|Reference|Syntax|Type|URI)?Error)\\b(?!\\$)"
      },
      {
        name: "support.class.promise.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Promise)\\b(?!\\$)"
      },
      {
        name: "support.function.ts",
        match: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(clear(Interval|Timeout)|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|\n  isFinite|isNaN|parseFloat|parseInt|require|set(Interval|Timeout)|super|unescape|uneval)(?=\\s*\\()"
      },
      {
        match: "(?x)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(Math)(?:\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(?:\n  (abs|acos|acosh|asin|asinh|atan|atan2|atanh|cbrt|ceil|clz32|cos|cosh|exp|\n  expm1|floor|fround|hypot|imul|log|log10|log1p|log2|max|min|pow|random|\n  round|sign|sin|sinh|sqrt|tan|tanh|trunc)\n  |\n  (E|LN10|LN2|LOG10E|LOG2E|PI|SQRT1_2|SQRT2)))?\\b(?!\\$)",
        captures: {
          "1": {
            name: "support.constant.math.ts"
          },
          "2": {
            name: "punctuation.accessor.ts"
          },
          "3": {
            name: "punctuation.accessor.optional.ts"
          },
          "4": {
            name: "support.function.math.ts"
          },
          "5": {
            name: "support.constant.property.math.ts"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(JSON)(?:\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(parse|stringify))?\\b(?!\\$)",
        captures: {
          "1": {
            name: "support.constant.json.ts"
          },
          "2": {
            name: "punctuation.accessor.ts"
          },
          "3": {
            name: "punctuation.accessor.optional.ts"
          },
          "4": {
            name: "support.function.json.ts"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(import)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(meta)\\b(?!\\$)",
        captures: {
          "1": {
            name: "keyword.control.import.ts"
          },
          "2": {
            name: "punctuation.accessor.ts"
          },
          "3": {
            name: "punctuation.accessor.optional.ts"
          },
          "4": {
            name: "support.variable.property.importmeta.ts"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(new)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(target)\\b(?!\\$)",
        captures: {
          "1": {
            name: "keyword.operator.new.ts"
          },
          "2": {
            name: "punctuation.accessor.ts"
          },
          "3": {
            name: "punctuation.accessor.optional.ts"
          },
          "4": {
            name: "support.variable.property.target.ts"
          }
        }
      },
      {
        match: "(?x) (?:(\\.)|(\\?\\.(?!\\s*[[:digit:]]))) \\s* (?:\n  (?:(constructor|length|prototype|__proto__)\\b(?!\\$|\\s*(<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\\())\n  |\n  (?:(EPSILON|MAX_SAFE_INTEGER|MAX_VALUE|MIN_SAFE_INTEGER|MIN_VALUE|NEGATIVE_INFINITY|POSITIVE_INFINITY)\\b(?!\\$)))",
        captures: {
          "1": {
            name: "punctuation.accessor.ts"
          },
          "2": {
            name: "punctuation.accessor.optional.ts"
          },
          "3": {
            name: "support.variable.property.ts"
          },
          "4": {
            name: "support.constant.ts"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(exports)|(module)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))(exports|id|filename|loaded|parent|children))?)\\b(?!\\$)",
        captures: {
          "1": {
            name: "support.type.object.module.ts"
          },
          "2": {
            name: "support.type.object.module.ts"
          },
          "3": {
            name: "punctuation.accessor.ts"
          },
          "4": {
            name: "punctuation.accessor.optional.ts"
          },
          "5": {
            name: "support.type.object.module.ts"
          }
        }
      }
    ]
  },
  identifiers: {
    patterns: [
      {
        include: "#object-identifiers"
      },
      {
        match: "(?x)(?:(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*)?([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*=\\s*(\n  ((async\\s+)?(\n    (function\\s*[(<*]) |\n    (function\\s+) |\n    ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)\n  )) |\n  ((async\\s*)?(\n    ((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))))) |\n    # sure shot arrow functions even if => is on new line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?\n  [(]\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*\n  (\n    ([)]\\s*:) |                                                                                       # ():\n    ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                                                  # [(]param: | [(]...param:\n  )\n) |\n\n# arrow function possible to detect only with => on same line\n(\n  (<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?                                                                                 # typeparameters\n  \\(\\s*(\\/\\*([^\\*]|(\\*[^\\/]))*\\*\\/\\s*)*(([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\.\\.\\.\\s*[_$[:alpha:]]))([^()\\'\\\"\\`]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))*)?\\)   # parameters\n  (\\s*:\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+)?                                                                        # return type\n  \\s*=>                                                                                               # arrow operator\n)\n  ))\n))",
        captures: {
          "1": {
            name: "punctuation.accessor.ts"
          },
          "2": {
            name: "punctuation.accessor.optional.ts"
          },
          "3": {
            name: "entity.name.function.ts"
          }
        }
      },
      {
        match: "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])",
        captures: {
          "1": {
            name: "punctuation.accessor.ts"
          },
          "2": {
            name: "punctuation.accessor.optional.ts"
          },
          "3": {
            name: "variable.other.constant.property.ts"
          }
        }
      },
      {
        match: "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(\\#?[_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "punctuation.accessor.ts"
          },
          "2": {
            name: "punctuation.accessor.optional.ts"
          },
          "3": {
            name: "variable.other.property.ts"
          }
        }
      },
      {
        name: "variable.other.constant.ts",
        match: "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])"
      },
      {
        name: "variable.other.readwrite.ts",
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      }
    ]
  },
  "object-identifiers": {
    patterns: [
      {
        name: "support.class.ts",
        match: "([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\\??\\.\\s*prototype\\b(?!\\$))"
      },
      {
        match: "(?x)(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(?:\n  (\\#?[[:upper:]][_$[:digit:][:upper:]]*) |\n  (\\#?[_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "punctuation.accessor.ts"
          },
          "2": {
            name: "punctuation.accessor.optional.ts"
          },
          "3": {
            name: "variable.other.constant.object.property.ts"
          },
          "4": {
            name: "variable.other.object.property.ts"
          }
        }
      },
      {
        match: "(?x)(?:\n  ([[:upper:]][_$[:digit:][:upper:]]*) |\n  ([_$[:alpha:]][_$[:alnum:]]*)\n)(?=\\s*\\??\\.\\s*\\#?[_$[:alpha:]][_$[:alnum:]]*)",
        captures: {
          "1": {
            name: "variable.other.constant.object.ts"
          },
          "2": {
            name: "variable.other.object.ts"
          }
        }
      }
    ]
  },
  "type-annotation": {
    patterns: [
      {
        name: "meta.type.annotation.ts",
        begin: "(:)(?=\\s*\\S)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.ts"
          }
        },
        end: "(?<![:|&])((?=$|^|[,);\\}\\]]|//)|(?==[^>])|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        name: "meta.type.annotation.ts",
        begin: "(:)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.ts"
          }
        },
        end: "(?<![:|&])((?=[,);\\}\\]]|//)|(?==[^>])|(?=^\\s*$)|((?<=\\S)(?=\\s*$))|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))",
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "parameter-type-annotation": {
    patterns: [
      {
        name: "meta.type.annotation.ts",
        begin: "(:)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.ts"
          }
        },
        end: "(?=[,)])|(?==[^>])",
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "return-type": {
    patterns: [
      {
        name: "meta.return.type.ts",
        begin: "(?<=\\))\\s*(:)(?=\\s*\\S)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.ts"
          }
        },
        end: "(?<![:|&])(?=$|^|[{};,]|//)",
        patterns: [
          {
            include: "#return-type-core"
          }
        ]
      },
      {
        name: "meta.return.type.ts",
        begin: "(?<=\\))\\s*(:)",
        beginCaptures: {
          "1": {
            name: "keyword.operator.type.annotation.ts"
          }
        },
        end: "(?<![:|&])((?=[{};,]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))",
        patterns: [
          {
            include: "#return-type-core"
          }
        ]
      }
    ]
  },
  "return-type-core": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?<=[:|&])(?=\\s*\\{)",
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        include: "#type-predicate-operator"
      },
      {
        include: "#type"
      }
    ]
  },
  "arrow-return-type": {
    name: "meta.return.type.arrow.ts",
    begin: "(?<=\\))\\s*(:)",
    beginCaptures: {
      "1": {
        name: "keyword.operator.type.annotation.ts"
      }
    },
    end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))",
    patterns: [
      {
        include: "#arrow-return-type-body"
      }
    ]
  },
  "possibly-arrow-return-type": {
    begin: "(?<=\\)|^)\\s*(:)(?=\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*=>)",
    beginCaptures: {
      "1": {
        name: "meta.arrow.ts meta.return.type.arrow.ts keyword.operator.type.annotation.ts"
      }
    },
    end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))",
    contentName: "meta.arrow.ts meta.return.type.arrow.ts",
    patterns: [
      {
        include: "#arrow-return-type-body"
      }
    ]
  },
  "arrow-return-type-body": {
    patterns: [
      {
        begin: "(?<=[:])(?=\\s*\\{)",
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        include: "#type-predicate-operator"
      },
      {
        include: "#type"
      }
    ]
  },
  "type-parameters": {
    name: "meta.type.parameters.ts",
    begin: "(<)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.typeparameters.begin.ts"
      }
    },
    end: "(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.typeparameters.end.ts"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        name: "storage.modifier.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        include: "#type"
      },
      {
        include: "#punctuation-comma"
      },
      {
        name: "keyword.operator.assignment.ts",
        match: "(=)(?!>)"
      }
    ]
  },
  "type-arguments": {
    name: "meta.type.parameters.ts",
    begin: "\\<",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.typeparameters.begin.ts"
      }
    },
    end: "\\>",
    endCaptures: {
      "0": {
        name: "punctuation.definition.typeparameters.end.ts"
      }
    },
    patterns: [
      {
        include: "#type-arguments-body"
      }
    ]
  },
  "type-arguments-body": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(_)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "0": {
            name: "keyword.operator.type.ts"
          }
        }
      },
      {
        include: "#type"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  type: {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#type-string"
      },
      {
        include: "#numeric-literal"
      },
      {
        include: "#type-primitive"
      },
      {
        include: "#type-builtin-literals"
      },
      {
        include: "#type-parameters"
      },
      {
        include: "#type-tuple"
      },
      {
        include: "#type-object"
      },
      {
        include: "#type-conditional"
      },
      {
        include: "#type-operators"
      },
      {
        include: "#type-fn-type-parameters"
      },
      {
        include: "#type-paren-or-function-parameters"
      },
      {
        include: "#type-function-return-type"
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(readonly)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))\\s*",
        captures: {
          "1": {
            name: "storage.modifier.ts"
          }
        }
      },
      {
        include: "#type-name"
      }
    ]
  },
  "type-primitive": {
    name: "support.type.primitive.ts",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(string|number|bigint|boolean|symbol|any|void|never|unknown)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "type-builtin-literals": {
    name: "support.type.builtin.ts",
    match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(this|true|false|undefined|null|object)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
  },
  "type-tuple": {
    name: "meta.type.tuple.ts",
    begin: "\\[",
    beginCaptures: {
      "0": {
        name: "meta.brace.square.ts"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "meta.brace.square.ts"
      }
    },
    patterns: [
      {
        name: "keyword.operator.rest.ts",
        match: "\\.\\.\\."
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))([_$[:alpha:]][_$[:alnum:]]*)\\s*(\\?)?\\s*(:)",
        captures: {
          "1": {
            name: "entity.name.label.ts"
          },
          "2": {
            name: "keyword.operator.optional.ts"
          },
          "3": {
            name: "punctuation.separator.label.ts"
          }
        }
      },
      {
        include: "#type"
      },
      {
        include: "#punctuation-comma"
      }
    ]
  },
  "type-object": {
    name: "meta.object.type.ts",
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.block.ts"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.block.ts"
      }
    },
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#method-declaration"
      },
      {
        include: "#indexer-declaration"
      },
      {
        include: "#indexer-mapped-type-declaration"
      },
      {
        include: "#field-declaration"
      },
      {
        include: "#type-annotation"
      },
      {
        begin: "\\.\\.\\.",
        beginCaptures: {
          "0": {
            name: "keyword.operator.spread.ts"
          }
        },
        end: "(?=\\}|;|,|$)|(?<=\\})",
        patterns: [
          {
            include: "#type"
          }
        ]
      },
      {
        include: "#punctuation-comma"
      },
      {
        include: "#punctuation-semicolon"
      },
      {
        include: "#type"
      }
    ]
  },
  "type-conditional": {
    patterns: [
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(extends)\\s+",
        beginCaptures: {
          "1": {
            name: "storage.modifier.ts"
          }
        },
        end: "(?<=:)",
        patterns: [
          {
            begin: "\\?",
            beginCaptures: {
              "0": {
                name: "keyword.operator.ternary.ts"
              }
            },
            end: ":",
            endCaptures: {
              "0": {
                name: "keyword.operator.ternary.ts"
              }
            },
            patterns: [
              {
                include: "#type"
              }
            ]
          },
          {
            include: "#type"
          }
        ]
      }
    ]
  },
  "type-paren-or-function-parameters": {
    name: "meta.type.paren.cover.ts",
    begin: "\\(",
    beginCaptures: {
      "0": {
        name: "meta.brace.round.ts"
      }
    },
    end: "\\)",
    endCaptures: {
      "0": {
        name: "meta.brace.round.ts"
      }
    },
    patterns: [
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=\\s*(:\\s*(\n  (<) |\n  ([(]\\s*(\n    ([)]) |\n    (\\.\\.\\.) |\n    ([_$[:alnum:]]+\\s*(\n      ([:,?=])|\n      ([)]\\s*=>)\n    ))\n  ))\n)) |\n(:\\s*(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))Function(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))) |\n(:\\s*((<\\s*$)|((<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<]|\\<\\s*([_$[:alpha:]]|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\]))([^=<>]|=[^<])*\\>)*\\>)*>\\s*)?[\\(]\\s*((([\\{\\[]\\s*)?$)|((\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})\\s*((:\\s*\\{?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*)))|((\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])\\s*((:\\s*\\[?$)|((\\s*([^<>\\(\\)\\{\\}]|\\<([^<>]|\\<([^<>]|\\<[^<>]+\\>)+\\>)+\\>|\\([^\\(\\)]+\\)|\\{[^\\{\\}]+\\})+\\s*)?=\\s*))))))))",
        captures: {
          "1": {
            name: "storage.modifier.ts"
          },
          "2": {
            name: "keyword.operator.rest.ts"
          },
          "3": {
            name: "entity.name.function.ts variable.language.this.ts"
          },
          "4": {
            name: "entity.name.function.ts"
          },
          "5": {
            name: "keyword.operator.optional.ts"
          }
        }
      },
      {
        match: "(?x)(?:(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(public|private|protected|readonly)\\s+)?(?:(\\.\\.\\.)\\s*)?(?<!=|:)(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=:)",
        captures: {
          "1": {
            name: "storage.modifier.ts"
          },
          "2": {
            name: "keyword.operator.rest.ts"
          },
          "3": {
            name: "variable.parameter.ts variable.language.this.ts"
          },
          "4": {
            name: "variable.parameter.ts"
          },
          "5": {
            name: "keyword.operator.optional.ts"
          }
        }
      },
      {
        include: "#type-annotation"
      },
      {
        name: "punctuation.separator.parameter.ts",
        match: ","
      },
      {
        include: "#type"
      }
    ]
  },
  "type-fn-type-parameters": {
    patterns: [
      {
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b(?=\\s*\\<)",
        beginCaptures: {
          "1": {
            name: "meta.type.constructor.ts storage.modifier.ts"
          },
          "2": {
            name: "meta.type.constructor.ts keyword.control.new.ts"
          }
        },
        end: "(?<=>)",
        patterns: [
          {
            include: "#comment"
          },
          {
            include: "#type-parameters"
          }
        ]
      },
      {
        name: "meta.type.constructor.ts",
        begin: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(abstract)\\s+)?(new)\\b\\s*(?=\\()",
        beginCaptures: {
          "1": {
            name: "storage.modifier.ts"
          },
          "2": {
            name: "keyword.control.new.ts"
          }
        },
        end: "(?<=\\))",
        patterns: [
          {
            include: "#function-parameters"
          }
        ]
      },
      {
        name: "meta.type.function.ts",
        begin: "(?x)(\n  (?=\n    [(]\\s*(\n      ([)]) |\n      (\\.\\.\\.) |\n      ([_$[:alnum:]]+\\s*(\n        ([:,?=])|\n        ([)]\\s*=>)\n      ))\n    )\n  )\n)",
        end: "(?<=\\))",
        patterns: [
          {
            include: "#function-parameters"
          }
        ]
      }
    ]
  },
  "type-function-return-type": {
    patterns: [
      {
        name: "meta.type.function.return.ts",
        begin: "(=>)(?=\\s*\\S)",
        beginCaptures: {
          "1": {
            name: "storage.type.function.arrow.ts"
          }
        },
        end: "(?<!=>)(?<![|&])(?=[,\\]\\)\\{\\}=;>:\\?]|//|$)",
        patterns: [
          {
            include: "#type-function-return-type-core"
          }
        ]
      },
      {
        name: "meta.type.function.return.ts",
        begin: "=>",
        beginCaptures: {
          "0": {
            name: "storage.type.function.arrow.ts"
          }
        },
        end: "(?<!=>)(?<![|&])((?=[,\\]\\)\\{\\}=;:\\?>]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))",
        patterns: [
          {
            include: "#type-function-return-type-core"
          }
        ]
      }
    ]
  },
  "type-function-return-type-core": {
    patterns: [
      {
        include: "#comment"
      },
      {
        begin: "(?<==>)(?=\\s*\\{)",
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        include: "#type-predicate-operator"
      },
      {
        include: "#type"
      }
    ]
  },
  "type-operators": {
    patterns: [
      {
        include: "#typeof-operator"
      },
      {
        begin: "([&|])(?=\\s*\\{)",
        beginCaptures: {
          "0": {
            name: "keyword.operator.type.ts"
          }
        },
        end: "(?<=\\})",
        patterns: [
          {
            include: "#type-object"
          }
        ]
      },
      {
        begin: "[&|]",
        beginCaptures: {
          "0": {
            name: "keyword.operator.type.ts"
          }
        },
        end: "(?=\\S)"
      },
      {
        name: "keyword.operator.expression.keyof.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))keyof(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.ternary.ts",
        match: "(\\?|\\:)"
      },
      {
        name: "keyword.operator.expression.infer.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))infer(?=\\s+[_$[:alpha:]])"
      },
      {
        name: "keyword.operator.expression.import.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))import(?=\\s*\\()"
      }
    ]
  },
  "type-predicate-operator": {
    patterns: [
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(?:(asserts)\\s+)?(?!asserts)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s(is)(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "1": {
            name: "keyword.operator.type.asserts.ts"
          },
          "2": {
            name: "variable.parameter.ts variable.language.this.ts"
          },
          "3": {
            name: "variable.parameter.ts"
          },
          "4": {
            name: "keyword.operator.expression.is.ts"
          }
        }
      },
      {
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))(asserts)\\s+(?!is)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))",
        captures: {
          "1": {
            name: "keyword.operator.type.asserts.ts"
          },
          "2": {
            name: "variable.parameter.ts variable.language.this.ts"
          },
          "3": {
            name: "variable.parameter.ts"
          }
        }
      },
      {
        name: "keyword.operator.type.asserts.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))asserts(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      },
      {
        name: "keyword.operator.expression.is.ts",
        match: "(?<![_$[:alnum:]])(?:(?<=\\.\\.\\.)|(?<!\\.))is(?![_$[:alnum:]])(?:(?=\\.\\.\\.)|(?!\\.))"
      }
    ]
  },
  "type-name": {
    patterns: [
      {
        begin: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))\\s*(<)",
        captures: {
          "1": {
            name: "entity.name.type.module.ts"
          },
          "2": {
            name: "punctuation.accessor.ts"
          },
          "3": {
            name: "punctuation.accessor.optional.ts"
          },
          "4": {
            name: "meta.type.parameters.ts punctuation.definition.typeparameters.begin.ts"
          }
        },
        end: "(>)",
        endCaptures: {
          "1": {
            name: "meta.type.parameters.ts punctuation.definition.typeparameters.end.ts"
          }
        },
        contentName: "meta.type.parameters.ts",
        patterns: [
          {
            include: "#type-arguments-body"
          }
        ]
      },
      {
        begin: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(<)",
        beginCaptures: {
          "1": {
            name: "entity.name.type.ts"
          },
          "2": {
            name: "meta.type.parameters.ts punctuation.definition.typeparameters.begin.ts"
          }
        },
        end: "(>)",
        endCaptures: {
          "1": {
            name: "meta.type.parameters.ts punctuation.definition.typeparameters.end.ts"
          }
        },
        contentName: "meta.type.parameters.ts",
        patterns: [
          {
            include: "#type-arguments-body"
          }
        ]
      },
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))",
        captures: {
          "1": {
            name: "entity.name.type.module.ts"
          },
          "2": {
            name: "punctuation.accessor.ts"
          },
          "3": {
            name: "punctuation.accessor.optional.ts"
          }
        }
      },
      {
        name: "entity.name.type.ts",
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      }
    ]
  },
  "punctuation-comma": {
    name: "punctuation.separator.comma.ts",
    match: ","
  },
  "punctuation-semicolon": {
    name: "punctuation.terminator.statement.ts",
    match: ";"
  },
  "punctuation-accessor": {
    match: "(?:(\\.)|(\\?\\.(?!\\s*[[:digit:]])))",
    captures: {
      "1": {
        name: "punctuation.accessor.ts"
      },
      "2": {
        name: "punctuation.accessor.optional.ts"
      }
    }
  },
  string: {
    patterns: [
      {
        include: "#qstring-single"
      },
      {
        include: "#qstring-double"
      },
      {
        include: "#template"
      }
    ]
  },
  "qstring-double": {
    name: "string.quoted.double.ts",
    begin: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.ts"
      }
    },
    end: '(")|((?:[^\\\\\\n])$)',
    endCaptures: {
      "1": {
        name: "punctuation.definition.string.end.ts"
      },
      "2": {
        name: "invalid.illegal.newline.ts"
      }
    },
    patterns: [
      {
        include: "#string-character-escape"
      }
    ]
  },
  "qstring-single": {
    name: "string.quoted.single.ts",
    begin: "'",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.ts"
      }
    },
    end: "(\\')|((?:[^\\\\\\n])$)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.string.end.ts"
      },
      "2": {
        name: "invalid.illegal.newline.ts"
      }
    },
    patterns: [
      {
        include: "#string-character-escape"
      }
    ]
  },
  "string-character-escape": {
    name: "constant.character.escape.ts",
    match: "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|u\\{[0-9A-Fa-f]+\\}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)"
  },
  template: {
    patterns: [
      {
        include: "#template-call"
      },
      {
        name: "string.template.ts",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)?(`)",
        beginCaptures: {
          "1": {
            name: "entity.name.function.tagged-template.ts"
          },
          "2": {
            name: "punctuation.definition.string.template.begin.ts"
          }
        },
        end: "`",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.template.end.ts"
          }
        },
        patterns: [
          {
            include: "#template-substitution-element"
          },
          {
            include: "#string-character-escape"
          }
        ]
      }
    ]
  },
  "template-call": {
    patterns: [
      {
        name: "string.template.ts",
        begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*)(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)",
        end: "(?=`)",
        patterns: [
          {
            begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\??\\.\\s*)*|(\\??\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*))",
            end: "(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)?`)",
            patterns: [
              {
                include: "#support-function-call-identifiers"
              },
              {
                name: "entity.name.function.tagged-template.ts",
                match: "([_$[:alpha:]][_$[:alnum:]]*)"
              }
            ]
          },
          {
            include: "#type-arguments"
          }
        ]
      },
      {
        name: "string.template.ts",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)?\\s*(?=(<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))(([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>|\\<\\s*(((keyof|infer|typeof|readonly)\\s+)|(([_$[:alpha:]][_$[:alnum:]]*|(\\{([^\\{\\}]|(\\{([^\\{\\}]|\\{[^\\{\\}]*\\})*\\}))*\\})|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(\\[([^\\[\\]]|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])*\\]))*\\])|(\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`))(?=\\s*([\\<\\>\\,\\.\\[]|=>|&(?!&)|\\|(?!\\|)))))([^<>\\(]|(\\(([^\\(\\)]|(\\(([^\\(\\)]|\\([^\\(\\)]*\\))*\\)))*\\))|(?<==)\\>)*(?<!=)\\>))*(?<!=)\\>)*(?<!=)>\\s*)`)",
        beginCaptures: {
          "1": {
            name: "entity.name.function.tagged-template.ts"
          }
        },
        end: "(?=`)",
        patterns: [
          {
            include: "#type-arguments"
          }
        ]
      }
    ]
  },
  "template-substitution-element": {
    name: "meta.template.expression.ts",
    begin: "\\$\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.begin.ts"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.end.ts"
      }
    },
    patterns: [
      {
        include: "#expression"
      }
    ],
    contentName: "meta.embedded.line.ts"
  },
  "type-string": {
    patterns: [
      {
        include: "#qstring-single"
      },
      {
        include: "#qstring-double"
      },
      {
        include: "#template-type"
      }
    ]
  },
  "template-type": {
    patterns: [
      {
        include: "#template-call"
      },
      {
        name: "string.template.ts",
        begin: "([_$[:alpha:]][_$[:alnum:]]*)?(`)",
        beginCaptures: {
          "1": {
            name: "entity.name.function.tagged-template.ts"
          },
          "2": {
            name: "punctuation.definition.string.template.begin.ts"
          }
        },
        end: "`",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.template.end.ts"
          }
        },
        patterns: [
          {
            include: "#template-type-substitution-element"
          },
          {
            include: "#string-character-escape"
          }
        ]
      }
    ]
  },
  "template-type-substitution-element": {
    name: "meta.template.expression.ts",
    begin: "\\$\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.begin.ts"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.template-expression.end.ts"
      }
    },
    patterns: [
      {
        include: "#type"
      }
    ],
    contentName: "meta.embedded.line.ts"
  },
  regex: {
    patterns: [
      {
        name: "string.regexp.ts",
        begin: "(?<!\\+\\+|--|})(?<=[=(:,\\[?+!]|^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case|=>|&&|\\|\\||\\*\\/)\\s*(\\/)(?![\\/*])(?=(?:[^\\/\\\\\\[\\()]|\\\\.|\\[([^\\]\\\\]|\\\\.)+\\]|\\(([^\\)\\\\]|\\\\.)+\\))+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.string.begin.ts"
          }
        },
        end: "(/)([dgimsuy]*)",
        endCaptures: {
          "1": {
            name: "punctuation.definition.string.end.ts"
          },
          "2": {
            name: "keyword.other.ts"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      },
      {
        name: "string.regexp.ts",
        begin: "((?<![_$[:alnum:])\\]]|\\+\\+|--|}|\\*\\/)|((?<=^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case))\\s*)\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)*\\])+\\/([dgimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.ts"
          }
        },
        end: "(/)([dgimsuy]*)",
        endCaptures: {
          "1": {
            name: "punctuation.definition.string.end.ts"
          },
          "2": {
            name: "keyword.other.ts"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      }
    ]
  },
  regexp: {
    patterns: [
      {
        name: "keyword.control.anchor.regexp",
        match: "\\\\[bB]|\\^|\\$"
      },
      {
        match: "\\\\[1-9]\\d*|\\\\k<([a-zA-Z_$][\\w$]*)>",
        captures: {
          "0": {
            name: "keyword.other.back-reference.regexp"
          },
          "1": {
            name: "variable.other.regexp"
          }
        }
      },
      {
        name: "keyword.operator.quantifier.regexp",
        match: "[?+*]|\\{(\\d+,\\d+|\\d+,|,\\d+|\\d+)\\}\\??"
      },
      {
        name: "keyword.operator.or.regexp",
        match: "\\|"
      },
      {
        name: "meta.group.assertion.regexp",
        begin: "(\\()((\\?=)|(\\?!)|(\\?<=)|(\\?<!))",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.group.regexp"
          },
          "2": {
            name: "punctuation.definition.group.assertion.regexp"
          },
          "3": {
            name: "meta.assertion.look-ahead.regexp"
          },
          "4": {
            name: "meta.assertion.negative-look-ahead.regexp"
          },
          "5": {
            name: "meta.assertion.look-behind.regexp"
          },
          "6": {
            name: "meta.assertion.negative-look-behind.regexp"
          }
        },
        end: "(\\))",
        endCaptures: {
          "1": {
            name: "punctuation.definition.group.regexp"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      },
      {
        name: "meta.group.regexp",
        begin: "\\((?:(\\?:)|(?:\\?<([a-zA-Z_$][\\w$]*)>))?",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.group.regexp"
          },
          "1": {
            name: "punctuation.definition.group.no-capture.regexp"
          },
          "2": {
            name: "variable.other.regexp"
          }
        },
        end: "\\)",
        endCaptures: {
          "0": {
            name: "punctuation.definition.group.regexp"
          }
        },
        patterns: [
          {
            include: "#regexp"
          }
        ]
      },
      {
        name: "constant.other.character-class.set.regexp",
        begin: "(\\[)(\\^)?",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.character-class.regexp"
          },
          "2": {
            name: "keyword.operator.negation.regexp"
          }
        },
        end: "(\\])",
        endCaptures: {
          "1": {
            name: "punctuation.definition.character-class.regexp"
          }
        },
        patterns: [
          {
            name: "constant.other.character-class.range.regexp",
            match: "(?:.|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))\\-(?:[^\\]\\\\]|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))",
            captures: {
              "1": {
                name: "constant.character.numeric.regexp"
              },
              "2": {
                name: "constant.character.control.regexp"
              },
              "3": {
                name: "constant.character.escape.backslash.regexp"
              },
              "4": {
                name: "constant.character.numeric.regexp"
              },
              "5": {
                name: "constant.character.control.regexp"
              },
              "6": {
                name: "constant.character.escape.backslash.regexp"
              }
            }
          },
          {
            include: "#regex-character-class"
          }
        ]
      },
      {
        include: "#regex-character-class"
      }
    ]
  },
  "regex-character-class": {
    patterns: [
      {
        name: "constant.other.character-class.regexp",
        match: "\\\\[wWsSdDtrnvf]|\\."
      },
      {
        name: "constant.character.numeric.regexp",
        match: "\\\\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})"
      },
      {
        name: "constant.character.control.regexp",
        match: "\\\\c[A-Z]"
      },
      {
        name: "constant.character.escape.backslash.regexp",
        match: "\\\\."
      }
    ]
  },
  comment: {
    patterns: [
      {
        name: "comment.block.documentation.ts",
        begin: "/\\*\\*(?!/)",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.comment.ts"
          }
        },
        end: "\\*/",
        endCaptures: {
          "0": {
            name: "punctuation.definition.comment.ts"
          }
        },
        patterns: [
          {
            include: "#docblock"
          }
        ]
      },
      {
        name: "comment.block.ts",
        begin: "(/\\*)(?:\\s*((@)internal)(?=\\s|(\\*/)))?",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.comment.ts"
          },
          "2": {
            name: "storage.type.internaldeclaration.ts"
          },
          "3": {
            name: "punctuation.decorator.internaldeclaration.ts"
          }
        },
        end: "\\*/",
        endCaptures: {
          "0": {
            name: "punctuation.definition.comment.ts"
          }
        }
      },
      {
        begin: "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)",
        beginCaptures: {
          "1": {
            name: "punctuation.whitespace.comment.leading.ts"
          },
          "2": {
            name: "comment.line.double-slash.ts"
          },
          "3": {
            name: "punctuation.definition.comment.ts"
          },
          "4": {
            name: "storage.type.internaldeclaration.ts"
          },
          "5": {
            name: "punctuation.decorator.internaldeclaration.ts"
          }
        },
        end: "(?=$)",
        contentName: "comment.line.double-slash.ts"
      }
    ]
  },
  "single-line-comment-consuming-line-ending": {
    begin: "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)",
    beginCaptures: {
      "1": {
        name: "punctuation.whitespace.comment.leading.ts"
      },
      "2": {
        name: "comment.line.double-slash.ts"
      },
      "3": {
        name: "punctuation.definition.comment.ts"
      },
      "4": {
        name: "storage.type.internaldeclaration.ts"
      },
      "5": {
        name: "punctuation.decorator.internaldeclaration.ts"
      }
    },
    end: "(?=^)",
    contentName: "comment.line.double-slash.ts"
  },
  directives: {
    name: "comment.line.triple-slash.directive.ts",
    begin: "^(///)\\s*(?=<(reference|amd-dependency|amd-module)(\\s+(path|types|no-default-lib|lib|name)\\s*=\\s*((\\'([^\\'\\\\]|\\\\.)*\\')|(\\\"([^\\\"\\\\]|\\\\.)*\\\")|(\\`([^\\`\\\\]|\\\\.)*\\`)))+\\s*/>\\s*$)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.comment.ts"
      }
    },
    end: "(?=$)",
    patterns: [
      {
        name: "meta.tag.ts",
        begin: "(<)(reference|amd-dependency|amd-module)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.directive.ts"
          },
          "2": {
            name: "entity.name.tag.directive.ts"
          }
        },
        end: "/>",
        endCaptures: {
          "0": {
            name: "punctuation.definition.tag.directive.ts"
          }
        },
        patterns: [
          {
            name: "entity.other.attribute-name.directive.ts",
            match: "path|types|no-default-lib|lib|name"
          },
          {
            name: "keyword.operator.assignment.ts",
            match: "="
          },
          {
            include: "#string"
          }
        ]
      }
    ]
  },
  docblock: {
    patterns: [
      {
        match: "(?x)\n((@)(?:access|api))\n\\s+\n(private|protected|public)\n\\b",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "constant.language.access-type.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)author)\n\\s+\n(\n  [^@\\s<>*/]\n  (?:[^@<>*/]|\\*[^/])*\n)\n(?:\n  \\s*\n  (<)\n  ([^>\\s]+)\n  (>)\n)?",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "entity.name.type.instance.jsdoc"
          },
          "4": {
            name: "punctuation.definition.bracket.angle.begin.jsdoc"
          },
          "5": {
            name: "constant.other.email.link.underline.jsdoc"
          },
          "6": {
            name: "punctuation.definition.bracket.angle.end.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)borrows) \\s+\n((?:[^@\\s*/]|\\*[^/])+)    # <that namepath>\n\\s+ (as) \\s+              # as\n((?:[^@\\s*/]|\\*[^/])+)    # <this namepath>",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "entity.name.type.instance.jsdoc"
          },
          "4": {
            name: "keyword.operator.control.jsdoc"
          },
          "5": {
            name: "entity.name.type.instance.jsdoc"
          }
        }
      },
      {
        name: "meta.example.jsdoc",
        begin: "((@)example)\\s+",
        end: "(?=@|\\*/)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        patterns: [
          {
            match: "^\\s\\*\\s+"
          },
          {
            contentName: "constant.other.description.jsdoc",
            begin: "\\G(<)caption(>)",
            beginCaptures: {
              "0": {
                name: "entity.name.tag.inline.jsdoc"
              },
              "1": {
                name: "punctuation.definition.bracket.angle.begin.jsdoc"
              },
              "2": {
                name: "punctuation.definition.bracket.angle.end.jsdoc"
              }
            },
            end: "(</)caption(>)|(?=\\*/)",
            endCaptures: {
              "0": {
                name: "entity.name.tag.inline.jsdoc"
              },
              "1": {
                name: "punctuation.definition.bracket.angle.begin.jsdoc"
              },
              "2": {
                name: "punctuation.definition.bracket.angle.end.jsdoc"
              }
            }
          },
          {
            match: "[^\\s@*](?:[^*]|\\*[^/])*",
            captures: {
              "0": {
                name: "source.embedded.ts"
              }
            }
          }
        ]
      },
      {
        match: "(?x) ((@)kind) \\s+ (class|constant|event|external|file|function|member|mixin|module|namespace|typedef) \\b",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "constant.language.symbol-type.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)see)\n\\s+\n(?:\n  # URL\n  (\n    (?=https?://)\n    (?:[^\\s*]|\\*[^/])+\n  )\n  |\n  # JSDoc namepath\n  (\n    (?!\n      # Avoid matching bare URIs (also acceptable as links)\n      https?://\n      |\n      # Avoid matching {@inline tags}; we match those below\n      (?:\\[[^\\[\\]]*\\])? # Possible description [preceding]{@tag}\n      {@(?:link|linkcode|linkplain|tutorial)\\b\n    )\n    # Matched namepath\n    (?:[^@\\s*/]|\\*[^/])+\n  )\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.link.underline.jsdoc"
          },
          "4": {
            name: "entity.name.type.instance.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n((@)template)\n\\s+\n# One or more valid identifiers\n(\n  [A-Za-z_$]         # First character: non-numeric word character\n  [\\w$.\\[\\]]*        # Rest of identifier\n  (?:                # Possible list of additional identifiers\n    \\s* , \\s*\n    [A-Za-z_$]\n    [\\w$.\\[\\]]*\n  )*\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          }
        }
      },
      {
        match: "(?x)\n(\n  (@)\n  (?:arg|argument|const|constant|member|namespace|param|var)\n)\n\\s+\n(\n  [A-Za-z_$]\n  [\\w$.\\[\\]]*\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          }
        }
      },
      {
        begin: "((@)typedef)\\s+(?={)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])",
        patterns: [
          {
            include: "#jsdoctype"
          },
          {
            name: "entity.name.type.instance.jsdoc",
            match: "(?:[^@\\s*/]|\\*[^/])+"
          }
        ]
      },
      {
        begin: "((@)(?:arg|argument|const|constant|member|namespace|param|prop|property|var))\\s+(?={)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])",
        patterns: [
          {
            include: "#jsdoctype"
          },
          {
            name: "variable.other.jsdoc",
            match: "([A-Za-z_$][\\w$.\\[\\]]*)"
          },
          {
            name: "variable.other.jsdoc",
            match: `(?x)
(\\[)\\s*
[\\w$]+
(?:
  (?:\\[\\])?                                        # Foo[ ].bar properties within an array
  \\.                                                # Foo.Bar namespaced parameter
  [\\w$]+
)*
(?:
  \\s*
  (=)                                                # [foo=bar] Default parameter value
  \\s*
  (
    # The inner regexes are to stop the match early at */ and to not stop at escaped quotes
    (?>
      "(?:(?:\\*(?!/))|(?:\\\\(?!"))|[^*\\\\])*?" |                      # [foo="bar"] Double-quoted
      '(?:(?:\\*(?!/))|(?:\\\\(?!'))|[^*\\\\])*?' |                      # [foo='bar'] Single-quoted
      \\[ (?:(?:\\*(?!/))|[^*])*? \\] |                                # [foo=[1,2]] Array literal
      (?:(?:\\*(?!/))|\\s(?!\\s*\\])|\\[.*?(?:\\]|(?=\\*/))|[^*\\s\\[\\]])*   # Everything else
    )*
  )
)?
\\s*(?:(\\])((?:[^*\\s]|\\*[^\\s/])+)?|(?=\\*/))`,
            captures: {
              "1": {
                name: "punctuation.definition.optional-value.begin.bracket.square.jsdoc"
              },
              "2": {
                name: "keyword.operator.assignment.jsdoc"
              },
              "3": {
                name: "source.embedded.ts"
              },
              "4": {
                name: "punctuation.definition.optional-value.end.bracket.square.jsdoc"
              },
              "5": {
                name: "invalid.illegal.syntax.jsdoc"
              }
            }
          }
        ]
      },
      {
        begin: "(?x)\n(\n  (@)\n  (?:define|enum|exception|export|extends|lends|implements|modifies\n  |namespace|private|protected|returns?|suppress|this|throws|type\n  |yields?)\n)\n\\s+(?={)",
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        },
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])",
        patterns: [
          {
            include: "#jsdoctype"
          }
        ]
      },
      {
        match: "(?x)\n(\n  (@)\n  (?:alias|augments|callback|constructs|emits|event|fires|exports?\n  |extends|external|function|func|host|lends|listens|interface|memberof!?\n  |method|module|mixes|mixin|name|requires|see|this|typedef|uses)\n)\n\\s+\n(\n  (?:\n    [^{}@\\s*] | \\*[^/]\n  )+\n)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "entity.name.type.instance.jsdoc"
          }
        }
      },
      {
        contentName: "variable.other.jsdoc",
        begin: `((@)(?:default(?:value)?|license|version))\\s+(([''"]))`,
        beginCaptures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          },
          "4": {
            name: "punctuation.definition.string.begin.jsdoc"
          }
        },
        end: "(\\3)|(?=$|\\*/)",
        endCaptures: {
          "0": {
            name: "variable.other.jsdoc"
          },
          "1": {
            name: "punctuation.definition.string.end.jsdoc"
          }
        }
      },
      {
        match: "((@)(?:default(?:value)?|license|tutorial|variation|version))\\s+([^\\s*]+)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          },
          "3": {
            name: "variable.other.jsdoc"
          }
        }
      },
      {
        name: "storage.type.class.jsdoc",
        match: "(?x) (@) (?:abstract|access|alias|api|arg|argument|async|attribute|augments|author|beta|borrows|bubbles |callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright |default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exception |exports?|extends|extension(?:_?for)?|external|externs|file|fileoverview|final|fires|for|func |function|generator|global|hideconstructor|host|ignore|implements|implicitCast|inherit[Dd]oc |inner|instance|interface|internal|kind|lends|license|listens|main|member|memberof!?|method |mixes|mixins?|modifies|module|name|namespace|noalias|nocollapse|nocompile|nosideeffects |override|overview|package|param|polymer(?:Behavior)?|preserve|private|prop|property|protected |public|read[Oo]nly|record|require[ds]|returns?|see|since|static|struct|submodule|summary |suppress|template|this|throws|todo|tutorial|type|typedef|unrestricted|uses|var|variation |version|virtual|writeOnce|yields?) \\b",
        captures: {
          "1": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        }
      },
      {
        include: "#inline-tags"
      },
      {
        match: "((@)(?:[_$[:alpha:]][_$[:alnum:]]*))(?=\\s+)",
        captures: {
          "1": {
            name: "storage.type.class.jsdoc"
          },
          "2": {
            name: "punctuation.definition.block.tag.jsdoc"
          }
        }
      }
    ]
  },
  brackets: {
    patterns: [
      {
        begin: "{",
        end: "}|(?=\\*/)",
        patterns: [
          {
            include: "#brackets"
          }
        ]
      },
      {
        begin: "\\[",
        end: "\\]|(?=\\*/)",
        patterns: [
          {
            include: "#brackets"
          }
        ]
      }
    ]
  },
  "inline-tags": {
    patterns: [
      {
        name: "constant.other.description.jsdoc",
        match: "(\\[)[^\\]]+(\\])(?={@(?:link|linkcode|linkplain|tutorial))",
        captures: {
          "1": {
            name: "punctuation.definition.bracket.square.begin.jsdoc"
          },
          "2": {
            name: "punctuation.definition.bracket.square.end.jsdoc"
          }
        }
      },
      {
        name: "entity.name.type.instance.jsdoc",
        begin: "({)((@)(?:link(?:code|plain)?|tutorial))\\s*",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.bracket.curly.begin.jsdoc"
          },
          "2": {
            name: "storage.type.class.jsdoc"
          },
          "3": {
            name: "punctuation.definition.inline.tag.jsdoc"
          }
        },
        end: "}|(?=\\*/)",
        endCaptures: {
          "0": {
            name: "punctuation.definition.bracket.curly.end.jsdoc"
          }
        },
        patterns: [
          {
            match: "\\G((?=https?://)(?:[^|}\\s*]|\\*[/])+)(\\|)?",
            captures: {
              "1": {
                name: "variable.other.link.underline.jsdoc"
              },
              "2": {
                name: "punctuation.separator.pipe.jsdoc"
              }
            }
          },
          {
            match: "\\G((?:[^{}@\\s|*]|\\*[^/])+)(\\|)?",
            captures: {
              "1": {
                name: "variable.other.description.jsdoc"
              },
              "2": {
                name: "punctuation.separator.pipe.jsdoc"
              }
            }
          }
        ]
      }
    ]
  },
  jsdoctype: {
    patterns: [
      {
        contentName: "entity.name.type.instance.jsdoc",
        begin: "\\G({)",
        beginCaptures: {
          "0": {
            name: "entity.name.type.instance.jsdoc"
          },
          "1": {
            name: "punctuation.definition.bracket.curly.begin.jsdoc"
          }
        },
        end: "((}))\\s*|(?=\\*/)",
        endCaptures: {
          "1": {
            name: "entity.name.type.instance.jsdoc"
          },
          "2": {
            name: "punctuation.definition.bracket.curly.end.jsdoc"
          }
        },
        patterns: [
          {
            include: "#brackets"
          }
        ]
      }
    ]
  }
};
const typescript_tmLanguage = {
  information_for_contributors: information_for_contributors$1,
  version: version$1,
  name: name$4,
  scopeName: scopeName$3,
  patterns: patterns$3,
  repository: repository$3
};
const __vite_glob_0_7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: typescript_tmLanguage,
  information_for_contributors: information_for_contributors$1,
  name: name$4,
  patterns: patterns$3,
  repository: repository$3,
  scopeName: scopeName$3,
  version: version$1
}, Symbol.toStringTag, { value: "Module" }));
const name$3 = "vue-html";
const scopeName$2 = "text.html.vue-html";
const fileTypes$1 = [];
const uuid$1 = "ca2e4260-5d62-45bf-8cf1-d8b5cc19c8f8";
const patterns$2 = [
  {
    include: "source.vue#vue-interpolations"
  },
  {
    name: "meta.tag.any.html",
    begin: "(<)([A-Z][a-zA-Z0-9:-]*)(?=[^>]*></\\2>)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "support.class.component.html"
      }
    },
    end: "(>)(<)(/)(\\2)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.html"
      },
      "2": {
        name: "punctuation.definition.tag.begin.html meta.scope.between-tag-pair.html"
      },
      "3": {
        name: "punctuation.definition.tag.begin.html"
      },
      "4": {
        name: "support.class.component.html"
      },
      "5": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      }
    ]
  },
  {
    name: "meta.tag.any.html",
    begin: "(<)([a-z][a-zA-Z0-9:-]*)(?=[^>]*></\\2>)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.html"
      }
    },
    end: "(>)(<)(/)(\\2)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.html"
      },
      "2": {
        name: "punctuation.definition.tag.begin.html meta.scope.between-tag-pair.html"
      },
      "3": {
        name: "punctuation.definition.tag.begin.html"
      },
      "4": {
        name: "entity.name.tag.html"
      },
      "5": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      }
    ]
  },
  {
    name: "meta.tag.preprocessor.xml.html",
    begin: "(<\\?)(xml)",
    end: "(\\?>)",
    captures: {
      "1": {
        name: "punctuation.definition.tag.html"
      },
      "2": {
        name: "entity.name.tag.xml.html"
      }
    },
    patterns: [
      {
        include: "#tag-generic-attribute"
      },
      {
        include: "#string-double-quoted"
      },
      {
        include: "#string-single-quoted"
      }
    ]
  },
  {
    name: "comment.block.html",
    begin: "<!--",
    end: "-->",
    captures: {
      "0": {
        name: "punctuation.definition.comment.html"
      }
    }
  },
  {
    name: "meta.tag.sgml.html",
    begin: "<!",
    end: ">",
    captures: {
      "0": {
        name: "punctuation.definition.tag.html"
      }
    },
    patterns: [
      {
        name: "meta.tag.sgml.doctype.html",
        begin: "(?i:DOCTYPE)",
        end: "(?=>)",
        captures: {
          "1": {
            name: "entity.name.tag.doctype.html"
          }
        },
        patterns: [
          {
            name: "string.quoted.double.doctype.identifiers-and-DTDs.html",
            match: '"[^">]*"'
          }
        ]
      },
      {
        name: "constant.other.inline-data.html",
        begin: "\\[CDATA\\[",
        end: "]](?=>)"
      },
      {
        name: "invalid.illegal.bad-comments-or-CDATA.html",
        match: "(\\s*)(?!--|>)\\S(\\s*)"
      }
    ]
  },
  {
    name: "meta.tag.block.any.html",
    begin: "(</?)([A-Z][a-zA-Z0-9:-]*\\b)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "support.class.component.html"
      }
    },
    end: "(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      }
    ]
  },
  {
    name: "meta.tag.block.any.html",
    begin: "(</?)([a-z][a-zA-Z0-9:-]*\\b)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.block.any.html"
      }
    },
    end: "(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      }
    ]
  },
  {
    name: "meta.tag.structure.any.html",
    begin: "(</?)((?i:body|head|html)\\b)",
    end: "(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    captures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.structure.any.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      }
    ]
  },
  {
    name: "meta.tag.block.any.html",
    begin: "(</?)((?i:address|blockquote|dd|div|dl|dt|fieldset|form|frame|frameset|h1|h2|h3|h4|h5|h6|iframe|noframes|object|ol|p|ul|applet|center|dir|hr|menu|pre)(?!-)\\b)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.block.any.html"
      }
    },
    end: "(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      }
    ]
  },
  {
    name: "meta.tag.inline.any.html",
    begin: "(</?)((?i:a|abbr|acronym|area|b|base|basefont|bdo|big|br|button|caption|cite|code|col|colgroup|del|dfn|em|font|head|html|i|img|input|ins|isindex|kbd|label|legend|li|link|map|meta|noscript|optgroup|option|param|q|s|samp|script|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|title|tr|tt|u|var)(?!-)\\b)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.inline.any.html"
      }
    },
    end: "(/?>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      }
    ]
  },
  {
    name: "meta.tag.other.html",
    begin: "(</?)([a-zA-Z0-9:-]+)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.other.html"
      }
    },
    end: "(/?>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      }
    ]
  },
  {
    include: "#entities"
  },
  {
    name: "invalid.illegal.incomplete.html",
    match: "<>"
  },
  {
    name: "invalid.illegal.bad-angle-bracket.html",
    match: "<"
  }
];
const repository$2 = {
  entities: {
    patterns: [
      {
        name: "constant.character.entity.html",
        match: "(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)",
        captures: {
          "1": {
            name: "punctuation.definition.entity.html"
          },
          "3": {
            name: "punctuation.definition.entity.html"
          }
        }
      },
      {
        name: "invalid.illegal.bad-ampersand.html",
        match: "&"
      }
    ]
  },
  "string-double-quoted": {
    name: "string.quoted.double.html",
    begin: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.html"
      }
    },
    end: '"',
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.html"
      }
    },
    patterns: [
      {
        include: "source.vue#vue-interpolations"
      },
      {
        include: "#entities"
      }
    ]
  },
  "string-single-quoted": {
    name: "string.quoted.single.html",
    begin: "'",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.html"
      }
    },
    end: "'",
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.html"
      }
    },
    patterns: [
      {
        include: "source.vue#vue-interpolations"
      },
      {
        include: "#entities"
      }
    ]
  },
  "tag-generic-attribute": {
    name: "entity.other.attribute-name.html",
    match: "(?<=[^=])\\b([a-zA-Z0-9:\\-_]+)"
  },
  "tag-id-attribute": {
    name: "meta.attribute-with-value.id.html",
    begin: "\\b(id)\\b\\s*(=)",
    end: `(?!\\G)(?<='|"|[^\\s<>/])`,
    captures: {
      "1": {
        name: "entity.other.attribute-name.id.html"
      },
      "2": {
        name: "punctuation.separator.key-value.html"
      }
    },
    patterns: [
      {
        name: "string.quoted.double.html",
        contentName: "meta.toc-list.id.html",
        begin: '"',
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.html"
          }
        },
        end: '"',
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.end.html"
          }
        },
        patterns: [
          {
            include: "source.vue#vue-interpolations"
          },
          {
            include: "#entities"
          }
        ]
      },
      {
        name: "string.quoted.single.html",
        contentName: "meta.toc-list.id.html",
        begin: "'",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.html"
          }
        },
        end: "'",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.end.html"
          }
        },
        patterns: [
          {
            include: "source.vue#vue-interpolations"
          },
          {
            include: "#entities"
          }
        ]
      },
      {
        name: "string.unquoted.html",
        match: `(?<==)(?:[^\\s<>/'"]|/(?!>))+`,
        captures: {
          "0": {
            name: "meta.toc-list.id.html"
          }
        }
      }
    ]
  },
  "tag-stuff": {
    patterns: [
      {
        include: "#vue-directives"
      },
      {
        include: "#tag-id-attribute"
      },
      {
        include: "#tag-generic-attribute"
      },
      {
        include: "#string-double-quoted"
      },
      {
        include: "#string-single-quoted"
      },
      {
        include: "#unquoted-attribute"
      }
    ]
  },
  "unquoted-attribute": {
    name: "string.unquoted.html",
    match: `(?<==)(?:[^\\s<>/'"]|/(?!>))+`
  },
  "vue-directives": {
    name: "meta.directive.vue",
    begin: "(?:\\b(v-)|(:|@|#))([a-zA-Z0-9\\-_]+)(?:\\:([a-zA-Z\\-_]+))?(?:\\.([a-zA-Z\\-_]+))*\\s*(=)",
    end: "(?<='|\")|(?=[\\s<>`])",
    captures: {
      "1": {
        name: "entity.other.attribute-name.html"
      },
      "2": {
        name: "punctuation.separator.key-value.html"
      },
      "3": {
        name: "entity.other.attribute-name.html"
      },
      "4": {
        name: "entity.other.attribute-name.html"
      },
      "5": {
        name: "entity.other.attribute-name.html"
      },
      "6": {
        name: "punctuation.separator.key-value.html"
      }
    },
    patterns: [
      {
        name: "source.directive.vue",
        begin: "`",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.html"
          }
        },
        end: "`",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.end.html"
          }
        },
        patterns: [
          {
            include: "source.js#expression"
          }
        ]
      },
      {
        name: "source.directive.vue",
        begin: '"',
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.html"
          }
        },
        end: '"',
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.end.html"
          }
        },
        patterns: [
          {
            include: "source.js#expression"
          }
        ]
      },
      {
        name: "source.directive.vue",
        begin: "'",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.html"
          }
        },
        end: "'",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.end.html"
          }
        },
        patterns: [
          {
            include: "source.js#expression"
          }
        ]
      }
    ]
  }
};
const vueHtml_tmLanguage = {
  name: name$3,
  scopeName: scopeName$2,
  fileTypes: fileTypes$1,
  uuid: uuid$1,
  patterns: patterns$2,
  repository: repository$2
};
const __vite_glob_0_8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: vueHtml_tmLanguage,
  fileTypes: fileTypes$1,
  name: name$3,
  patterns: patterns$2,
  repository: repository$2,
  scopeName: scopeName$2,
  uuid: uuid$1
}, Symbol.toStringTag, { value: "Module" }));
const name$2 = "vue";
const scopeName$1 = "source.vue";
const fileTypes = [
  "vue"
];
const uuid = "5512c10d-4cc5-434c-b8fc-53b912f55ab3";
const patterns$1 = [
  {
    begin: "(<)(slim)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      }
    },
    end: "(</)(slim)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</slim>)",
        contentName: "text.slim",
        patterns: [
          {
            include: "text.slim"
          }
        ]
      }
    ]
  },
  {
    begin: "(<)(i18n)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      }
    },
    end: "(</)(i18n)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</i18n>)",
        contentName: "source.json",
        patterns: [
          {
            include: "source.json"
          }
        ]
      }
    ]
  },
  {
    begin: "(<)(docs)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      }
    },
    end: "(</)(docs)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</docs>)",
        contentName: "text.html.markdown",
        patterns: [
          {
            include: "text.html.markdown"
          }
        ]
      }
    ]
  },
  {
    name: "comment.block.html",
    begin: "<!--",
    end: "-->",
    captures: {
      "0": {
        name: "punctuation.definition.comment.html"
      }
    }
  },
  {
    begin: "(<)(?=template.*[^/>]*/>\\s*$)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      }
    },
    end: "(/>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        begin: "(template)",
        beginCaptures: {
          "1": {
            name: "entity.name.tag.template.html"
          }
        },
        end: "(?=/>)",
        patterns: [
          {
            include: "#tag-stuff"
          }
        ]
      }
    ]
  },
  {
    begin: "(<)(template)(?=[^>]*>[^/>]*</template>)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      }
    },
    end: "(</)(template)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</template>)"
      }
    ]
  },
  {
    begin: `(<)(template)\\b(?=[^>]*lang=('jade'|"jade"|'pug'|"pug"))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      }
    },
    end: "(</)(template)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "text.pug",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</template>)",
        patterns: [
          {
            include: "text.pug"
          }
        ]
      }
    ]
  },
  {
    begin: `(<)(template)\\b(?=[^>]*lang=('haml'|"haml"))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      }
    },
    end: "(</)(template)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "text.haml",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</template>)",
        patterns: [
          {
            include: "text.haml"
          }
        ]
      }
    ]
  },
  {
    begin: `(<)(template)\\b(?=[^>]*lang=('slim'|"slim"))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      }
    },
    end: "(</)(template)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "text.slim",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</template>)",
        patterns: [
          {
            include: "text.slim"
          }
        ]
      }
    ]
  },
  {
    begin: `(<)(template)\\b(?=[^>]*lang=('slm'|"slm"))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      }
    },
    end: "(</)(template)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "text.jade.slm",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</template>)",
        patterns: [
          {
            include: "text.jade.slm"
          }
        ]
      }
    ]
  },
  {
    begin: `(<)(template)\\b(?=[^>]*lang=('liquid'|"liquid"))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      }
    },
    end: "(</)(template)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "text.html.liquid",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</template>)",
        patterns: [
          {
            include: "text.html.liquid"
          }
        ]
      }
    ]
  },
  {
    begin: "(<)(template)(?![^/>]*/>\\s*$)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      }
    },
    end: "^(</)(template)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.template.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "text.html.vue-html",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=^</template>)",
        patterns: [
          {
            include: "text.html.vue-html"
          }
        ]
      }
    ]
  },
  {
    begin: "(<)(style)\\b(?=[^/>]*/>\\s*$)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      }
    },
    end: "(/>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      }
    ]
  },
  {
    begin: "(<)(style)(?=[^>]*>[^/>]*</style>)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      }
    },
    end: "(</)(style)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</style>)"
      }
    ]
  },
  {
    begin: `(<)(style)\\b(?=[^>]*lang=('sass'|"sass"))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      }
    },
    end: "(</)(style)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "source.sass",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</style>)",
        patterns: [
          {
            include: "source.sass"
          }
        ]
      }
    ]
  },
  {
    begin: `(<)(style)\\b(?=[^>]*lang=('scss'|"scss"))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      }
    },
    end: "(</)(style)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "source.css.scss",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</style>)",
        patterns: [
          {
            include: "source.css.scss"
          }
        ]
      }
    ]
  },
  {
    begin: `(<)(style)\\b(?=[^>]*lang=('less'|"less"))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      }
    },
    end: "(</)(style)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "source.css.less",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</style>)",
        patterns: [
          {
            include: "source.css.less"
          }
        ]
      }
    ]
  },
  {
    begin: `(<)(style)\\b(?=[^>]*lang=('stylus'|"stylus"))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      }
    },
    end: "(</)(style)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "source.stylus",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</style>)",
        patterns: [
          {
            include: "source.stylus"
          }
        ]
      }
    ]
  },
  {
    begin: `(<)(style)\\b(?=[^>]*lang=('postcss'|"postcss"))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      }
    },
    end: "(</)(style)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "source.css.postcss",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</style>)",
        patterns: [
          {
            include: "source.css.postcss"
          }
        ]
      }
    ]
  },
  {
    begin: `(<)(style)\\b(?=[^>]*lang=(['"]sss['"]))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      }
    },
    end: "(</)(style)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "source.css.sugarss",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</style>)",
        patterns: [
          {
            include: "source.css.sugarss"
          }
        ]
      }
    ]
  },
  {
    begin: "(<)(style)(?![^/>]*/>\\s*$)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      }
    },
    end: "(</)(style)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.style.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "source.css",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=</style>)",
        patterns: [
          {
            include: "source.css"
          }
        ]
      }
    ]
  },
  {
    begin: "(<)(script)\\b(?=[^>]*/>$)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.script.html"
      }
    },
    end: "(/>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      }
    ]
  },
  {
    begin: "(<)(script)(?=[^>]*>[^/>]*<\/script>)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.script.html"
      }
    },
    end: "(</)(script)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.script.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=<\/script>)"
      }
    ]
  },
  {
    begin: `(<)(script)\\b(?=[^>]*lang=('ts'|"ts"))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.script.html"
      }
    },
    end: "(</)(script)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.script.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "source.ts",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=<\/script>)",
        patterns: [
          {
            include: "source.ts"
          }
        ]
      }
    ]
  },
  {
    begin: `(<)(script)\\b(?=[^>]*lang=('coffee'|"coffee"))(?![^/>]*/>\\s*$)`,
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.script.html"
      }
    },
    end: "(</)(script)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.script.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "source.coffee",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=<\/script>)",
        patterns: [
          {
            include: "source.coffee"
          }
        ]
      }
    ]
  },
  {
    begin: "(<)(script)(?![^/>]*/>\\s*$)",
    beginCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.script.html"
      }
    },
    end: "(</)(script)(>)",
    endCaptures: {
      "1": {
        name: "punctuation.definition.tag.begin.html"
      },
      "2": {
        name: "entity.name.tag.script.html"
      },
      "3": {
        name: "punctuation.definition.tag.end.html"
      }
    },
    patterns: [
      {
        include: "#tag-stuff"
      },
      {
        contentName: "source.js",
        begin: "(>)",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.tag.end.html"
          }
        },
        end: "(?=<\/script>)",
        patterns: [
          {
            include: "source.js"
          }
        ]
      }
    ]
  }
];
const repository$1 = {
  entities: {
    patterns: [
      {
        name: "constant.character.entity.html",
        match: "(&)([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+)(;)",
        captures: {
          "1": {
            name: "punctuation.definition.entity.html"
          },
          "3": {
            name: "punctuation.definition.entity.html"
          }
        }
      },
      {
        name: "invalid.illegal.bad-ampersand.html",
        match: "&"
      }
    ]
  },
  "string-double-quoted": {
    name: "string.quoted.double.html",
    begin: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.html"
      }
    },
    end: '"',
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.html"
      }
    },
    patterns: [
      {
        include: "#vue-interpolations"
      },
      {
        include: "#entities"
      }
    ]
  },
  "string-single-quoted": {
    name: "string.quoted.single.html",
    begin: "'",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.html"
      }
    },
    end: "'",
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.html"
      }
    },
    patterns: [
      {
        include: "#vue-interpolations"
      },
      {
        include: "#entities"
      }
    ]
  },
  "tag-generic-attribute": {
    name: "entity.other.attribute-name.html",
    match: "\\b([a-zA-Z\\-:_]+)"
  },
  "tag-id-attribute": {
    name: "meta.attribute-with-value.id.html",
    begin: "\\b(id)\\b\\s*(=)",
    end: `(?<='|")`,
    captures: {
      "1": {
        name: "entity.other.attribute-name.id.html"
      },
      "2": {
        name: "punctuation.separator.key-value.html"
      }
    },
    patterns: [
      {
        name: "string.quoted.double.html",
        contentName: "meta.toc-list.id.html",
        begin: '"',
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.html"
          }
        },
        end: '"',
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.end.html"
          }
        },
        patterns: [
          {
            include: "#vue-interpolations"
          },
          {
            include: "#entities"
          }
        ]
      },
      {
        name: "string.quoted.single.html",
        contentName: "meta.toc-list.id.html",
        begin: "'",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.html"
          }
        },
        end: "'",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.end.html"
          }
        },
        patterns: [
          {
            include: "#vue-interpolations"
          },
          {
            include: "#entities"
          }
        ]
      }
    ]
  },
  "tag-stuff": {
    patterns: [
      {
        include: "#vue-directives"
      },
      {
        include: "#tag-id-attribute"
      },
      {
        include: "#tag-generic-attribute"
      },
      {
        include: "#string-double-quoted"
      },
      {
        include: "#string-single-quoted"
      }
    ]
  },
  "vue-directives": {
    name: "meta.directive.vue",
    begin: "(?:\\b(v-)|(:|@|#))([a-zA-Z0-9\\-_]+)(?:\\:([a-zA-Z\\-_]+))?(?:\\.([a-zA-Z\\-_]+))*\\s*(=)",
    end: "(?<='|\")|(?=[\\s<>`])",
    captures: {
      "1": {
        name: "entity.other.attribute-name.html"
      },
      "2": {
        name: "punctuation.separator.key-value.html"
      },
      "3": {
        name: "entity.other.attribute-name.html"
      },
      "4": {
        name: "entity.other.attribute-name.html"
      },
      "5": {
        name: "entity.other.attribute-name.html"
      },
      "6": {
        name: "punctuation.separator.key-value.html"
      }
    },
    patterns: [
      {
        name: "source.directive.vue",
        begin: "`",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.html"
          }
        },
        end: "`",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.end.html"
          }
        },
        patterns: [
          {
            include: "source.js#expression"
          }
        ]
      },
      {
        name: "source.directive.vue",
        begin: '"',
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.html"
          }
        },
        end: '"',
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.end.html"
          }
        },
        patterns: [
          {
            include: "source.js#expression"
          }
        ]
      },
      {
        name: "source.directive.vue",
        begin: "'",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.string.begin.html"
          }
        },
        end: "'",
        endCaptures: {
          "0": {
            name: "punctuation.definition.string.end.html"
          }
        },
        patterns: [
          {
            include: "source.js#expression"
          }
        ]
      }
    ]
  },
  "vue-interpolations": {
    patterns: [
      {
        name: "expression.embedded.vue",
        begin: "\\{\\{\\{?",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.generic.begin.html"
          }
        },
        end: "\\}\\}\\}?",
        endCaptures: {
          "0": {
            name: "punctuation.definition.generic.end.html"
          }
        },
        patterns: [
          {
            include: "source.js#expression"
          }
        ]
      }
    ]
  }
};
const vue_tmLanguage = {
  name: name$2,
  scopeName: scopeName$1,
  fileTypes,
  uuid,
  patterns: patterns$1,
  repository: repository$1
};
const __vite_glob_0_9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: vue_tmLanguage,
  fileTypes,
  name: name$2,
  patterns: patterns$1,
  repository: repository$1,
  scopeName: scopeName$1,
  uuid
}, Symbol.toStringTag, { value: "Module" }));
const information_for_contributors = [
  "This file has been converted from https://github.com/textmate/yaml.tmbundle/blob/master/Syntaxes/YAML.tmLanguage",
  "If you want to provide a fix or improvement, please create a pull request against the original repository.",
  "Once accepted there, we are happy to receive an update request."
];
const version = "https://github.com/textmate/yaml.tmbundle/commit/e54ceae3b719506dba7e481a77cea4a8b576ae46";
const name$1 = "yaml";
const scopeName = "source.yaml";
const patterns = [
  {
    include: "#comment"
  },
  {
    include: "#property"
  },
  {
    include: "#directive"
  },
  {
    match: "^---",
    name: "entity.other.document.begin.yaml"
  },
  {
    match: "^\\.{3}",
    name: "entity.other.document.end.yaml"
  },
  {
    include: "#node"
  }
];
const repository = {
  "block-collection": {
    patterns: [
      {
        include: "#block-sequence"
      },
      {
        include: "#block-mapping"
      }
    ]
  },
  "block-mapping": {
    patterns: [
      {
        include: "#block-pair"
      }
    ]
  },
  "block-node": {
    patterns: [
      {
        include: "#prototype"
      },
      {
        include: "#block-scalar"
      },
      {
        include: "#block-collection"
      },
      {
        include: "#flow-scalar-plain-out"
      },
      {
        include: "#flow-node"
      }
    ]
  },
  "block-pair": {
    patterns: [
      {
        begin: "\\?",
        beginCaptures: {
          "1": {
            name: "punctuation.definition.key-value.begin.yaml"
          }
        },
        end: "(?=\\?)|^ *(:)|(:)",
        endCaptures: {
          "1": {
            name: "punctuation.separator.key-value.mapping.yaml"
          },
          "2": {
            name: "invalid.illegal.expected-newline.yaml"
          }
        },
        name: "meta.block-mapping.yaml",
        patterns: [
          {
            include: "#block-node"
          }
        ]
      },
      {
        begin: "(?x)\n                        (?=\n                            (?x:\n                                  [^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]\n                                | [?:-] \\S\n                            )\n                            (\n                                  [^\\s:]\n                                | : \\S\n                                | \\s+ (?![#\\s])\n                            )*\n                            \\s*\n                            :\n							(\\s|$)\n                        )\n                    ",
        end: "(?x)\n                        (?=\n                              \\s* $\n                            | \\s+ \\#\n                            | \\s* : (\\s|$)\n                        )\n                    ",
        patterns: [
          {
            include: "#flow-scalar-plain-out-implicit-type"
          },
          {
            begin: "(?x)\n                                  [^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]\n                                | [?:-] \\S\n                            ",
            beginCaptures: {
              "0": {
                name: "entity.name.tag.yaml"
              }
            },
            contentName: "entity.name.tag.yaml",
            end: "(?x)\n                                (?=\n                                      \\s* $\n                                    | \\s+ \\#\n                                    | \\s* : (\\s|$)\n                                )\n                            ",
            name: "string.unquoted.plain.out.yaml"
          }
        ]
      },
      {
        match: ":(?=\\s|$)",
        name: "punctuation.separator.key-value.mapping.yaml"
      }
    ]
  },
  "block-scalar": {
    begin: "(?:(\\|)|(>))([1-9])?([-+])?(.*\\n?)",
    beginCaptures: {
      "1": {
        name: "keyword.control.flow.block-scalar.literal.yaml"
      },
      "2": {
        name: "keyword.control.flow.block-scalar.folded.yaml"
      },
      "3": {
        name: "constant.numeric.indentation-indicator.yaml"
      },
      "4": {
        name: "storage.modifier.chomping-indicator.yaml"
      },
      "5": {
        patterns: [
          {
            include: "#comment"
          },
          {
            match: ".+",
            name: "invalid.illegal.expected-comment-or-newline.yaml"
          }
        ]
      }
    },
    end: "^(?=\\S)|(?!\\G)",
    patterns: [
      {
        begin: "^([ ]+)(?! )",
        end: "^(?!\\1|\\s*$)",
        name: "string.unquoted.block.yaml"
      }
    ]
  },
  "block-sequence": {
    match: "(-)(?!\\S)",
    name: "punctuation.definition.block.sequence.item.yaml"
  },
  comment: {
    begin: "(?:(^[ \\t]*)|[ \\t]+)(?=#\\p{Print}*$)",
    beginCaptures: {
      "1": {
        name: "punctuation.whitespace.comment.leading.yaml"
      }
    },
    end: "(?!\\G)",
    patterns: [
      {
        begin: "#",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.comment.yaml"
          }
        },
        end: "\\n",
        name: "comment.line.number-sign.yaml"
      }
    ]
  },
  directive: {
    begin: "^%",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.directive.begin.yaml"
      }
    },
    end: "(?=$|[ \\t]+($|#))",
    name: "meta.directive.yaml",
    patterns: [
      {
        captures: {
          "1": {
            name: "keyword.other.directive.yaml.yaml"
          },
          "2": {
            name: "constant.numeric.yaml-version.yaml"
          }
        },
        match: "\\G(YAML)[ \\t]+(\\d+\\.\\d+)"
      },
      {
        captures: {
          "1": {
            name: "keyword.other.directive.tag.yaml"
          },
          "2": {
            name: "storage.type.tag-handle.yaml"
          },
          "3": {
            name: "support.type.tag-prefix.yaml"
          }
        },
        match: "(?x)\n                        \\G\n                        (TAG)\n                        (?:[ \\t]+\n                            ((?:!(?:[0-9A-Za-z\\-]*!)?))\n                            (?:[ \\t]+ (\n                                  !              (?x: %[0-9A-Fa-f]{2} | [0-9A-Za-z\\-#;/?:@&=+$,_.!~*'()\\[\\]] )*\n                                | (?![,!\\[\\]{}]) (?x: %[0-9A-Fa-f]{2} | [0-9A-Za-z\\-#;/?:@&=+$,_.!~*'()\\[\\]] )+\n                                )\n                            )?\n                        )?\n                    "
      },
      {
        captures: {
          "1": {
            name: "support.other.directive.reserved.yaml"
          },
          "2": {
            name: "string.unquoted.directive-name.yaml"
          },
          "3": {
            name: "string.unquoted.directive-parameter.yaml"
          }
        },
        match: "(?x) \\G (\\w+) (?:[ \\t]+ (\\w+) (?:[ \\t]+ (\\w+))? )?"
      },
      {
        match: "\\S+",
        name: "invalid.illegal.unrecognized.yaml"
      }
    ]
  },
  "flow-alias": {
    captures: {
      "1": {
        name: "keyword.control.flow.alias.yaml"
      },
      "2": {
        name: "punctuation.definition.alias.yaml"
      },
      "3": {
        name: "variable.other.alias.yaml"
      },
      "4": {
        name: "invalid.illegal.character.anchor.yaml"
      }
    },
    match: "((\\*))([^\\s\\[\\]/{/},]+)([^\\s\\]},]\\S*)?"
  },
  "flow-collection": {
    patterns: [
      {
        include: "#flow-sequence"
      },
      {
        include: "#flow-mapping"
      }
    ]
  },
  "flow-mapping": {
    begin: "\\{",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.mapping.begin.yaml"
      }
    },
    end: "\\}",
    endCaptures: {
      "0": {
        name: "punctuation.definition.mapping.end.yaml"
      }
    },
    name: "meta.flow-mapping.yaml",
    patterns: [
      {
        include: "#prototype"
      },
      {
        match: ",",
        name: "punctuation.separator.mapping.yaml"
      },
      {
        include: "#flow-pair"
      }
    ]
  },
  "flow-node": {
    patterns: [
      {
        include: "#prototype"
      },
      {
        include: "#flow-alias"
      },
      {
        include: "#flow-collection"
      },
      {
        include: "#flow-scalar"
      }
    ]
  },
  "flow-pair": {
    patterns: [
      {
        begin: "\\?",
        beginCaptures: {
          "0": {
            name: "punctuation.definition.key-value.begin.yaml"
          }
        },
        end: "(?=[},\\]])",
        name: "meta.flow-pair.explicit.yaml",
        patterns: [
          {
            include: "#prototype"
          },
          {
            include: "#flow-pair"
          },
          {
            include: "#flow-node"
          },
          {
            begin: ":(?=\\s|$|[\\[\\]{},])",
            beginCaptures: {
              "0": {
                name: "punctuation.separator.key-value.mapping.yaml"
              }
            },
            end: "(?=[},\\]])",
            patterns: [
              {
                include: "#flow-value"
              }
            ]
          }
        ]
      },
      {
        begin: "(?x)\n                        (?=\n                            (?:\n                                [^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]\n                              | [?:-] [^\\s[\\[\\]{},]]\n                            )\n                            (\n                                  [^\\s:[\\[\\]{},]]\n                                | : [^\\s[\\[\\]{},]]\n                                | \\s+ (?![#\\s])\n                            )*\n                            \\s*\n                            :\n							(\\s|$)\n                        )\n                    ",
        end: "(?x)\n                        (?=\n                              \\s* $\n                            | \\s+ \\#\n                            | \\s* : (\\s|$)\n                            | \\s* : [\\[\\]{},]\n                            | \\s* [\\[\\]{},]\n                        )\n                    ",
        name: "meta.flow-pair.key.yaml",
        patterns: [
          {
            include: "#flow-scalar-plain-in-implicit-type"
          },
          {
            begin: "(?x)\n                                  [^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]\n                                | [?:-] [^\\s[\\[\\]{},]]\n                            ",
            beginCaptures: {
              "0": {
                name: "entity.name.tag.yaml"
              }
            },
            contentName: "entity.name.tag.yaml",
            end: "(?x)\n                                (?=\n                                      \\s* $\n                                    | \\s+ \\#\n                                    | \\s* : (\\s|$)\n                                    | \\s* : [\\[\\]{},]\n                                    | \\s* [\\[\\]{},]\n                                )\n                            ",
            name: "string.unquoted.plain.in.yaml"
          }
        ]
      },
      {
        include: "#flow-node"
      },
      {
        begin: ":(?=\\s|$|[\\[\\]{},])",
        captures: {
          "0": {
            name: "punctuation.separator.key-value.mapping.yaml"
          }
        },
        end: "(?=[},\\]])",
        name: "meta.flow-pair.yaml",
        patterns: [
          {
            include: "#flow-value"
          }
        ]
      }
    ]
  },
  "flow-scalar": {
    patterns: [
      {
        include: "#flow-scalar-double-quoted"
      },
      {
        include: "#flow-scalar-single-quoted"
      },
      {
        include: "#flow-scalar-plain-in"
      }
    ]
  },
  "flow-scalar-double-quoted": {
    begin: '"',
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.yaml"
      }
    },
    end: '"',
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.yaml"
      }
    },
    name: "string.quoted.double.yaml",
    patterns: [
      {
        match: '\\\\([0abtnvfre "/\\\\N_Lp]|x\\d\\d|u\\d{4}|U\\d{8})',
        name: "constant.character.escape.yaml"
      },
      {
        match: "\\\\\\n",
        name: "constant.character.escape.double-quoted.newline.yaml"
      }
    ]
  },
  "flow-scalar-plain-in": {
    patterns: [
      {
        include: "#flow-scalar-plain-in-implicit-type"
      },
      {
        begin: "(?x)\n                          [^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]\n                        | [?:-] [^\\s[\\[\\]{},]]\n                    ",
        end: "(?x)\n                        (?=\n                              \\s* $\n                            | \\s+ \\#\n                            | \\s* : (\\s|$)\n                            | \\s* : [\\[\\]{},]\n                            | \\s* [\\[\\]{},]\n                        )\n                    ",
        name: "string.unquoted.plain.in.yaml"
      }
    ]
  },
  "flow-scalar-plain-in-implicit-type": {
    patterns: [
      {
        captures: {
          "1": {
            name: "constant.language.null.yaml"
          },
          "2": {
            name: "constant.language.boolean.yaml"
          },
          "3": {
            name: "constant.numeric.integer.yaml"
          },
          "4": {
            name: "constant.numeric.float.yaml"
          },
          "5": {
            name: "constant.other.timestamp.yaml"
          },
          "6": {
            name: "constant.language.value.yaml"
          },
          "7": {
            name: "constant.language.merge.yaml"
          }
        },
        match: "(?x)\n                        (?x:\n                              (null|Null|NULL|~)\n                            | (y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)\n                            | (\n                                (?:\n                                      [-+]? 0b [0-1_]+ # (base 2)\n                                    | [-+]? 0  [0-7_]+ # (base 8)\n                                    | [-+]? (?: 0|[1-9][0-9_]*) # (base 10)\n                                    | [-+]? 0x [0-9a-fA-F_]+ # (base 16)\n                                    | [-+]? [1-9] [0-9_]* (?: :[0-5]?[0-9])+ # (base 60)\n                                )\n                              )\n                            | (\n                                (?x:\n                                      [-+]? (?: [0-9] [0-9_]*)? \\. [0-9.]* (?: [eE] [-+] [0-9]+)? # (base 10)\n                                    | [-+]? [0-9] [0-9_]* (?: :[0-5]?[0-9])+ \\. [0-9_]* # (base 60)\n                                    | [-+]? \\. (?: inf|Inf|INF) # (infinity)\n                                    |       \\. (?: nan|NaN|NAN) # (not a number)\n                                )\n                              )\n                            | (\n                                (?x:\n                                    \\d{4} - \\d{2} - \\d{2}           # (y-m-d)\n                                  | \\d{4}                           # (year)\n                                    - \\d{1,2}                       # (month)\n                                    - \\d{1,2}                       # (day)\n                                    (?: [Tt] | [ \\t]+) \\d{1,2}      # (hour)\n                                    : \\d{2}                         # (minute)\n                                    : \\d{2}                         # (second)\n                                    (?: \\.\\d*)?                     # (fraction)\n                                    (?:\n                                          (?:[ \\t]*) Z\n                                        | [-+] \\d{1,2} (?: :\\d{1,2})?\n                                    )?                              # (time zone)\n                                )\n                              )\n                            | (=)\n                            | (<<)\n                        )\n                        (?:\n                            (?=\n                                  \\s* $\n                                | \\s+ \\#\n                                | \\s* : (\\s|$)\n                                | \\s* : [\\[\\]{},]\n                                | \\s* [\\[\\]{},]\n                            )\n                        )\n                    "
      }
    ]
  },
  "flow-scalar-plain-out": {
    patterns: [
      {
        include: "#flow-scalar-plain-out-implicit-type"
      },
      {
        begin: "(?x)\n                          [^\\s[-?:,\\[\\]{}#&*!|>'\"%@`]]\n                        | [?:-] \\S\n                    ",
        end: "(?x)\n                        (?=\n                              \\s* $\n                            | \\s+ \\#\n                            | \\s* : (\\s|$)\n                        )\n                    ",
        name: "string.unquoted.plain.out.yaml"
      }
    ]
  },
  "flow-scalar-plain-out-implicit-type": {
    patterns: [
      {
        captures: {
          "1": {
            name: "constant.language.null.yaml"
          },
          "2": {
            name: "constant.language.boolean.yaml"
          },
          "3": {
            name: "constant.numeric.integer.yaml"
          },
          "4": {
            name: "constant.numeric.float.yaml"
          },
          "5": {
            name: "constant.other.timestamp.yaml"
          },
          "6": {
            name: "constant.language.value.yaml"
          },
          "7": {
            name: "constant.language.merge.yaml"
          }
        },
        match: "(?x)\n                        (?x:\n                              (null|Null|NULL|~)\n                            | (y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)\n                            | (\n                                (?:\n                                      [-+]? 0b [0-1_]+ # (base 2)\n                                    | [-+]? 0  [0-7_]+ # (base 8)\n                                    | [-+]? (?: 0|[1-9][0-9_]*) # (base 10)\n                                    | [-+]? 0x [0-9a-fA-F_]+ # (base 16)\n                                    | [-+]? [1-9] [0-9_]* (?: :[0-5]?[0-9])+ # (base 60)\n                                )\n                              )\n                            | (\n                                (?x:\n                                      [-+]? (?: [0-9] [0-9_]*)? \\. [0-9.]* (?: [eE] [-+] [0-9]+)? # (base 10)\n                                    | [-+]? [0-9] [0-9_]* (?: :[0-5]?[0-9])+ \\. [0-9_]* # (base 60)\n                                    | [-+]? \\. (?: inf|Inf|INF) # (infinity)\n                                    |       \\. (?: nan|NaN|NAN) # (not a number)\n                                )\n                              )\n                            | (\n                                (?x:\n                                    \\d{4} - \\d{2} - \\d{2}           # (y-m-d)\n                                  | \\d{4}                           # (year)\n                                    - \\d{1,2}                       # (month)\n                                    - \\d{1,2}                       # (day)\n                                    (?: [Tt] | [ \\t]+) \\d{1,2}      # (hour)\n                                    : \\d{2}                         # (minute)\n                                    : \\d{2}                         # (second)\n                                    (?: \\.\\d*)?                     # (fraction)\n                                    (?:\n                                          (?:[ \\t]*) Z\n                                        | [-+] \\d{1,2} (?: :\\d{1,2})?\n                                    )?                              # (time zone)\n                                )\n                              )\n                            | (=)\n                            | (<<)\n                        )\n                        (?x:\n                            (?=\n                                  \\s* $\n                                | \\s+ \\#\n                                | \\s* : (\\s|$)\n                            )\n                        )\n                    "
      }
    ]
  },
  "flow-scalar-single-quoted": {
    begin: "'",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.string.begin.yaml"
      }
    },
    end: "'(?!')",
    endCaptures: {
      "0": {
        name: "punctuation.definition.string.end.yaml"
      }
    },
    name: "string.quoted.single.yaml",
    patterns: [
      {
        match: "''",
        name: "constant.character.escape.single-quoted.yaml"
      }
    ]
  },
  "flow-sequence": {
    begin: "\\[",
    beginCaptures: {
      "0": {
        name: "punctuation.definition.sequence.begin.yaml"
      }
    },
    end: "\\]",
    endCaptures: {
      "0": {
        name: "punctuation.definition.sequence.end.yaml"
      }
    },
    name: "meta.flow-sequence.yaml",
    patterns: [
      {
        include: "#prototype"
      },
      {
        match: ",",
        name: "punctuation.separator.sequence.yaml"
      },
      {
        include: "#flow-pair"
      },
      {
        include: "#flow-node"
      }
    ]
  },
  "flow-value": {
    patterns: [
      {
        begin: "\\G(?![},\\]])",
        end: "(?=[},\\]])",
        name: "meta.flow-pair.value.yaml",
        patterns: [
          {
            include: "#flow-node"
          }
        ]
      }
    ]
  },
  node: {
    patterns: [
      {
        include: "#block-node"
      }
    ]
  },
  property: {
    begin: "(?=!|&)",
    end: "(?!\\G)",
    name: "meta.property.yaml",
    patterns: [
      {
        captures: {
          "1": {
            name: "keyword.control.property.anchor.yaml"
          },
          "2": {
            name: "punctuation.definition.anchor.yaml"
          },
          "3": {
            name: "entity.name.type.anchor.yaml"
          },
          "4": {
            name: "invalid.illegal.character.anchor.yaml"
          }
        },
        match: "\\G((&))([^\\s\\[\\]/{/},]+)(\\S+)?"
      },
      {
        match: "(?x)\n                        \\G\n                        (?:\n                            ! < (?: %[0-9A-Fa-f]{2} | [0-9A-Za-z\\-#;/?:@&=+$,_.!~*'()\\[\\]] )+ >\n                          | (?:!(?:[0-9A-Za-z\\-]*!)?) (?: %[0-9A-Fa-f]{2} | [0-9A-Za-z\\-#;/?:@&=+$_.~*'()] )+\n                          | !\n                        )\n                        (?=\\ |\\t|$)\n                    ",
        name: "storage.type.tag-handle.yaml"
      },
      {
        match: "\\S+",
        name: "invalid.illegal.tag-handle.yaml"
      }
    ]
  },
  prototype: {
    patterns: [
      {
        include: "#comment"
      },
      {
        include: "#property"
      }
    ]
  }
};
const yaml_tmLanguage = {
  information_for_contributors,
  version,
  name: name$1,
  scopeName,
  patterns,
  repository
};
const __vite_glob_0_10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: yaml_tmLanguage,
  information_for_contributors,
  name: name$1,
  patterns,
  repository,
  scopeName,
  version
}, Symbol.toStringTag, { value: "Module" }));
var lib = {};
var onigasmH = {};
var onigasm$1 = { exports: {} };
(function(module, exports) {
  var Onigasm = function() {
    typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
    return function(Onigasm2) {
      Onigasm2 = Onigasm2 || {};
      var Module = typeof Onigasm2 !== "undefined" ? Onigasm2 : {};
      var moduleOverrides = {};
      var key;
      for (key in Module) {
        if (Module.hasOwnProperty(key)) {
          moduleOverrides[key] = Module[key];
        }
      }
      var ENVIRONMENT_IS_WORKER = false;
      var scriptDirectory = "";
      function locateFile(path) {
        if (Module["locateFile"]) {
          return Module["locateFile"](path, scriptDirectory);
        }
        return scriptDirectory + path;
      }
      var readBinary;
      {
        readBinary = function readBinary2(f2) {
          var data;
          if (typeof readbuffer === "function") {
            return new Uint8Array(readbuffer(f2));
          }
          data = read(f2, "binary");
          assert(typeof data === "object");
          return data;
        };
        if (typeof scriptArgs != "undefined") {
          scriptArgs;
        }
        if (typeof print !== "undefined") {
          if (typeof console === "undefined")
            console = {};
          console.log = print;
          console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
        }
      }
      var out = Module["print"] || console.log.bind(console);
      var err = Module["printErr"] || console.warn.bind(console);
      for (key in moduleOverrides) {
        if (moduleOverrides.hasOwnProperty(key)) {
          Module[key] = moduleOverrides[key];
        }
      }
      moduleOverrides = null;
      if (Module["arguments"])
        Module["arguments"];
      if (Module["thisProgram"])
        Module["thisProgram"];
      if (Module["quit"])
        Module["quit"];
      var wasmBinary;
      if (Module["wasmBinary"])
        wasmBinary = Module["wasmBinary"];
      if (Module["noExitRuntime"])
        Module["noExitRuntime"];
      if (typeof WebAssembly !== "object") {
        err("no native wasm support detected");
      }
      var wasmMemory;
      var wasmTable = new WebAssembly.Table({ "initial": 244, "maximum": 244 + 0, "element": "anyfunc" });
      var ABORT = false;
      function assert(condition, text) {
        if (!condition) {
          abort("Assertion failed: " + text);
        }
      }
      function getCFunc(ident) {
        var func = Module["_" + ident];
        assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
        return func;
      }
      function ccall(ident, returnType, argTypes, args, opts) {
        var toC = { "string": function(str) {
          var ret2 = 0;
          if (str !== null && str !== void 0 && str !== 0) {
            var len = (str.length << 2) + 1;
            ret2 = stackAlloc(len);
            stringToUTF8(str, ret2, len);
          }
          return ret2;
        }, "array": function(arr) {
          var ret2 = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret2);
          return ret2;
        } };
        function convertReturnValue(ret2) {
          if (returnType === "string")
            return UTF8ToString(ret2);
          if (returnType === "boolean")
            return Boolean(ret2);
          return ret2;
        }
        var func = getCFunc(ident);
        var cArgs = [];
        var stack = 0;
        if (args) {
          for (var i = 0; i < args.length; i++) {
            var converter = toC[argTypes[i]];
            if (converter) {
              if (stack === 0)
                stack = stackSave();
              cArgs[i] = converter(args[i]);
            } else {
              cArgs[i] = args[i];
            }
          }
        }
        var ret = func.apply(null, cArgs);
        ret = convertReturnValue(ret);
        if (stack !== 0)
          stackRestore(stack);
        return ret;
      }
      var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
      function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;
        while (u8Array[endPtr] && !(endPtr >= endIdx))
          ++endPtr;
        if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
          return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
        } else {
          var str = "";
          while (idx < endPtr) {
            var u0 = u8Array[idx++];
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            var u1 = u8Array[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            var u2 = u8Array[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
        }
        return str;
      }
      function UTF8ToString(ptr, maxBytesToRead) {
        return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
      }
      function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
        if (!(maxBytesToWrite > 0))
          return 0;
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i = 0; i < str.length; ++i) {
          var u2 = str.charCodeAt(i);
          if (u2 >= 55296 && u2 <= 57343) {
            var u1 = str.charCodeAt(++i);
            u2 = 65536 + ((u2 & 1023) << 10) | u1 & 1023;
          }
          if (u2 <= 127) {
            if (outIdx >= endIdx)
              break;
            outU8Array[outIdx++] = u2;
          } else if (u2 <= 2047) {
            if (outIdx + 1 >= endIdx)
              break;
            outU8Array[outIdx++] = 192 | u2 >> 6;
            outU8Array[outIdx++] = 128 | u2 & 63;
          } else if (u2 <= 65535) {
            if (outIdx + 2 >= endIdx)
              break;
            outU8Array[outIdx++] = 224 | u2 >> 12;
            outU8Array[outIdx++] = 128 | u2 >> 6 & 63;
            outU8Array[outIdx++] = 128 | u2 & 63;
          } else {
            if (outIdx + 3 >= endIdx)
              break;
            outU8Array[outIdx++] = 240 | u2 >> 18;
            outU8Array[outIdx++] = 128 | u2 >> 12 & 63;
            outU8Array[outIdx++] = 128 | u2 >> 6 & 63;
            outU8Array[outIdx++] = 128 | u2 & 63;
          }
        }
        outU8Array[outIdx] = 0;
        return outIdx - startIdx;
      }
      function stringToUTF8(str, outPtr, maxBytesToWrite) {
        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
      }
      typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
      function writeArrayToMemory(array, buffer2) {
        HEAP8.set(array, buffer2);
      }
      var WASM_PAGE_SIZE = 65536;
      function alignUp(x2, multiple) {
        if (x2 % multiple > 0) {
          x2 += multiple - x2 % multiple;
        }
        return x2;
      }
      var buffer, HEAP8, HEAPU8, HEAP32;
      function updateGlobalBufferAndViews(buf) {
        buffer = buf;
        Module["HEAP8"] = HEAP8 = new Int8Array(buf);
        Module["HEAP16"] = new Int16Array(buf);
        Module["HEAP32"] = HEAP32 = new Int32Array(buf);
        Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
        Module["HEAPU16"] = new Uint16Array(buf);
        Module["HEAPU32"] = new Uint32Array(buf);
        Module["HEAPF32"] = new Float32Array(buf);
        Module["HEAPF64"] = new Float64Array(buf);
      }
      var DYNAMIC_BASE = 5507664, DYNAMICTOP_PTR = 264624;
      var INITIAL_TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 157286400;
      if (Module["wasmMemory"]) {
        wasmMemory = Module["wasmMemory"];
      } else {
        wasmMemory = new WebAssembly.Memory({ "initial": INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE });
      }
      if (wasmMemory) {
        buffer = wasmMemory.buffer;
      }
      INITIAL_TOTAL_MEMORY = buffer.byteLength;
      updateGlobalBufferAndViews(buffer);
      HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
      function callRuntimeCallbacks(callbacks2) {
        while (callbacks2.length > 0) {
          var callback = callbacks2.shift();
          if (typeof callback == "function") {
            callback();
            continue;
          }
          var func = callback.func;
          if (typeof func === "number") {
            if (callback.arg === void 0) {
              Module["dynCall_v"](func);
            } else {
              Module["dynCall_vi"](func, callback.arg);
            }
          } else {
            func(callback.arg === void 0 ? null : callback.arg);
          }
        }
      }
      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATMAIN__ = [];
      var __ATPOSTRUN__ = [];
      function preRun() {
        if (Module["preRun"]) {
          if (typeof Module["preRun"] == "function")
            Module["preRun"] = [Module["preRun"]];
          while (Module["preRun"].length) {
            addOnPreRun(Module["preRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPRERUN__);
      }
      function initRuntime() {
        callRuntimeCallbacks(__ATINIT__);
      }
      function preMain() {
        callRuntimeCallbacks(__ATMAIN__);
      }
      function postRun() {
        if (Module["postRun"]) {
          if (typeof Module["postRun"] == "function")
            Module["postRun"] = [Module["postRun"]];
          while (Module["postRun"].length) {
            addOnPostRun(Module["postRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPOSTRUN__);
      }
      function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
      }
      function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
      }
      var runDependencies = 0;
      var dependenciesFulfilled = null;
      function addRunDependency(id2) {
        runDependencies++;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
      }
      function removeRunDependency(id2) {
        runDependencies--;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (runDependencies == 0) {
          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }
      Module["preloadedImages"] = {};
      Module["preloadedAudios"] = {};
      function abort(what) {
        if (Module["onAbort"]) {
          Module["onAbort"](what);
        }
        what += "";
        out(what);
        err(what);
        ABORT = true;
        what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
        throw new WebAssembly.RuntimeError(what);
      }
      var dataURIPrefix = "data:application/octet-stream;base64,";
      function isDataURI(filename) {
        return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
      }
      var wasmBinaryFile = "onigasm.wasm";
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = locateFile(wasmBinaryFile);
      }
      function getBinary() {
        try {
          if (wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(wasmBinaryFile);
          } else {
            throw "both async and sync fetching of the wasm failed";
          }
        } catch (err2) {
          abort(err2);
        }
      }
      function getBinaryPromise() {
        if (!wasmBinary && ENVIRONMENT_IS_WORKER && typeof fetch === "function") {
          return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
            if (!response["ok"]) {
              throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
            }
            return response["arrayBuffer"]();
          }).catch(function() {
            return getBinary();
          });
        }
        return new Promise(function(resolve3, reject) {
          resolve3(getBinary());
        });
      }
      function createWasm() {
        var info = { "env": asmLibraryArg, "wasi_unstable": asmLibraryArg };
        function receiveInstance(instance, module2) {
          var exports3 = instance.exports;
          Module["asm"] = exports3;
          removeRunDependency();
        }
        addRunDependency();
        function receiveInstantiatedSource(output) {
          receiveInstance(output["instance"]);
        }
        function instantiateArrayBuffer(receiver) {
          return getBinaryPromise().then(function(binary2) {
            return WebAssembly.instantiate(binary2, info);
          }).then(receiver, function(reason) {
            err("failed to asynchronously prepare wasm: " + reason);
            abort(reason);
          });
        }
        function instantiateAsync() {
          if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && typeof fetch === "function") {
            fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
              var result = WebAssembly.instantiateStreaming(response, info);
              return result.then(receiveInstantiatedSource, function(reason) {
                err("wasm streaming compile failed: " + reason);
                err("falling back to ArrayBuffer instantiation");
                instantiateArrayBuffer(receiveInstantiatedSource);
              });
            });
          } else {
            return instantiateArrayBuffer(receiveInstantiatedSource);
          }
        }
        if (Module["instantiateWasm"]) {
          try {
            var exports2 = Module["instantiateWasm"](info, receiveInstance);
            return exports2;
          } catch (e) {
            err("Module.instantiateWasm callback failed with error: " + e);
            return false;
          }
        }
        instantiateAsync();
        return {};
      }
      __ATINIT__.push({ func: function() {
        ___wasm_call_ctors();
      } });
      function _abort() {
        abort();
      }
      function _emscripten_get_heap_size() {
        return HEAP8.length;
      }
      function _emscripten_get_sbrk_ptr() {
        return 264624;
      }
      function _emscripten_memcpy_big(dest, src, num) {
        HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
      }
      function emscripten_realloc_buffer(size2) {
        try {
          wasmMemory.grow(size2 - buffer.byteLength + 65535 >> 16);
          updateGlobalBufferAndViews(wasmMemory.buffer);
          return 1;
        } catch (e) {
        }
      }
      function _emscripten_resize_heap(requestedSize) {
        var oldSize = _emscripten_get_heap_size();
        var PAGE_MULTIPLE = 65536;
        var LIMIT = 2147483648 - PAGE_MULTIPLE;
        if (requestedSize > LIMIT) {
          return false;
        }
        var MIN_TOTAL_MEMORY = 16777216;
        var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);
        while (newSize < requestedSize) {
          if (newSize <= 536870912) {
            newSize = alignUp(2 * newSize, PAGE_MULTIPLE);
          } else {
            newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
          }
        }
        var replacement = emscripten_realloc_buffer(newSize);
        if (!replacement) {
          return false;
        }
        return true;
      }
      var SYSCALLS = { buffers: [null, [], []], printChar: function(stream, curr) {
        var buffer2 = SYSCALLS.buffers[stream];
        if (curr === 0 || curr === 10) {
          (stream === 1 ? out : err)(UTF8ArrayToString(buffer2, 0));
          buffer2.length = 0;
        } else {
          buffer2.push(curr);
        }
      }, varargs: 0, get: function(varargs) {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
        return ret;
      }, getStr: function() {
        var ret = UTF8ToString(SYSCALLS.get());
        return ret;
      }, get64: function() {
        var low = SYSCALLS.get();
        SYSCALLS.get();
        return low;
      }, getZero: function() {
        SYSCALLS.get();
      } };
      function _fd_close(fd) {
        try {
          return 0;
        } catch (e) {
          if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
            abort(e);
          return e.errno;
        }
      }
      function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
        try {
          return 0;
        } catch (e) {
          if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
            abort(e);
          return e.errno;
        }
      }
      function _fd_write(fd, iov, iovcnt, pnum) {
        try {
          var num = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAP32[iov + i * 8 >> 2];
            var len = HEAP32[iov + (i * 8 + 4) >> 2];
            for (var j = 0; j < len; j++) {
              SYSCALLS.printChar(fd, HEAPU8[ptr + j]);
            }
            num += len;
          }
          HEAP32[pnum >> 2] = num;
          return 0;
        } catch (e) {
          if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
            abort(e);
          return e.errno;
        }
      }
      function _setTempRet0($i) {
      }
      var asmLibraryArg = { "abort": _abort, "emscripten_get_sbrk_ptr": _emscripten_get_sbrk_ptr, "emscripten_memcpy_big": _emscripten_memcpy_big, "emscripten_resize_heap": _emscripten_resize_heap, "fd_close": _fd_close, "fd_seek": _fd_seek, "fd_write": _fd_write, "memory": wasmMemory, "setTempRet0": _setTempRet0, "table": wasmTable };
      var asm = createWasm();
      Module["asm"] = asm;
      var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
        return Module["asm"]["__wasm_call_ctors"].apply(null, arguments);
      };
      Module["_malloc"] = function() {
        return Module["asm"]["malloc"].apply(null, arguments);
      };
      Module["_free"] = function() {
        return Module["asm"]["free"].apply(null, arguments);
      };
      Module["_getLastError"] = function() {
        return Module["asm"]["getLastError"].apply(null, arguments);
      };
      Module["_compilePattern"] = function() {
        return Module["asm"]["compilePattern"].apply(null, arguments);
      };
      Module["_disposeCompiledPatterns"] = function() {
        return Module["asm"]["disposeCompiledPatterns"].apply(null, arguments);
      };
      Module["_findBestMatch"] = function() {
        return Module["asm"]["findBestMatch"].apply(null, arguments);
      };
      Module["___cxa_demangle"] = function() {
        return Module["asm"]["__cxa_demangle"].apply(null, arguments);
      };
      Module["_setThrew"] = function() {
        return Module["asm"]["setThrew"].apply(null, arguments);
      };
      var stackSave = Module["stackSave"] = function() {
        return Module["asm"]["stackSave"].apply(null, arguments);
      };
      var stackAlloc = Module["stackAlloc"] = function() {
        return Module["asm"]["stackAlloc"].apply(null, arguments);
      };
      var stackRestore = Module["stackRestore"] = function() {
        return Module["asm"]["stackRestore"].apply(null, arguments);
      };
      Module["__growWasmMemory"] = function() {
        return Module["asm"]["__growWasmMemory"].apply(null, arguments);
      };
      Module["dynCall_vi"] = function() {
        return Module["asm"]["dynCall_vi"].apply(null, arguments);
      };
      Module["dynCall_iiii"] = function() {
        return Module["asm"]["dynCall_iiii"].apply(null, arguments);
      };
      Module["dynCall_iiiii"] = function() {
        return Module["asm"]["dynCall_iiiii"].apply(null, arguments);
      };
      Module["dynCall_iii"] = function() {
        return Module["asm"]["dynCall_iii"].apply(null, arguments);
      };
      Module["dynCall_iidiiii"] = function() {
        return Module["asm"]["dynCall_iidiiii"].apply(null, arguments);
      };
      Module["dynCall_vii"] = function() {
        return Module["asm"]["dynCall_vii"].apply(null, arguments);
      };
      Module["dynCall_ii"] = function() {
        return Module["asm"]["dynCall_ii"].apply(null, arguments);
      };
      Module["dynCall_i"] = function() {
        return Module["asm"]["dynCall_i"].apply(null, arguments);
      };
      Module["dynCall_v"] = function() {
        return Module["asm"]["dynCall_v"].apply(null, arguments);
      };
      Module["dynCall_viiiiii"] = function() {
        return Module["asm"]["dynCall_viiiiii"].apply(null, arguments);
      };
      Module["dynCall_viiiii"] = function() {
        return Module["asm"]["dynCall_viiiii"].apply(null, arguments);
      };
      Module["dynCall_viiii"] = function() {
        return Module["asm"]["dynCall_viiii"].apply(null, arguments);
      };
      Module["dynCall_jiji"] = function() {
        return Module["asm"]["dynCall_jiji"].apply(null, arguments);
      };
      Module["asm"] = asm;
      Module["ccall"] = ccall;
      var calledRun;
      Module["then"] = function(func) {
        if (calledRun) {
          func(Module);
        } else {
          var old = Module["onRuntimeInitialized"];
          Module["onRuntimeInitialized"] = function() {
            if (old)
              old();
            func(Module);
          };
        }
        return Module;
      };
      dependenciesFulfilled = function runCaller() {
        if (!calledRun)
          run2();
        if (!calledRun)
          dependenciesFulfilled = runCaller;
      };
      function run2(args) {
        if (runDependencies > 0) {
          return;
        }
        preRun();
        if (runDependencies > 0)
          return;
        function doRun() {
          if (calledRun)
            return;
          calledRun = true;
          if (ABORT)
            return;
          initRuntime();
          preMain();
          if (Module["onRuntimeInitialized"])
            Module["onRuntimeInitialized"]();
          postRun();
        }
        if (Module["setStatus"]) {
          Module["setStatus"]("Running...");
          setTimeout(function() {
            setTimeout(function() {
              Module["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
      }
      Module["run"] = run2;
      if (Module["preInit"]) {
        if (typeof Module["preInit"] == "function")
          Module["preInit"] = [Module["preInit"]];
        while (Module["preInit"].length > 0) {
          Module["preInit"].pop()();
        }
      }
      run2();
      return Onigasm2;
    };
  }();
  module.exports = Onigasm;
})(onigasm$1);
var onigasmExports = onigasm$1.exports;
Object.defineProperty(onigasmH, "__esModule", { value: true });
const OnigasmModuleFactory = onigasmExports;
async function initModule(bytes) {
  return new Promise((resolve3, reject) => {
    const { log, warn: warn2, error } = console;
    OnigasmModuleFactory({
      instantiateWasm(imports, successCallback) {
        WebAssembly.instantiate(bytes, imports).then((output) => {
          successCallback(output.instance);
        }).catch((e) => {
          throw e;
        });
        return {};
      }
    }).then((moduleH) => {
      onigasmH.onigasmH = moduleH;
      resolve3();
    });
    if (typeof print !== "undefined") {
      console.log = log;
      console.error = error;
      console.warn = warn2;
    }
  });
}
let isInitialized = false;
async function loadWASM$1(data) {
  if (isInitialized) {
    throw new Error(`Onigasm#init has been called and was succesful, subsequent calls are not allowed once initialized`);
  }
  if (typeof data === "string") {
    const arrayBuffer = await (await fetch(data)).arrayBuffer();
    await initModule(arrayBuffer);
  } else if (data instanceof ArrayBuffer) {
    await initModule(data);
  } else {
    throw new TypeError(`Expected a string (URL of .wasm file) or ArrayBuffer (.wasm file itself) as first parameter`);
  }
  isInitialized = true;
}
onigasmH.loadWASM = loadWASM$1;
var OnigRegExp$1 = {};
var OnigScanner$2 = {};
var iterator;
var hasRequiredIterator;
function requireIterator() {
  if (hasRequiredIterator)
    return iterator;
  hasRequiredIterator = 1;
  iterator = function(Yallist2) {
    Yallist2.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
  return iterator;
}
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l2 = arguments.length; i < l2; i++) {
      self2.push(arguments[i]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node.next;
  var prev2 = node.prev;
  if (next) {
    next.prev = prev2;
  }
  if (prev2) {
    prev2.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev2;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i = 0, l2 = arguments.length; i < l2; i++) {
    push(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i = 0, l2 = arguments.length; i < l2; i++) {
    unshift(this, arguments[i]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn2, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn2.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn2, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn2.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    walker = walker.next;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    walker = walker.prev;
  }
  if (i === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn2, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn2.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn2, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn2.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn2, initial2) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial2;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = 0; walker !== null; i++) {
    acc = fn2(acc, walker.value, i);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn2, initial2) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial2;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn2(acc, walker.value, i);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start2, deleteCount) {
  if (start2 > this.length) {
    start2 = this.length - 1;
  }
  if (start2 < 0) {
    start2 = this.length + start2;
  }
  for (var i = 0, walker = this.head; walker !== null && i < start2; i++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i = 2; i < arguments.length; i++) {
    walker = insert(this, walker, arguments[i]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p2 = walker.prev;
    walker.prev = walker.next;
    walker.next = p2;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node, value) {
  var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node(value, prev2, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev2, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev2) {
    prev2.next = this;
    this.prev = prev2;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  requireIterator()(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
let LRUCache$1 = class LRUCache {
  constructor(options2) {
    if (typeof options2 === "number")
      options2 = { max: options2 };
    if (!options2)
      options2 = {};
    if (options2.max && (typeof options2.max !== "number" || options2.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options2.max || Infinity;
    const lc = options2.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options2.stale || false;
    if (options2.maxAge && typeof options2.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options2.maxAge || 0;
    this[DISPOSE] = options2.dispose;
    this[NO_DISPOSE_ON_SET] = options2.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options2.updateAgeOnGet || false;
    this.reset();
  }
  // resize the cache when the max changes.
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn2, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev2 = walker.prev;
      forEachStep(this, fn2, walker, thisp);
      walker = prev2;
    }
  }
  forEach(fn2, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn2, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k) => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k) => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = /* @__PURE__ */ new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h2) => h2);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now2 = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const node = this[CACHE].get(key);
      const item = node.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now2;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry(key, value, len, now2, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key))
      return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get(this, key, true);
  }
  peek(key) {
    return get(this, key, false);
  }
  pop() {
    const node = this[LRU_LIST].tail;
    if (!node)
      return null;
    del(this, node);
    return node.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now2 = Date.now();
    for (let l2 = arr.length - 1; l2 >= 0; l2--) {
      const hit = arr[l2];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now2;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
};
const get = (self2, key, doUse) => {
  const node = self2[CACHE].get(key);
  if (node) {
    const hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
      const prev2 = walker.prev;
      del(self2, walker);
      walker = prev2;
    }
  }
};
const del = (self2, node) => {
  if (node) {
    const hit = node.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node);
  }
};
class Entry {
  constructor(key, value, length2, now2, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length2;
    this.now = now2;
    this.maxAge = maxAge || 0;
  }
}
const forEachStep = (self2, fn2, node, thisp) => {
  let hit = node.value;
  if (isStale(self2, hit)) {
    del(self2, node);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn2.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache$1;
var OnigString$2 = {};
Object.defineProperty(OnigString$2, "__esModule", { value: true });
let OnigString$1 = class OnigString {
  constructor(content) {
    this.substring = (start2, end2) => {
      return this.source.substring(start2, end2);
    };
    this.toString = (start2, end2) => {
      return this.source;
    };
    if (typeof content !== "string") {
      throw new TypeError("Argument must be a string");
    }
    this.source = content;
    this._utf8Bytes = null;
    this._utf8Indexes = null;
  }
  get utf8Bytes() {
    if (!this._utf8Bytes) {
      this.encode();
    }
    return this._utf8Bytes;
  }
  /**
   * Returns `null` if all utf8 offsets match utf-16 offset (content has no multi byte characters)
   */
  get utf8Indexes() {
    if (!this._utf8Bytes) {
      this.encode();
    }
    return this._utf8Indexes;
  }
  get content() {
    return this.source;
  }
  get length() {
    return this.source.length;
  }
  get hasMultiByteCharacters() {
    return this.utf8Indexes !== null;
  }
  convertUtf8OffsetToUtf16(utf8Offset) {
    if (utf8Offset < 0) {
      return 0;
    }
    const utf8Array = this._utf8Bytes;
    if (utf8Offset >= utf8Array.length - 1) {
      return this.source.length;
    }
    const utf8OffsetMap = this.utf8Indexes;
    if (utf8OffsetMap && utf8Offset >= this._mappingTableStartOffset) {
      return findFirstInSorted(utf8OffsetMap, utf8Offset - this._mappingTableStartOffset) + this._mappingTableStartOffset;
    }
    return utf8Offset;
  }
  convertUtf16OffsetToUtf8(utf16Offset) {
    if (utf16Offset < 0) {
      return 0;
    }
    const utf8Array = this._utf8Bytes;
    if (utf16Offset >= this.source.length) {
      return utf8Array.length - 1;
    }
    const utf8OffsetMap = this.utf8Indexes;
    if (utf8OffsetMap && utf16Offset >= this._mappingTableStartOffset) {
      return utf8OffsetMap[utf16Offset - this._mappingTableStartOffset] + this._mappingTableStartOffset;
    }
    return utf16Offset;
  }
  encode() {
    const str = this.source;
    const n = str.length;
    let utf16OffsetToUtf8;
    let utf8Offset = 0;
    let mappingTableStartOffset = 0;
    function createOffsetTable(startOffset) {
      const maxUtf8Len = (n - startOffset) * 3;
      if (maxUtf8Len <= 255) {
        utf16OffsetToUtf8 = new Uint8Array(n - startOffset);
      } else if (maxUtf8Len <= 65535) {
        utf16OffsetToUtf8 = new Uint16Array(n - startOffset);
      } else {
        utf16OffsetToUtf8 = new Uint32Array(n - startOffset);
      }
      mappingTableStartOffset = startOffset;
      utf16OffsetToUtf8[utf8Offset++] = 0;
    }
    const u8view = new Uint8Array(
      n * 3 + 1
      /** null termination character */
    );
    let ptrHead = 0;
    let i = 0;
    while (i < str.length) {
      let codepoint;
      const c2 = str.charCodeAt(i);
      if (utf16OffsetToUtf8) {
        utf16OffsetToUtf8[utf8Offset++] = ptrHead - mappingTableStartOffset;
      }
      if (c2 < 55296 || c2 > 57343) {
        codepoint = c2;
      } else if (c2 >= 56320) {
        codepoint = 65533;
      } else {
        if (i === n - 1) {
          codepoint = 65533;
        } else {
          const d2 = str.charCodeAt(i + 1);
          if (56320 <= d2 && d2 <= 57343) {
            if (!utf16OffsetToUtf8) {
              createOffsetTable(i);
            }
            const a2 = c2 & 1023;
            const b2 = d2 & 1023;
            codepoint = 65536 + (a2 << 10) + b2;
            i += 1;
            utf16OffsetToUtf8[utf8Offset++] = ptrHead - mappingTableStartOffset;
          } else {
            codepoint = 65533;
          }
        }
      }
      let bytesRequiredToEncode;
      let offset2;
      if (codepoint <= 127) {
        bytesRequiredToEncode = 1;
        offset2 = 0;
      } else if (codepoint <= 2047) {
        bytesRequiredToEncode = 2;
        offset2 = 192;
      } else if (codepoint <= 65535) {
        bytesRequiredToEncode = 3;
        offset2 = 224;
      } else {
        bytesRequiredToEncode = 4;
        offset2 = 240;
      }
      if (bytesRequiredToEncode === 1) {
        u8view[ptrHead++] = codepoint;
      } else {
        if (!utf16OffsetToUtf8) {
          createOffsetTable(ptrHead);
        }
        u8view[ptrHead++] = (codepoint >> 6 * --bytesRequiredToEncode) + offset2;
        while (bytesRequiredToEncode > 0) {
          const temp = codepoint >> 6 * (bytesRequiredToEncode - 1);
          u8view[ptrHead++] = 128 | temp & 63;
          bytesRequiredToEncode -= 1;
        }
      }
      i += 1;
    }
    const utf8 = u8view.slice(0, ptrHead + 1);
    utf8[ptrHead] = 0;
    this._utf8Bytes = utf8;
    if (utf16OffsetToUtf8) {
      this._utf8Indexes = utf16OffsetToUtf8;
      this._mappingTableStartOffset = mappingTableStartOffset;
    }
  }
};
function findFirstInSorted(array, i) {
  let low = 0;
  let high = array.length;
  if (high === 0) {
    return 0;
  }
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    if (array[mid] >= i) {
      high = mid;
    } else {
      low = mid + 1;
    }
  }
  while (low > 0 && (low >= array.length || array[low] > i)) {
    low--;
  }
  if (low > 0 && array[low] === array[low - 1]) {
    low--;
  }
  return low;
}
OnigString$2.default = OnigString$1;
Object.defineProperty(OnigScanner$2, "__esModule", { value: true });
const LRUCache2 = lruCache;
const onigasmH_1$1 = onigasmH;
const OnigString_1$1 = OnigString$2;
function mallocAndWriteString(str) {
  const ptr = onigasmH_1$1.onigasmH._malloc(str.utf8Bytes.length);
  onigasmH_1$1.onigasmH.HEAPU8.set(str.utf8Bytes, ptr);
  return ptr;
}
function convertUTF8BytesFromPtrToString(ptr) {
  const chars = [];
  let i = 0;
  while (onigasmH_1$1.onigasmH.HEAPU8[ptr] !== 0) {
    chars[i++] = onigasmH_1$1.onigasmH.HEAPU8[ptr++];
  }
  return chars.join();
}
const cache = new LRUCache2({
  dispose: (scanner, info) => {
    const regexTPtrsPtr = onigasmH_1$1.onigasmH._malloc(info.regexTPtrs.length);
    onigasmH_1$1.onigasmH.HEAPU8.set(info.regexTPtrs, regexTPtrsPtr);
    const status = onigasmH_1$1.onigasmH._disposeCompiledPatterns(regexTPtrsPtr, scanner.patterns.length);
    if (status !== 0) {
      const errMessage = convertUTF8BytesFromPtrToString(onigasmH_1$1.onigasmH._getLastError());
      throw new Error(errMessage);
    }
    onigasmH_1$1.onigasmH._free(regexTPtrsPtr);
  },
  max: 1e3
});
let OnigScanner$1 = class OnigScanner {
  /**
   * Create a new scanner with the given patterns
   * @param patterns  An array of string patterns
   */
  constructor(patterns2) {
    if (onigasmH_1$1.onigasmH === null) {
      throw new Error(`Onigasm has not been initialized, call loadWASM from 'onigasm' exports before using any other API`);
    }
    for (let i = 0; i < patterns2.length; i++) {
      const pattern = patterns2[i];
      if (typeof pattern !== "string") {
        throw new TypeError(`First parameter to OnigScanner constructor must be array of (pattern) strings`);
      }
    }
    this.sources = patterns2.slice();
  }
  get patterns() {
    return this.sources.slice();
  }
  /**
   * Find the next match from a given position
   * @param string The string to search
   * @param startPosition The optional position to start at, defaults to 0
   * @param callback The (error, match) function to call when done, match will null when there is no match
   */
  findNextMatch(string, startPosition, callback) {
    if (startPosition == null) {
      startPosition = 0;
    }
    if (typeof startPosition === "function") {
      callback = startPosition;
      startPosition = 0;
    }
    try {
      const match2 = this.findNextMatchSync(string, startPosition);
      callback(null, match2);
    } catch (error) {
      callback(error);
    }
  }
  /**
   * Find the next match from a given position
   * @param string The string to search
   * @param startPosition The optional position to start at, defaults to 0
   */
  findNextMatchSync(string, startPosition) {
    if (startPosition == null) {
      startPosition = 0;
    }
    startPosition = this.convertToNumber(startPosition);
    let onigNativeInfo = cache.get(this);
    let status = 0;
    if (!onigNativeInfo) {
      const regexTAddrRecieverPtr = onigasmH_1$1.onigasmH._malloc(4);
      const regexTPtrs = [];
      for (let i = 0; i < this.sources.length; i++) {
        const pattern = this.sources[i];
        const patternStrPtr = mallocAndWriteString(new OnigString_1$1.default(pattern));
        status = onigasmH_1$1.onigasmH._compilePattern(patternStrPtr, regexTAddrRecieverPtr);
        if (status !== 0) {
          const errMessage = convertUTF8BytesFromPtrToString(onigasmH_1$1.onigasmH._getLastError());
          throw new Error(errMessage);
        }
        const regexTAddress = onigasmH_1$1.onigasmH.HEAP32[regexTAddrRecieverPtr / 4];
        regexTPtrs.push(regexTAddress);
        onigasmH_1$1.onigasmH._free(patternStrPtr);
      }
      onigNativeInfo = {
        regexTPtrs: new Uint8Array(Uint32Array.from(regexTPtrs).buffer)
      };
      onigasmH_1$1.onigasmH._free(regexTAddrRecieverPtr);
      cache.set(this, onigNativeInfo);
    }
    const onigString = string instanceof OnigString_1$1.default ? string : new OnigString_1$1.default(this.convertToString(string));
    const strPtr = mallocAndWriteString(onigString);
    const resultInfoReceiverPtr = onigasmH_1$1.onigasmH._malloc(8);
    const regexTPtrsPtr = onigasmH_1$1.onigasmH._malloc(onigNativeInfo.regexTPtrs.length);
    onigasmH_1$1.onigasmH.HEAPU8.set(onigNativeInfo.regexTPtrs, regexTPtrsPtr);
    status = onigasmH_1$1.onigasmH._findBestMatch(
      // regex_t **patterns
      regexTPtrsPtr,
      // int patternCount
      this.sources.length,
      // UChar *utf8String
      strPtr,
      // int strLen
      onigString.utf8Bytes.length - 1,
      // int startOffset
      onigString.convertUtf16OffsetToUtf8(startPosition),
      // int *resultInfo
      resultInfoReceiverPtr
    );
    if (status !== 0) {
      const errMessage = convertUTF8BytesFromPtrToString(onigasmH_1$1.onigasmH._getLastError());
      throw new Error(errMessage);
    }
    const [
      // The index of pattern which matched the string at least offset from 0 (start)
      bestPatternIdx,
      // Begin address of capture info encoded as pairs
      // like [start, end, start, end, start, end, ...]
      //  - first start-end pair is entire match (index 0 and 1)
      //  - subsequent pairs are capture groups (2, 3 = first capture group, 4, 5 = second capture group and so on)
      encodedResultBeginAddress,
      // Length of the [start, end, ...] sequence so we know how much memory to read (will always be 0 or multiple of 2)
      encodedResultLength
    ] = new Uint32Array(onigasmH_1$1.onigasmH.HEAPU32.buffer, resultInfoReceiverPtr, 3);
    onigasmH_1$1.onigasmH._free(strPtr);
    onigasmH_1$1.onigasmH._free(resultInfoReceiverPtr);
    onigasmH_1$1.onigasmH._free(regexTPtrsPtr);
    if (encodedResultLength > 0) {
      const encodedResult = new Uint32Array(onigasmH_1$1.onigasmH.HEAPU32.buffer, encodedResultBeginAddress, encodedResultLength);
      const captureIndices = [];
      let i = 0;
      let captureIdx = 0;
      while (i < encodedResultLength) {
        const index = captureIdx++;
        let start2 = encodedResult[i++];
        let end2 = encodedResult[i++];
        if (onigString.hasMultiByteCharacters) {
          start2 = onigString.convertUtf8OffsetToUtf16(start2);
          end2 = onigString.convertUtf8OffsetToUtf16(end2);
        }
        captureIndices.push({
          end: end2,
          index,
          length: end2 - start2,
          start: start2
        });
      }
      onigasmH_1$1.onigasmH._free(encodedResultBeginAddress);
      return {
        captureIndices,
        index: bestPatternIdx,
        scanner: this
      };
    }
    return null;
  }
  convertToString(value) {
    if (value === void 0) {
      return "undefined";
    }
    if (value === null) {
      return "null";
    }
    if (value instanceof OnigString_1$1.default) {
      return value.content;
    }
    return value.toString();
  }
  convertToNumber(value) {
    value = parseInt(value, 10);
    if (!isFinite(value)) {
      value = 0;
    }
    value = Math.max(value, 0);
    return value;
  }
};
OnigScanner$2.OnigScanner = OnigScanner$1;
OnigScanner$2.default = OnigScanner$1;
Object.defineProperty(OnigRegExp$1, "__esModule", { value: true });
const OnigScanner_1$1 = OnigScanner$2;
class OnigRegExp {
  /**
   * Create a new regex with the given pattern
   * @param source A string pattern
   */
  constructor(source) {
    this.source = source;
    try {
      this.scanner = new OnigScanner_1$1.default([this.source]);
    } catch (error) {
    }
  }
  /**
   * Synchronously search the string for a match starting at the given position
   * @param string The string to search
   * @param startPosition The optional position to start the search at, defaults to `0`
   */
  searchSync(string, startPosition) {
    let match2;
    if (startPosition == null) {
      startPosition = 0;
    }
    match2 = this.scanner.findNextMatchSync(string, startPosition);
    return this.captureIndicesForMatch(string, match2);
  }
  /**
   * Search the string for a match starting at the given position
   * @param string The string to search
   * @param startPosition The optional position to start the search at, defaults to `0`
   * @param callback The `(error, match)` function to call when done, match will be null if no matches were found. match will be an array of objects for each matched group on a successful search
   */
  search(string, startPosition, callback) {
    if (startPosition == null) {
      startPosition = 0;
    }
    if (typeof startPosition === "function") {
      callback = startPosition;
      startPosition = 0;
    }
    try {
      const ret = this.searchSync(string, startPosition);
      callback(null, ret);
    } catch (error) {
      callback(error);
    }
  }
  /**
   * Synchronously test if this regular expression matches the given string
   * @param string The string to test against
   */
  testSync(string) {
    if (typeof this.source === "boolean" || typeof string === "boolean") {
      return this.source === string;
    }
    return this.searchSync(string) != null;
  }
  /**
   * Test if this regular expression matches the given string
   * @param string The string to test against
   * @param callback The (error, matches) function to call when done, matches will be true if at least one match is found, false otherwise
   */
  test(string, callback) {
    if (typeof callback !== "function") {
      callback = () => {
      };
    }
    try {
      callback(null, this.testSync(string));
    } catch (error) {
      callback(error);
    }
  }
  captureIndicesForMatch(string, match2) {
    if (match2 != null) {
      const { captureIndices } = match2;
      let capture;
      string = this.scanner.convertToString(string);
      for (let i = 0; i < captureIndices.length; i++) {
        capture = captureIndices[i];
        capture.match = string.slice(capture.start, capture.end);
      }
      return captureIndices;
    } else {
      return null;
    }
  }
}
OnigRegExp$1.default = OnigRegExp;
Object.defineProperty(lib, "__esModule", { value: true });
const onigasmH_1 = onigasmH;
var loadWASM = lib.loadWASM = onigasmH_1.loadWASM;
const OnigRegExp_1 = OnigRegExp$1;
lib.OnigRegExp = OnigRegExp_1.default;
const OnigScanner_1 = OnigScanner$2;
var OnigScanner2 = lib.OnigScanner = OnigScanner_1.default;
const OnigString_1 = OnigString$2;
var OnigString2 = lib.OnigString = OnigString_1.default;
var main$1 = { exports: {} };
(function(module, exports) {
  !function(e, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    return function(e) {
      var t2 = {};
      function n(r2) {
        if (t2[r2])
          return t2[r2].exports;
        var i = t2[r2] = { i: r2, l: false, exports: {} };
        return e[r2].call(i.exports, i, i.exports, n), i.l = true, i.exports;
      }
      return n.m = e, n.c = t2, n.d = function(e2, t3, r2) {
        n.o(e2, t3) || Object.defineProperty(e2, t3, { enumerable: true, get: r2 });
      }, n.r = function(e2) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      }, n.t = function(e2, t3) {
        if (1 & t3 && (e2 = n(e2)), 8 & t3)
          return e2;
        if (4 & t3 && "object" == typeof e2 && e2 && e2.__esModule)
          return e2;
        var r2 = /* @__PURE__ */ Object.create(null);
        if (n.r(r2), Object.defineProperty(r2, "default", { enumerable: true, value: e2 }), 2 & t3 && "string" != typeof e2)
          for (var i in e2)
            n.d(r2, i, (function(t4) {
              return e2[t4];
            }).bind(null, i));
        return r2;
      }, n.n = function(e2) {
        var t3 = e2 && e2.__esModule ? function() {
          return e2.default;
        } : function() {
          return e2;
        };
        return n.d(t3, "a", t3), t3;
      }, n.o = function(e2, t3) {
        return Object.prototype.hasOwnProperty.call(e2, t3);
      }, n.p = "", n(n.s = 3);
    }([function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2 = n(1), i = n(5), o2 = n(6), s2 = n(2), a2 = "undefined" == typeof performance ? function() {
        return Date.now();
      } : function() {
        return performance.now();
      };
      t2.createGrammar = function(e2, t3, n2, r3, i2, o3) {
        return new v(e2, t3, n2, r3, i2, o3);
      };
      var c2 = function(e2) {
        this.scopeName = e2;
      };
      t2.FullScopeDependency = c2;
      var u2 = function() {
        function e2(e3, t3) {
          this.scopeName = e3, this.include = t3;
        }
        return e2.prototype.toKey = function() {
          return this.scopeName + "#" + this.include;
        }, e2;
      }();
      t2.PartialScopeDependency = u2;
      var l2 = function() {
        function e2() {
          this.full = [], this.partial = [], this.visitedRule = /* @__PURE__ */ new Set(), this._seenFull = /* @__PURE__ */ new Set(), this._seenPartial = /* @__PURE__ */ new Set();
        }
        return e2.prototype.add = function(e3) {
          e3 instanceof c2 ? this._seenFull.has(e3.scopeName) || (this._seenFull.add(e3.scopeName), this.full.push(e3)) : this._seenPartial.has(e3.toKey()) || (this._seenPartial.add(e3.toKey()), this.partial.push(e3));
        }, e2;
      }();
      function h2(e2, t3, n2, i2, o3) {
        for (var s3 = 0, a3 = i2; s3 < a3.length; s3++) {
          var l3 = a3[s3];
          if (!e2.visitedRule.has(l3)) {
            e2.visitedRule.add(l3);
            var d3 = l3.repository ? r2.mergeObjects({}, o3, l3.repository) : o3;
            Array.isArray(l3.patterns) && h2(e2, t3, n2, l3.patterns, d3);
            var g2 = l3.include;
            if (g2)
              if ("$base" === g2 || g2 === t3.scopeName)
                f2(e2, t3, t3);
              else if ("$self" === g2 || g2 === n2.scopeName)
                f2(e2, t3, n2);
              else if ("#" === g2.charAt(0))
                p2(e2, t3, n2, g2.substring(1), d3);
              else {
                var m3 = g2.indexOf("#");
                if (m3 >= 0) {
                  var _3 = g2.substring(0, m3), y3 = g2.substring(m3 + 1);
                  _3 === t3.scopeName ? p2(e2, t3, t3, y3, d3) : _3 === n2.scopeName ? p2(e2, t3, n2, y3, d3) : e2.add(new u2(_3, g2.substring(m3 + 1)));
                } else
                  e2.add(new c2(g2));
              }
          }
        }
      }
      function p2(e2, t3, n2, r3, i2) {
        (void 0 === i2 && (i2 = n2.repository), i2 && i2[r3]) && h2(e2, t3, n2, [i2[r3]], i2);
      }
      function f2(e2, t3, n2) {
        if (n2.patterns && Array.isArray(n2.patterns) && h2(e2, t3, n2, n2.patterns, n2.repository), n2.injections) {
          var r3 = [];
          for (var i2 in n2.injections)
            r3.push(n2.injections[i2]);
          h2(e2, t3, n2, r3, n2.repository);
        }
      }
      function d2(e2, t3) {
        if (!e2)
          return false;
        if (e2 === t3)
          return true;
        var n2 = t3.length;
        return e2.length > n2 && e2.substr(0, n2) === t3 && "." === e2[n2];
      }
      function g(e2, t3) {
        if (t3.length < e2.length)
          return false;
        var n2 = 0;
        return e2.every(function(e3) {
          for (var r3 = n2; r3 < t3.length; r3++)
            if (d2(t3[r3], e3))
              return n2 = r3 + 1, true;
          return false;
        });
      }
      function m2(e2, t3, n2, r3, s3) {
        for (var a3 = o2.createMatchers(t3, g), c3 = i.RuleFactory.getCompiledRuleId(n2, r3, s3.repository), u3 = 0, l3 = a3; u3 < l3.length; u3++) {
          var h3 = l3[u3];
          e2.push({ matcher: h3.matcher, ruleId: c3, grammar: s3, priority: h3.priority });
        }
      }
      t2.ScopeDependencyCollector = l2, t2.collectSpecificDependencies = p2, t2.collectDependencies = f2;
      var _2 = function(e2, t3, n2, r3) {
        this.scopeName = e2, this.languageId = t3, this.tokenType = n2, this.themeData = r3;
      };
      t2.ScopeMetadata = _2;
      var y2 = function() {
        function e2(t3, n2, r3) {
          if (this._initialLanguage = t3, this._themeProvider = n2, this._cache = /* @__PURE__ */ new Map(), this._defaultMetaData = new _2("", this._initialLanguage, 0, [this._themeProvider.getDefaults()]), this._embeddedLanguages = /* @__PURE__ */ Object.create(null), r3)
            for (var i2 = Object.keys(r3), o3 = 0, s3 = i2.length; o3 < s3; o3++) {
              var a3 = i2[o3], c3 = r3[a3];
              "number" == typeof c3 && 0 !== c3 ? this._embeddedLanguages[a3] = c3 : console.warn("Invalid embedded language found at scope " + a3 + ": <<" + c3 + ">>");
            }
          var u3 = Object.keys(this._embeddedLanguages).map(function(t4) {
            return e2._escapeRegExpCharacters(t4);
          });
          0 === u3.length ? this._embeddedLanguagesRegex = null : (u3.sort(), u3.reverse(), this._embeddedLanguagesRegex = new RegExp("^((" + u3.join(")|(") + "))($|\\.)", ""));
        }
        return e2.prototype.onDidChangeTheme = function() {
          this._cache = /* @__PURE__ */ new Map(), this._defaultMetaData = new _2("", this._initialLanguage, 0, [this._themeProvider.getDefaults()]);
        }, e2.prototype.getDefaultMetadata = function() {
          return this._defaultMetaData;
        }, e2._escapeRegExpCharacters = function(e3) {
          return e3.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
        }, e2.prototype.getMetadataForScope = function(t3) {
          if (null === t3)
            return e2._NULL_SCOPE_METADATA;
          var n2 = this._cache.get(t3);
          return n2 || (n2 = this._doGetMetadataForScope(t3), this._cache.set(t3, n2), n2);
        }, e2.prototype._doGetMetadataForScope = function(e3) {
          var t3 = this._scopeToLanguage(e3), n2 = this._toStandardTokenType(e3), r3 = this._themeProvider.themeMatch(e3);
          return new _2(e3, t3, n2, r3);
        }, e2.prototype._scopeToLanguage = function(e3) {
          if (!e3)
            return 0;
          if (!this._embeddedLanguagesRegex)
            return 0;
          var t3 = e3.match(this._embeddedLanguagesRegex);
          if (!t3)
            return 0;
          var n2 = this._embeddedLanguages[t3[1]] || 0;
          return n2 || 0;
        }, e2.prototype._toStandardTokenType = function(t3) {
          var n2 = t3.match(e2.STANDARD_TOKEN_TYPE_REGEXP);
          if (!n2)
            return 0;
          switch (n2[1]) {
            case "comment":
              return 1;
            case "string":
              return 2;
            case "regex":
              return 4;
            case "meta.embedded":
              return 8;
          }
          throw new Error("Unexpected match for standard token type!");
        }, e2._NULL_SCOPE_METADATA = new _2("", 0, 0, null), e2.STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/, e2;
      }(), v = function() {
        function e2(e3, t3, n2, r3, i2, s3) {
          if (this._scopeMetadataProvider = new y2(t3, i2, n2), this._onigLib = s3, this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = i2, this._grammar = C2(e3, null), this._injections = null, this._tokenTypeMatchers = [], r3)
            for (var a3 = 0, c3 = Object.keys(r3); a3 < c3.length; a3++)
              for (var u3 = c3[a3], l3 = 0, h3 = o2.createMatchers(u3, g); l3 < h3.length; l3++) {
                var p3 = h3[l3];
                this._tokenTypeMatchers.push({ matcher: p3.matcher, type: r3[u3] });
              }
        }
        return e2.prototype.dispose = function() {
          for (var e3 = 0, t3 = this._ruleId2desc; e3 < t3.length; e3++) {
            var n2 = t3[e3];
            n2 && n2.dispose();
          }
        }, e2.prototype.createOnigScanner = function(e3) {
          return this._onigLib.createOnigScanner(e3);
        }, e2.prototype.createOnigString = function(e3) {
          return this._onigLib.createOnigString(e3);
        }, e2.prototype.onDidChangeTheme = function() {
          this._scopeMetadataProvider.onDidChangeTheme();
        }, e2.prototype.getMetadataForScope = function(e3) {
          return this._scopeMetadataProvider.getMetadataForScope(e3);
        }, e2.prototype.getInjections = function() {
          var e3 = this;
          if (null === this._injections) {
            this._injections = [];
            var t3 = this._grammar.injections;
            if (t3)
              for (var n2 in t3)
                m2(this._injections, n2, t3[n2], this, this._grammar);
            if (this._grammarRepository) {
              var r3 = this._grammarRepository.injections(this._grammar.scopeName);
              r3 && r3.forEach(function(t4) {
                var n3 = e3.getExternalGrammar(t4);
                if (n3) {
                  var r4 = n3.injectionSelector;
                  r4 && m2(e3._injections, r4, n3, e3, n3);
                }
              });
            }
            this._injections.sort(function(e4, t4) {
              return e4.priority - t4.priority;
            });
          }
          return this._injections;
        }, e2.prototype.registerRule = function(e3) {
          var t3 = ++this._lastRuleId, n2 = e3(t3);
          return this._ruleId2desc[t3] = n2, n2;
        }, e2.prototype.getRule = function(e3) {
          return this._ruleId2desc[e3];
        }, e2.prototype.getExternalGrammar = function(e3, t3) {
          if (this._includedGrammars[e3])
            return this._includedGrammars[e3];
          if (this._grammarRepository) {
            var n2 = this._grammarRepository.lookup(e3);
            if (n2)
              return this._includedGrammars[e3] = C2(n2, t3 && t3.$base), this._includedGrammars[e3];
          }
          return null;
        }, e2.prototype.tokenizeLine = function(e3, t3) {
          var n2 = this._tokenize(e3, t3, false);
          return { tokens: n2.lineTokens.getResult(n2.ruleStack, n2.lineLength), ruleStack: n2.ruleStack };
        }, e2.prototype.tokenizeLine2 = function(e3, t3) {
          var n2 = this._tokenize(e3, t3, true);
          return { tokens: n2.lineTokens.getBinaryResult(n2.ruleStack, n2.lineLength), ruleStack: n2.ruleStack };
        }, e2.prototype._tokenize = function(e3, t3, n2) {
          var r3;
          if (-1 === this._rootId && (this._rootId = i.RuleFactory.getCompiledRuleId(this._grammar.repository.$self, this, this._grammar.repository)), t3 && t3 !== I.NULL)
            r3 = false, t3.reset();
          else {
            r3 = true;
            var o3 = this._scopeMetadataProvider.getDefaultMetadata(), s3 = o3.themeData[0], a3 = P.set(0, o3.languageId, o3.tokenType, s3.fontStyle, s3.foreground, s3.background), c3 = this.getRule(this._rootId).getName(null, null), u3 = this._scopeMetadataProvider.getMetadataForScope(c3), l3 = x2.mergeMetadata(a3, null, u3), h3 = new x2(null, null === c3 ? "unknown" : c3, l3);
            t3 = new I(null, this._rootId, -1, -1, false, null, h3, h3);
          }
          e3 += "\n";
          var p3 = this.createOnigString(e3), f3 = p3.content.length, d3 = new T(n2, e3, this._tokenTypeMatchers), g2 = S2(this, p3, r3, 0, t3, d3, true);
          return b2(p3), { lineLength: f3, lineTokens: d3, ruleStack: g2 };
        }, e2;
      }();
      function b2(e2) {
        "function" == typeof e2.dispose && e2.dispose();
      }
      function C2(e2, t3) {
        return (e2 = r2.clone(e2)).repository = e2.repository || {}, e2.repository.$self = { $vscodeTextmateLocation: e2.$vscodeTextmateLocation, patterns: e2.patterns, name: e2.scopeName }, e2.repository.$base = t3 || e2.repository.$self, e2;
      }
      function w2(e2, t3, n2, r3, i2, o3, s3) {
        if (0 !== o3.length) {
          for (var a3 = t3.content, c3 = Math.min(o3.length, s3.length), u3 = [], l3 = s3[0].end, h3 = 0; h3 < c3; h3++) {
            var p3 = o3[h3];
            if (null !== p3) {
              var f3 = s3[h3];
              if (0 !== f3.length) {
                if (f3.start > l3)
                  break;
                for (; u3.length > 0 && u3[u3.length - 1].endPos <= f3.start; )
                  i2.produceFromScopes(u3[u3.length - 1].scopes, u3[u3.length - 1].endPos), u3.pop();
                if (u3.length > 0 ? i2.produceFromScopes(u3[u3.length - 1].scopes, f3.start) : i2.produce(r3, f3.start), p3.retokenizeCapturedWithRuleId) {
                  var d3 = p3.getName(a3, s3), g2 = r3.contentNameScopesList.push(e2, d3), m3 = p3.getContentName(a3, s3), _3 = g2.push(e2, m3), y3 = r3.push(p3.retokenizeCapturedWithRuleId, f3.start, -1, false, null, g2, _3), v2 = e2.createOnigString(a3.substring(0, f3.end));
                  S2(e2, v2, n2 && 0 === f3.start, f3.start, y3, i2, false), b2(v2);
                } else {
                  var C3 = p3.getName(a3, s3);
                  if (null !== C3) {
                    var w3 = (u3.length > 0 ? u3[u3.length - 1].scopes : r3.contentNameScopesList).push(e2, C3);
                    u3.push(new A(w3, f3.end));
                  }
                }
              }
            }
          }
          for (; u3.length > 0; )
            i2.produceFromScopes(u3[u3.length - 1].scopes, u3[u3.length - 1].endPos), u3.pop();
        }
      }
      function k(e2) {
        for (var t3 = [], n2 = 0, r3 = e2.rules.length; n2 < r3; n2++)
          t3.push("   - " + e2.rules[n2] + ": " + e2.debugRegExps[n2]);
        return t3.join("\n");
      }
      function R2(e2, t3, n2, r3, i2, o3) {
        var c3 = function(e3, t4, n3, r4, i3, o4) {
          var c4 = i3.getRule(e3), u4 = c4.compile(e3, i3.endRule, n3, r4 === o4), l4 = 0;
          s2.DebugFlags.InDebugMode && (l4 = a2());
          var h4 = u4.scanner.findNextMatchSync(t4, r4);
          if (s2.DebugFlags.InDebugMode) {
            var p4 = a2() - l4;
            p4 > 5 && console.warn("Rule " + c4.debugName + " (" + c4.id + ") matching took " + p4 + " against '" + t4 + "'"), h4 && console.log("matched rule id: " + u4.rules[h4.index] + " from " + h4.captureIndices[0].start + " to " + h4.captureIndices[0].end);
          }
          return h4 ? { captureIndices: h4.captureIndices, matchedRuleId: u4.rules[h4.index] } : null;
        }(e2, t3, n2, r3, i2, o3), u3 = e2.getInjections();
        if (0 === u3.length)
          return c3;
        var l3 = function(e3, t4, n3, r4, i3, o4, a3) {
          for (var c4, u4 = Number.MAX_VALUE, l4 = null, h4 = 0, p4 = o4.contentNameScopesList.generateScopes(), f3 = 0, d3 = e3.length; f3 < d3; f3++) {
            var g2 = e3[f3];
            if (g2.matcher(p4)) {
              var m3 = t4.getRule(g2.ruleId).compile(t4, null, r4, i3 === a3), _3 = m3.scanner.findNextMatchSync(n3, i3);
              if (s2.DebugFlags.InDebugMode && (console.log("  scanning for injections"), console.log(k(m3))), _3) {
                var y3 = _3.captureIndices[0].start;
                if (!(y3 >= u4) && (u4 = y3, l4 = _3.captureIndices, c4 = m3.rules[_3.index], h4 = g2.priority, u4 === i3))
                  break;
              }
            }
          }
          return l4 ? { priorityMatch: -1 === h4, captureIndices: l4, matchedRuleId: c4 } : null;
        }(u3, e2, t3, n2, r3, i2, o3);
        if (!l3)
          return c3;
        if (!c3)
          return l3;
        var h3 = c3.captureIndices[0].start, p3 = l3.captureIndices[0].start;
        return p3 < h3 || l3.priorityMatch && p3 === h3 ? l3 : c3;
      }
      function S2(e2, t3, n2, r3, o3, a3, c3) {
        var u3 = t3.content.length, l3 = false, h3 = -1;
        if (c3) {
          var p3 = function(e3, t4, n3, r4, o4, a4) {
            for (var c4 = o4.beginRuleCapturedEOL ? 0 : -1, u4 = [], l4 = o4; l4; l4 = l4.pop()) {
              var h4 = l4.getRule(e3);
              h4 instanceof i.BeginWhileRule && u4.push({ rule: h4, stack: l4 });
            }
            for (var p4 = u4.pop(); p4; p4 = u4.pop()) {
              var f4 = p4.rule.compileWhile(e3, p4.stack.endRule, n3, c4 === r4), d3 = f4.scanner.findNextMatchSync(t4, r4);
              if (s2.DebugFlags.InDebugMode && (console.log("  scanning for while rule"), console.log(k(f4))), !d3) {
                s2.DebugFlags.InDebugMode && console.log("  popping " + p4.rule.debugName + " - " + p4.rule.debugWhileRegExp), o4 = p4.stack.pop();
                break;
              }
              if (-2 !== f4.rules[d3.index]) {
                o4 = p4.stack.pop();
                break;
              }
              d3.captureIndices && d3.captureIndices.length && (a4.produce(p4.stack, d3.captureIndices[0].start), w2(e3, t4, n3, p4.stack, a4, p4.rule.whileCaptures, d3.captureIndices), a4.produce(p4.stack, d3.captureIndices[0].end), c4 = d3.captureIndices[0].end, d3.captureIndices[0].end > r4 && (r4 = d3.captureIndices[0].end, n3 = false));
            }
            return { stack: o4, linePos: r4, anchorPosition: c4, isFirstLine: n3 };
          }(e2, t3, n2, r3, o3, a3);
          o3 = p3.stack, r3 = p3.linePos, n2 = p3.isFirstLine, h3 = p3.anchorPosition;
        }
        for (; !l3; )
          f3();
        function f3() {
          s2.DebugFlags.InDebugMode && (console.log(""), console.log("@@scanNext " + r3 + ": |" + t3.content.substr(r3).replace(/\n$/, "\\n") + "|"));
          var c4 = R2(e2, t3, n2, r3, o3, h3);
          if (!c4)
            return s2.DebugFlags.InDebugMode && console.log("  no more matches."), a3.produce(o3, u3), void (l3 = true);
          var p4 = c4.captureIndices, f4 = c4.matchedRuleId, d3 = !!(p4 && p4.length > 0) && p4[0].end > r3;
          if (-1 === f4) {
            var g2 = o3.getRule(e2);
            s2.DebugFlags.InDebugMode && console.log("  popping " + g2.debugName + " - " + g2.debugEndRegExp), a3.produce(o3, p4[0].start), o3 = o3.setContentNameScopesList(o3.nameScopesList), w2(e2, t3, n2, o3, a3, g2.endCaptures, p4), a3.produce(o3, p4[0].end);
            var m3 = o3;
            if (o3 = o3.pop(), h3 = m3.getAnchorPos(), !d3 && m3.getEnterPos() === r3)
              return s2.DebugFlags.InDebugMode && console.error("[1] - Grammar is in an endless loop - Grammar pushed & popped a rule without advancing"), o3 = m3, a3.produce(o3, u3), void (l3 = true);
          } else {
            var _3 = e2.getRule(f4);
            a3.produce(o3, p4[0].start);
            var y3 = o3, v2 = _3.getName(t3.content, p4), b3 = o3.contentNameScopesList.push(e2, v2);
            if (o3 = o3.push(f4, r3, h3, p4[0].end === u3, null, b3, b3), _3 instanceof i.BeginEndRule) {
              var C3 = _3;
              s2.DebugFlags.InDebugMode && console.log("  pushing " + C3.debugName + " - " + C3.debugBeginRegExp), w2(e2, t3, n2, o3, a3, C3.beginCaptures, p4), a3.produce(o3, p4[0].end), h3 = p4[0].end;
              var k2 = C3.getContentName(t3.content, p4), S3 = b3.push(e2, k2);
              if (o3 = o3.setContentNameScopesList(S3), C3.endHasBackReferences && (o3 = o3.setEndRule(C3.getEndWithResolvedBackReferences(t3.content, p4))), !d3 && y3.hasSameRuleAs(o3))
                return s2.DebugFlags.InDebugMode && console.error("[2] - Grammar is in an endless loop - Grammar pushed the same rule without advancing"), o3 = o3.pop(), a3.produce(o3, u3), void (l3 = true);
            } else if (_3 instanceof i.BeginWhileRule) {
              C3 = _3;
              s2.DebugFlags.InDebugMode && console.log("  pushing " + C3.debugName), w2(e2, t3, n2, o3, a3, C3.beginCaptures, p4), a3.produce(o3, p4[0].end), h3 = p4[0].end;
              k2 = C3.getContentName(t3.content, p4), S3 = b3.push(e2, k2);
              if (o3 = o3.setContentNameScopesList(S3), C3.whileHasBackReferences && (o3 = o3.setEndRule(C3.getWhileWithResolvedBackReferences(t3.content, p4))), !d3 && y3.hasSameRuleAs(o3))
                return s2.DebugFlags.InDebugMode && console.error("[3] - Grammar is in an endless loop - Grammar pushed the same rule without advancing"), o3 = o3.pop(), a3.produce(o3, u3), void (l3 = true);
            } else {
              var P2 = _3;
              if (s2.DebugFlags.InDebugMode && console.log("  matched " + P2.debugName + " - " + P2.debugMatchRegExp), w2(e2, t3, n2, o3, a3, P2.captures, p4), a3.produce(o3, p4[0].end), o3 = o3.pop(), !d3)
                return s2.DebugFlags.InDebugMode && console.error("[4] - Grammar is in an endless loop - Grammar is not advancing, nor is it pushing/popping"), o3 = o3.safePop(), a3.produce(o3, u3), void (l3 = true);
            }
          }
          p4[0].end > r3 && (r3 = p4[0].end, n2 = false);
        }
        return o3;
      }
      t2.Grammar = v;
      var P = function() {
        function e2() {
        }
        return e2.toBinaryStr = function(e3) {
          for (var t3 = e3.toString(2); t3.length < 32; )
            t3 = "0" + t3;
          return t3;
        }, e2.printMetadata = function(t3) {
          var n2 = e2.getLanguageId(t3), r3 = e2.getTokenType(t3), i2 = e2.getFontStyle(t3), o3 = e2.getForeground(t3), s3 = e2.getBackground(t3);
          console.log({ languageId: n2, tokenType: r3, fontStyle: i2, foreground: o3, background: s3 });
        }, e2.getLanguageId = function(e3) {
          return (255 & e3) >>> 0;
        }, e2.getTokenType = function(e3) {
          return (1792 & e3) >>> 8;
        }, e2.getFontStyle = function(e3) {
          return (14336 & e3) >>> 11;
        }, e2.getForeground = function(e3) {
          return (8372224 & e3) >>> 14;
        }, e2.getBackground = function(e3) {
          return (4286578688 & e3) >>> 23;
        }, e2.set = function(t3, n2, r3, i2, o3, s3) {
          var a3 = e2.getLanguageId(t3), c3 = e2.getTokenType(t3), u3 = e2.getFontStyle(t3), l3 = e2.getForeground(t3), h3 = e2.getBackground(t3);
          return 0 !== n2 && (a3 = n2), 0 !== r3 && (c3 = 8 === r3 ? 0 : r3), -1 !== i2 && (u3 = i2), 0 !== o3 && (l3 = o3), 0 !== s3 && (h3 = s3), (a3 << 0 | c3 << 8 | u3 << 11 | l3 << 14 | h3 << 23) >>> 0;
        }, e2;
      }();
      t2.StackElementMetadata = P;
      var x2 = function() {
        function e2(e3, t3, n2) {
          this.parent = e3, this.scope = t3, this.metadata = n2;
        }
        return e2._equals = function(e3, t3) {
          for (; ; ) {
            if (e3 === t3)
              return true;
            if (!e3 && !t3)
              return true;
            if (!e3 || !t3)
              return false;
            if (e3.scope !== t3.scope || e3.metadata !== t3.metadata)
              return false;
            e3 = e3.parent, t3 = t3.parent;
          }
        }, e2.prototype.equals = function(t3) {
          return e2._equals(this, t3);
        }, e2._matchesScope = function(e3, t3, n2) {
          return t3 === e3 || e3.substring(0, n2.length) === n2;
        }, e2._matches = function(e3, t3) {
          if (null === t3)
            return true;
          for (var n2 = t3.length, r3 = 0, i2 = t3[r3], o3 = i2 + "."; e3; ) {
            if (this._matchesScope(e3.scope, i2, o3)) {
              if (++r3 === n2)
                return true;
              o3 = (i2 = t3[r3]) + ".";
            }
            e3 = e3.parent;
          }
          return false;
        }, e2.mergeMetadata = function(e3, t3, n2) {
          if (null === n2)
            return e3;
          var r3 = -1, i2 = 0, o3 = 0;
          if (null !== n2.themeData)
            for (var s3 = 0, a3 = n2.themeData.length; s3 < a3; s3++) {
              var c3 = n2.themeData[s3];
              if (this._matches(t3, c3.parentScopes)) {
                r3 = c3.fontStyle, i2 = c3.foreground, o3 = c3.background;
                break;
              }
            }
          return P.set(e3, n2.languageId, n2.tokenType, r3, i2, o3);
        }, e2._push = function(t3, n2, r3) {
          for (var i2 = 0, o3 = r3.length; i2 < o3; i2++) {
            var s3 = r3[i2], a3 = n2.getMetadataForScope(s3), c3 = e2.mergeMetadata(t3.metadata, t3, a3);
            t3 = new e2(t3, s3, c3);
          }
          return t3;
        }, e2.prototype.push = function(t3, n2) {
          return null === n2 ? this : n2.indexOf(" ") >= 0 ? e2._push(this, t3, n2.split(/ /g)) : e2._push(this, t3, [n2]);
        }, e2._generateScopes = function(e3) {
          for (var t3 = [], n2 = 0; e3; )
            t3[n2++] = e3.scope, e3 = e3.parent;
          return t3.reverse(), t3;
        }, e2.prototype.generateScopes = function() {
          return e2._generateScopes(this);
        }, e2;
      }();
      t2.ScopeListElement = x2;
      var I = function() {
        function e2(e3, t3, n2, r3, i2, o3, s3, a3) {
          this.parent = e3, this.depth = this.parent ? this.parent.depth + 1 : 1, this.ruleId = t3, this._enterPos = n2, this._anchorPos = r3, this.beginRuleCapturedEOL = i2, this.endRule = o3, this.nameScopesList = s3, this.contentNameScopesList = a3;
        }
        return e2._structuralEquals = function(e3, t3) {
          for (; ; ) {
            if (e3 === t3)
              return true;
            if (!e3 && !t3)
              return true;
            if (!e3 || !t3)
              return false;
            if (e3.depth !== t3.depth || e3.ruleId !== t3.ruleId || e3.endRule !== t3.endRule)
              return false;
            e3 = e3.parent, t3 = t3.parent;
          }
        }, e2._equals = function(e3, t3) {
          return e3 === t3 || !!this._structuralEquals(e3, t3) && e3.contentNameScopesList.equals(t3.contentNameScopesList);
        }, e2.prototype.clone = function() {
          return this;
        }, e2.prototype.equals = function(t3) {
          return null !== t3 && e2._equals(this, t3);
        }, e2._reset = function(e3) {
          for (; e3; )
            e3._enterPos = -1, e3._anchorPos = -1, e3 = e3.parent;
        }, e2.prototype.reset = function() {
          e2._reset(this);
        }, e2.prototype.pop = function() {
          return this.parent;
        }, e2.prototype.safePop = function() {
          return this.parent ? this.parent : this;
        }, e2.prototype.push = function(t3, n2, r3, i2, o3, s3, a3) {
          return new e2(this, t3, n2, r3, i2, o3, s3, a3);
        }, e2.prototype.getEnterPos = function() {
          return this._enterPos;
        }, e2.prototype.getAnchorPos = function() {
          return this._anchorPos;
        }, e2.prototype.getRule = function(e3) {
          return e3.getRule(this.ruleId);
        }, e2.prototype._writeString = function(e3, t3) {
          return this.parent && (t3 = this.parent._writeString(e3, t3)), e3[t3++] = "(" + this.ruleId + ", TODO-" + this.nameScopesList + ", TODO-" + this.contentNameScopesList + ")", t3;
        }, e2.prototype.toString = function() {
          var e3 = [];
          return this._writeString(e3, 0), "[" + e3.join(",") + "]";
        }, e2.prototype.setContentNameScopesList = function(e3) {
          return this.contentNameScopesList === e3 ? this : this.parent.push(this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, this.endRule, this.nameScopesList, e3);
        }, e2.prototype.setEndRule = function(t3) {
          return this.endRule === t3 ? this : new e2(this.parent, this.ruleId, this._enterPos, this._anchorPos, this.beginRuleCapturedEOL, t3, this.nameScopesList, this.contentNameScopesList);
        }, e2.prototype.hasSameRuleAs = function(e3) {
          return this.ruleId === e3.ruleId;
        }, e2.NULL = new e2(null, 0, 0, 0, false, null, null, null), e2;
      }();
      t2.StackElement = I;
      var A = function(e2, t3) {
        this.scopes = e2, this.endPos = t3;
      };
      t2.LocalStackElement = A;
      var T = function() {
        function e2(e3, t3, n2) {
          this._emitBinaryTokens = e3, this._tokenTypeOverrides = n2, s2.DebugFlags.InDebugMode ? this._lineText = t3 : this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
        }
        return e2.prototype.produce = function(e3, t3) {
          this.produceFromScopes(e3.contentNameScopesList, t3);
        }, e2.prototype.produceFromScopes = function(e3, t3) {
          if (!(this._lastTokenEndIndex >= t3)) {
            if (this._emitBinaryTokens) {
              for (var n2 = e3.metadata, r3 = 0, i2 = this._tokenTypeOverrides; r3 < i2.length; r3++) {
                var o3 = i2[r3];
                o3.matcher(e3.generateScopes()) && (n2 = P.set(n2, 0, L2(o3.type), -1, 0, 0));
              }
              return this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === n2 || (this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(n2)), void (this._lastTokenEndIndex = t3);
            }
            var a3 = e3.generateScopes();
            if (s2.DebugFlags.InDebugMode) {
              console.log("  token: |" + this._lineText.substring(this._lastTokenEndIndex, t3).replace(/\n$/, "\\n") + "|");
              for (var c3 = 0; c3 < a3.length; c3++)
                console.log("      * " + a3[c3]);
            }
            this._tokens.push({ startIndex: this._lastTokenEndIndex, endIndex: t3, scopes: a3 }), this._lastTokenEndIndex = t3;
          }
        }, e2.prototype.getResult = function(e3, t3) {
          return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === t3 - 1 && this._tokens.pop(), 0 === this._tokens.length && (this._lastTokenEndIndex = -1, this.produce(e3, t3), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
        }, e2.prototype.getBinaryResult = function(e3, t3) {
          this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === t3 - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), 0 === this._binaryTokens.length && (this._lastTokenEndIndex = -1, this.produce(e3, t3), this._binaryTokens[this._binaryTokens.length - 2] = 0);
          for (var n2 = new Uint32Array(this._binaryTokens.length), r3 = 0, i2 = this._binaryTokens.length; r3 < i2; r3++)
            n2[r3] = this._binaryTokens[r3];
          return n2;
        }, e2;
      }();
      function L2(e2) {
        switch (e2) {
          case 4:
            return 4;
          case 2:
            return 2;
          case 1:
            return 1;
          case 0:
          default:
            return 8;
        }
      }
    }, function(e, t2, n) {
      function r2(e2) {
        return Array.isArray(e2) ? function(e3) {
          for (var t3 = [], n2 = 0, i2 = e3.length; n2 < i2; n2++)
            t3[n2] = r2(e3[n2]);
          return t3;
        }(e2) : "object" == typeof e2 ? function(e3) {
          var t3 = {};
          for (var n2 in e3)
            t3[n2] = r2(e3[n2]);
          return t3;
        }(e2) : e2;
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.clone = function(e2) {
        return r2(e2);
      }, t2.mergeObjects = function(e2) {
        for (var t3 = [], n2 = 1; n2 < arguments.length; n2++)
          t3[n2 - 1] = arguments[n2];
        return t3.forEach(function(t4) {
          for (var n3 in t4)
            e2[n3] = t4[n3];
        }), e2;
      }, t2.basename = function e2(t3) {
        var n2 = ~t3.lastIndexOf("/") || ~t3.lastIndexOf("\\");
        return 0 === n2 ? t3 : ~n2 == t3.length - 1 ? e2(t3.substring(0, t3.length - 1)) : t3.substr(1 + ~n2);
      };
      var i = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/, o2 = function() {
        function e2() {
        }
        return e2.hasCaptures = function(e3) {
          return null !== e3 && i.test(e3);
        }, e2.replaceCaptures = function(e3, t3, n2) {
          return e3.replace(i, function(e4, r3, i2, o3) {
            var s2 = n2[parseInt(r3 || i2, 10)];
            if (!s2)
              return e4;
            for (var a2 = t3.substring(s2.start, s2.end); "." === a2[0]; )
              a2 = a2.substring(1);
            switch (o3) {
              case "downcase":
                return a2.toLowerCase();
              case "upcase":
                return a2.toUpperCase();
              default:
                return a2;
            }
          });
        }, e2;
      }();
      t2.RegexSource = o2;
    }, function(e, t2, n) {
      (function(e2) {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DebugFlags = { InDebugMode: void 0 !== e2 && !!e2.env.VSCODE_TEXTMATE_DEBUG };
      }).call(this, n(7));
    }, function(e, t2, n) {
      var r2 = this && this.__awaiter || function(e2, t3, n2, r3) {
        return new (n2 || (n2 = Promise))(function(i2, o3) {
          function s3(e3) {
            try {
              c3(r3.next(e3));
            } catch (e4) {
              o3(e4);
            }
          }
          function a3(e3) {
            try {
              c3(r3.throw(e3));
            } catch (e4) {
              o3(e4);
            }
          }
          function c3(e3) {
            var t4;
            e3.done ? i2(e3.value) : (t4 = e3.value, t4 instanceof n2 ? t4 : new n2(function(e4) {
              e4(t4);
            })).then(s3, a3);
          }
          c3((r3 = r3.apply(e2, t3 || [])).next());
        });
      }, i = this && this.__generator || function(e2, t3) {
        var n2, r3, i2, o3, s3 = { label: 0, sent: function() {
          if (1 & i2[0])
            throw i2[1];
          return i2[1];
        }, trys: [], ops: [] };
        return o3 = { next: a3(0), throw: a3(1), return: a3(2) }, "function" == typeof Symbol && (o3[Symbol.iterator] = function() {
          return this;
        }), o3;
        function a3(o4) {
          return function(a4) {
            return function(o5) {
              if (n2)
                throw new TypeError("Generator is already executing.");
              for (; s3; )
                try {
                  if (n2 = 1, r3 && (i2 = 2 & o5[0] ? r3.return : o5[0] ? r3.throw || ((i2 = r3.return) && i2.call(r3), 0) : r3.next) && !(i2 = i2.call(r3, o5[1])).done)
                    return i2;
                  switch (r3 = 0, i2 && (o5 = [2 & o5[0], i2.value]), o5[0]) {
                    case 0:
                    case 1:
                      i2 = o5;
                      break;
                    case 4:
                      return s3.label++, { value: o5[1], done: false };
                    case 5:
                      s3.label++, r3 = o5[1], o5 = [0];
                      continue;
                    case 7:
                      o5 = s3.ops.pop(), s3.trys.pop();
                      continue;
                    default:
                      if (!(i2 = s3.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o5[0] && 2 !== o5[0])) {
                        s3 = 0;
                        continue;
                      }
                      if (3 === o5[0] && (!i2 || o5[1] > i2[0] && o5[1] < i2[3])) {
                        s3.label = o5[1];
                        break;
                      }
                      if (6 === o5[0] && s3.label < i2[1]) {
                        s3.label = i2[1], i2 = o5;
                        break;
                      }
                      if (i2 && s3.label < i2[2]) {
                        s3.label = i2[2], s3.ops.push(o5);
                        break;
                      }
                      i2[2] && s3.ops.pop(), s3.trys.pop();
                      continue;
                  }
                  o5 = t3.call(e2, s3);
                } catch (e3) {
                  o5 = [6, e3], r3 = 0;
                } finally {
                  n2 = i2 = 0;
                }
              if (5 & o5[0])
                throw o5[1];
              return { value: o5[0] ? o5[1] : void 0, done: true };
            }([o4, a4]);
          };
        }
      };
      Object.defineProperty(t2, "__esModule", { value: true });
      var o2 = n(4), s2 = n(8), a2 = n(11), c2 = n(0), u2 = function() {
        function e2(e3) {
          this._options = e3, this._syncRegistry = new o2.SyncRegistry(a2.Theme.createFromRawTheme(e3.theme, e3.colorMap), e3.onigLib), this._ensureGrammarCache = /* @__PURE__ */ new Map();
        }
        return e2.prototype.dispose = function() {
          this._syncRegistry.dispose();
        }, e2.prototype.setTheme = function(e3, t3) {
          this._syncRegistry.setTheme(a2.Theme.createFromRawTheme(e3, t3));
        }, e2.prototype.getColorMap = function() {
          return this._syncRegistry.getColorMap();
        }, e2.prototype.loadGrammarWithEmbeddedLanguages = function(e3, t3, n2) {
          return this.loadGrammarWithConfiguration(e3, t3, { embeddedLanguages: n2 });
        }, e2.prototype.loadGrammarWithConfiguration = function(e3, t3, n2) {
          return this._loadGrammar(e3, t3, n2.embeddedLanguages, n2.tokenTypes);
        }, e2.prototype.loadGrammar = function(e3) {
          return this._loadGrammar(e3, 0, null, null);
        }, e2.prototype._doLoadSingleGrammar = function(e3) {
          return r2(this, void 0, void 0, function() {
            var t3, n2;
            return i(this, function(r3) {
              switch (r3.label) {
                case 0:
                  return [4, this._options.loadGrammar(e3)];
                case 1:
                  return (t3 = r3.sent()) && (n2 = "function" == typeof this._options.getInjections ? this._options.getInjections(e3) : void 0, this._syncRegistry.addGrammar(t3, n2)), [2];
              }
            });
          });
        }, e2.prototype._loadSingleGrammar = function(e3) {
          return r2(this, void 0, void 0, function() {
            return i(this, function(t3) {
              return this._ensureGrammarCache.has(e3) || this._ensureGrammarCache.set(e3, this._doLoadSingleGrammar(e3)), [2, this._ensureGrammarCache.get(e3)];
            });
          });
        }, e2.prototype._collectDependenciesForDep = function(e3, t3, n2) {
          var r3 = this._syncRegistry.lookup(n2.scopeName);
          if (r3) {
            n2 instanceof c2.FullScopeDependency ? c2.collectDependencies(t3, this._syncRegistry.lookup(e3), r3) : c2.collectSpecificDependencies(t3, this._syncRegistry.lookup(e3), r3, n2.include);
            var i2 = this._syncRegistry.injections(n2.scopeName);
            if (i2)
              for (var o3 = 0, s3 = i2; o3 < s3.length; o3++) {
                var a3 = s3[o3];
                t3.add(new c2.FullScopeDependency(a3));
              }
          } else if (n2.scopeName === e3)
            throw new Error("No grammar provided for <" + e3 + ">");
        }, e2.prototype._loadGrammar = function(e3, t3, n2, o3) {
          return r2(this, void 0, void 0, function() {
            var r3, s3, a3, u3, l2, h2, p2, f2, d2, g, m2, _2, y2 = this;
            return i(this, function(i2) {
              switch (i2.label) {
                case 0:
                  r3 = /* @__PURE__ */ new Set(), s3 = /* @__PURE__ */ new Set(), r3.add(e3), a3 = [new c2.FullScopeDependency(e3)], i2.label = 1;
                case 1:
                  return a3.length > 0 ? (u3 = a3, a3 = [], [4, Promise.all(u3.map(function(e4) {
                    return y2._loadSingleGrammar(e4.scopeName);
                  }))]) : [3, 3];
                case 2:
                  for (i2.sent(), l2 = new c2.ScopeDependencyCollector(), h2 = 0, p2 = u3; h2 < p2.length; h2++)
                    _2 = p2[h2], this._collectDependenciesForDep(e3, l2, _2);
                  for (f2 = 0, d2 = l2.full; f2 < d2.length; f2++)
                    _2 = d2[f2], r3.has(_2.scopeName) || (r3.add(_2.scopeName), a3.push(_2));
                  for (g = 0, m2 = l2.partial; g < m2.length; g++)
                    _2 = m2[g], r3.has(_2.scopeName) || s3.has(_2.toKey()) || (s3.add(_2.toKey()), a3.push(_2));
                  return [3, 1];
                case 3:
                  return [2, this.grammarForScopeName(e3, t3, n2, o3)];
              }
            });
          });
        }, e2.prototype.addGrammar = function(e3, t3, n2, o3) {
          return void 0 === t3 && (t3 = []), void 0 === n2 && (n2 = 0), void 0 === o3 && (o3 = null), r2(this, void 0, void 0, function() {
            return i(this, function(r3) {
              switch (r3.label) {
                case 0:
                  return this._syncRegistry.addGrammar(e3, t3), [4, this.grammarForScopeName(e3.scopeName, n2, o3)];
                case 1:
                  return [2, r3.sent()];
              }
            });
          });
        }, e2.prototype.grammarForScopeName = function(e3, t3, n2, r3) {
          return void 0 === t3 && (t3 = 0), void 0 === n2 && (n2 = null), void 0 === r3 && (r3 = null), this._syncRegistry.grammarForScopeName(e3, t3, n2, r3);
        }, e2;
      }();
      t2.Registry = u2, t2.INITIAL = c2.StackElement.NULL, t2.parseRawGrammar = s2.parseRawGrammar;
    }, function(e, t2, n) {
      var r2 = this && this.__awaiter || function(e2, t3, n2, r3) {
        return new (n2 || (n2 = Promise))(function(i2, o3) {
          function s3(e3) {
            try {
              c2(r3.next(e3));
            } catch (e4) {
              o3(e4);
            }
          }
          function a2(e3) {
            try {
              c2(r3.throw(e3));
            } catch (e4) {
              o3(e4);
            }
          }
          function c2(e3) {
            var t4;
            e3.done ? i2(e3.value) : (t4 = e3.value, t4 instanceof n2 ? t4 : new n2(function(e4) {
              e4(t4);
            })).then(s3, a2);
          }
          c2((r3 = r3.apply(e2, t3 || [])).next());
        });
      }, i = this && this.__generator || function(e2, t3) {
        var n2, r3, i2, o3, s3 = { label: 0, sent: function() {
          if (1 & i2[0])
            throw i2[1];
          return i2[1];
        }, trys: [], ops: [] };
        return o3 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o3[Symbol.iterator] = function() {
          return this;
        }), o3;
        function a2(o4) {
          return function(a3) {
            return function(o5) {
              if (n2)
                throw new TypeError("Generator is already executing.");
              for (; s3; )
                try {
                  if (n2 = 1, r3 && (i2 = 2 & o5[0] ? r3.return : o5[0] ? r3.throw || ((i2 = r3.return) && i2.call(r3), 0) : r3.next) && !(i2 = i2.call(r3, o5[1])).done)
                    return i2;
                  switch (r3 = 0, i2 && (o5 = [2 & o5[0], i2.value]), o5[0]) {
                    case 0:
                    case 1:
                      i2 = o5;
                      break;
                    case 4:
                      return s3.label++, { value: o5[1], done: false };
                    case 5:
                      s3.label++, r3 = o5[1], o5 = [0];
                      continue;
                    case 7:
                      o5 = s3.ops.pop(), s3.trys.pop();
                      continue;
                    default:
                      if (!(i2 = s3.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || 6 !== o5[0] && 2 !== o5[0])) {
                        s3 = 0;
                        continue;
                      }
                      if (3 === o5[0] && (!i2 || o5[1] > i2[0] && o5[1] < i2[3])) {
                        s3.label = o5[1];
                        break;
                      }
                      if (6 === o5[0] && s3.label < i2[1]) {
                        s3.label = i2[1], i2 = o5;
                        break;
                      }
                      if (i2 && s3.label < i2[2]) {
                        s3.label = i2[2], s3.ops.push(o5);
                        break;
                      }
                      i2[2] && s3.ops.pop(), s3.trys.pop();
                      continue;
                  }
                  o5 = t3.call(e2, s3);
                } catch (e3) {
                  o5 = [6, e3], r3 = 0;
                } finally {
                  n2 = i2 = 0;
                }
              if (5 & o5[0])
                throw o5[1];
              return { value: o5[0] ? o5[1] : void 0, done: true };
            }([o4, a3]);
          };
        }
      };
      Object.defineProperty(t2, "__esModule", { value: true });
      var o2 = n(0), s2 = function() {
        function e2(e3, t3) {
          this._theme = e3, this._grammars = {}, this._rawGrammars = {}, this._injectionGrammars = {}, this._onigLibPromise = t3;
        }
        return e2.prototype.dispose = function() {
          for (var e3 in this._grammars)
            this._grammars.hasOwnProperty(e3) && this._grammars[e3].dispose();
        }, e2.prototype.setTheme = function(e3) {
          var t3 = this;
          this._theme = e3, Object.keys(this._grammars).forEach(function(e4) {
            t3._grammars[e4].onDidChangeTheme();
          });
        }, e2.prototype.getColorMap = function() {
          return this._theme.getColorMap();
        }, e2.prototype.addGrammar = function(e3, t3) {
          this._rawGrammars[e3.scopeName] = e3, t3 && (this._injectionGrammars[e3.scopeName] = t3);
        }, e2.prototype.lookup = function(e3) {
          return this._rawGrammars[e3];
        }, e2.prototype.injections = function(e3) {
          return this._injectionGrammars[e3];
        }, e2.prototype.getDefaults = function() {
          return this._theme.getDefaults();
        }, e2.prototype.themeMatch = function(e3) {
          return this._theme.match(e3);
        }, e2.prototype.grammarForScopeName = function(e3, t3, n2, s3) {
          return r2(this, void 0, void 0, function() {
            var r3, a2, c2, u2, l2;
            return i(this, function(i2) {
              switch (i2.label) {
                case 0:
                  return this._grammars[e3] ? [3, 2] : (r3 = this._rawGrammars[e3]) ? (a2 = this._grammars, c2 = e3, u2 = o2.createGrammar, l2 = [r3, t3, n2, s3, this], [4, this._onigLibPromise]) : [2, null];
                case 1:
                  a2[c2] = u2.apply(void 0, l2.concat([i2.sent()])), i2.label = 2;
                case 2:
                  return [2, this._grammars[e3]];
              }
            });
          });
        }, e2;
      }();
      t2.SyncRegistry = s2;
    }, function(e, t2, n) {
      var r2, i = this && this.__extends || (r2 = function(e2, t3) {
        return (r2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t4) {
          e3.__proto__ = t4;
        } || function(e3, t4) {
          for (var n2 in t4)
            t4.hasOwnProperty(n2) && (e3[n2] = t4[n2]);
        })(e2, t3);
      }, function(e2, t3) {
        function n2() {
          this.constructor = e2;
        }
        r2(e2, t3), e2.prototype = null === t3 ? Object.create(t3) : (n2.prototype = t3.prototype, new n2());
      });
      Object.defineProperty(t2, "__esModule", { value: true });
      var o2 = n(1), s2 = /\\(\d+)/, a2 = /\\(\d+)/g, c2 = function() {
        function e2(e3, t3, n2) {
          this.debugRegExps = t3, this.rules = n2, this.scanner = e3.createOnigScanner(t3);
        }
        return e2.prototype.dispose = function() {
          "function" == typeof this.scanner.dispose && this.scanner.dispose();
        }, e2;
      }();
      t2.CompiledRule = c2;
      var u2 = function() {
        function e2(e3, t3, n2, r3) {
          this.$location = e3, this.id = t3, this._name = n2 || null, this._nameIsCapturing = o2.RegexSource.hasCaptures(this._name), this._contentName = r3 || null, this._contentNameIsCapturing = o2.RegexSource.hasCaptures(this._contentName);
        }
        return Object.defineProperty(e2.prototype, "debugName", { get: function() {
          var e3 = this.$location ? o2.basename(this.$location.filename) + ":" + this.$location.line : "unknown";
          return this.constructor.name + "#" + this.id + " @ " + e3;
        }, enumerable: true, configurable: true }), e2.prototype.getName = function(e3, t3) {
          return this._nameIsCapturing && null !== this._name && null !== e3 && null !== t3 ? o2.RegexSource.replaceCaptures(this._name, e3, t3) : this._name;
        }, e2.prototype.getContentName = function(e3, t3) {
          return this._contentNameIsCapturing && null !== this._contentName ? o2.RegexSource.replaceCaptures(this._contentName, e3, t3) : this._contentName;
        }, e2;
      }();
      t2.Rule = u2;
      var l2 = function(e2) {
        function t3(t4, n2, r3, i2, o3) {
          var s3 = e2.call(this, t4, n2, r3, i2) || this;
          return s3.retokenizeCapturedWithRuleId = o3, s3;
        }
        return i(t3, e2), t3.prototype.dispose = function() {
        }, t3.prototype.collectPatternsRecursive = function(e3, t4, n2) {
          throw new Error("Not supported!");
        }, t3.prototype.compile = function(e3, t4, n2, r3) {
          throw new Error("Not supported!");
        }, t3;
      }(u2);
      t2.CaptureRule = l2;
      var h2 = function() {
        function e2(e3, t3, n2) {
          if (void 0 === n2 && (n2 = true), n2)
            if (e3) {
              for (var r3 = e3.length, i2 = 0, o3 = [], a3 = false, c3 = 0; c3 < r3; c3++) {
                if ("\\" === e3.charAt(c3) && c3 + 1 < r3) {
                  var u3 = e3.charAt(c3 + 1);
                  "z" === u3 ? (o3.push(e3.substring(i2, c3)), o3.push("$(?!\\n)(?<!\\n)"), i2 = c3 + 2) : "A" !== u3 && "G" !== u3 || (a3 = true), c3++;
                }
              }
              this.hasAnchor = a3, 0 === i2 ? this.source = e3 : (o3.push(e3.substring(i2, r3)), this.source = o3.join(""));
            } else
              this.hasAnchor = false, this.source = e3;
          else
            this.hasAnchor = false, this.source = e3;
          this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = t3, this.hasBackReferences = s2.test(this.source);
        }
        return e2.prototype.clone = function() {
          return new e2(this.source, this.ruleId, true);
        }, e2.prototype.setSource = function(e3) {
          this.source !== e3 && (this.source = e3, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
        }, e2.prototype.resolveBackReferences = function(e3, t3) {
          var n2 = t3.map(function(t4) {
            return e3.substring(t4.start, t4.end);
          });
          return a2.lastIndex = 0, this.source.replace(a2, function(e4, t4) {
            return (n2[parseInt(t4, 10)] || "").replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
          });
        }, e2.prototype._buildAnchorCache = function() {
          var e3, t3, n2, r3, i2 = [], o3 = [], s3 = [], a3 = [];
          for (e3 = 0, t3 = this.source.length; e3 < t3; e3++)
            n2 = this.source.charAt(e3), i2[e3] = n2, o3[e3] = n2, s3[e3] = n2, a3[e3] = n2, "\\" === n2 && e3 + 1 < t3 && ("A" === (r3 = this.source.charAt(e3 + 1)) ? (i2[e3 + 1] = "", o3[e3 + 1] = "", s3[e3 + 1] = "A", a3[e3 + 1] = "A") : "G" === r3 ? (i2[e3 + 1] = "", o3[e3 + 1] = "G", s3[e3 + 1] = "", a3[e3 + 1] = "G") : (i2[e3 + 1] = r3, o3[e3 + 1] = r3, s3[e3 + 1] = r3, a3[e3 + 1] = r3), e3++);
          return { A0_G0: i2.join(""), A0_G1: o3.join(""), A1_G0: s3.join(""), A1_G1: a3.join("") };
        }, e2.prototype.resolveAnchors = function(e3, t3) {
          return this.hasAnchor && this._anchorCache ? e3 ? t3 ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : t3 ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0 : this.source;
        }, e2;
      }();
      t2.RegExpSource = h2;
      var p2 = function() {
        function e2() {
          this._items = [], this._hasAnchors = false, this._cached = null, this._anchorCache = { A0_G0: null, A0_G1: null, A1_G0: null, A1_G1: null };
        }
        return e2.prototype.dispose = function() {
          this._disposeCaches();
        }, e2.prototype._disposeCaches = function() {
          this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
        }, e2.prototype.push = function(e3) {
          this._items.push(e3), this._hasAnchors = this._hasAnchors || e3.hasAnchor;
        }, e2.prototype.unshift = function(e3) {
          this._items.unshift(e3), this._hasAnchors = this._hasAnchors || e3.hasAnchor;
        }, e2.prototype.length = function() {
          return this._items.length;
        }, e2.prototype.setSource = function(e3, t3) {
          this._items[e3].source !== t3 && (this._disposeCaches(), this._items[e3].setSource(t3));
        }, e2.prototype.compile = function(e3, t3, n2) {
          if (this._hasAnchors)
            return t3 ? n2 ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(e3, t3, n2)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(e3, t3, n2)), this._anchorCache.A1_G0) : n2 ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(e3, t3, n2)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(e3, t3, n2)), this._anchorCache.A0_G0);
          if (!this._cached) {
            var r3 = this._items.map(function(e4) {
              return e4.source;
            });
            this._cached = new c2(e3, r3, this._items.map(function(e4) {
              return e4.ruleId;
            }));
          }
          return this._cached;
        }, e2.prototype._resolveAnchors = function(e3, t3, n2) {
          var r3 = this._items.map(function(e4) {
            return e4.resolveAnchors(t3, n2);
          });
          return new c2(e3, r3, this._items.map(function(e4) {
            return e4.ruleId;
          }));
        }, e2;
      }();
      t2.RegExpSourceList = p2;
      var f2 = function(e2) {
        function t3(t4, n2, r3, i2, o3) {
          var s3 = e2.call(this, t4, n2, r3, null) || this;
          return s3._match = new h2(i2, s3.id), s3.captures = o3, s3._cachedCompiledPatterns = null, s3;
        }
        return i(t3, e2), t3.prototype.dispose = function() {
          this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
        }, Object.defineProperty(t3.prototype, "debugMatchRegExp", { get: function() {
          return "" + this._match.source;
        }, enumerable: true, configurable: true }), t3.prototype.collectPatternsRecursive = function(e3, t4, n2) {
          t4.push(this._match);
        }, t3.prototype.compile = function(e3, t4, n2, r3) {
          return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new p2(), this.collectPatternsRecursive(e3, this._cachedCompiledPatterns, true)), this._cachedCompiledPatterns.compile(e3, n2, r3);
        }, t3;
      }(u2);
      t2.MatchRule = f2;
      var d2 = function(e2) {
        function t3(t4, n2, r3, i2, o3) {
          var s3 = e2.call(this, t4, n2, r3, i2) || this;
          return s3.patterns = o3.patterns, s3.hasMissingPatterns = o3.hasMissingPatterns, s3._cachedCompiledPatterns = null, s3;
        }
        return i(t3, e2), t3.prototype.dispose = function() {
          this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
        }, t3.prototype.collectPatternsRecursive = function(e3, t4, n2) {
          var r3, i2;
          for (r3 = 0, i2 = this.patterns.length; r3 < i2; r3++)
            e3.getRule(this.patterns[r3]).collectPatternsRecursive(e3, t4, false);
        }, t3.prototype.compile = function(e3, t4, n2, r3) {
          return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new p2(), this.collectPatternsRecursive(e3, this._cachedCompiledPatterns, true)), this._cachedCompiledPatterns.compile(e3, n2, r3);
        }, t3;
      }(u2);
      t2.IncludeOnlyRule = d2;
      var g = function(e2) {
        function t3(t4, n2, r3, i2, o3, s3, a3, c3, u3, l3) {
          var p3 = e2.call(this, t4, n2, r3, i2) || this;
          return p3._begin = new h2(o3, p3.id), p3.beginCaptures = s3, p3._end = new h2(a3 || "", -1), p3.endHasBackReferences = p3._end.hasBackReferences, p3.endCaptures = c3, p3.applyEndPatternLast = u3 || false, p3.patterns = l3.patterns, p3.hasMissingPatterns = l3.hasMissingPatterns, p3._cachedCompiledPatterns = null, p3;
        }
        return i(t3, e2), t3.prototype.dispose = function() {
          this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
        }, Object.defineProperty(t3.prototype, "debugBeginRegExp", { get: function() {
          return "" + this._begin.source;
        }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "debugEndRegExp", { get: function() {
          return "" + this._end.source;
        }, enumerable: true, configurable: true }), t3.prototype.getEndWithResolvedBackReferences = function(e3, t4) {
          return this._end.resolveBackReferences(e3, t4);
        }, t3.prototype.collectPatternsRecursive = function(e3, t4, n2) {
          if (n2) {
            var r3, i2 = void 0;
            for (i2 = 0, r3 = this.patterns.length; i2 < r3; i2++)
              e3.getRule(this.patterns[i2]).collectPatternsRecursive(e3, t4, false);
          } else
            t4.push(this._begin);
        }, t3.prototype.compile = function(e3, t4, n2, r3) {
          return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new p2(), this.collectPatternsRecursive(e3, this._cachedCompiledPatterns, true), this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end)), this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, t4) : this._cachedCompiledPatterns.setSource(0, t4)), this._cachedCompiledPatterns.compile(e3, n2, r3);
        }, t3;
      }(u2);
      t2.BeginEndRule = g;
      var m2 = function(e2) {
        function t3(t4, n2, r3, i2, o3, s3, a3, c3, u3) {
          var l3 = e2.call(this, t4, n2, r3, i2) || this;
          return l3._begin = new h2(o3, l3.id), l3.beginCaptures = s3, l3.whileCaptures = c3, l3._while = new h2(a3, -2), l3.whileHasBackReferences = l3._while.hasBackReferences, l3.patterns = u3.patterns, l3.hasMissingPatterns = u3.hasMissingPatterns, l3._cachedCompiledPatterns = null, l3._cachedCompiledWhilePatterns = null, l3;
        }
        return i(t3, e2), t3.prototype.dispose = function() {
          this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
        }, Object.defineProperty(t3.prototype, "debugBeginRegExp", { get: function() {
          return "" + this._begin.source;
        }, enumerable: true, configurable: true }), Object.defineProperty(t3.prototype, "debugWhileRegExp", { get: function() {
          return "" + this._while.source;
        }, enumerable: true, configurable: true }), t3.prototype.getWhileWithResolvedBackReferences = function(e3, t4) {
          return this._while.resolveBackReferences(e3, t4);
        }, t3.prototype.collectPatternsRecursive = function(e3, t4, n2) {
          if (n2) {
            var r3, i2 = void 0;
            for (i2 = 0, r3 = this.patterns.length; i2 < r3; i2++)
              e3.getRule(this.patterns[i2]).collectPatternsRecursive(e3, t4, false);
          } else
            t4.push(this._begin);
        }, t3.prototype.compile = function(e3, t4, n2, r3) {
          return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new p2(), this.collectPatternsRecursive(e3, this._cachedCompiledPatterns, true)), this._cachedCompiledPatterns.compile(e3, n2, r3);
        }, t3.prototype.compileWhile = function(e3, t4, n2, r3) {
          return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new p2(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, t4 || ""), this._cachedCompiledWhilePatterns.compile(e3, n2, r3);
        }, t3;
      }(u2);
      t2.BeginWhileRule = m2;
      var _2 = function() {
        function e2() {
        }
        return e2.createCaptureRule = function(e3, t3, n2, r3, i2) {
          return e3.registerRule(function(e4) {
            return new l2(t3, e4, n2, r3, i2);
          });
        }, e2.getCompiledRuleId = function(t3, n2, r3) {
          return t3.id || n2.registerRule(function(i2) {
            if (t3.id = i2, t3.match)
              return new f2(t3.$vscodeTextmateLocation, t3.id, t3.name, t3.match, e2._compileCaptures(t3.captures, n2, r3));
            if (void 0 === t3.begin) {
              t3.repository && (r3 = o2.mergeObjects({}, r3, t3.repository));
              var s3 = t3.patterns;
              return void 0 === s3 && t3.include && (s3 = [{ include: t3.include }]), new d2(t3.$vscodeTextmateLocation, t3.id, t3.name, t3.contentName, e2._compilePatterns(s3, n2, r3));
            }
            return t3.while ? new m2(t3.$vscodeTextmateLocation, t3.id, t3.name, t3.contentName, t3.begin, e2._compileCaptures(t3.beginCaptures || t3.captures, n2, r3), t3.while, e2._compileCaptures(t3.whileCaptures || t3.captures, n2, r3), e2._compilePatterns(t3.patterns, n2, r3)) : new g(t3.$vscodeTextmateLocation, t3.id, t3.name, t3.contentName, t3.begin, e2._compileCaptures(t3.beginCaptures || t3.captures, n2, r3), t3.end, e2._compileCaptures(t3.endCaptures || t3.captures, n2, r3), t3.applyEndPatternLast, e2._compilePatterns(t3.patterns, n2, r3));
          }), t3.id;
        }, e2._compileCaptures = function(t3, n2, r3) {
          var i2 = [];
          if (t3) {
            var o3 = 0;
            for (var s3 in t3) {
              if ("$vscodeTextmateLocation" !== s3)
                (c3 = parseInt(s3, 10)) > o3 && (o3 = c3);
            }
            for (var a3 = 0; a3 <= o3; a3++)
              i2[a3] = null;
            for (var s3 in t3)
              if ("$vscodeTextmateLocation" !== s3) {
                var c3 = parseInt(s3, 10), u3 = 0;
                t3[s3].patterns && (u3 = e2.getCompiledRuleId(t3[s3], n2, r3)), i2[c3] = e2.createCaptureRule(n2, t3[s3].$vscodeTextmateLocation, t3[s3].name, t3[s3].contentName, u3);
              }
          }
          return i2;
        }, e2._compilePatterns = function(t3, n2, r3) {
          var i2 = [];
          if (t3)
            for (var o3 = 0, s3 = t3.length; o3 < s3; o3++) {
              var a3 = t3[o3], c3 = -1;
              if (a3.include)
                if ("#" === a3.include.charAt(0)) {
                  var u3 = r3[a3.include.substr(1)];
                  u3 && (c3 = e2.getCompiledRuleId(u3, n2, r3));
                } else if ("$base" === a3.include || "$self" === a3.include)
                  c3 = e2.getCompiledRuleId(r3[a3.include], n2, r3);
                else {
                  var l3 = null, h3 = null, p3 = a3.include.indexOf("#");
                  p3 >= 0 ? (l3 = a3.include.substring(0, p3), h3 = a3.include.substring(p3 + 1)) : l3 = a3.include;
                  var f3 = n2.getExternalGrammar(l3, r3);
                  if (f3)
                    if (h3) {
                      var _3 = f3.repository[h3];
                      _3 && (c3 = e2.getCompiledRuleId(_3, n2, f3.repository));
                    } else
                      c3 = e2.getCompiledRuleId(f3.repository.$self, n2, f3.repository);
                }
              else
                c3 = e2.getCompiledRuleId(a3, n2, r3);
              if (-1 !== c3) {
                var y2 = n2.getRule(c3), v = false;
                if ((y2 instanceof d2 || y2 instanceof g || y2 instanceof m2) && y2.hasMissingPatterns && 0 === y2.patterns.length && (v = true), v)
                  continue;
                i2.push(c3);
              }
            }
          return { patterns: i2, hasMissingPatterns: (t3 ? t3.length : 0) !== i2.length };
        }, e2;
      }();
      t2.RuleFactory = _2;
    }, function(e, t2, n) {
      function r2(e2) {
        return !!e2 && !!e2.match(/[\w\.:]+/);
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.createMatchers = function(e2, t3) {
        for (var n2, i, o2, s2 = [], a2 = (o2 = (i = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g).exec(n2 = e2), { next: function() {
          if (!o2)
            return null;
          var e3 = o2[0];
          return o2 = i.exec(n2), e3;
        } }), c2 = a2.next(); null !== c2; ) {
          var u2 = 0;
          if (2 === c2.length && ":" === c2.charAt(1)) {
            switch (c2.charAt(0)) {
              case "R":
                u2 = 1;
                break;
              case "L":
                u2 = -1;
                break;
              default:
                console.log("Unknown priority " + c2 + " in scope selector");
            }
            c2 = a2.next();
          }
          var l2 = p2();
          if (s2.push({ matcher: l2, priority: u2 }), "," !== c2)
            break;
          c2 = a2.next();
        }
        return s2;
        function h2() {
          if ("-" === c2) {
            c2 = a2.next();
            var e3 = h2();
            return function(t4) {
              return !!e3 && !e3(t4);
            };
          }
          if ("(" === c2) {
            c2 = a2.next();
            var n3 = function() {
              var e4 = [], t4 = p2();
              for (; t4 && (e4.push(t4), "|" === c2 || "," === c2); ) {
                do {
                  c2 = a2.next();
                } while ("|" === c2 || "," === c2);
                t4 = p2();
              }
              return function(t5) {
                return e4.some(function(e5) {
                  return e5(t5);
                });
              };
            }();
            return ")" === c2 && (c2 = a2.next()), n3;
          }
          if (r2(c2)) {
            var i2 = [];
            do {
              i2.push(c2), c2 = a2.next();
            } while (r2(c2));
            return function(e4) {
              return t3(i2, e4);
            };
          }
          return null;
        }
        function p2() {
          for (var e3 = [], t4 = h2(); t4; )
            e3.push(t4), t4 = h2();
          return function(t5) {
            return e3.every(function(e4) {
              return e4(t5);
            });
          };
        }
      };
    }, function(e, t2) {
      var n, r2, i = e.exports = {};
      function o2() {
        throw new Error("setTimeout has not been defined");
      }
      function s2() {
        throw new Error("clearTimeout has not been defined");
      }
      function a2(e2) {
        if (n === setTimeout)
          return setTimeout(e2, 0);
        if ((n === o2 || !n) && setTimeout)
          return n = setTimeout, setTimeout(e2, 0);
        try {
          return n(e2, 0);
        } catch (t3) {
          try {
            return n.call(null, e2, 0);
          } catch (t4) {
            return n.call(this, e2, 0);
          }
        }
      }
      !function() {
        try {
          n = "function" == typeof setTimeout ? setTimeout : o2;
        } catch (e2) {
          n = o2;
        }
        try {
          r2 = "function" == typeof clearTimeout ? clearTimeout : s2;
        } catch (e2) {
          r2 = s2;
        }
      }();
      var c2, u2 = [], l2 = false, h2 = -1;
      function p2() {
        l2 && c2 && (l2 = false, c2.length ? u2 = c2.concat(u2) : h2 = -1, u2.length && f2());
      }
      function f2() {
        if (!l2) {
          var e2 = a2(p2);
          l2 = true;
          for (var t3 = u2.length; t3; ) {
            for (c2 = u2, u2 = []; ++h2 < t3; )
              c2 && c2[h2].run();
            h2 = -1, t3 = u2.length;
          }
          c2 = null, l2 = false, function(e3) {
            if (r2 === clearTimeout)
              return clearTimeout(e3);
            if ((r2 === s2 || !r2) && clearTimeout)
              return r2 = clearTimeout, clearTimeout(e3);
            try {
              r2(e3);
            } catch (t4) {
              try {
                return r2.call(null, e3);
              } catch (t5) {
                return r2.call(this, e3);
              }
            }
          }(e2);
        }
      }
      function d2(e2, t3) {
        this.fun = e2, this.array = t3;
      }
      function g() {
      }
      i.nextTick = function(e2) {
        var t3 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n2 = 1; n2 < arguments.length; n2++)
            t3[n2 - 1] = arguments[n2];
        u2.push(new d2(e2, t3)), 1 !== u2.length || l2 || a2(f2);
      }, d2.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, i.title = "browser", i.browser = true, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = g, i.addListener = g, i.once = g, i.off = g, i.removeListener = g, i.removeAllListeners = g, i.emit = g, i.prependListener = g, i.prependOnceListener = g, i.listeners = function(e2) {
        return [];
      }, i.binding = function(e2) {
        throw new Error("process.binding is not supported");
      }, i.cwd = function() {
        return "/";
      }, i.chdir = function(e2) {
        throw new Error("process.chdir is not supported");
      }, i.umask = function() {
        return 0;
      };
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2 = n(9), i = n(2), o2 = n(10);
      t2.parseRawGrammar = function(e2, t3) {
        return void 0 === t3 && (t3 = null), null !== t3 && /\.json$/.test(t3) ? function(e3, t4) {
          if (i.DebugFlags.InDebugMode)
            return o2.parse(e3, t4, true);
          return JSON.parse(e3);
        }(e2, t3) : function(e3, t4) {
          if (i.DebugFlags.InDebugMode)
            return r2.parseWithLocation(e3, t4, "$vscodeTextmateLocation");
          return r2.parse(e3);
        }(e2, t3);
      };
    }, function(e, t2, n) {
      function r2(e2, t3, n2) {
        var r3 = e2.length, i = 0, o2 = 1, s2 = 0;
        function a2(t4) {
          if (null === n2)
            i += t4;
          else
            for (; t4 > 0; ) {
              10 === e2.charCodeAt(i) ? (i++, o2++, s2 = 0) : (i++, s2++), t4--;
            }
        }
        function c2(e3) {
          null === n2 ? i = e3 : a2(e3 - i);
        }
        function u2() {
          for (; i < r3; ) {
            var t4 = e2.charCodeAt(i);
            if (32 !== t4 && 9 !== t4 && 13 !== t4 && 10 !== t4)
              break;
            a2(1);
          }
        }
        function l2(t4) {
          return e2.substr(i, t4.length) === t4 && (a2(t4.length), true);
        }
        function h2(t4) {
          var n3 = e2.indexOf(t4, i);
          c2(-1 !== n3 ? n3 + t4.length : r3);
        }
        function p2(t4) {
          var n3 = e2.indexOf(t4, i);
          if (-1 !== n3) {
            var o3 = e2.substring(i, n3);
            return c2(n3 + t4.length), o3;
          }
          o3 = e2.substr(i);
          return c2(r3), o3;
        }
        r3 > 0 && 65279 === e2.charCodeAt(0) && (i = 1);
        var f2 = 0, d2 = null, g = [], m2 = [], _2 = null;
        function y2(e3, t4) {
          g.push(f2), m2.push(d2), f2 = e3, d2 = t4;
        }
        function v() {
          if (0 === g.length)
            return b2("illegal state stack");
          f2 = g.pop(), d2 = m2.pop();
        }
        function b2(t4) {
          throw new Error("Near offset " + i + ": " + t4 + " ~~~" + e2.substr(i, 50) + "~~~");
        }
        var C2, w2, k, R2 = function() {
          if (null === _2)
            return b2("missing <key>");
          var e3 = {};
          null !== n2 && (e3[n2] = { filename: t3, line: o2, char: s2 }), d2[_2] = e3, _2 = null, y2(1, e3);
        }, S2 = function() {
          if (null === _2)
            return b2("missing <key>");
          var e3 = [];
          d2[_2] = e3, _2 = null, y2(2, e3);
        }, P = function() {
          var e3 = {};
          null !== n2 && (e3[n2] = { filename: t3, line: o2, char: s2 }), d2.push(e3), y2(1, e3);
        }, x2 = function() {
          var e3 = [];
          d2.push(e3), y2(2, e3);
        };
        function I() {
          if (1 !== f2)
            return b2("unexpected </dict>");
          v();
        }
        function A() {
          return 1 === f2 || 2 !== f2 ? b2("unexpected </array>") : void v();
        }
        function T(e3) {
          if (1 === f2) {
            if (null === _2)
              return b2("missing <key>");
            d2[_2] = e3, _2 = null;
          } else
            2 === f2 ? d2.push(e3) : d2 = e3;
        }
        function L2(e3) {
          if (isNaN(e3))
            return b2("cannot parse float");
          if (1 === f2) {
            if (null === _2)
              return b2("missing <key>");
            d2[_2] = e3, _2 = null;
          } else
            2 === f2 ? d2.push(e3) : d2 = e3;
        }
        function M2(e3) {
          if (isNaN(e3))
            return b2("cannot parse integer");
          if (1 === f2) {
            if (null === _2)
              return b2("missing <key>");
            d2[_2] = e3, _2 = null;
          } else
            2 === f2 ? d2.push(e3) : d2 = e3;
        }
        function G(e3) {
          if (1 === f2) {
            if (null === _2)
              return b2("missing <key>");
            d2[_2] = e3, _2 = null;
          } else
            2 === f2 ? d2.push(e3) : d2 = e3;
        }
        function D2(e3) {
          if (1 === f2) {
            if (null === _2)
              return b2("missing <key>");
            d2[_2] = e3, _2 = null;
          } else
            2 === f2 ? d2.push(e3) : d2 = e3;
        }
        function N2(e3) {
          if (1 === f2) {
            if (null === _2)
              return b2("missing <key>");
            d2[_2] = e3, _2 = null;
          } else
            2 === f2 ? d2.push(e3) : d2 = e3;
        }
        function E2(e3) {
          if (e3.isClosed)
            return "";
          var t4 = p2("</");
          return h2(">"), t4.replace(/&#([0-9]+);/g, function(e4, t5) {
            return String.fromCodePoint(parseInt(t5, 10));
          }).replace(/&#x([0-9a-f]+);/g, function(e4, t5) {
            return String.fromCodePoint(parseInt(t5, 16));
          }).replace(/&amp;|&lt;|&gt;|&quot;|&apos;/g, function(e4) {
            switch (e4) {
              case "&amp;":
                return "&";
              case "&lt;":
                return "<";
              case "&gt;":
                return ">";
              case "&quot;":
                return '"';
              case "&apos;":
                return "'";
            }
            return e4;
          });
        }
        for (; i < r3 && (u2(), !(i >= r3)); ) {
          var O2 = e2.charCodeAt(i);
          if (a2(1), 60 !== O2)
            return b2("expected <");
          if (i >= r3)
            return b2("unexpected end of input");
          var j = e2.charCodeAt(i);
          if (63 !== j)
            if (33 !== j) {
              if (47 === j) {
                if (a2(1), u2(), l2("plist")) {
                  h2(">");
                  continue;
                }
                if (l2("dict")) {
                  h2(">"), I();
                  continue;
                }
                if (l2("array")) {
                  h2(">"), A();
                  continue;
                }
                return b2("unexpected closed tag");
              }
              var F2 = (w2 = void 0, k = void 0, w2 = p2(">"), k = false, 47 === w2.charCodeAt(w2.length - 1) && (k = true, w2 = w2.substring(0, w2.length - 1)), { name: w2.trim(), isClosed: k });
              switch (F2.name) {
                case "dict":
                  1 === f2 ? R2() : 2 === f2 ? P() : (d2 = {}, null !== n2 && (d2[n2] = { filename: t3, line: o2, char: s2 }), y2(1, d2)), F2.isClosed && I();
                  continue;
                case "array":
                  1 === f2 ? S2() : 2 === f2 ? x2() : y2(2, d2 = []), F2.isClosed && A();
                  continue;
                case "key":
                  C2 = E2(F2), 1 !== f2 ? b2("unexpected <key>") : null !== _2 ? b2("too many <key>") : _2 = C2;
                  continue;
                case "string":
                  T(E2(F2));
                  continue;
                case "real":
                  L2(parseFloat(E2(F2)));
                  continue;
                case "integer":
                  M2(parseInt(E2(F2), 10));
                  continue;
                case "date":
                  G(new Date(E2(F2)));
                  continue;
                case "data":
                  D2(E2(F2));
                  continue;
                case "true":
                  E2(F2), N2(true);
                  continue;
                case "false":
                  E2(F2), N2(false);
                  continue;
              }
              if (!/^plist/.test(F2.name))
                return b2("unexpected opened tag " + F2.name);
            } else {
              if (a2(1), l2("--")) {
                h2("-->");
                continue;
              }
              h2(">");
            }
          else
            a2(1), h2("?>");
        }
        return d2;
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.parseWithLocation = function(e2, t3, n2) {
        return r2(e2, t3, n2);
      }, t2.parse = function(e2) {
        return r2(e2, null, null);
      };
    }, function(e, t2, n) {
      function r2(e2, t3) {
        throw new Error("Near offset " + e2.pos + ": " + t3 + " ~~~" + e2.source.substr(e2.pos, 50) + "~~~");
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.parse = function(e2, t3, n2) {
        var a2 = new i(e2), c2 = new o2(), u2 = 0, l2 = null, h2 = [], p2 = [];
        function f2() {
          h2.push(u2), p2.push(l2);
        }
        function d2() {
          u2 = h2.pop(), l2 = p2.pop();
        }
        function g(e3) {
          r2(a2, e3);
        }
        for (; s2(a2, c2); ) {
          if (0 === u2) {
            if (null !== l2 && g("too many constructs in root"), 3 === c2.type) {
              l2 = {}, n2 && (l2.$vscodeTextmateLocation = c2.toLocation(t3)), f2(), u2 = 1;
              continue;
            }
            if (2 === c2.type) {
              l2 = [], f2(), u2 = 4;
              continue;
            }
            g("unexpected token in root");
          }
          if (2 === u2) {
            if (5 === c2.type) {
              d2();
              continue;
            }
            if (7 === c2.type) {
              u2 = 3;
              continue;
            }
            g("expected , or }");
          }
          if (1 === u2 || 3 === u2) {
            if (1 === u2 && 5 === c2.type) {
              d2();
              continue;
            }
            if (1 === c2.type) {
              var m2 = c2.value;
              if (s2(a2, c2) && 6 === c2.type || g("expected colon"), s2(a2, c2) || g("expected value"), u2 = 2, 1 === c2.type) {
                l2[m2] = c2.value;
                continue;
              }
              if (8 === c2.type) {
                l2[m2] = null;
                continue;
              }
              if (9 === c2.type) {
                l2[m2] = true;
                continue;
              }
              if (10 === c2.type) {
                l2[m2] = false;
                continue;
              }
              if (11 === c2.type) {
                l2[m2] = parseFloat(c2.value);
                continue;
              }
              if (2 === c2.type) {
                var _2 = [];
                l2[m2] = _2, f2(), u2 = 4, l2 = _2;
                continue;
              }
              if (3 === c2.type) {
                var y2 = {};
                n2 && (y2.$vscodeTextmateLocation = c2.toLocation(t3)), l2[m2] = y2, f2(), u2 = 1, l2 = y2;
                continue;
              }
            }
            g("unexpected token in dict");
          }
          if (5 === u2) {
            if (4 === c2.type) {
              d2();
              continue;
            }
            if (7 === c2.type) {
              u2 = 6;
              continue;
            }
            g("expected , or ]");
          }
          if (4 === u2 || 6 === u2) {
            if (4 === u2 && 4 === c2.type) {
              d2();
              continue;
            }
            if (u2 = 5, 1 === c2.type) {
              l2.push(c2.value);
              continue;
            }
            if (8 === c2.type) {
              l2.push(null);
              continue;
            }
            if (9 === c2.type) {
              l2.push(true);
              continue;
            }
            if (10 === c2.type) {
              l2.push(false);
              continue;
            }
            if (11 === c2.type) {
              l2.push(parseFloat(c2.value));
              continue;
            }
            if (2 === c2.type) {
              _2 = [];
              l2.push(_2), f2(), u2 = 4, l2 = _2;
              continue;
            }
            if (3 === c2.type) {
              y2 = {};
              n2 && (y2.$vscodeTextmateLocation = c2.toLocation(t3)), l2.push(y2), f2(), u2 = 1, l2 = y2;
              continue;
            }
            g("unexpected token in array");
          }
          g("unknown state");
        }
        return 0 !== p2.length && g("unclosed constructs"), l2;
      };
      var i = function(e2) {
        this.source = e2, this.pos = 0, this.len = e2.length, this.line = 1, this.char = 0;
      }, o2 = function() {
        function e2() {
          this.value = null, this.type = 0, this.offset = -1, this.len = -1, this.line = -1, this.char = -1;
        }
        return e2.prototype.toLocation = function(e3) {
          return { filename: e3, line: this.line, char: this.char };
        }, e2;
      }();
      function s2(e2, t3) {
        t3.value = null, t3.type = 0, t3.offset = -1, t3.len = -1, t3.line = -1, t3.char = -1;
        for (var n2, i2 = e2.source, o3 = e2.pos, s3 = e2.len, a2 = e2.line, c2 = e2.char; ; ) {
          if (o3 >= s3)
            return false;
          if (32 !== (n2 = i2.charCodeAt(o3)) && 9 !== n2 && 13 !== n2) {
            if (10 !== n2)
              break;
            o3++, a2++, c2 = 0;
          } else
            o3++, c2++;
        }
        if (t3.offset = o3, t3.line = a2, t3.char = c2, 34 === n2) {
          for (t3.type = 1, o3++, c2++; ; ) {
            if (o3 >= s3)
              return false;
            if (n2 = i2.charCodeAt(o3), o3++, c2++, 92 !== n2) {
              if (34 === n2)
                break;
            } else
              o3++, c2++;
          }
          t3.value = i2.substring(t3.offset + 1, o3 - 1).replace(/\\u([0-9A-Fa-f]{4})/g, function(e3, t4) {
            return String.fromCodePoint(parseInt(t4, 16));
          }).replace(/\\(.)/g, function(t4, n3) {
            switch (n3) {
              case '"':
                return '"';
              case "\\":
                return "\\";
              case "/":
                return "/";
              case "b":
                return "\b";
              case "f":
                return "\f";
              case "n":
                return "\n";
              case "r":
                return "\r";
              case "t":
                return "	";
              default:
                r2(e2, "invalid escape sequence");
            }
            throw new Error("unreachable");
          });
        } else if (91 === n2)
          t3.type = 2, o3++, c2++;
        else if (123 === n2)
          t3.type = 3, o3++, c2++;
        else if (93 === n2)
          t3.type = 4, o3++, c2++;
        else if (125 === n2)
          t3.type = 5, o3++, c2++;
        else if (58 === n2)
          t3.type = 6, o3++, c2++;
        else if (44 === n2)
          t3.type = 7, o3++, c2++;
        else if (110 === n2) {
          if (t3.type = 8, o3++, c2++, 117 !== (n2 = i2.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 108 !== (n2 = i2.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 108 !== (n2 = i2.charCodeAt(o3)))
            return false;
          o3++, c2++;
        } else if (116 === n2) {
          if (t3.type = 9, o3++, c2++, 114 !== (n2 = i2.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 117 !== (n2 = i2.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 101 !== (n2 = i2.charCodeAt(o3)))
            return false;
          o3++, c2++;
        } else if (102 === n2) {
          if (t3.type = 10, o3++, c2++, 97 !== (n2 = i2.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 108 !== (n2 = i2.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 115 !== (n2 = i2.charCodeAt(o3)))
            return false;
          if (o3++, c2++, 101 !== (n2 = i2.charCodeAt(o3)))
            return false;
          o3++, c2++;
        } else
          for (t3.type = 11; ; ) {
            if (o3 >= s3)
              return false;
            if (!(46 === (n2 = i2.charCodeAt(o3)) || n2 >= 48 && n2 <= 57 || 101 === n2 || 69 === n2 || 45 === n2 || 43 === n2))
              break;
            o3++, c2++;
          }
        return t3.len = o3 - t3.offset, null === t3.value && (t3.value = i2.substr(t3.offset, t3.len)), e2.pos = o3, e2.line = a2, e2.char = c2, true;
      }
    }, function(e, t2, n) {
      Object.defineProperty(t2, "__esModule", { value: true });
      var r2 = function(e2, t3, n2, r3, i2, o3) {
        this.scope = e2, this.parentScopes = t3, this.index = n2, this.fontStyle = r3, this.foreground = i2, this.background = o3;
      };
      function i(e2) {
        return !!/^#[0-9a-f]{6}$/i.test(e2) || (!!/^#[0-9a-f]{8}$/i.test(e2) || (!!/^#[0-9a-f]{3}$/i.test(e2) || !!/^#[0-9a-f]{4}$/i.test(e2)));
      }
      function o2(e2) {
        if (!e2)
          return [];
        if (!e2.settings || !Array.isArray(e2.settings))
          return [];
        for (var t3 = e2.settings, n2 = [], o3 = 0, s3 = 0, a3 = t3.length; s3 < a3; s3++) {
          var c3 = t3[s3];
          if (c3.settings) {
            var u3 = void 0;
            if ("string" == typeof c3.scope)
              u3 = c3.scope.replace(/^[,]+/, "").replace(/[,]+$/, "").split(",");
            else
              u3 = Array.isArray(c3.scope) ? c3.scope : [""];
            var l3 = -1;
            if ("string" == typeof c3.settings.fontStyle) {
              l3 = 0;
              for (var h3 = 0, p3 = (g = c3.settings.fontStyle.split(" ")).length; h3 < p3; h3++) {
                switch (g[h3]) {
                  case "italic":
                    l3 |= 1;
                    break;
                  case "bold":
                    l3 |= 2;
                    break;
                  case "underline":
                    l3 |= 4;
                }
              }
            }
            var f2 = null;
            "string" == typeof c3.settings.foreground && i(c3.settings.foreground) && (f2 = c3.settings.foreground);
            var d2 = null;
            "string" == typeof c3.settings.background && i(c3.settings.background) && (d2 = c3.settings.background);
            for (h3 = 0, p3 = u3.length; h3 < p3; h3++) {
              var g, m2 = (g = u3[h3].trim().split(" "))[g.length - 1], _2 = null;
              g.length > 1 && (_2 = g.slice(0, g.length - 1)).reverse(), n2[o3++] = new r2(m2, _2, s3, l3, f2, d2);
            }
          }
        }
        return n2;
      }
      function s2(e2, t3) {
        e2.sort(function(e3, t4) {
          var n3 = u2(e3.scope, t4.scope);
          return 0 !== n3 || 0 !== (n3 = l2(e3.parentScopes, t4.parentScopes)) ? n3 : e3.index - t4.index;
        });
        for (var n2 = 0, r3 = "#000000", i2 = "#ffffff"; e2.length >= 1 && "" === e2[0].scope; ) {
          var o3 = e2.shift();
          -1 !== o3.fontStyle && (n2 = o3.fontStyle), null !== o3.foreground && (r3 = o3.foreground), null !== o3.background && (i2 = o3.background);
        }
        for (var s3 = new a2(t3), f2 = new h2(0, null, n2, s3.getId(r3), s3.getId(i2)), d2 = new p2(new h2(0, null, -1, 0, 0), []), g = 0, m2 = e2.length; g < m2; g++) {
          var _2 = e2[g];
          d2.insert(0, _2.scope, _2.parentScopes, _2.fontStyle, s3.getId(_2.foreground), s3.getId(_2.background));
        }
        return new c2(s3, f2, d2);
      }
      t2.ParsedThemeRule = r2, t2.parseTheme = o2;
      var a2 = function() {
        function e2(e3) {
          if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(e3)) {
            this._isFrozen = true;
            for (var t3 = 0, n2 = e3.length; t3 < n2; t3++)
              this._color2id[e3[t3]] = t3, this._id2color[t3] = e3[t3];
          } else
            this._isFrozen = false;
        }
        return e2.prototype.getId = function(e3) {
          if (null === e3)
            return 0;
          e3 = e3.toUpperCase();
          var t3 = this._color2id[e3];
          if (t3)
            return t3;
          if (this._isFrozen)
            throw new Error("Missing color in color map - " + e3);
          return t3 = ++this._lastColorId, this._color2id[e3] = t3, this._id2color[t3] = e3, t3;
        }, e2.prototype.getColorMap = function() {
          return this._id2color.slice(0);
        }, e2;
      }();
      t2.ColorMap = a2;
      var c2 = function() {
        function e2(e3, t3, n2) {
          this._colorMap = e3, this._root = n2, this._defaults = t3, this._cache = {};
        }
        return e2.createFromRawTheme = function(e3, t3) {
          return this.createFromParsedTheme(o2(e3), t3);
        }, e2.createFromParsedTheme = function(e3, t3) {
          return s2(e3, t3);
        }, e2.prototype.getColorMap = function() {
          return this._colorMap.getColorMap();
        }, e2.prototype.getDefaults = function() {
          return this._defaults;
        }, e2.prototype.match = function(e3) {
          return this._cache.hasOwnProperty(e3) || (this._cache[e3] = this._root.match(e3)), this._cache[e3];
        }, e2;
      }();
      function u2(e2, t3) {
        return e2 < t3 ? -1 : e2 > t3 ? 1 : 0;
      }
      function l2(e2, t3) {
        if (null === e2 && null === t3)
          return 0;
        if (!e2)
          return -1;
        if (!t3)
          return 1;
        var n2 = e2.length, r3 = t3.length;
        if (n2 === r3) {
          for (var i2 = 0; i2 < n2; i2++) {
            var o3 = u2(e2[i2], t3[i2]);
            if (0 !== o3)
              return o3;
          }
          return 0;
        }
        return n2 - r3;
      }
      t2.Theme = c2, t2.strcmp = u2, t2.strArrCmp = l2;
      var h2 = function() {
        function e2(e3, t3, n2, r3, i2) {
          this.scopeDepth = e3, this.parentScopes = t3, this.fontStyle = n2, this.foreground = r3, this.background = i2;
        }
        return e2.prototype.clone = function() {
          return new e2(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
        }, e2.cloneArr = function(e3) {
          for (var t3 = [], n2 = 0, r3 = e3.length; n2 < r3; n2++)
            t3[n2] = e3[n2].clone();
          return t3;
        }, e2.prototype.acceptOverwrite = function(e3, t3, n2, r3) {
          this.scopeDepth > e3 ? console.log("how did this happen?") : this.scopeDepth = e3, -1 !== t3 && (this.fontStyle = t3), 0 !== n2 && (this.foreground = n2), 0 !== r3 && (this.background = r3);
        }, e2;
      }();
      t2.ThemeTrieElementRule = h2;
      var p2 = function() {
        function e2(e3, t3, n2) {
          void 0 === t3 && (t3 = []), void 0 === n2 && (n2 = {}), this._mainRule = e3, this._rulesWithParentScopes = t3, this._children = n2;
        }
        return e2._sortBySpecificity = function(e3) {
          return 1 === e3.length || e3.sort(this._cmpBySpecificity), e3;
        }, e2._cmpBySpecificity = function(e3, t3) {
          if (e3.scopeDepth === t3.scopeDepth) {
            var n2 = e3.parentScopes, r3 = t3.parentScopes, i2 = null === n2 ? 0 : n2.length, o3 = null === r3 ? 0 : r3.length;
            if (i2 === o3)
              for (var s3 = 0; s3 < i2; s3++) {
                var a3 = n2[s3].length, c3 = r3[s3].length;
                if (a3 !== c3)
                  return c3 - a3;
              }
            return o3 - i2;
          }
          return t3.scopeDepth - e3.scopeDepth;
        }, e2.prototype.match = function(t3) {
          if ("" === t3)
            return e2._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
          var n2, r3, i2 = t3.indexOf(".");
          return -1 === i2 ? (n2 = t3, r3 = "") : (n2 = t3.substring(0, i2), r3 = t3.substring(i2 + 1)), this._children.hasOwnProperty(n2) ? this._children[n2].match(r3) : e2._sortBySpecificity([].concat(this._mainRule).concat(this._rulesWithParentScopes));
        }, e2.prototype.insert = function(t3, n2, r3, i2, o3, s3) {
          if ("" !== n2) {
            var a3, c3, u3, l3 = n2.indexOf(".");
            -1 === l3 ? (a3 = n2, c3 = "") : (a3 = n2.substring(0, l3), c3 = n2.substring(l3 + 1)), this._children.hasOwnProperty(a3) ? u3 = this._children[a3] : (u3 = new e2(this._mainRule.clone(), h2.cloneArr(this._rulesWithParentScopes)), this._children[a3] = u3), u3.insert(t3 + 1, c3, r3, i2, o3, s3);
          } else
            this._doInsertHere(t3, r3, i2, o3, s3);
        }, e2.prototype._doInsertHere = function(e3, t3, n2, r3, i2) {
          if (null !== t3) {
            for (var o3 = 0, s3 = this._rulesWithParentScopes.length; o3 < s3; o3++) {
              var a3 = this._rulesWithParentScopes[o3];
              if (0 === l2(a3.parentScopes, t3))
                return void a3.acceptOverwrite(e3, n2, r3, i2);
            }
            -1 === n2 && (n2 = this._mainRule.fontStyle), 0 === r3 && (r3 = this._mainRule.foreground), 0 === i2 && (i2 = this._mainRule.background), this._rulesWithParentScopes.push(new h2(e3, t3, n2, r3, i2));
          } else
            this._mainRule.acceptOverwrite(e3, n2, r3, i2);
        }, e2;
      }();
      t2.ThemeTrieElement = p2;
    }]);
  });
})(main$1);
var mainExports = main$1.exports;
const languages = [
  {
    id: "abap",
    scopeName: "source.abap",
    path: "abap.tmLanguage.json",
    samplePath: "abap.sample"
  },
  {
    id: "actionscript-3",
    scopeName: "source.actionscript.3",
    path: "actionscript-3.tmLanguage.json",
    samplePath: "actionscript-3.sample"
  },
  {
    id: "ada",
    scopeName: "source.ada",
    path: "ada.tmLanguage.json",
    samplePath: "ada.sample"
  },
  {
    id: "apache",
    scopeName: "source.apacheconf",
    path: "apache.tmLanguage.json"
  },
  {
    id: "apex",
    scopeName: "source.apex",
    path: "apex.tmLanguage.json",
    samplePath: "apex.sample"
  },
  {
    id: "apl",
    scopeName: "source.apl",
    path: "apl.tmLanguage.json",
    embeddedLangs: ["html", "xml", "css", "javascript", "json"]
  },
  {
    id: "applescript",
    scopeName: "source.applescript",
    path: "applescript.tmLanguage.json",
    samplePath: "applescript.sample"
  },
  {
    id: "asm",
    scopeName: "source.asm.x86_64",
    path: "asm.tmLanguage.json",
    samplePath: "asm.sample"
  },
  {
    id: "astro",
    scopeName: "text.html.astro",
    path: "astro.tmLanguage.json",
    samplePath: "astro.sample",
    embeddedLangs: ["css", "sass", "scss", "tsx"]
  },
  {
    id: "awk",
    scopeName: "source.awk",
    path: "awk.tmLanguage.json",
    samplePath: "awk.sample"
  },
  {
    id: "ballerina",
    scopeName: "source.ballerina",
    path: "ballerina.tmLanguage.json",
    samplePath: "ballerina.sample"
  },
  {
    id: "bat",
    scopeName: "source.batchfile",
    path: "bat.tmLanguage.json",
    samplePath: "bat.sample",
    aliases: ["batch"]
  },
  {
    id: "c",
    scopeName: "source.c",
    path: "c.tmLanguage.json",
    samplePath: "c.sample"
  },
  {
    id: "clojure",
    scopeName: "source.clojure",
    path: "clojure.tmLanguage.json",
    samplePath: "clojure.sample",
    aliases: ["clj"]
  },
  {
    id: "cobol",
    scopeName: "source.cobol",
    path: "cobol.tmLanguage.json",
    samplePath: "cobol.sample",
    embeddedLangs: ["sql", "html", "java"]
  },
  {
    id: "coffee",
    scopeName: "source.coffee",
    path: "coffee.tmLanguage.json",
    samplePath: "coffee.sample",
    embeddedLangs: ["javascript"]
  },
  {
    id: "cpp",
    scopeName: "source.cpp",
    path: "cpp.tmLanguage.json",
    samplePath: "cpp.sample",
    embeddedLangs: ["sql"]
  },
  {
    id: "crystal",
    scopeName: "source.crystal",
    path: "crystal.tmLanguage.json",
    samplePath: "crystal.sample",
    embeddedLangs: ["html", "sql", "css", "c", "javascript", "shellscript"]
  },
  {
    id: "csharp",
    scopeName: "source.cs",
    path: "csharp.tmLanguage.json",
    samplePath: "csharp.sample",
    aliases: ["c#"]
  },
  {
    id: "css",
    scopeName: "source.css",
    path: "css.tmLanguage.json",
    samplePath: "css.sample"
  },
  {
    id: "d",
    scopeName: "source.d",
    path: "d.tmLanguage.json",
    samplePath: "d.sample"
  },
  {
    id: "dart",
    scopeName: "source.dart",
    path: "dart.tmLanguage.json",
    samplePath: "dart.sample"
  },
  {
    id: "diff",
    scopeName: "source.diff",
    path: "diff.tmLanguage.json",
    samplePath: "diff.sample"
  },
  {
    id: "docker",
    scopeName: "source.dockerfile",
    path: "docker.tmLanguage.json",
    samplePath: "docker.sample"
  },
  {
    id: "dream-maker",
    scopeName: "source.dm",
    path: "dream-maker.tmLanguage.json"
  },
  {
    id: "elixir",
    scopeName: "source.elixir",
    path: "elixir.tmLanguage.json",
    samplePath: "elixir.sample",
    embeddedLangs: ["html"]
  },
  {
    id: "elm",
    scopeName: "source.elm",
    path: "elm.tmLanguage.json",
    samplePath: "elm.sample"
  },
  {
    id: "erb",
    scopeName: "text.html.erb",
    path: "erb.tmLanguage.json",
    samplePath: "erb.sample",
    embeddedLangs: ["html", "ruby"]
  },
  {
    id: "erlang",
    scopeName: "source.erlang",
    path: "erlang.tmLanguage.json",
    samplePath: "erlang.sample"
  },
  {
    id: "fish",
    scopeName: "source.fish",
    path: "fish.tmLanguage.json",
    samplePath: "fish.sample"
  },
  {
    id: "fsharp",
    scopeName: "source.fsharp",
    path: "fsharp.tmLanguage.json",
    samplePath: "fsharp.sample",
    aliases: ["f#"],
    embeddedLangs: ["markdown"]
  },
  {
    id: "gherkin",
    scopeName: "text.gherkin.feature",
    path: "gherkin.tmLanguage.json"
  },
  {
    id: "git-commit",
    scopeName: "text.git-commit",
    path: "git-commit.tmLanguage.json",
    embeddedLangs: ["diff"]
  },
  {
    id: "git-rebase",
    scopeName: "text.git-rebase",
    path: "git-rebase.tmLanguage.json",
    embeddedLangs: ["shellscript"]
  },
  {
    id: "gnuplot",
    scopeName: "source.gnuplot",
    path: "gnuplot.tmLanguage.json"
  },
  {
    id: "go",
    scopeName: "source.go",
    path: "go.tmLanguage.json",
    samplePath: "go.sample"
  },
  {
    id: "graphql",
    scopeName: "source.graphql",
    path: "graphql.tmLanguage.json",
    embeddedLangs: ["javascript", "typescript", "jsx", "tsx"]
  },
  {
    id: "groovy",
    scopeName: "source.groovy",
    path: "groovy.tmLanguage.json"
  },
  {
    id: "hack",
    scopeName: "source.hack",
    path: "hack.tmLanguage.json",
    embeddedLangs: ["html", "sql"]
  },
  {
    id: "haml",
    scopeName: "text.haml",
    path: "haml.tmLanguage.json",
    embeddedLangs: ["ruby", "javascript", "sass", "coffee", "markdown", "css"]
  },
  {
    id: "handlebars",
    scopeName: "text.html.handlebars",
    path: "handlebars.tmLanguage.json",
    aliases: ["hbs"],
    embeddedLangs: ["html", "css", "javascript", "yaml"]
  },
  {
    id: "haskell",
    scopeName: "source.haskell",
    path: "haskell.tmLanguage.json"
  },
  {
    id: "hcl",
    scopeName: "source.hcl",
    path: "hcl.tmLanguage.json"
  },
  {
    id: "hlsl",
    scopeName: "source.hlsl",
    path: "hlsl.tmLanguage.json"
  },
  {
    id: "html",
    scopeName: "text.html.basic",
    path: "html.tmLanguage.json",
    samplePath: "html.sample",
    embeddedLangs: ["javascript", "css"]
  },
  {
    id: "ini",
    scopeName: "source.ini",
    path: "ini.tmLanguage.json"
  },
  {
    id: "java",
    scopeName: "source.java",
    path: "java.tmLanguage.json",
    samplePath: "java.sample"
  },
  {
    id: "javascript",
    scopeName: "source.js",
    path: "javascript.tmLanguage.json",
    samplePath: "javascript.sample",
    aliases: ["js"]
  },
  {
    id: "jinja-html",
    scopeName: "text.html.jinja",
    path: "jinja-html.tmLanguage.json",
    embeddedLangs: ["html"]
  },
  {
    id: "json",
    scopeName: "source.json",
    path: "json.tmLanguage.json"
  },
  {
    id: "jsonc",
    scopeName: "source.json.comments",
    path: "jsonc.tmLanguage.json"
  },
  {
    id: "jsonnet",
    scopeName: "source.jsonnet",
    path: "jsonnet.tmLanguage.json"
  },
  {
    id: "jssm",
    scopeName: "source.jssm",
    path: "jssm.tmLanguage.json",
    samplePath: "jssm.sample",
    aliases: ["fsl"]
  },
  {
    id: "jsx",
    scopeName: "source.js.jsx",
    path: "jsx.tmLanguage.json"
  },
  {
    id: "julia",
    scopeName: "source.julia",
    path: "julia.tmLanguage.json",
    embeddedLangs: ["cpp", "python", "javascript", "r", "sql"]
  },
  {
    id: "jupyter",
    scopeName: "source.jupyter",
    path: "jupyter.tmLanguage.json",
    embeddedLangs: ["json"]
  },
  {
    id: "kotlin",
    scopeName: "source.kotlin",
    path: "kotlin.tmLanguage.json"
  },
  {
    id: "latex",
    scopeName: "text.tex.latex",
    path: "latex.tmLanguage.json",
    embeddedLangs: ["tex", "css", "html", "java", "javascript", "typescript", "lua", "python", "julia", "ruby", "xml", "yaml", "cpp", "haskell", "scala", "gnuplot"]
  },
  {
    id: "less",
    scopeName: "source.css.less",
    path: "less.tmLanguage.json",
    embeddedLangs: ["css"]
  },
  {
    id: "lisp",
    scopeName: "source.lisp",
    path: "lisp.tmLanguage.json"
  },
  {
    id: "logo",
    scopeName: "source.logo",
    path: "logo.tmLanguage.json"
  },
  {
    id: "lua",
    scopeName: "source.lua",
    path: "lua.tmLanguage.json",
    embeddedLangs: ["c"]
  },
  {
    id: "make",
    scopeName: "source.makefile",
    path: "make.tmLanguage.json",
    aliases: ["makefile"]
  },
  {
    id: "markdown",
    scopeName: "text.html.markdown",
    path: "markdown.tmLanguage.json",
    aliases: ["md"],
    embeddedLangs: ["css", "html", "ini", "java", "lua", "make", "perl", "r", "ruby", "php", "sql", "vb", "xml", "xsl", "yaml", "bat", "clojure", "coffee", "c", "cpp", "diff", "docker", "git-commit", "git-rebase", "go", "groovy", "pug", "javascript", "json", "jsonc", "less", "objective-c", "swift", "scss", "raku", "powershell", "python", "rust", "scala", "shellscript", "typescript", "tsx", "csharp", "fsharp", "dart", "handlebars", "erlang", "elixir"]
  },
  {
    id: "matlab",
    scopeName: "source.matlab",
    path: "matlab.tmLanguage.json"
  },
  {
    id: "mdx",
    scopeName: "text.html.markdown.jsx",
    path: "mdx.tmLanguage.json",
    embeddedLangs: ["jsx", "markdown"]
  },
  {
    id: "nginx",
    scopeName: "source.nginx",
    path: "nginx.tmLanguage.json"
  },
  {
    id: "nim",
    scopeName: "source.nim",
    path: "nim.tmLanguage.json",
    embeddedLangs: ["c", "html", "xml", "javascript", "css", "markdown"]
  },
  {
    id: "nix",
    scopeName: "source.nix",
    path: "nix.tmLanguage.json"
  },
  {
    id: "objective-c",
    scopeName: "source.objc",
    path: "objective-c.tmLanguage.json",
    aliases: ["objc"]
  },
  {
    id: "objective-cpp",
    scopeName: "source.objcpp",
    path: "objective-cpp.tmLanguage.json"
  },
  {
    id: "ocaml",
    scopeName: "source.ocaml",
    path: "ocaml.tmLanguage.json"
  },
  {
    id: "pascal",
    scopeName: "source.pascal",
    path: "pascal.tmLanguage.json"
  },
  {
    id: "perl",
    scopeName: "source.perl",
    path: "perl.tmLanguage.json",
    embeddedLangs: ["html", "xml", "css", "javascript", "sql"]
  },
  {
    id: "php",
    scopeName: "source.php",
    path: "php.tmLanguage.json",
    embeddedLangs: ["html", "xml", "sql", "javascript", "json", "css"]
  },
  {
    id: "plsql",
    scopeName: "source.plsql.oracle",
    path: "plsql.tmLanguage.json"
  },
  {
    id: "postcss",
    scopeName: "source.css.postcss",
    path: "postcss.tmLanguage.json"
  },
  {
    id: "powershell",
    scopeName: "source.powershell",
    path: "powershell.tmLanguage.json",
    aliases: ["ps", "ps1"]
  },
  {
    id: "prisma",
    scopeName: "source.prisma",
    path: "prisma.tmLanguage.json",
    samplePath: "prisma.sample"
  },
  {
    id: "prolog",
    scopeName: "source.prolog",
    path: "prolog.tmLanguage.json"
  },
  {
    id: "pug",
    scopeName: "text.pug",
    path: "pug.tmLanguage.json",
    aliases: ["jade"],
    embeddedLangs: ["javascript", "css", "sass", "stylus", "coffee", "html"]
  },
  {
    id: "puppet",
    scopeName: "source.puppet",
    path: "puppet.tmLanguage.json"
  },
  {
    id: "purescript",
    scopeName: "source.purescript",
    path: "purescript.tmLanguage.json"
  },
  {
    id: "python",
    scopeName: "source.python",
    path: "python.tmLanguage.json",
    samplePath: "python.sample",
    aliases: ["py"]
  },
  {
    id: "r",
    scopeName: "source.r",
    path: "r.tmLanguage.json"
  },
  {
    id: "raku",
    scopeName: "source.perl.6",
    path: "raku.tmLanguage.json",
    aliases: ["perl6"]
  },
  {
    id: "razor",
    scopeName: "text.aspnetcorerazor",
    path: "razor.tmLanguage.json",
    embeddedLangs: ["html", "csharp"]
  },
  {
    id: "riscv",
    scopeName: "source.riscv",
    path: "riscv.tmLanguage.json"
  },
  {
    id: "ruby",
    scopeName: "source.ruby",
    path: "ruby.tmLanguage.json",
    samplePath: "ruby.sample",
    aliases: ["rb"],
    embeddedLangs: ["html", "xml", "sql", "css", "c", "javascript", "shellscript", "lua"]
  },
  {
    id: "rust",
    scopeName: "source.rust",
    path: "rust.tmLanguage.json"
  },
  {
    id: "sas",
    scopeName: "source.sas",
    path: "sas.tmLanguage.json",
    embeddedLangs: ["sql"]
  },
  {
    id: "sass",
    scopeName: "source.sass",
    path: "sass.tmLanguage.json"
  },
  {
    id: "scala",
    scopeName: "source.scala",
    path: "scala.tmLanguage.json"
  },
  {
    id: "scheme",
    scopeName: "source.scheme",
    path: "scheme.tmLanguage.json"
  },
  {
    id: "scss",
    scopeName: "source.css.scss",
    path: "scss.tmLanguage.json",
    embeddedLangs: ["css"]
  },
  {
    id: "shaderlab",
    scopeName: "source.shaderlab",
    path: "shaderlab.tmLanguage.json",
    aliases: ["shader"],
    embeddedLangs: ["hlsl"]
  },
  {
    id: "shellscript",
    scopeName: "source.shell",
    path: "shellscript.tmLanguage.json",
    aliases: ["shell", "bash", "sh", "zsh"],
    embeddedLangs: ["ruby", "python", "applescript", "html", "markdown"]
  },
  {
    id: "smalltalk",
    scopeName: "source.smalltalk",
    path: "smalltalk.tmLanguage.json"
  },
  {
    id: "solidity",
    scopeName: "source.solidity",
    path: "solidity.tmLanguage.json"
  },
  {
    id: "sparql",
    scopeName: "source.sparql",
    path: "sparql.tmLanguage.json",
    samplePath: "sparql.sample",
    embeddedLangs: ["turtle"]
  },
  {
    id: "sql",
    scopeName: "source.sql",
    path: "sql.tmLanguage.json"
  },
  {
    id: "ssh-config",
    scopeName: "source.ssh-config",
    path: "ssh-config.tmLanguage.json"
  },
  {
    id: "stylus",
    scopeName: "source.stylus",
    path: "stylus.tmLanguage.json",
    aliases: ["styl"]
  },
  {
    id: "svelte",
    scopeName: "source.svelte",
    path: "svelte.tmLanguage.json",
    embeddedLangs: ["javascript", "typescript", "coffee", "stylus", "sass", "css", "scss", "less", "postcss", "pug", "markdown"]
  },
  {
    id: "swift",
    scopeName: "source.swift",
    path: "swift.tmLanguage.json"
  },
  {
    id: "system-verilog",
    scopeName: "source.systemverilog",
    path: "system-verilog.tmLanguage.json"
  },
  {
    id: "tasl",
    scopeName: "source.tasl",
    path: "tasl.tmLanguage.json",
    samplePath: "tasl.sample"
  },
  {
    id: "tcl",
    scopeName: "source.tcl",
    path: "tcl.tmLanguage.json"
  },
  {
    id: "tex",
    scopeName: "text.tex",
    path: "tex.tmLanguage.json",
    embeddedLangs: ["r"]
  },
  {
    id: "toml",
    scopeName: "source.toml",
    path: "toml.tmLanguage.json"
  },
  {
    id: "tsx",
    scopeName: "source.tsx",
    path: "tsx.tmLanguage.json",
    samplePath: "tsx.sample"
  },
  {
    id: "turtle",
    scopeName: "source.turtle",
    path: "turtle.tmLanguage.json",
    samplePath: "turtle.sample"
  },
  {
    id: "twig",
    scopeName: "text.html.twig",
    path: "twig.tmLanguage.json",
    embeddedLangs: ["css", "javascript", "php", "python", "ruby"]
  },
  {
    id: "typescript",
    scopeName: "source.ts",
    path: "typescript.tmLanguage.json",
    aliases: ["ts"]
  },
  {
    id: "vb",
    scopeName: "source.asp.vb.net",
    path: "vb.tmLanguage.json",
    aliases: ["cmd"]
  },
  {
    id: "verilog",
    scopeName: "source.verilog",
    path: "verilog.tmLanguage.json"
  },
  {
    id: "vhdl",
    scopeName: "source.vhdl",
    path: "vhdl.tmLanguage.json"
  },
  {
    id: "viml",
    scopeName: "source.viml",
    path: "viml.tmLanguage.json"
  },
  {
    id: "vue-html",
    scopeName: "text.html.vue-html",
    path: "vue-html.tmLanguage.json",
    embeddedLangs: ["vue", "javascript"]
  },
  {
    id: "vue",
    scopeName: "source.vue",
    path: "vue.tmLanguage.json",
    embeddedLangs: ["json", "markdown", "pug", "haml", "vue-html", "sass", "scss", "less", "stylus", "postcss", "css", "typescript", "coffee", "javascript"]
  },
  {
    id: "wasm",
    scopeName: "source.wat",
    path: "wasm.tmLanguage.json"
  },
  {
    id: "wenyan",
    scopeName: "source.wenyan",
    path: "wenyan.tmLanguage.json",
    aliases: [""]
  },
  {
    id: "xml",
    scopeName: "text.xml",
    path: "xml.tmLanguage.json",
    embeddedLangs: ["java"]
  },
  {
    id: "xsl",
    scopeName: "text.xml.xsl",
    path: "xsl.tmLanguage.json",
    embeddedLangs: ["xml"]
  },
  {
    id: "yaml",
    scopeName: "source.yaml",
    path: "yaml.tmLanguage.json"
  }
];
var FontStyle;
(function(FontStyle2) {
  FontStyle2[FontStyle2["NotSet"] = -1] = "NotSet";
  FontStyle2[FontStyle2["None"] = 0] = "None";
  FontStyle2[FontStyle2["Italic"] = 1] = "Italic";
  FontStyle2[FontStyle2["Bold"] = 2] = "Bold";
  FontStyle2[FontStyle2["Underline"] = 4] = "Underline";
})(FontStyle || (FontStyle = {}));
class StackElementMetadata {
  static toBinaryStr(metadata) {
    let r2 = metadata.toString(2);
    while (r2.length < 32) {
      r2 = "0" + r2;
    }
    return r2;
  }
  static printMetadata(metadata) {
    let languageId = StackElementMetadata.getLanguageId(metadata);
    let tokenType = StackElementMetadata.getTokenType(metadata);
    let fontStyle = StackElementMetadata.getFontStyle(metadata);
    let foreground = StackElementMetadata.getForeground(metadata);
    let background = StackElementMetadata.getBackground(metadata);
    console.log({
      languageId,
      tokenType,
      fontStyle,
      foreground,
      background
    });
  }
  static getLanguageId(metadata) {
    return (metadata & 255) >>> 0;
  }
  static getTokenType(metadata) {
    return (metadata & 1792) >>> 8;
  }
  static getFontStyle(metadata) {
    return (metadata & 14336) >>> 11;
  }
  static getForeground(metadata) {
    return (metadata & 8372224) >>> 14;
  }
  static getBackground(metadata) {
    return (metadata & 4286578688) >>> 23;
  }
  static set(metadata, languageId, tokenType, fontStyle, foreground, background) {
    let _languageId = StackElementMetadata.getLanguageId(metadata);
    let _tokenType = StackElementMetadata.getTokenType(metadata);
    let _fontStyle = StackElementMetadata.getFontStyle(metadata);
    let _foreground = StackElementMetadata.getForeground(metadata);
    let _background = StackElementMetadata.getBackground(metadata);
    if (languageId !== 0) {
      _languageId = languageId;
    }
    if (tokenType !== 0) {
      _tokenType = tokenType === 8 ? 0 : tokenType;
    }
    if (fontStyle !== FontStyle.NotSet) {
      _fontStyle = fontStyle;
    }
    if (foreground !== 0) {
      _foreground = foreground;
    }
    if (background !== 0) {
      _background = background;
    }
    return (_languageId << 0 | _tokenType << 8 | _fontStyle << 11 | _foreground << 14 | _background << 23) >>> 0;
  }
}
function trimEndSlash(str) {
  if (str.endsWith("/") || str.endsWith("\\"))
    return str.slice(0, -1);
  return str;
}
function trimStartDot(str) {
  if (str.startsWith("./"))
    return str.slice(2);
  return str;
}
function dirname(str) {
  const parts2 = str.split(/[\/\\]/g);
  return parts2[parts2.length - 2];
}
function join(...parts2) {
  return parts2.map(trimEndSlash).map(trimStartDot).join("/");
}
function createScanner(text, ignoreTrivia) {
  if (ignoreTrivia === void 0) {
    ignoreTrivia = false;
  }
  var len = text.length;
  var pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count, exact) {
    var digits = 0;
    var value2 = 0;
    while (digits < count || !exact) {
      var ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    var start2 = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start2, pos);
      }
    }
    var end2 = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end2 = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start2, end2);
  }
  function scanString() {
    var result = "", start2 = pos;
    while (true) {
      if (pos >= len) {
        result += text.substring(start2, pos);
        scanError = 2;
        break;
      }
      var ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start2, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start2, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        var ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            var ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start2 = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start2, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    var code2 = text.charCodeAt(pos);
    if (isWhiteSpace(code2)) {
      do {
        pos++;
        value += String.fromCharCode(code2);
        code2 = text.charCodeAt(pos);
      } while (isWhiteSpace(code2));
      return token = 15;
    }
    if (isLineBreak(code2)) {
      pos++;
      value += String.fromCharCode(code2);
      if (code2 === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code2) {
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      case 47:
        var start2 = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start2, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          var safeLength = len - 1;
          var commentClosed = false;
          while (pos < safeLength) {
            var ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start2, pos);
          return token = 13;
        }
        value += String.fromCharCode(code2);
        pos++;
        return token = 16;
      case 45:
        value += String.fromCharCode(code2);
        pos++;
        if (pos === len || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      default:
        while (pos < len && isUnknownContentCharacter(code2)) {
          pos++;
          code2 = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code2);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code2) {
    if (isWhiteSpace(code2) || isLineBreak(code2)) {
      return false;
    }
    switch (code2) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    var result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: function() {
      return pos;
    },
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: function() {
      return token;
    },
    getTokenValue: function() {
      return value;
    },
    getTokenOffset: function() {
      return tokenOffset;
    },
    getTokenLength: function() {
      return pos - tokenOffset;
    },
    getTokenStartLine: function() {
      return lineStartOffset;
    },
    getTokenStartCharacter: function() {
      return tokenOffset - prevTokenLineStartOffset;
    },
    getTokenError: function() {
      return scanError;
    }
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch === 5760 || ch >= 8192 && ch <= 8203 || ch === 8239 || ch === 8287 || ch === 12288 || ch === 65279;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var ParseOptions;
(function(ParseOptions2) {
  ParseOptions2.DEFAULT = {
    allowTrailingComma: false
  };
})(ParseOptions || (ParseOptions = {}));
function parse$1(text, errors, options2) {
  if (errors === void 0) {
    errors = [];
  }
  if (options2 === void 0) {
    options2 = ParseOptions.DEFAULT;
  }
  var currentProperty = null;
  var currentParent = [];
  var previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  var visitor = {
    onObjectBegin: function() {
      var object2 = {};
      onValue(object2);
      previousParents.push(currentParent);
      currentParent = object2;
      currentProperty = null;
    },
    onObjectProperty: function(name2) {
      currentProperty = name2;
    },
    onObjectEnd: function() {
      currentParent = previousParents.pop();
    },
    onArrayBegin: function() {
      var array = [];
      onValue(array);
      previousParents.push(currentParent);
      currentParent = array;
      currentProperty = null;
    },
    onArrayEnd: function() {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: function(error, offset2, length2) {
      errors.push({ error, offset: offset2, length: length2 });
    }
  };
  visit(text, visitor, options2);
  return currentParent[0];
}
function visit(text, visitor, options2) {
  if (options2 === void 0) {
    options2 = ParseOptions.DEFAULT;
  }
  var _scanner = createScanner(text, false);
  function toNoArgVisit(visitFunction) {
    return visitFunction ? function() {
      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? function(arg) {
      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  var disallowComments = options2 && options2.disallowComments;
  var allowTrailingComma = options2 && options2.allowTrailingComma;
  function scanNext() {
    while (true) {
      var token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError2(
            14
            /* InvalidUnicode */
          );
          break;
        case 5:
          handleError2(
            15
            /* InvalidEscapeCharacter */
          );
          break;
        case 3:
          handleError2(
            13
            /* UnexpectedEndOfNumber */
          );
          break;
        case 1:
          if (!disallowComments) {
            handleError2(
              11
              /* UnexpectedEndOfComment */
            );
          }
          break;
        case 2:
          handleError2(
            12
            /* UnexpectedEndOfString */
          );
          break;
        case 6:
          handleError2(
            16
            /* InvalidCharacter */
          );
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError2(
              10
              /* InvalidCommentToken */
            );
          } else {
            onComment();
          }
          break;
        case 16:
          handleError2(
            1
            /* InvalidSymbol */
          );
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError2(error, skipUntilAfter, skipUntil) {
    if (skipUntilAfter === void 0) {
      skipUntilAfter = [];
    }
    if (skipUntil === void 0) {
      skipUntil = [];
    }
    onError(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      var token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    var value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        var tokenValue = _scanner.getTokenValue();
        var value = Number(tokenValue);
        if (isNaN(value)) {
          handleError2(
            2
            /* InvalidNumberFormat */
          );
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError2(3, [], [
        2,
        5
        /* CommaToken */
      ]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue2()) {
        handleError2(4, [], [
          2,
          5
          /* CommaToken */
        ]);
      }
    } else {
      handleError2(5, [], [
        2,
        5
        /* CommaToken */
      ]);
    }
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError2(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError2(6, [], []);
      }
      if (!parseProperty()) {
        handleError2(4, [], [
          2,
          5
          /* CommaToken */
        ]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError2(7, [
        2
        /* CloseBraceToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError2(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError2(6, [], []);
      }
      if (!parseValue2()) {
        handleError2(4, [], [
          4,
          5
          /* CommaToken */
        ]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (_scanner.getToken() !== 4) {
      handleError2(8, [
        4
        /* CloseBracketToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue2() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options2.allowEmptyContent) {
      return true;
    }
    handleError2(4, [], []);
    return false;
  }
  if (!parseValue2()) {
    handleError2(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError2(9, [], []);
  }
  return true;
}
var parse = parse$1;
const isWebWorker = typeof self !== "undefined" && typeof self.WorkerGlobalScope !== "undefined";
const isBrowser = isWebWorker || typeof window !== "undefined" && typeof window.document !== "undefined" && typeof fetch !== "undefined";
let CDN_ROOT = "";
let ONIGASM_WASM = "";
function setOnigasmWASM(path) {
  ONIGASM_WASM = path;
}
let _onigasmPromise = null;
async function getOnigasm() {
  if (!_onigasmPromise) {
    let loader;
    if (isBrowser) {
      loader = loadWASM(ONIGASM_WASM || _resolvePath("dist/onigasm.wasm"));
    } else {
      const path = require("path");
      const onigasmPath = path.join(require.resolve("onigasm"), "../onigasm.wasm");
      const fs = require("fs");
      const wasmBin = fs.readFileSync(onigasmPath).buffer;
      loader = loadWASM(wasmBin);
    }
    _onigasmPromise = loader.then(() => {
      return {
        createOnigScanner(patterns2) {
          return new OnigScanner2(patterns2);
        },
        createOnigString(s2) {
          return new OnigString2(s2);
        }
      };
    });
  }
  return _onigasmPromise;
}
function _resolvePath(filepath) {
  if (isBrowser) {
    {
      console.warn("[Shiki] no CDN provider found, use `setCDN()` to specify the CDN for loading the resources before calling `getHighlighter()`");
    }
    return `${CDN_ROOT}${filepath}`;
  } else {
    const path = require("path");
    if (path.isAbsolute(filepath)) {
      return filepath;
    } else {
      return path.resolve(__dirname, "..", filepath);
    }
  }
}
async function _fetchAssets(filepath) {
  const path = _resolvePath(filepath);
  if (isBrowser) {
    return await fetch(path).then((r2) => r2.text());
  } else {
    const fs = require("fs");
    return await fs.promises.readFile(path, "utf-8");
  }
}
async function _fetchJSONAssets(filepath) {
  const errors = [];
  const rawTheme = parse(await _fetchAssets(filepath), errors, {
    allowTrailingComma: true
  });
  if (errors.length) {
    throw errors[0];
  }
  return rawTheme;
}
async function fetchTheme(themePath) {
  let theme = await _fetchJSONAssets(themePath);
  const shikiTheme = toShikiTheme(theme);
  if (shikiTheme.include) {
    const includedTheme = await fetchTheme(join(dirname(themePath), shikiTheme.include));
    if (includedTheme.settings) {
      shikiTheme.settings = includedTheme.settings.concat(shikiTheme.settings);
    }
    if (includedTheme.bg && !shikiTheme.bg) {
      shikiTheme.bg = includedTheme.bg;
    }
    if (includedTheme.colors) {
      shikiTheme.colors = Object.assign(Object.assign({}, includedTheme.colors), shikiTheme.colors);
    }
    delete shikiTheme.include;
  }
  return shikiTheme;
}
async function fetchGrammar(filepath) {
  return await _fetchJSONAssets(filepath);
}
function repairTheme(theme) {
  if (!theme.settings)
    theme.settings = [];
  if (theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope) {
    return;
  }
  theme.settings.unshift({
    settings: {
      foreground: theme.fg,
      background: theme.bg
    }
  });
}
function toShikiTheme(rawTheme) {
  const type2 = rawTheme.type || "dark";
  const shikiTheme = Object.assign(Object.assign({ name: rawTheme.name, type: type2 }, rawTheme), getThemeDefaultColors(rawTheme));
  if (rawTheme.include) {
    shikiTheme.include = rawTheme.include;
  }
  if (rawTheme.tokenColors) {
    shikiTheme.settings = rawTheme.tokenColors;
    delete shikiTheme.tokenColors;
  }
  repairTheme(shikiTheme);
  return shikiTheme;
}
const VSCODE_FALLBACK_EDITOR_FG = { light: "#333333", dark: "#bbbbbb" };
const VSCODE_FALLBACK_EDITOR_BG = { light: "#fffffe", dark: "#1e1e1e" };
function getThemeDefaultColors(theme) {
  var _a2, _b2, _c, _d, _e, _f;
  let fg, bg;
  let settings = theme.settings ? theme.settings : theme.tokenColors;
  const globalSetting = settings ? settings.find((s2) => {
    return !s2.name && !s2.scope;
  }) : void 0;
  if ((_a2 = globalSetting === null || globalSetting === void 0 ? void 0 : globalSetting.settings) === null || _a2 === void 0 ? void 0 : _a2.foreground) {
    fg = globalSetting.settings.foreground;
  }
  if ((_b2 = globalSetting === null || globalSetting === void 0 ? void 0 : globalSetting.settings) === null || _b2 === void 0 ? void 0 : _b2.background) {
    bg = globalSetting.settings.background;
  }
  if (!fg && ((_d = (_c = theme) === null || _c === void 0 ? void 0 : _c.colors) === null || _d === void 0 ? void 0 : _d["editor.foreground"])) {
    fg = theme.colors["editor.foreground"];
  }
  if (!bg && ((_f = (_e = theme) === null || _e === void 0 ? void 0 : _e.colors) === null || _f === void 0 ? void 0 : _f["editor.background"])) {
    bg = theme.colors["editor.background"];
  }
  if (!fg) {
    fg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;
  }
  if (!bg) {
    bg = theme.type === "light" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;
  }
  return {
    fg,
    bg
  };
}
class Resolver {
  constructor(onigLibPromise, onigLibName) {
    this.languagesPath = "languages/";
    this.languageMap = {};
    this.scopeToLangMap = {};
    this._onigLibPromise = onigLibPromise;
    this._onigLibName = onigLibName;
  }
  get onigLib() {
    return this._onigLibPromise;
  }
  getOnigLibName() {
    return this._onigLibName;
  }
  getLangRegistration(langIdOrAlias) {
    return this.languageMap[langIdOrAlias];
  }
  async loadGrammar(scopeName2) {
    const lang = this.scopeToLangMap[scopeName2];
    if (!lang) {
      return null;
    }
    if (lang.grammar) {
      return lang.grammar;
    }
    const g = await fetchGrammar(languages.includes(lang) ? `${this.languagesPath}${lang.path}` : lang.path);
    lang.grammar = g;
    return g;
  }
  addLanguage(l2) {
    this.languageMap[l2.id] = l2;
    if (l2.aliases) {
      l2.aliases.forEach((a2) => {
        this.languageMap[a2] = l2;
      });
    }
    this.scopeToLangMap[l2.scopeName] = l2;
  }
}
function tokenizeWithTheme(theme, colorMap, fileContents, grammar, options2) {
  let lines = fileContents.split(/\r\n|\r|\n/);
  let ruleStack = mainExports.INITIAL;
  let actual = [];
  let final = [];
  for (let i = 0, len = lines.length; i < len; i++) {
    let line = lines[i];
    if (line === "") {
      actual = [];
      final.push([]);
      continue;
    }
    let resultWithScopes;
    let tokensWithScopes;
    let tokensWithScopesIndex;
    if (options2.includeExplanation) {
      resultWithScopes = grammar.tokenizeLine(line, ruleStack);
      tokensWithScopes = resultWithScopes.tokens;
      tokensWithScopesIndex = 0;
    }
    let result = grammar.tokenizeLine2(line, ruleStack);
    let tokensLength = result.tokens.length / 2;
    for (let j = 0; j < tokensLength; j++) {
      let startIndex = result.tokens[2 * j];
      let nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;
      if (startIndex === nextStartIndex) {
        continue;
      }
      let metadata = result.tokens[2 * j + 1];
      let foreground = StackElementMetadata.getForeground(metadata);
      let foregroundColor = colorMap[foreground];
      let fontStyle = StackElementMetadata.getFontStyle(metadata);
      let explanation = [];
      if (options2.includeExplanation) {
        let offset2 = 0;
        while (startIndex + offset2 < nextStartIndex) {
          let tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];
          let tokenWithScopesText = line.substring(tokenWithScopes.startIndex, tokenWithScopes.endIndex);
          offset2 += tokenWithScopesText.length;
          explanation.push({
            content: tokenWithScopesText,
            scopes: explainThemeScopes(theme, tokenWithScopes.scopes)
          });
          tokensWithScopesIndex++;
        }
      }
      actual.push({
        content: line.substring(startIndex, nextStartIndex),
        color: foregroundColor,
        fontStyle,
        explanation
      });
    }
    final.push(actual);
    actual = [];
    ruleStack = result.ruleStack;
  }
  return final;
}
function explainThemeScopes(theme, scopes) {
  let result = [];
  for (let i = 0, len = scopes.length; i < len; i++) {
    let parentScopes = scopes.slice(0, i);
    let scope = scopes[i];
    result[i] = {
      scopeName: scope,
      themeMatches: explainThemeScope(theme, scope, parentScopes)
    };
  }
  return result;
}
function matchesOne(selector, scope) {
  let selectorPrefix = selector + ".";
  if (selector === scope || scope.substring(0, selectorPrefix.length) === selectorPrefix) {
    return true;
  }
  return false;
}
function matches(selector, selectorParentScopes, scope, parentScopes) {
  if (!matchesOne(selector, scope)) {
    return false;
  }
  let selectorParentIndex = selectorParentScopes.length - 1;
  let parentIndex = parentScopes.length - 1;
  while (selectorParentIndex >= 0 && parentIndex >= 0) {
    if (matchesOne(selectorParentScopes[selectorParentIndex], parentScopes[parentIndex])) {
      selectorParentIndex--;
    }
    parentIndex--;
  }
  if (selectorParentIndex === -1) {
    return true;
  }
  return false;
}
function explainThemeScope(theme, scope, parentScopes) {
  let result = [], resultLen = 0;
  for (let i = 0, len = theme.settings.length; i < len; i++) {
    let setting = theme.settings[i];
    let selectors;
    if (typeof setting.scope === "string") {
      selectors = setting.scope.split(/,/).map((scope2) => scope2.trim());
    } else if (Array.isArray(setting.scope)) {
      selectors = setting.scope;
    } else {
      continue;
    }
    for (let j = 0, lenJ = selectors.length; j < lenJ; j++) {
      let rawSelector = selectors[j];
      let rawSelectorPieces = rawSelector.split(/ /);
      let selector = rawSelectorPieces[rawSelectorPieces.length - 1];
      let selectorParentScopes = rawSelectorPieces.slice(0, rawSelectorPieces.length - 1);
      if (matches(selector, selectorParentScopes, scope, parentScopes)) {
        result[resultLen++] = setting;
        j = lenJ;
      }
    }
  }
  return result;
}
function renderToHtml(lines, options2 = {}) {
  const bg = options2.bg || "#fff";
  let html = "";
  html += `<pre class="shiki" style="background-color: ${bg}">`;
  if (options2.langId) {
    html += `<div class="language-id">${options2.langId}</div>`;
  }
  html += `<code>`;
  lines.forEach((l2) => {
    html += `<span class="line">`;
    l2.forEach((token) => {
      const cssDeclarations = [`color: ${token.color || options2.fg}`];
      if (token.fontStyle & FontStyle.Italic) {
        cssDeclarations.push("font-style: italic");
      }
      if (token.fontStyle & FontStyle.Bold) {
        cssDeclarations.push("font-weight: bold");
      }
      if (token.fontStyle & FontStyle.Underline) {
        cssDeclarations.push("text-decoration: underline");
      }
      html += `<span style="${cssDeclarations.join("; ")}">${escapeHtml(token.content)}</span>`;
    });
    html += `</span>
`;
  });
  html = html.replace(/\n*$/, "");
  html += `</code></pre>`;
  return html;
}
const htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function escapeHtml(html) {
  return html.replace(/[&<>"']/g, (chr) => htmlEscapes[chr]);
}
class Registry extends mainExports.Registry {
  constructor(_resolver2) {
    super(_resolver2);
    this._resolver = _resolver2;
    this.themesPath = "themes/";
    this._resolvedThemes = {};
    this._resolvedGrammars = {};
  }
  getTheme(theme) {
    if (typeof theme === "string") {
      return this._resolvedThemes[theme];
    } else {
      return theme;
    }
  }
  async loadTheme(theme) {
    if (typeof theme === "string") {
      if (!this._resolvedThemes[theme]) {
        this._resolvedThemes[theme] = await fetchTheme(`${this.themesPath}${theme}.json`);
      }
      return this._resolvedThemes[theme];
    } else {
      theme = toShikiTheme(theme);
      if (theme.name) {
        this._resolvedThemes[theme.name] = theme;
      }
      return theme;
    }
  }
  async loadThemes(themes) {
    return await Promise.all(themes.map((theme) => this.loadTheme(theme)));
  }
  getLoadedThemes() {
    return Object.keys(this._resolvedThemes);
  }
  getGrammer(name2) {
    return this._resolvedGrammars[name2];
  }
  async loadLanguage(lang) {
    const g = await this.loadGrammar(lang.scopeName);
    this._resolvedGrammars[lang.id] = g;
    if (lang.aliases) {
      lang.aliases.forEach((la) => {
        this._resolvedGrammars[la] = g;
      });
    }
  }
  async loadLanguages(langs2) {
    for (const lang of langs2) {
      this._resolver.addLanguage(lang);
    }
    for (const lang of langs2) {
      await this.loadLanguage(lang);
    }
  }
  getLoadedLanguages() {
    return Object.keys(this._resolvedGrammars);
  }
}
function resolveLang(lang) {
  return typeof lang === "string" ? languages.find((l2) => {
    var _a2;
    return l2.id === lang || ((_a2 = l2.aliases) === null || _a2 === void 0 ? void 0 : _a2.includes(lang));
  }) : lang;
}
function resolveOptions(options2) {
  var _a2;
  let _languages = languages;
  let _themes = options2.themes || [];
  if ((_a2 = options2.langs) === null || _a2 === void 0 ? void 0 : _a2.length) {
    _languages = options2.langs.map(resolveLang);
  }
  if (options2.theme) {
    _themes.unshift(options2.theme);
  }
  if (!_themes.length) {
    _themes = ["nord"];
  }
  return { _languages, _themes };
}
async function getHighlighter(options2) {
  var _a2, _b2;
  const { _languages, _themes } = resolveOptions(options2);
  const _resolver2 = new Resolver(getOnigasm(), "onigasm");
  const _registry = new Registry(_resolver2);
  if ((_a2 = options2.paths) === null || _a2 === void 0 ? void 0 : _a2.themes) {
    _registry.themesPath = options2.paths.themes;
  }
  if ((_b2 = options2.paths) === null || _b2 === void 0 ? void 0 : _b2.languages) {
    _resolver2.languagesPath = options2.paths.languages;
  }
  const themes = await _registry.loadThemes(_themes);
  const _defaultTheme = themes[0];
  let _currentTheme;
  await _registry.loadLanguages(_languages);
  const COLOR_REPLACEMENTS = {
    "#000001": "var(--shiki-color-text)",
    "#000002": "var(--shiki-color-background)",
    "#000004": "var(--shiki-token-constant)",
    "#000005": "var(--shiki-token-string)",
    "#000006": "var(--shiki-token-comment)",
    "#000007": "var(--shiki-token-keyword)",
    "#000008": "var(--shiki-token-parameter)",
    "#000009": "var(--shiki-token-function)",
    "#000010": "var(--shiki-token-string-expression)",
    "#000011": "var(--shiki-token-punctuation)",
    "#000012": "var(--shiki-token-link)"
  };
  function fixCssVariablesTheme(theme, colorMap) {
    theme.bg = COLOR_REPLACEMENTS[theme.bg] || theme.bg;
    theme.fg = COLOR_REPLACEMENTS[theme.fg] || theme.fg;
    colorMap.forEach((val, i) => {
      colorMap[i] = COLOR_REPLACEMENTS[val] || val;
    });
  }
  function getTheme(theme) {
    const _theme = theme ? _registry.getTheme(theme) : _defaultTheme;
    if (!_theme) {
      throw Error(`No theme registration for ${theme}`);
    }
    if (!_currentTheme || _currentTheme.name !== _theme.name) {
      _registry.setTheme(_theme);
      _currentTheme = _theme;
    }
    const _colorMap = _registry.getColorMap();
    if (_theme.name === "css-variables") {
      fixCssVariablesTheme(_theme, _colorMap);
    }
    return { _theme, _colorMap };
  }
  function getGrammer(lang) {
    const _grammer = _registry.getGrammer(lang);
    if (!_grammer) {
      throw Error(`No language registration for ${lang}`);
    }
    return { _grammer };
  }
  function codeToThemedTokens(code2, lang = "text", theme, options3 = { includeExplanation: true }) {
    if (isPlaintext(lang)) {
      return [[{ content: code2 }]];
    }
    const { _grammer } = getGrammer(lang);
    const { _theme, _colorMap } = getTheme(theme);
    return tokenizeWithTheme(_theme, _colorMap, code2, _grammer, options3);
  }
  function codeToHtml(code2, lang = "text", theme) {
    const tokens = codeToThemedTokens(code2, lang, theme, {
      includeExplanation: false
    });
    const { _theme } = getTheme(theme);
    return renderToHtml(tokens, {
      fg: _theme.fg,
      bg: _theme.bg
    });
  }
  async function loadTheme(theme) {
    await _registry.loadTheme(theme);
  }
  async function loadLanguage(lang) {
    const _lang = resolveLang(lang);
    _resolver2.addLanguage(_lang);
    await _registry.loadLanguage(_lang);
  }
  function getLoadedThemes() {
    return _registry.getLoadedThemes();
  }
  function getLoadedLanguages() {
    return _registry.getLoadedLanguages();
  }
  function getBackgroundColor(theme) {
    const { _theme } = getTheme(theme);
    return _theme.bg;
  }
  function getForegroundColor(theme) {
    const { _theme } = getTheme(theme);
    return _theme.fg;
  }
  return {
    codeToThemedTokens,
    codeToHtml,
    getTheme: (theme) => {
      return getTheme(theme)._theme;
    },
    loadTheme,
    loadLanguage,
    getBackgroundColor,
    getForegroundColor,
    getLoadedThemes,
    getLoadedLanguages
  };
}
function isPlaintext(lang) {
  return !lang || ["plaintext", "txt", "text"].includes(lang);
}
const onigasm = "" + new URL("onigasm-kQxuTr47.wasm", import.meta.url).href;
const name = "cypress";
const type = "light";
const tokenColors = [
  {
    settings: {
      foreground: "#434861"
    }
  },
  {
    scope: [
      "meta.embedded",
      "source.groovy.embedded"
    ],
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: "emphasis",
    settings: {
      fontStyle: "italic"
    }
  },
  {
    scope: "strong",
    settings: {
      fontStyle: "bold"
    }
  },
  {
    scope: "meta.diff.header",
    settings: {
      foreground: "#252E8F"
    }
  },
  {
    scope: "comment",
    settings: {
      foreground: "#9095AD"
    }
  },
  {
    scope: "constant.language",
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: [
      "constant.numeric",
      "variable.other.enummember",
      "keyword.operator.plus.exponent",
      "keyword.operator.minus.exponent"
    ],
    settings: {
      foreground: "#00814D"
    }
  },
  {
    scope: "constant.regexp",
    settings: {
      foreground: "#4F0018"
    }
  },
  {
    name: "css tags in selectors, xml tags",
    scope: "entity.name.tag",
    settings: {
      foreground: "#5E021B"
    }
  },
  {
    scope: "entity.name.selector",
    settings: {
      foreground: "#5E021B"
    }
  },
  {
    scope: "entity.other.attribute-name",
    settings: {
      foreground: "#C62B49"
    }
  },
  {
    scope: [
      "entity.other.attribute-name.class.css",
      "entity.other.attribute-name.class.mixin.css",
      "entity.other.attribute-name.id.css",
      "entity.other.attribute-name.parent-selector.css",
      "entity.other.attribute-name.pseudo-class.css",
      "entity.other.attribute-name.pseudo-element.css",
      "source.css.less entity.other.attribute-name.id",
      "entity.other.attribute-name.scss"
    ],
    settings: {
      foreground: "#5E021B"
    }
  },
  {
    scope: "invalid",
    settings: {
      foreground: "#C62B49"
    }
  },
  {
    scope: "markup.underline",
    settings: {
      fontStyle: "underline"
    }
  },
  {
    scope: "markup.bold",
    settings: {
      fontStyle: "bold",
      foreground: "#252E8F"
    }
  },
  {
    scope: "markup.heading",
    settings: {
      fontStyle: "bold",
      foreground: "#5E021B"
    }
  },
  {
    scope: "markup.italic",
    settings: {
      fontStyle: "italic"
    }
  },
  {
    scope: "markup.inserted",
    settings: {
      foreground: "#00814D"
    }
  },
  {
    scope: "markup.deleted",
    settings: {
      foreground: "#C62B49"
    }
  },
  {
    scope: "markup.changed",
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: [
      "punctuation.definition.quote.begin.markdown",
      "punctuation.definition.list.begin.markdown"
    ],
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: "markup.inline.raw",
    settings: {
      foreground: "#5E021B"
    }
  },
  {
    name: "brackets of XML/HTML tags",
    scope: "punctuation.definition.tag",
    settings: {
      foreground: "#5E021B"
    }
  },
  {
    scope: [
      "meta.preprocessor",
      "entity.name.function.preprocessor"
    ],
    settings: {
      foreground: "#BD5800"
    }
  },
  {
    scope: "meta.preprocessor.string",
    settings: {
      foreground: "#00814D"
    }
  },
  {
    scope: "meta.preprocessor.numeric",
    settings: {
      foreground: "#00814D"
    }
  },
  {
    scope: "meta.structure.dictionary.key.python",
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: "storage",
    settings: {
      foreground: "#BD5800"
    }
  },
  {
    scope: "storage.type",
    settings: {
      foreground: "#BD5800"
    }
  },
  {
    scope: [
      "storage.modifier",
      "keyword.operator.noexcept"
    ],
    settings: {
      foreground: "#BD5800"
    }
  },
  {
    scope: [
      "string",
      "meta.embedded.assembly"
    ],
    settings: {
      foreground: "#00814D"
    }
  },
  {
    scope: [
      "string.comment.buffered.block.pug",
      "string.quoted.pug",
      "string.interpolated.pug",
      "string.unquoted.plain.in.yaml",
      "string.unquoted.plain.out.yaml",
      "string.unquoted.block.yaml",
      "string.quoted.single.yaml",
      "string.quoted.double.xml",
      "string.quoted.single.xml",
      "string.unquoted.cdata.xml",
      "string.quoted.double.html",
      "string.quoted.single.html",
      "string.unquoted.html",
      "string.quoted.single.handlebars",
      "string.quoted.double.handlebars"
    ],
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: "string.regexp",
    settings: {
      foreground: "#5E021B"
    }
  },
  {
    name: "String interpolation",
    scope: [
      "punctuation.definition.template-expression.begin",
      "punctuation.definition.template-expression.end",
      "punctuation.section.embedded"
    ],
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    name: "Reset JavaScript string interpolation expression",
    scope: [
      "meta.template.expression"
    ],
    settings: {
      foreground: "#434861"
    }
  },
  {
    scope: [
      "support.constant.property-value",
      "support.constant.font-name",
      "support.constant.media-type",
      "support.constant.media",
      "constant.other.color.rgb-value",
      "constant.other.rgb-value",
      "support.constant.color"
    ],
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: [
      "support.type.vendored.property-name",
      "support.type.property-name",
      "variable.css",
      "variable.scss",
      "variable.other.less",
      "source.coffee.embedded"
    ],
    settings: {
      foreground: "#C62B49"
    }
  },
  {
    scope: [
      "support.type.property-name.json"
    ],
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: "keyword",
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: "keyword.control",
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: "keyword.operator",
    settings: {
      foreground: "#434861"
    }
  },
  {
    scope: [
      "keyword.operator.new",
      "keyword.operator.expression",
      "keyword.operator.cast",
      "keyword.operator.sizeof",
      "keyword.operator.alignof",
      "keyword.operator.typeid",
      "keyword.operator.alignas",
      "keyword.operator.instanceof",
      "keyword.operator.logical.python",
      "keyword.operator.wordlike"
    ],
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: "keyword.other.unit",
    settings: {
      foreground: "#00814D"
    }
  },
  {
    scope: [
      "punctuation.section.embedded.begin.php",
      "punctuation.section.embedded.end.php"
    ],
    settings: {
      foreground: "#5E021B"
    }
  },
  {
    scope: "support.function.git-rebase",
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: "constant.sha.git-rebase",
    settings: {
      foreground: "#00814D"
    }
  },
  {
    name: "coloring of the Java import and package identifiers",
    scope: [
      "storage.modifier.import.java",
      "variable.language.wildcard.java",
      "storage.modifier.package.java"
    ],
    settings: {
      foreground: "#434861"
    }
  },
  {
    name: "this.self",
    scope: "variable.language",
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    name: "Function declarations",
    scope: [
      "entity.name.function",
      "support.function",
      "support.constant.handlebars",
      "source.powershell variable.other.member",
      "entity.name.operator.custom-literal"
    ],
    settings: {
      foreground: "#BD5800"
    }
  },
  {
    name: "Types declaration and references",
    scope: [
      "meta.return-type",
      "support.class",
      "support.type",
      "entity.name.type",
      "entity.name.namespace",
      "entity.other.attribute",
      "entity.name.scope-resolution",
      "entity.name.class",
      "storage.type.numeric.go",
      "storage.type.byte.go",
      "storage.type.boolean.go",
      "storage.type.string.go",
      "storage.type.uintptr.go",
      "storage.type.error.go",
      "storage.type.rune.go",
      "storage.type.cs",
      "storage.type.generic.cs",
      "storage.type.modifier.cs",
      "storage.type.variable.cs",
      "storage.type.annotation.java",
      "storage.type.generic.java",
      "storage.type.java",
      "storage.type.object.array.java",
      "storage.type.primitive.array.java",
      "storage.type.primitive.java",
      "storage.type.token.java",
      "storage.type.groovy",
      "storage.type.annotation.groovy",
      "storage.type.parameters.groovy",
      "storage.type.generic.groovy",
      "storage.type.object.array.groovy",
      "storage.type.primitive.array.groovy",
      "storage.type.primitive.groovy"
    ],
    settings: {
      foreground: "#C53282"
    }
  },
  {
    name: "Types declaration and references, TS grammar specific",
    scope: [
      "meta.type.cast.expr",
      "meta.type.new.expr",
      "support.constant.math",
      "support.constant.dom",
      "support.constant.json",
      "entity.other.inherited-class"
    ],
    settings: {
      foreground: "#434861"
    }
  },
  {
    name: "Control flow / Special keywords",
    scope: [
      "keyword.control",
      "source.cpp keyword.operator.new",
      "source.cpp keyword.operator.delete",
      "keyword.other.using",
      "keyword.other.operator",
      "entity.name.operator"
    ],
    settings: {
      foreground: "#7F43C9"
    }
  },
  {
    name: "Variable and parameter name",
    scope: [
      "variable",
      "meta.definition.variable.name",
      "support.variable",
      "entity.name.variable",
      "constant.other.placeholder"
    ],
    settings: {
      foreground: "#434861"
    }
  },
  {
    name: "Constants and enums",
    scope: [
      "variable.other.constant",
      "variable.other.enummember"
    ],
    settings: {
      foreground: "#434861"
    }
  },
  {
    name: "Object keys, TS grammar specific",
    scope: [
      "meta.object-literal.key"
    ],
    settings: {
      foreground: "#434861"
    }
  },
  {
    name: "CSS property value",
    scope: [
      "support.constant.property-value",
      "support.constant.font-name",
      "support.constant.media-type",
      "support.constant.media",
      "constant.other.color.rgb-value",
      "constant.other.rgb-value",
      "support.constant.color"
    ],
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    name: "Regular expression groups",
    scope: [
      "punctuation.definition.group.regexp",
      "punctuation.definition.group.assertion.regexp",
      "punctuation.definition.character-class.regexp",
      "punctuation.character.set.begin.regexp",
      "punctuation.character.set.end.regexp",
      "keyword.operator.negation.regexp",
      "support.other.parenthesis.regexp"
    ],
    settings: {
      foreground: "#BD5800"
    }
  },
  {
    name: "Punctuation tokens",
    scope: [
      "punctuation"
    ],
    settings: {
      foreground: "#9095AD"
    }
  },
  {
    scope: [
      "constant.character.character-class.regexp",
      "constant.other.character-class.set.regexp",
      "constant.other.character-class.regexp",
      "constant.character.set.regexp"
    ],
    settings: {
      foreground: "#C53282"
    }
  },
  {
    scope: "keyword.operator.quantifier.regexp",
    settings: {
      foreground: "#434861"
    }
  },
  {
    scope: [
      "keyword.operator.or.regexp",
      "keyword.control.anchor.regexp"
    ],
    settings: {
      foreground: "#E45770"
    }
  },
  {
    scope: "constant.character",
    settings: {
      foreground: "#4956E3"
    }
  },
  {
    scope: "constant.character.escape",
    settings: {
      foreground: "#E45770"
    }
  },
  {
    scope: "entity.name.label",
    settings: {
      foreground: "#434861"
    }
  }
];
const shikiCyTheme = {
  name,
  type,
  tokenColors
};
const langJSONFilesArray = /* @__PURE__ */ Object.assign({ "../public/shiki/languages/css.tmLanguage.json": __vite_glob_0_0, "../public/shiki/languages/html.tmLanguage.json": __vite_glob_0_1, "../public/shiki/languages/javascript.tmLanguage.json": __vite_glob_0_2, "../public/shiki/languages/json.tmLanguage.json": __vite_glob_0_3, "../public/shiki/languages/jsonc.tmLanguage.json": __vite_glob_0_4, "../public/shiki/languages/jsx.tmLanguage.json": __vite_glob_0_5, "../public/shiki/languages/tsx.tmLanguage.json": __vite_glob_0_6, "../public/shiki/languages/typescript.tmLanguage.json": __vite_glob_0_7, "../public/shiki/languages/vue-html.tmLanguage.json": __vite_glob_0_8, "../public/shiki/languages/vue.tmLanguage.json": __vite_glob_0_9, "../public/shiki/languages/yaml.tmLanguage.json": __vite_glob_0_10 });
const langs = Object.values(langJSONFilesArray).map((grammar) => {
  return {
    grammar,
    id: grammar.name,
    scopeName: grammar.scopeName
  };
});
setOnigasmWASM(onigasm);
let highlighter;
const langsSupported = langs.map((lang) => lang.id);
async function initHighlighter() {
  if (highlighter) {
    return;
  }
  highlighter = await getHighlighter({
    theme: shikiCyTheme,
    langs
  });
}
const _hoisted_1$7 = { class: "text-left cursor-text" };
const _hoisted_2$7 = ["innerHTML"];
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "ShikiHighlight",
  props: {
    code: null,
    initialLine: { default: 1 },
    lang: null,
    lineNumbers: { type: Boolean, default: false },
    wrap: { type: Boolean, default: false },
    copyOnClick: { type: Boolean, default: false },
    copyButton: { type: Boolean, default: false },
    codeframe: { type: Boolean, default: false },
    skipTrim: { type: Boolean, default: false },
    class: { default: void 0 }
  },
  setup(__props) {
    const props = __props;
    useCssVars((_ctx) => ({
      "02b2fc17": props.initialLine
    }));
    const highlighterInitialized = ref(false);
    onBeforeMount(async () => {
      await initHighlighter();
      highlighterInitialized.value = true;
    });
    const resolvedLang = computed(() => {
      switch (props.lang) {
        case "javascript":
        case "js":
        case "jsx":
          return "jsx";
        case "typescript":
        case "ts":
        case "tsx":
          return "tsx";
        default:
          return props.lang && langsSupported.includes(props.lang) ? props.lang : "plaintext";
      }
    });
    const trimmedCode = computed(() => props.skipTrim ? props.code : props.code.trim());
    const highlightedCode = computed(() => {
      return highlighter == null ? void 0 : highlighter.codeToHtml(trimmedCode.value, resolvedLang.value);
    });
    const codeEl = ref(null);
    const { copy } = useClipboard();
    const copyCode = () => {
      if (codeEl.value) {
        const text = codeEl.value.innerText;
        copy(text);
      }
    };
    const numberOfLines = computed(() => props.code.trim().split("\n").length);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        highlighterInitialized.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref_key: "codeEl",
          ref: codeEl,
          tabindex: "0",
          class: normalizeClass([
            "shiki-wrapper",
            // All styles contain these utility classes
            "overflow-scroll hover:border-indigo-200 text-[14px] leading-[24px] font-normal",
            /**
             * 1. Single line is forced onto one line without any borders. It loses
             *    any additional padding.
             *
             * 2. Multi-line without line-numbers adds padding to compensate for the
             *    lack of margin-right that the line-numbers usually add. It has a
             *    border.
             *
             * 3. Multi-line with line-numbers doesn't have the padding, because the
             *    line numbers have margin-right.
             *
             * 4. Any of these can be wrapped with whitespace: pre-wrap. When using
             *    with line-numbers, the breaks will create a new line.
             */
            {
              "wrap": props.wrap,
              "line-numbers": props.lineNumbers,
              "p-[8px]": !props.lineNumbers && !props.codeframe,
              "p-[2px]": props.codeframe
            },
            props.class
          ]),
          onClick: _cache[0] || (_cache[0] = ($event) => __props.copyOnClick ? () => copyCode() : () => {
          }),
          innerHTML: unref(highlightedCode)
        }, null, 10, _hoisted_2$7)) : (openBlock(), createElementBlock("pre", {
          key: 1,
          class: normalizeClass(["border rounded font-normal border-gray-100 py-[8px] text-[14px] leading-[24px] overflow-scroll", [props.class, __props.lineNumbers ? "pl-[56px]" : "pl-[8px]"]])
        }, toDisplayString$1(unref(trimmedCode)), 3)),
        __props.copyButton ? (openBlock(), createBlock(_sfc_main$u, {
          key: 2,
          variant: "outline",
          tabindex: "-1",
          class: normalizeClass(["bg-white ml-auto mt-[-32px] sticky", unref(numberOfLines) === 1 ? "bottom-[5px] right-[5px]" : "bottom-[8px] right-[8px]"]),
          text: __props.code,
          "no-icon": ""
        }, null, 8, ["class", "text"])) : createCommentVNode("", true)
      ]);
    };
  }
});
const ShikiHighlight = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__scopeId", "data-v-d56ab850"]]);
const _hoisted_1$6 = { class: "mt-[24px] mb-[16px] text-[16px] leading-[24px]" };
const _hoisted_2$6 = /* @__PURE__ */ createBaseVNode("code", { class: "border rounded border-gray-200 m-[2px] py-[2px] px-[3px] text-purple-500 text-[16px]" }, "projectId", -1);
const _hoisted_3$5 = /* @__PURE__ */ createBaseVNode("span", { class: "text-indigo-500" }, "cypress.config.js", -1);
const _hoisted_4$4 = { class: "flex gap-[16px]" };
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "NeedManualUpdateModal",
  props: {
    gql: null,
    newProjectId: null
  },
  emits: ["cancel"],
  setup(__props, { emit: emit3 }) {
    const props = __props;
    const { t: t2 } = useI18n();
    gql`
fragment NeedManualUpdateModal on CurrentProject {
  id
  projectId
}`;
    const projectIdCode = computed(() => `projectId: '${props.newProjectId}'`);
    const helpCode = computed(() => {
      return `
export ${"default"} {
  ${projectIdCode.value}, // <- add this line
}`;
    });
    return (_ctx, _cache) => {
      const _component_i18n_t = resolveComponent("i18n-t");
      const _component_i_cy_loading_x16 = __unplugin_components_0$6;
      return openBlock(), createBlock(_sfc_main$o, {
        "model-value": "",
        title: unref(t2)("runs.connect.modal.connectManually.title"),
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => emit3("cancel"))
      }, {
        footer: withCtx(() => [
          createBaseVNode("div", _hoisted_4$4, [
            createVNode(_sfc_main$y, {
              size: "lg",
              variant: "pending"
            }, {
              prefix: withCtx(() => [
                createVNode(_component_i_cy_loading_x16, { class: "animate-spin icon-dark-white icon-light-gray-400" })
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString$1(unref(t2)("runs.connect.modal.connectManually.waitingButton")), 1)
              ]),
              _: 1
            }),
            createVNode(_sfc_main$y, {
              variant: "outline",
              size: "lg",
              onClick: _cache[0] || (_cache[0] = ($event) => emit3("cancel"))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString$1(unref(t2)("runs.connect.modal.cancel")), 1)
              ]),
              _: 1
            })
          ])
        ]),
        default: withCtx(() => [
          createVNode(_sfc_main$i, {
            status: "warning",
            title: unref(t2)("runs.connect.modal.connectManually.warning"),
            icon: unref(WarningIcon),
            "icon-classes": "icon-dark-orange-400"
          }, null, 8, ["title", "icon"]),
          createBaseVNode("p", _hoisted_1$6, [
            createVNode(_component_i18n_t, {
              scope: "global",
              keypath: "runs.connect.modal.connectManually.mainMessage"
            }, {
              projectId: withCtx(() => [
                _hoisted_2$6
              ]),
              configFile: withCtx(() => [
                _hoisted_3$5
              ]),
              _: 1
            })
          ]),
          createVNode(ShikiHighlight, {
            class: "rounded border border-gray-200",
            lang: "javascript",
            code: unref(helpCode),
            "line-numbers": "",
            "copy-button": ""
          }, null, 8, ["code"])
        ]),
        _: 1
      }, 8, ["title"]);
    };
  }
});
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "CloudConnectModals",
  props: {
    gql: null,
    utmMedium: null,
    utmContent: null
  },
  emits: ["success", "cancel"],
  setup(__props, { emit: emit3 }) {
    const props = __props;
    gql`
fragment CloudConnectModals on Query {
  ...SelectCloudProjectModal
  cloudViewer {
    id
    ...CreateCloudOrgModal
    firstOrganization: organizations(first: 1) {
      nodes {
        id
      }
    }
  }
  currentProject{
    id
    ...NeedManualUpdateModal
  }
}
`;
    gql`
subscription CloudConnectModals_MonitorCloudViewer {
  cloudViewerChange {
    ...CloudConnectModals
  }
}
`;
    useSubscription({ query: CloudConnectModals_MonitorCloudViewerDocument });
    const newProjectId = ref("");
    const isManualUpdateOpen = ref(false);
    function showManualUpdate(projectId) {
      newProjectId.value = projectId;
      isManualUpdateOpen.value = true;
    }
    return (_ctx, _cache) => {
      var _a2, _b2;
      return isManualUpdateOpen.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        props.gql.currentProject ? (openBlock(), createBlock(_sfc_main$e, {
          key: 0,
          gql: props.gql.currentProject,
          "new-project-id": newProjectId.value,
          onCancel: _cache[0] || (_cache[0] = ($event) => emit3("cancel"))
        }, null, 8, ["gql", "new-project-id"])) : createCommentVNode("", true)
      ], 64)) : ((_b2 = (_a2 = props.gql.cloudViewer) == null ? void 0 : _a2.organizations) == null ? void 0 : _b2.nodes.length) ?? 0 > 0 ? (openBlock(), createBlock(_sfc_main$h, {
        key: 1,
        gql: props.gql,
        show: "",
        "utm-medium": props.utmMedium,
        "utm-content": props.utmContent,
        onUpdateProjectIdFailed: showManualUpdate,
        onSuccess: _cache[1] || (_cache[1] = ($event) => emit3("success")),
        onCancel: _cache[2] || (_cache[2] = ($event) => emit3("cancel"))
      }, null, 8, ["gql", "utm-medium", "utm-content"])) : props.gql.cloudViewer ? (openBlock(), createBlock(_sfc_main$g, {
        key: 2,
        gql: props.gql.cloudViewer,
        onCancel: _cache[3] || (_cache[3] = ($event) => emit3("cancel"))
      }, null, 8, ["gql"])) : createCommentVNode("", true);
    };
  }
});
const _hoisted_1$5 = {
  style: { "min-width": "16px", "min-height": "16px" },
  width: "16",
  height: "16",
  viewBox: "0 0 16 16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$5 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M15 3C15 1.89543 14.1046 1 13 1H3C1.89543 1 1 1.89543 1 3V4H15V3Z",
  fill: "#D0D2E0",
  class: "icon-light"
}, null, -1);
const _hoisted_3$4 = /* @__PURE__ */ createBaseVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M15 3C15 1.89543 14.1046 1 13 1H3C1.89543 1 1 1.89543 1 3V4H15V3Z",
  fill: "#D0D2E0",
  class: "icon-light"
}, null, -1);
const _hoisted_4$3 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M1 4V13C1 14.1046 1.89543 15 3 15H13C14.1046 15 15 14.1046 15 13V4M1 4V3C1 1.89543 1.89543 1 3 1H13C14.1046 1 15 1.89543 15 3V4M1 4H15M5 8L6.5 9.5L5 11",
  stroke: "#1B1E2E",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  class: "icon-dark"
}, null, -1);
const _hoisted_5$2 = [
  _hoisted_2$5,
  _hoisted_3$4,
  _hoisted_4$3
];
function render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5, _hoisted_5$2);
}
const IconTerminal = { name: "cy-terminal_x16", render };
const _hoisted_1$4 = { class: "border rounded flex font-normal border-gray-100 pl-[16px] pr-[4px] text-gray-700 leading-[40px] items-center whitespace-nowrap overflow-hidden" };
const _hoisted_2$4 = /* @__PURE__ */ createBaseVNode("span", { class: "mr-[8px] text-purple-500" }, " $ ", -1);
const _hoisted_3$3 = ["value"];
const _hoisted_4$2 = { class: "font-sans" };
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "TerminalPrompt",
  props: {
    command: null
  },
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_i_cy_terminal_x16 = IconTerminal;
      return openBlock(), createElementBlock("code", _hoisted_1$4, [
        createVNode(_component_i_cy_terminal_x16, { class: "shrink-0 h-[16px] mr-[8px] w-[16px] icon-dark-gray-500 icon-light-gray-100" }),
        _hoisted_2$4,
        createBaseVNode("input", {
          readonly: "true",
          type: "text",
          value: __props.command,
          "data-cy": "terminal-prompt-input",
          class: "border-none flex-1",
          "aria-label": "Terminal command"
        }, null, 8, _hoisted_3$3),
        createBaseVNode("div", _hoisted_4$2, [
          createVNode(_sfc_main$u, { text: __props.command }, null, 8, ["text"])
        ])
      ]);
    };
  }
});
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "RecordPrompt",
  props: {
    recordKey: null,
    currentTestingType: null
  },
  setup(__props) {
    const props = __props;
    const firstRecordKey = computed(() => {
      return props.recordKey ?? "<record-key>";
    });
    const recordCommand = computed(() => {
      const componentFlagOrSpace = props.currentTestingType === "component" ? " --component " : " ";
      return `npx cypress run${componentFlagOrSpace}--record --key ${firstRecordKey.value}`;
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$c, {
        command: unref(recordCommand),
        class: "bg-white max-w-[900px]"
      }, null, 8, ["command"]);
    };
  }
});
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "RecordPromptAdapter",
  setup(__props) {
    gql`
query RecordPromptAdapter {
  currentProject {
    id
    title
    currentTestingType
    cloudProject {
      __typename
      ... on CloudProject {
        id
        recordKeys {
          id
          key
        }
      }
    }
  }
}
`;
    const query2 = useQuery({ query: RecordPromptAdapterDocument });
    return (_ctx, _cache) => {
      var _a2, _b2, _c, _d, _e, _f, _g, _h;
      return openBlock(), createBlock(_sfc_main$b, {
        "record-key": ((_c = (_b2 = (_a2 = unref(query2).data.value) == null ? void 0 : _a2.currentProject) == null ? void 0 : _b2.cloudProject) == null ? void 0 : _c.__typename) === "CloudProject" ? (_f = (_e = (_d = unref(query2).data.value) == null ? void 0 : _d.currentProject.cloudProject.recordKeys) == null ? void 0 : _e[0]) == null ? void 0 : _f.key : "",
        "current-testing-type": (_h = (_g = unref(query2).data.value) == null ? void 0 : _g.currentProject) == null ? void 0 : _h.currentTestingType
      }, null, 8, ["record-key", "current-testing-type"]);
    };
  }
});
const getUrlWithParams = (link2) => {
  let result = link2.url;
  const paramNames = Object.keys(link2.params);
  if (paramNames.length > 0) {
    const hasUtmParams = paramNames.some((param) => param.startsWith("utm_"));
    if (hasUtmParams) {
      link2.params.utm_source = getUtmSource();
    }
    let url2;
    let searchParams;
    if (link2.url.includes("?")) {
      url2 = link2.url.substring(0, link2.url.indexOf("?"));
      searchParams = new URLSearchParams(link2.url.substring(link2.url.indexOf("?")));
    } else {
      url2 = link2.url;
      searchParams = new URLSearchParams();
    }
    Object.entries(link2.params).forEach(([key, value]) => searchParams.append(key, value));
    result = `${url2}?${searchParams.toString()}`;
  }
  return result;
};
const units = {};
units.second = 1e3;
units.minute = units.second * 60;
units.hour = units.minute * 60;
units.day = units.hour * 24;
units.week = units.day * 7;
units.month = units.day * 30;
units.year = units.day * 365;
const languageMap = {
  one: 1,
  two: 2,
  three: 3,
  four: 4,
  five: 5,
  six: 6,
  seven: 7,
  eight: 8,
  nine: 9,
  ten: 10
};
const swapLanguageToDecimals = (time) => {
  const language = languageMap;
  const languageMapRegex = new RegExp("(" + Object.keys(language).join("|") + ")", "g");
  const matches2 = time.match(languageMapRegex);
  if (!matches2) {
    return time;
  }
  matches2.forEach((match2) => {
    const matchStr = language[match2] > 1 ? language[match2] : language[match2].toString().slice(1);
    time = time.replace(match2, matchStr);
  });
  return time;
};
const processUnits = (time) => {
  if (time.match(/(second|minute|hour|day|week|month|year)s?/) === null) {
    return void 0;
  }
  const num = parseFloat(time, 10) || 1;
  const unit = time.match(/(second|minute|hour|day|week|month|year)s?/)[1];
  return units[unit] * num;
};
const humanInterval = (time) => {
  if (!time) {
    return time;
  }
  if (typeof time === "number") {
    return time;
  }
  time = swapLanguageToDecimals(time);
  time = time.replace(/(second|minute|hour|day|week|month|year)s?(?! ?(s )?and |s?$)/, "$1,");
  return time.split(/and|,/).reduce((sum, group) => {
    return sum + (group ? processUnits(group) : 0);
  }, 0);
};
humanInterval.languageMap = languageMap;
var humanInterval_1 = humanInterval;
const interval = /* @__PURE__ */ getDefaultExportFromCjs(humanInterval_1);
const BANNER_ID_BY_STATE = {
  isLoggedOut: BannerIds.ACI_082022_LOGIN,
  needsOrgConnect: BannerIds.ACI_082022_CREATE_ORG,
  needsProjectConnect: BannerIds.ACI_082022_CONNECT_PROJECT,
  needsRecordedRun: BannerIds.ACI_082022_RECORD,
  isComponentTestingCandidate: BannerIds.CT_052023_AVAILABLE
};
const minTimeSinceEvent = (eventTime, waitTime) => {
  if (!eventTime) {
    return true;
  }
  const waitTimestamp = interval(waitTime.toLocaleLowerCase());
  if (isNaN(waitTimestamp)) {
    throw new Error(`incorrect format for waitTime provided, value must be \`n days\`, \`n minutes\` etc. Value received was ${waitTime}`);
  }
  return Date.now() - eventTime > waitTimestamp;
};
const isAllowedFeature = (featureName, userProjectStatusStore, state = "allTasksCompleted") => {
  const {
    cypressFirstOpened,
    promptsShown,
    latestBannerShownTime,
    bannersState,
    project
  } = userProjectStatusStore;
  const events2 = {
    cypressFirstOpened,
    navCiPromptAutoOpened: promptsShown.ci1,
    loginModalRecordPromptShown: promptsShown.loginModalRecord,
    latestSmartBannerShown: latestBannerShownTime
  };
  function bannerForCurrentStatusWasNotDismissed() {
    var _a2;
    if (!state) {
      return true;
    }
    const bannerId = BANNER_ID_BY_STATE[state];
    if (!bannerId) {
      return true;
    }
    return !((_a2 = bannersState == null ? void 0 : bannersState[bannerId]) == null ? void 0 : _a2.dismissed);
  }
  function noOtherSmartBannerShownWithin(interval2) {
    const currentBannerId = BANNER_ID_BY_STATE[state];
    return Object.entries(BannerIds).map(([_2, bannerId]) => bannerId).filter((bannerId) => bannerId !== currentBannerId).map((bannerId) => {
      var _a2;
      return (_a2 = bannersState[bannerId]) == null ? void 0 : _a2.dismissed;
    }).every((bannerDismissed) => minTimeSinceEvent(bannerDismissed, interval2));
  }
  function bannersAreNotDisabledForTesting() {
    return !(bannersState == null ? void 0 : bannersState._disabled);
  }
  const rules = {
    specsListBanner: {
      base: [
        minTimeSinceEvent(events2.cypressFirstOpened, "4 days"),
        minTimeSinceEvent(events2.navCiPromptAutoOpened, "1 day"),
        bannerForCurrentStatusWasNotDismissed(),
        bannersAreNotDisabledForTesting()
      ],
      needsRecordedRun: [
        minTimeSinceEvent(events2.loginModalRecordPromptShown, "1 day"),
        project.hasNonExampleSpec
      ],
      needsOrgConnect: [],
      needsProjectConnect: [],
      isLoggedOut: [],
      isComponentTestingCandidate: [
        noOtherSmartBannerShownWithin("2 days")
      ]
    },
    docsCiPrompt: {
      base: [
        minTimeSinceEvent(events2.cypressFirstOpened, "4 days"),
        minTimeSinceEvent(events2.latestSmartBannerShown, "1 day")
      ],
      needsRecordedRun: [],
      needsOrgConnect: [],
      needsProjectConnect: [],
      isLoggedOut: [],
      allTasksCompleted: [],
      isComponentTestingCandidate: []
    }
  };
  const baseRules = [...rules[featureName].base];
  const statusSpecificRules = (state && rules[featureName][state]) ?? [false];
  const rulesToCheck = baseRules.concat(statusSpecificRules);
  return rulesToCheck.every((rule) => rule === true);
};
gql`
mutation UsePromptManager_SetProjectPreferences($value: String!) {
  setPreferences(type: project, value: $value) {
    currentProject {
      id
      savedState
    }
  }
}
`;
gql`
mutation UsePromptManager_SetGlobalPreferences($value: String!) {
  setPreferences(type: global, value: $value) {
    localSettings {
      preferences {
        majorVersionWelcomeDismissed
      }
    }
  }
}
`;
function usePromptManager() {
  const setProjectPreferencesMutation = useMutation(UsePromptManager_SetProjectPreferencesDocument);
  const setGlobalPreferencesMutation = useMutation(UsePromptManager_SetGlobalPreferencesDocument);
  const userProjectStatusStore = useUserProjectStatusStore();
  function setPromptShown(slug) {
    return setProjectPreferencesMutation.executeMutation({ value: JSON.stringify({ promptsShown: { [slug]: Date.now() } }) });
  }
  function setMajorVersionWelcomeDismissed(majorVersion) {
    return setGlobalPreferencesMutation.executeMutation({ value: JSON.stringify({ majorVersionWelcomeDismissed: { [majorVersion]: Date.now() } }) });
  }
  const wrappedIsAllowedFeature = (featureName, state) => {
    return isAllowedFeature(featureName, userProjectStatusStore, state);
  };
  const getEffectiveBannerState = (featureName) => {
    const cloudStatus = userProjectStatusStore.cloudStatus;
    const projectStatus = userProjectStatusStore.projectStatus;
    if (featureName === "specsListBanner") {
      if (cloudStatus !== "allTasksCompleted" && wrappedIsAllowedFeature("specsListBanner", cloudStatus)) {
        return cloudStatus;
      }
      if (projectStatus !== "allTasksCompleted" && wrappedIsAllowedFeature("specsListBanner", projectStatus)) {
        return projectStatus;
      }
    }
    return null;
  };
  return {
    setPromptShown,
    isAllowedFeature: wrappedIsAllowedFeature,
    setMajorVersionWelcomeDismissed,
    getEffectiveBannerState
  };
}
const _hoisted_1$3 = { class: "max-w-[43.75rem] py-7 px-6 text-gray-600" };
const _hoisted_2$3 = { class: "mb-[24px]" };
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "RecordRunModal",
  props: {
    utmMedium: null,
    utmContent: null
  },
  emits: ["cancel"],
  setup(__props, { emit: emit3 }) {
    const props = __props;
    const { setPromptShown } = usePromptManager();
    onMounted(() => {
      setPromptShown("loginModalRecord");
    });
    const { t: t2 } = useI18n();
    const isModalOpen = ref(true);
    const helpLink = getUrlWithParams({
      url: "https://on.cypress.io/cypress-run-record-key",
      params: {
        utm_medium: props.utmMedium,
        utm_source: getUtmSource(),
        utm_content: props.utmContent || ""
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$o, {
        class: "transition transition-all duration-200",
        variant: "bare",
        title: unref(t2)("specPage.banners.record.title"),
        "model-value": isModalOpen.value,
        "help-link": unref(helpLink),
        "no-help": !unref(helpLink),
        "data-cy": "record-run-modal",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => emit3("cancel"))
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$3, [
            createBaseVNode("p", _hoisted_2$3, toDisplayString$1(unref(t2)("specPage.banners.record.content")), 1),
            createVNode(_sfc_main$a)
          ])
        ]),
        _: 1
      }, 8, ["title", "model-value", "help-link", "no-help"]);
    };
  }
});
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "LoginConnectModalsContent",
  props: {
    gql: null
  },
  setup(__props) {
    const props = __props;
    gql`
fragment LoginConnectModalsContent on Query {
  ...LoginModal
  ...CloudConnectModals
  currentProject {
    id
    currentTestingType
  }
}
`;
    const userProjectStatusStore = useUserProjectStatusStore();
    const { closeLoginConnectModal, cloudStatusMatches } = userProjectStatusStore;
    const keepLoginOpen = ref(false);
    watch(() => userProjectStatusStore.cloudStatus, (newVal, oldVal) => {
      if (oldVal === "isLoggedOut" && newVal !== "isLoggedOut") {
        keepLoginOpen.value = true;
      }
    }, {
      immediate: true
    });
    const handleCloseLogin = () => {
      if (cloudStatusMatches("allTasksCompleted")) {
        closeLoginConnectModal();
      } else {
        keepLoginOpen.value = false;
      }
    };
    const gqlRef = ref(null);
    debouncedWatch(() => props.gql, (newVal) => {
      if (newVal) {
        gqlRef.value = newVal;
      }
    }, {
      debounce: 10,
      immediate: true
    });
    return (_ctx, _cache) => {
      return unref(userProjectStatusStore).isLoginConnectOpen && gqlRef.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        unref(cloudStatusMatches)("isLoggedOut") || keepLoginOpen.value ? (openBlock(), createBlock(_sfc_main$r, {
          key: 0,
          gql: gqlRef.value,
          "utm-medium": unref(userProjectStatusStore).utmMedium,
          "utm-content": unref(userProjectStatusStore).utmContent,
          onCancel: unref(closeLoginConnectModal),
          onClose: handleCloseLogin
        }, null, 8, ["gql", "utm-medium", "utm-content", "onCancel"])) : unref(cloudStatusMatches)("needsRecordedRun") ? (openBlock(), createBlock(_sfc_main$9, {
          key: 1,
          "utm-medium": unref(userProjectStatusStore).utmMedium,
          "utm-content": unref(userProjectStatusStore).utmContent,
          onCancel: unref(closeLoginConnectModal)
        }, null, 8, ["utm-medium", "utm-content", "onCancel"])) : unref(cloudStatusMatches)("needsProjectConnect") || unref(cloudStatusMatches)("needsOrgConnect") ? (openBlock(), createBlock(_sfc_main$d, {
          key: 2,
          show: unref(userProjectStatusStore).user.isLoggedIn,
          gql: gqlRef.value,
          "utm-medium": unref(userProjectStatusStore).utmMedium,
          "utm-content": unref(userProjectStatusStore).utmContent,
          onCancel: unref(closeLoginConnectModal),
          onSuccess: unref(closeLoginConnectModal)
        }, null, 8, ["show", "gql", "utm-medium", "utm-content", "onCancel", "onSuccess"])) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true);
    };
  }
});
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "LoginConnectModals",
  setup(__props) {
    const userProjectStatusStore = useUserProjectStatusStore();
    gql`
query LoginConnectModals_LoginConnectModalsQuery {
  ...LoginConnectModalsContent
}
`;
    const query2 = useQuery({ query: LoginConnectModals_LoginConnectModalsQueryDocument, pause: true });
    const executeQuery = async () => {
      await query2.executeQuery();
    };
    whenever(() => userProjectStatusStore.isLoginConnectOpen, executeQuery);
    return (_ctx, _cache) => {
      return unref(userProjectStatusStore).isLoginConnectOpen ? (openBlock(), createBlock(_sfc_main$8, {
        key: 0,
        gql: unref(query2).data.value
      }, null, 8, ["gql"])) : createCommentVNode("", true);
    };
  }
});
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "CloudViewerAndProject",
  setup(__props) {
    gql`
fragment CloudViewerAndProject on Query {
  cloudViewer {
    id
    fullName
    email
    firstOrganization: organizations(first: 1) {
      nodes {
        id
      }
    }
  }
  cachedUser {
    id
    fullName
    email
  }
  authState {
    name
  }
  currentProject {
    id
    projectId
    config
    currentTestingType
    isFullConfigReady
    isCTConfigured
    hasNonExampleSpec
    savedState
    branch
    cloudProject {
      __typename
      ... on CloudProject {
        id
        runs(first: 10) {
          nodes {
            id
            status
            url
          }
        }
      }
    }
  }
  wizard {
    framework {
      id
      name
      icon
      isDetected
    }
  }
}
`;
    gql`
query CloudViewerAndProject_RequiredData {
  ...CloudViewerAndProject
}
`;
    gql`
subscription CloudViewerAndProject_CheckCloudOrgMembership {
  cloudViewerChange {
    ...CloudViewerAndProject
  }
}
`;
    gql`
mutation CloudViewerAndProject_DetectCtFrameworks {
  initializeCtFrameworks
}
`;
    const hasDetectedFrameworks = ref(false);
    const userProjectStatusStore = useUserProjectStatusStore();
    const {
      setHasInitiallyLoaded,
      setUserFlag,
      setProjectFlag,
      setUserData,
      setPromptShown,
      setCypressFirstOpened,
      setTestingType,
      setProjectId,
      setBannersState
    } = userProjectStatusStore;
    useSubscription({ query: CloudViewerAndProject_CheckCloudOrgMembershipDocument });
    const query2 = useQuery({ query: CloudViewerAndProject_RequiredDataDocument });
    const detectCtFrameworks = useMutation(CloudViewerAndProject_DetectCtFrameworksDocument);
    watchEffect(async () => {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      if (!query2.data.value) {
        return;
      }
      if (!hasDetectedFrameworks.value && ((_a2 = query2.data.value.currentProject) == null ? void 0 : _a2.currentTestingType) === "e2e") {
        await detectCtFrameworks.executeMutation({});
        hasDetectedFrameworks.value = true;
        return;
      }
      setHasInitiallyLoaded();
      const {
        currentProject,
        cachedUser,
        cloudViewer,
        authState,
        wizard
      } = query2.data.value;
      const savedState = currentProject == null ? void 0 : currentProject.savedState;
      if (savedState == null ? void 0 : savedState.promptsShown) {
        for (const item in savedState.promptsShown) {
          setPromptShown(item, savedState.promptsShown[item]);
        }
      }
      if (savedState == null ? void 0 : savedState.firstOpened) {
        setCypressFirstOpened(savedState.firstOpened);
      }
      if (savedState == null ? void 0 : savedState.banners) {
        setBannersState(savedState.banners);
      }
      setTestingType((currentProject == null ? void 0 : currentProject.currentTestingType) ?? void 0);
      setProjectId((currentProject == null ? void 0 : currentProject.projectId) ?? void 0);
      const AUTH_STATE_ERRORS = ["AUTH_COULD_NOT_LAUNCH_BROWSER", "AUTH_ERROR_DURING_LOGIN", "AUTH_COULD_NOT_LAUNCH_BROWSER"];
      setUserData(cloudViewer ?? cachedUser ?? void 0);
      setUserFlag("isLoggedIn", !!(cachedUser == null ? void 0 : cachedUser.id) || !!(cloudViewer == null ? void 0 : cloudViewer.id));
      setUserFlag("loginError", AUTH_STATE_ERRORS.includes((authState == null ? void 0 : authState.name) ?? ""));
      if (cloudViewer) {
        setUserFlag("isOrganizationLoaded", !!cloudViewer.firstOrganization);
        setUserFlag("isMemberOfOrganization", (((_c = (_b2 = cloudViewer.firstOrganization) == null ? void 0 : _b2.nodes) == null ? void 0 : _c.length) ?? 0) > 0);
      }
      setProjectFlag("isConfigLoaded", !!(currentProject == null ? void 0 : currentProject.isFullConfigReady));
      setProjectFlag("isNotAuthorized", ((_d = currentProject == null ? void 0 : currentProject.cloudProject) == null ? void 0 : _d.__typename) === "CloudProjectUnauthorized");
      setProjectFlag("isNotFound", ((_e = currentProject == null ? void 0 : currentProject.cloudProject) == null ? void 0 : _e.__typename) === "CloudProjectNotFound");
      setProjectFlag("hasNonExampleSpec", !!(currentProject == null ? void 0 : currentProject.hasNonExampleSpec));
      setProjectFlag("hasNoRecordedRuns", ((_f = currentProject == null ? void 0 : currentProject.cloudProject) == null ? void 0 : _f.__typename) === "CloudProject" && (((_i = (_h = (_g = currentProject.cloudProject) == null ? void 0 : _g.runs) == null ? void 0 : _h.nodes) == null ? void 0 : _i.length) ?? 0) === 0);
      if ((currentProject == null ? void 0 : currentProject.cloudProject) || !userProjectStatusStore.user.isLoggedIn) {
        setProjectFlag("isProjectConnected", ((_j = currentProject == null ? void 0 : currentProject.cloudProject) == null ? void 0 : _j.__typename) === "CloudProject");
      }
      setProjectFlag("isCTConfigured", !!(currentProject == null ? void 0 : currentProject.isCTConfigured));
      setProjectFlag("hasDetectedCtFramework", ((_k = wizard == null ? void 0 : wizard.framework) == null ? void 0 : _k.isDetected) ?? false);
      setProjectFlag("isUsingGit", !!(currentProject == null ? void 0 : currentProject.branch));
    });
    return () => {
    };
  }
});
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_router_view = resolveComponent("router-view");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_component_router_view, null, {
          default: withCtx(({ Component }) => [
            (openBlock(), createBlock(resolveDynamicComponent(Component)))
          ]),
          _: 1
        }),
        !unref(isRunMode) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createVNode(_sfc_main$6),
          createVNode(_sfc_main$7)
        ], 64)) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const scriptRel = "modulepreload";
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.all(deps.map((dep) => {
      dep = assetsURL(dep, importerUrl);
      if (dep in seen)
        return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      const isBaseRelative = !!importerUrl;
      if (isBaseRelative) {
        for (let i = links.length - 1; i >= 0; i--) {
          const link3 = links[i];
          if (link3.href === dep && (!isCss || link3.rel === "stylesheet")) {
            return;
          }
        }
      } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
        return;
      }
      const link2 = document.createElement("link");
      link2.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) {
        link2.as = "script";
        link2.crossOrigin = "";
      }
      link2.href = dep;
      if (cspNonce) {
        link2.setAttribute("nonce", cspNonce);
      }
      document.head.appendChild(link2);
      if (isCss) {
        return new Promise((res, rej) => {
          link2.addEventListener("load", res);
          link2.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
        });
      }
    }));
  }
  return promise.then(() => baseModule()).catch((err) => {
    const e = new Event("vite:preloadError", { cancelable: true });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  });
};
const __pages_import_0__ = () => __vitePreload(() => import("./Specs-CQNWz6Iy.js"), true ? __vite__mapDeps([0,1]) : void 0, import.meta.url);
const __pages_import_1__ = () => __vitePreload(() => import("./Runner-B9rX-Bu-.js"), true ? __vite__mapDeps([2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,17,18]) : void 0, import.meta.url);
const __pages_import_2__ = () => __vitePreload(() => import("./Index-C5YeVnOn.js"), true ? __vite__mapDeps([19,20,3,4,5,6,7,8,9,10,11,12,21,17,22,23,24,25,1,26]) : void 0, import.meta.url);
const __pages_import_3__ = () => __vitePreload(() => import("./Settings-y4LfxyMT.js"), true ? __vite__mapDeps([27,11,3,4,28,9,10,29,30,13,21,24,31,17,32]) : void 0, import.meta.url);
const __pages_import_4__ = () => __vitePreload(() => import("./Runs-0650BlSr.js"), true ? __vite__mapDeps([33,29,30,23,3,4,34,21,35,16,28,15,20,25,36]) : void 0, import.meta.url);
const __pages_import_5__ = () => __vitePreload(() => import("./Debug-CPwXVzhh.js"), true ? __vite__mapDeps([37,22,38,34,21,23,3,4,35,17,8,11,16,29,30,25,39]) : void 0, import.meta.url);
const __pages_import_6__ = () => __vitePreload(() => import("./_...all_-DRL1mQ2q.js"), true ? __vite__mapDeps([40,1]) : void 0, import.meta.url);
const routes = [{ "path": "/specs", "component": __pages_import_0__, "children": [{ "name": "SpecRunner", "path": "runner", "component": __pages_import_1__, "props": true, "meta": { "header": false, "navBarExpandedAllowed": false } }, { "name": "Specs", "path": "", "component": __pages_import_2__, "props": true }], "props": true, "meta": { "default": true } }, { "name": "Settings", "path": "/settings", "component": __pages_import_3__, "props": true }, { "name": "Runs", "path": "/runs", "component": __pages_import_4__, "props": true }, { "name": "Debug", "path": "/debug", "component": __pages_import_5__, "props": true }, { "name": "all", "path": "/:all(.*)*", "component": __pages_import_6__, "props": true, "meta": { "title": "404" } }];
const setupLayouts = (routes2) => {
  const layouts = {};
  const modules = /* @__PURE__ */ Object.assign({ "/src/layouts/default.vue": () => __vitePreload(() => import("./default-BIPJivEf.js"), true ? __vite__mapDeps([41,38,14,3,4,30,35,6,7,28,16,10,11,25,31,21,42]) : void 0, import.meta.url) });
  Object.entries(modules).forEach(([name2, module]) => {
    let key = name2.replace("/src/layouts/", "").replace(".vue", "");
    layouts[key] = module;
  });
  function deepSetupLayout(routes3, top2 = true) {
    return routes3.map((route) => {
      var _a2, _b2, _c, _d, _e, _f;
      if (((_a2 = route.children) == null ? void 0 : _a2.length) > 0) {
        route.children = deepSetupLayout(route.children, false);
      }
      if (top2) {
        const skipLayout = !route.component && ((_b2 = route.children) == null ? void 0 : _b2.find((r2) => {
          var _a3;
          return (r2.path === "" || r2.path === "/") && ((_a3 = r2.meta) == null ? void 0 : _a3.isLayout);
        }));
        if (skipLayout) {
          return route;
        }
        if (((_c = route.meta) == null ? void 0 : _c.layout) !== false) {
          return {
            path: route.path,
            component: layouts[((_d = route.meta) == null ? void 0 : _d.layout) || "default"],
            children: route.path === "/" ? [route] : [{ ...route, path: "" }],
            meta: {
              isLayout: true
            }
          };
        }
      }
      if ((_e = route.meta) == null ? void 0 : _e.layout) {
        return {
          path: route.path,
          component: layouts[(_f = route.meta) == null ? void 0 : _f.layout],
          children: [{ ...route, path: "" }],
          meta: {
            isLayout: true
          }
        };
      }
      return route;
    });
  }
  return deepSetupLayout(routes2);
};
const createRouter = () => {
  const routes$1 = setupLayouts(routes);
  const defaultRoute = routes.find((route) => {
    var _a2;
    return (_a2 = route.meta) == null ? void 0 : _a2.default;
  });
  if (defaultRoute) {
    routes$1.push({
      path: "/",
      redirect: defaultRoute.path
    });
  }
  routes$1.push({
    path: "/redirect",
    redirect: (from) => {
      if (from.query.name) {
        if (typeof from.query.name !== "string") {
          throw new Error(`name should be a single string but got: ${from.query.name}`);
        }
        let params = {};
        if (from.query.params) {
          if (typeof from.query.params !== "string") {
            throw new Error(`params should be a string but got: ${from.query.params}`);
          }
          try {
            params = JSON.parse(from.query.params);
          } catch {
            throw new Error(`params was not valid JSON: ${from.query.params}`);
          }
        }
        return {
          name: from.query.name,
          params,
          query: {}
          //reset query params so they do not get passed on
        };
      }
      return { path: "/" };
    }
  });
  return createRouter$1({
    history: createWebHashHistory(),
    routes: routes$1
  });
};
const pDefer = () => {
  const deferred = {};
  deferred.promise = new Promise((resolve3, reject) => {
    deferred.resolve = resolve3;
    deferred.reject = reject;
  });
  return deferred;
};
var pDefer_1 = pDefer;
const pDefer$1 = /* @__PURE__ */ getDefaultExportFromCjs(pDefer_1);
const dfd = pDefer$1();
function injectBundle(namespace) {
  const script2 = document.createElement("script");
  script2.src = `/${namespace}/runner/cypress_runner.js`;
  script2.type = "text/javascript";
  const link2 = document.createElement("link");
  link2.rel = "stylesheet";
  link2.href = `/${namespace}/runner/cypress_runner.css`;
  script2.onload = () => {
    dfd.resolve();
  };
  document.head.appendChild(script2);
  document.head.appendChild(link2);
}
const useSpecStore = defineStore({
  id: "spec",
  state() {
    return {
      activeSpec: void 0,
      specFilter: void 0,
      testFilter: void 0
    };
  },
  actions: {
    setActiveSpec(activeSpec) {
      this.activeSpec = activeSpec;
    },
    setSpecFilter(filter) {
      this.specFilter = filter;
    },
    setTestFilter(filter) {
      this.testFilter = filter;
    }
  }
});
const useAutStore = defineStore({
  id: "aut-store",
  state: () => {
    const defaultViewportHeight = window.__CYPRESS_TESTING_TYPE__ === "e2e" ? 660 : 500;
    const defaultViewportWidth = window.__CYPRESS_TESTING_TYPE__ === "e2e" ? 1e3 : 500;
    return {
      isLoadingUrl: false,
      highlightUrl: false,
      url: void 0,
      viewportHeight: defaultViewportHeight,
      viewportWidth: defaultViewportWidth,
      defaultViewportHeight,
      defaultViewportWidth,
      isLoading: false,
      isRunning: false,
      viewportUpdateCallback: null,
      scriptError: null,
      scale: 1,
      specRunnerHeaderHeight: 64
    };
  },
  actions: {
    setHighlightUrl(highlightUrl) {
      this.highlightUrl = highlightUrl;
    },
    updateUrl(url2) {
      this.url = url2;
    },
    updateDimensions(viewportWidth, viewportHeight) {
      this.viewportHeight = viewportHeight;
      this.viewportWidth = viewportWidth;
    },
    setViewportUpdatedCallback(cb) {
      this.viewportUpdateCallback = cb;
    },
    setIsLoadingUrl(isLoadingUrl) {
      this.isLoadingUrl = isLoadingUrl;
    },
    setIsRunning(isRunning) {
      this.isRunning = isRunning;
    },
    setIsLoading(isLoading) {
      this.isLoading = isLoading;
    },
    resetUrl() {
      this.url = void 0;
      this.highlightUrl = false;
      this.isLoadingUrl = false;
    },
    setScriptError(err) {
      this.scriptError = err;
    },
    setScale(scale) {
      this.scale = scale;
    },
    setSpecRunnerHeaderHeight(height) {
      this.specRunnerHeaderHeight = height;
    }
  },
  getters: {
    viewportDimensions(state) {
      return {
        height: state.viewportHeight,
        width: state.viewportWidth
      };
    }
  }
});
const runnerConstants = {
  defaultSpecListWidth: 280,
  defaultReporterWidth: 450,
  preferredMinimumPanelWidth: 200,
  absoluteAutMinimum: 100,
  absoluteSpecListMinimum: 50,
  absoluteReporterMinimum: 50,
  collapsedNavBarWidth: 64
};
const automation = {
  CONNECTING: "CONNECTING",
  MISSING: "MISSING",
  CONNECTED: "CONNECTED",
  DISCONNECTED: "DISCONNECTED"
};
const useRunnerUiStore = defineStore({
  id: "runner-ui",
  state() {
    return {
      showChooseExternalEditorModal: false,
      autoScrollingEnabled: true,
      isSpecsListOpen: false,
      specListWidth: runnerConstants.defaultSpecListWidth,
      reporterWidth: runnerConstants.defaultReporterWidth,
      automationStatus: automation.CONNECTING,
      randomString: `${Math.random()}`,
      hideCommandLog: window.__CYPRESS_CONFIG__.hideCommandLog,
      hideRunnerUi: window.__CYPRESS_CONFIG__.hideRunnerUi
    };
  },
  actions: {
    setAutomationStatus(status) {
      this.automationStatus = status;
    },
    setShowChooseExternalEditorModal(value) {
      this.showChooseExternalEditorModal = value;
    },
    setPreference(preference, value) {
      this.$state[preference] = value;
    }
  }
});
let nanoid = (size2 = 21) => crypto.getRandomValues(new Uint8Array(size2)).reduce((id2, byte) => {
  byte &= 63;
  if (byte < 36) {
    id2 += byte.toString(36);
  } else if (byte < 62) {
    id2 += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id2 += "-";
  } else {
    id2 += "_";
  }
  return id2;
}, "");
var define_process_env_default$2 = { CYPRESS_INTERNAL_ENV: "development", NODE_ENV: "production" };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d22, b22) {
    d22.__proto__ = b22;
  } || function(d22, b22) {
    for (var p2 in b22)
      if (b22.hasOwnProperty(p2))
        d22[p2] = b22[p2];
  };
  return extendStatics(d2, b2);
};
function __extends$6(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$3 = function() {
  __assign$3 = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
function __values$6(o2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator], i = 0;
  if (m2)
    return m2.call(o2);
  return {
    next: function() {
      if (o2 && i >= o2.length)
        o2 = void 0;
      return { value: o2 && o2[i++], done: !o2 };
    }
  };
}
function __read$f(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read$f(arguments[i]));
  return ar;
}
var OBFUSCATED_ERROR = "An invariant failed, however the error is obfuscated because this is a production build.";
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
function getNextId() {
  return ++globalState.mobxGuid;
}
function fail(message) {
  invariant(false, message);
  throw "X";
}
function invariant(check, message) {
  if (!check)
    throw new Error("[mobx] " + (message || OBFUSCATED_ERROR));
}
function once$1(func) {
  var invoked = false;
  return function() {
    if (invoked)
      return;
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop$1 = function() {
};
function unique(list) {
  var res = [];
  list.forEach(function(item) {
    if (res.indexOf(item) === -1)
      res.push(item);
  });
  return res;
}
function isObject$1(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject$1(value) {
  if (value === null || typeof value !== "object")
    return false;
  var proto = Object.getPrototypeOf(value);
  return proto === Object.prototype || proto === null;
}
function addHiddenProp(object2, propName, value) {
  Object.defineProperty(object2, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp(object2, propName, value) {
  Object.defineProperty(object2, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function isPropertyConfigurable(object2, prop) {
  var descriptor = Object.getOwnPropertyDescriptor(object2, prop);
  return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;
}
function createInstanceofPredicate(name2, clazz) {
  var propName = "isMobX" + name2;
  clazz.prototype[propName] = true;
  return function(x2) {
    return isObject$1(x2) && x2[propName] === true;
  };
}
function isES6Map(thing) {
  return thing instanceof Map;
}
function isES6Set(thing) {
  return thing instanceof Set;
}
function getPlainObjectKeys(object2) {
  var enumerables = /* @__PURE__ */ new Set();
  for (var key in object2)
    enumerables.add(key);
  Object.getOwnPropertySymbols(object2).forEach(function(k) {
    if (Object.getOwnPropertyDescriptor(object2, k).enumerable)
      enumerables.add(k);
  });
  return Array.from(enumerables);
}
function stringifyKey(key) {
  if (key && key.toString)
    return key.toString();
  else
    return new String(key).toString();
}
function getMapLikeKeys(map2) {
  if (isPlainObject$1(map2))
    return Object.keys(map2);
  if (Array.isArray(map2))
    return map2.map(function(_a2) {
      var _b2 = __read$f(_a2, 1), key = _b2[0];
      return key;
    });
  if (isES6Map(map2) || isObservableMap(map2))
    return Array.from(map2.keys());
  return fail("Cannot get keys from '" + map2 + "'");
}
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
var $mobx = Symbol("mobx administration");
var Atom = (
  /** @class */
  function() {
    function Atom2(name2) {
      if (name2 === void 0) {
        name2 = "Atom@" + getNextId();
      }
      this.name = name2;
      this.isPendingUnobservation = false;
      this.isBeingObserved = false;
      this.observers = /* @__PURE__ */ new Set();
      this.diffValue = 0;
      this.lastAccessedBy = 0;
      this.lowestObserverState = IDerivationState.NOT_TRACKING;
    }
    Atom2.prototype.onBecomeObserved = function() {
      if (this.onBecomeObservedListeners) {
        this.onBecomeObservedListeners.forEach(function(listener) {
          return listener();
        });
      }
    };
    Atom2.prototype.onBecomeUnobserved = function() {
      if (this.onBecomeUnobservedListeners) {
        this.onBecomeUnobservedListeners.forEach(function(listener) {
          return listener();
        });
      }
    };
    Atom2.prototype.reportObserved = function() {
      return reportObserved(this);
    };
    Atom2.prototype.reportChanged = function() {
      startBatch();
      propagateChanged(this);
      endBatch();
    };
    Atom2.prototype.toString = function() {
      return this.name;
    };
    return Atom2;
  }()
);
var isAtom = createInstanceofPredicate("Atom", Atom);
function createAtom(name2, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop$1;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop$1;
  }
  var atom = new Atom(name2);
  if (onBecomeObservedHandler !== noop$1) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop$1) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer(a2, b2) {
  return a2 === b2;
}
function structuralComparer(a2, b2) {
  return deepEqual(a2, b2);
}
function shallowComparer(a2, b2) {
  return deepEqual(a2, b2, 1);
}
function defaultComparer(a2, b2) {
  return Object.is(a2, b2);
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  default: defaultComparer,
  shallow: shallowComparer
};
var mobxDidRunLazyInitializersSymbol = Symbol("mobx did run lazy initializers");
var mobxPendingDecorators = Symbol("mobx pending decorators");
var enumerableDescriptorCache = {};
var nonEnumerableDescriptorCache = {};
function createPropertyInitializerDescriptor(prop, enumerable) {
  var cache2 = enumerable ? enumerableDescriptorCache : nonEnumerableDescriptorCache;
  return cache2[prop] || (cache2[prop] = {
    configurable: true,
    enumerable,
    get: function() {
      initializeInstance(this);
      return this[prop];
    },
    set: function(value) {
      initializeInstance(this);
      this[prop] = value;
    }
  });
}
function initializeInstance(target) {
  var e_1, _a2;
  if (target[mobxDidRunLazyInitializersSymbol] === true)
    return;
  var decorators = target[mobxPendingDecorators];
  if (decorators) {
    addHiddenProp(target, mobxDidRunLazyInitializersSymbol, true);
    var keys2 = __spread(Object.getOwnPropertySymbols(decorators), Object.keys(decorators));
    try {
      for (var keys_1 = __values$6(keys2), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
        var key = keys_1_1.value;
        var d2 = decorators[key];
        d2.propertyCreator(target, d2.prop, d2.descriptor, d2.decoratorTarget, d2.decoratorArguments);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (keys_1_1 && !keys_1_1.done && (_a2 = keys_1.return))
          _a2.call(keys_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
}
function createPropDecorator(propertyInitiallyEnumerable, propertyCreator) {
  return function decoratorFactory() {
    var decoratorArguments;
    var decorator = function decorate2(target, prop, descriptor, applyImmediately) {
      if (applyImmediately === true) {
        propertyCreator(target, prop, descriptor, target, decoratorArguments);
        return null;
      }
      if (!Object.prototype.hasOwnProperty.call(target, mobxPendingDecorators)) {
        var inheritedDecorators = target[mobxPendingDecorators];
        addHiddenProp(target, mobxPendingDecorators, __assign$3({}, inheritedDecorators));
      }
      target[mobxPendingDecorators][prop] = {
        prop,
        propertyCreator,
        descriptor,
        decoratorTarget: target,
        decoratorArguments
      };
      return createPropertyInitializerDescriptor(prop, propertyInitiallyEnumerable);
    };
    if (quacksLikeADecorator(arguments)) {
      decoratorArguments = EMPTY_ARRAY;
      return decorator.apply(null, arguments);
    } else {
      decoratorArguments = Array.prototype.slice.call(arguments);
      return decorator;
    }
  };
}
function quacksLikeADecorator(args) {
  return (args.length === 2 || args.length === 3) && (typeof args[1] === "string" || typeof args[1] === "symbol") || args.length === 4 && args[3] === true;
}
function deepEnhancer(v, _2, name2) {
  if (isObservable(v))
    return v;
  if (Array.isArray(v))
    return observable.array(v, { name: name2 });
  if (isPlainObject$1(v))
    return observable.object(v, void 0, { name: name2 });
  if (isES6Map(v))
    return observable.map(v, { name: name2 });
  if (isES6Set(v))
    return observable.set(v, { name: name2 });
  return v;
}
function shallowEnhancer(v, _2, name2) {
  if (v === void 0 || v === null)
    return v;
  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v))
    return v;
  if (Array.isArray(v))
    return observable.array(v, { name: name2, deep: false });
  if (isPlainObject$1(v))
    return observable.object(v, void 0, { name: name2, deep: false });
  if (isES6Map(v))
    return observable.map(v, { name: name2, deep: false });
  if (isES6Set(v))
    return observable.set(v, { name: name2, deep: false });
  return fail(false);
}
function referenceEnhancer(newValue) {
  return newValue;
}
function refStructEnhancer(v, oldValue, name2) {
  if (deepEqual(v, oldValue))
    return oldValue;
  return v;
}
function createDecoratorForEnhancer(enhancer) {
  invariant(enhancer);
  var decorator = createPropDecorator(true, function(target, propertyName, descriptor, _decoratorTarget, decoratorArgs) {
    var initialValue = descriptor ? descriptor.initializer ? descriptor.initializer.call(target) : descriptor.value : void 0;
    asObservableObject(target).addObservableProp(propertyName, initialValue, enhancer);
  });
  var res = (
    // Extra process checks, as this happens during module initialization
    typeof process !== "undefined" && define_process_env_default$2 && false ? function observableDecorator() {
      if (arguments.length < 2)
        return fail("Incorrect decorator invocation. @observable decorator doesn't expect any arguments");
      return decorator.apply(null, arguments);
    } : decorator
  );
  res.enhancer = enhancer;
  return res;
}
var defaultCreateObservableOptions = {
  deep: true,
  name: void 0,
  defaultDecorator: void 0,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  if (thing === null || thing === void 0)
    return defaultCreateObservableOptions;
  if (typeof thing === "string")
    return { name: thing, deep: true, proxy: true };
  return thing;
}
var deepDecorator = createDecoratorForEnhancer(deepEnhancer);
var shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);
var refDecorator = createDecoratorForEnhancer(referenceEnhancer);
var refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);
function getEnhancerFromOptions(options2) {
  return options2.defaultDecorator ? options2.defaultDecorator.enhancer : options2.deep === false ? referenceEnhancer : deepEnhancer;
}
function createObservable(v, arg2, arg3) {
  if (typeof arguments[1] === "string" || typeof arguments[1] === "symbol") {
    return deepDecorator.apply(null, arguments);
  }
  if (isObservable(v))
    return v;
  var res = isPlainObject$1(v) ? observable.object(v, arg2, arg3) : Array.isArray(v) ? observable.array(v, arg2) : isES6Map(v) ? observable.map(v, arg2) : isES6Set(v) ? observable.set(v, arg2) : v;
  if (res !== v)
    return res;
  fail(false);
}
var observableFactories = {
  box: function(value, options2) {
    if (arguments.length > 2)
      incorrectlyUsedAsDecorator("box");
    var o2 = asCreateObservableOptions(options2);
    return new ObservableValue(value, getEnhancerFromOptions(o2), o2.name, true, o2.equals);
  },
  array: function(initialValues, options2) {
    if (arguments.length > 2)
      incorrectlyUsedAsDecorator("array");
    var o2 = asCreateObservableOptions(options2);
    return createObservableArray(initialValues, getEnhancerFromOptions(o2), o2.name);
  },
  map: function(initialValues, options2) {
    if (arguments.length > 2)
      incorrectlyUsedAsDecorator("map");
    var o2 = asCreateObservableOptions(options2);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o2), o2.name);
  },
  set: function(initialValues, options2) {
    if (arguments.length > 2)
      incorrectlyUsedAsDecorator("set");
    var o2 = asCreateObservableOptions(options2);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o2), o2.name);
  },
  object: function(props, decorators, options2) {
    if (typeof arguments[1] === "string")
      incorrectlyUsedAsDecorator("object");
    var o2 = asCreateObservableOptions(options2);
    if (o2.proxy === false) {
      return extendObservable({}, props, decorators, o2);
    } else {
      var defaultDecorator = getDefaultDecoratorFromObjectOptions(o2);
      var base = extendObservable({}, void 0, void 0, o2);
      var proxy = createDynamicObservableObject(base);
      extendObservableObjectWithProperties(proxy, props, decorators, defaultDecorator);
      return proxy;
    }
  },
  ref: refDecorator,
  shallow: shallowDecorator,
  deep: deepDecorator,
  struct: refStructDecorator
};
var observable = createObservable;
Object.keys(observableFactories).forEach(function(name2) {
  return observable[name2] = observableFactories[name2];
});
function incorrectlyUsedAsDecorator(methodName) {
  fail(
    // process.env.NODE_ENV !== "production" &&
    "Expected one or two arguments to observable." + methodName + ". Did you accidentally try to use observable." + methodName + " as decorator?"
  );
}
var computedDecorator = createPropDecorator(false, function(instance, propertyName, descriptor, decoratorTarget, decoratorArgs) {
  var get2 = descriptor.get, set2 = descriptor.set;
  var options2 = decoratorArgs[0] || {};
  asObservableObject(instance).addComputedProp(instance, propertyName, __assign$3({
    get: get2,
    set: set2,
    context: instance
  }, options2));
});
computedDecorator({ equals: comparer.structural });
var IDerivationState;
(function(IDerivationState2) {
  IDerivationState2[IDerivationState2["NOT_TRACKING"] = -1] = "NOT_TRACKING";
  IDerivationState2[IDerivationState2["UP_TO_DATE"] = 0] = "UP_TO_DATE";
  IDerivationState2[IDerivationState2["POSSIBLY_STALE"] = 1] = "POSSIBLY_STALE";
  IDerivationState2[IDerivationState2["STALE"] = 2] = "STALE";
})(IDerivationState || (IDerivationState = {}));
var TraceMode;
(function(TraceMode2) {
  TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
  TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
  TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = (
  /** @class */
  /* @__PURE__ */ function() {
    function CaughtException2(cause) {
      this.cause = cause;
    }
    return CaughtException2;
  }()
);
function isCaughtException(e) {
  return e instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState) {
    case IDerivationState.UP_TO_DATE:
      return false;
    case IDerivationState.NOT_TRACKING:
    case IDerivationState.STALE:
      return true;
    case IDerivationState.POSSIBLY_STALE: {
      var prevAllowStateReads = allowStateReadsStart(true);
      var prevUntracked = untrackedStart();
      var obs = derivation.observing, l2 = obs.length;
      for (var i = 0; i < l2; i++) {
        var obj = obs[i];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState === IDerivationState.STALE) {
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo0(derivation);
      untrackedEnd(prevUntracked);
      allowStateReadsEnd(prevAllowStateReads);
      return false;
    }
  }
}
function checkIfStateModificationsAreAllowed(atom) {
  var hasObservers2 = atom.observers.size > 0;
  if (globalState.computationDepth > 0 && hasObservers2)
    fail(false);
  if (!globalState.allowStateChanges && (hasObservers2 || globalState.enforceActions === "strict"))
    fail(false);
}
function trackDerivedFunction(derivation, f2, context2) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  derivation.newObserving = new Array(derivation.observing.length + 100);
  derivation.unboundDepsCount = 0;
  derivation.runId = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f2.call(context2);
  } else {
    try {
      result = f2.call(context2);
    } catch (e) {
      result = new CaughtException(e);
    }
  }
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function bindDependencies(derivation) {
  var prevObserving = derivation.observing;
  var observing = derivation.observing = derivation.newObserving;
  var lowestNewObservingDerivationState = IDerivationState.UP_TO_DATE;
  var i0 = 0, l2 = derivation.unboundDepsCount;
  for (var i = 0; i < l2; i++) {
    var dep = observing[i];
    if (dep.diffValue === 0) {
      dep.diffValue = 1;
      if (i0 !== i)
        observing[i0] = dep;
      i0++;
    }
    if (dep.dependenciesState > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState;
    }
  }
  observing.length = i0;
  derivation.newObserving = null;
  l2 = prevObserving.length;
  while (l2--) {
    var dep = prevObserving[l2];
    if (dep.diffValue === 0) {
      removeObserver(dep, derivation);
    }
    dep.diffValue = 0;
  }
  while (i0--) {
    var dep = observing[i0];
    if (dep.diffValue === 1) {
      dep.diffValue = 0;
      addObserver(dep, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE) {
    derivation.dependenciesState = lowestNewObservingDerivationState;
    derivation.onBecomeStale();
  }
}
function clearObserving(derivation) {
  var obs = derivation.observing;
  derivation.observing = [];
  var i = obs.length;
  while (i--)
    removeObserver(obs[i], derivation);
  derivation.dependenciesState = IDerivationState.NOT_TRACKING;
}
function untracked(action3) {
  var prev2 = untrackedStart();
  try {
    return action3();
  } finally {
    untrackedEnd(prev2);
  }
}
function untrackedStart() {
  var prev2 = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev2;
}
function untrackedEnd(prev2) {
  globalState.trackingDerivation = prev2;
}
function allowStateReadsStart(allowStateReads) {
  var prev2 = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev2;
}
function allowStateReadsEnd(prev2) {
  globalState.allowStateReads = prev2;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState === IDerivationState.UP_TO_DATE)
    return;
  derivation.dependenciesState = IDerivationState.UP_TO_DATE;
  var obs = derivation.observing;
  var i = obs.length;
  while (i--)
    obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;
}
var currentActionId = 0;
var nextActionId = 1;
var functionNameDescriptor = Object.getOwnPropertyDescriptor(function() {
}, "name");
functionNameDescriptor && functionNameDescriptor.configurable;
function createAction(actionName, fn2, ref2) {
  var res = function() {
    return executeAction(actionName, fn2, ref2 || this, arguments);
  };
  res.isMobxAction = true;
  return res;
}
function executeAction(actionName, fn2, scope, args) {
  var runInfo = _startAction();
  try {
    return fn2.apply(scope, args);
  } catch (err) {
    runInfo.error = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, scope, args) {
  var notifySpy = isSpyEnabled();
  var startTime = 0;
  var prevDerivation = untrackedStart();
  startBatch();
  var prevAllowStateChanges = allowStateChangesStart(true);
  var prevAllowStateReads = allowStateReadsStart(true);
  var runInfo = {
    prevDerivation,
    prevAllowStateChanges,
    prevAllowStateReads,
    notifySpy,
    startTime,
    actionId: nextActionId++,
    parentActionId: currentActionId
  };
  currentActionId = runInfo.actionId;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId) {
    fail("invalid action stack. did you forget to finish an action?");
  }
  currentActionId = runInfo.parentActionId;
  if (runInfo.error !== void 0) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges);
  allowStateReadsEnd(runInfo.prevAllowStateReads);
  endBatch();
  untrackedEnd(runInfo.prevDerivation);
  if (runInfo.notifySpy && false) {
    spyReportEnd({ time: Date.now() - runInfo.startTime });
  }
  globalState.suppressReactionErrors = false;
}
function allowStateChangesStart(allowStateChanges2) {
  var prev2 = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges2;
  return prev2;
}
function allowStateChangesEnd(prev2) {
  globalState.allowStateChanges = prev2;
}
var ObservableValue = (
  /** @class */
  function(_super) {
    __extends$6(ObservableValue2, _super);
    function ObservableValue2(value, enhancer, name2, notifySpy, equals) {
      if (name2 === void 0) {
        name2 = "ObservableValue@" + getNextId();
      }
      if (notifySpy === void 0) {
        notifySpy = true;
      }
      if (equals === void 0) {
        equals = comparer.default;
      }
      var _this = _super.call(this, name2) || this;
      _this.enhancer = enhancer;
      _this.name = name2;
      _this.equals = equals;
      _this.hasUnreportedChange = false;
      _this.value = enhancer(value, void 0, name2);
      if (notifySpy && isSpyEnabled() && false) {
        spyReport({ type: "create", name: _this.name, newValue: "" + _this.value });
      }
      return _this;
    }
    ObservableValue2.prototype.dehanceValue = function(value) {
      if (this.dehancer !== void 0)
        return this.dehancer(value);
      return value;
    };
    ObservableValue2.prototype.set = function(newValue) {
      var oldValue = this.value;
      newValue = this.prepareNewValue(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notifySpy = isSpyEnabled();
        if (notifySpy && false) {
          spyReportStart({
            type: "update",
            name: this.name,
            newValue,
            oldValue
          });
        }
        this.setNewValue(newValue);
      }
    };
    ObservableValue2.prototype.prepareNewValue = function(newValue) {
      checkIfStateModificationsAreAllowed(this);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this,
          type: "update",
          newValue
        });
        if (!change)
          return globalState.UNCHANGED;
        newValue = change.newValue;
      }
      newValue = this.enhancer(newValue, this.value, this.name);
      return this.equals(this.value, newValue) ? globalState.UNCHANGED : newValue;
    };
    ObservableValue2.prototype.setNewValue = function(newValue) {
      var oldValue = this.value;
      this.value = newValue;
      this.reportChanged();
      if (hasListeners(this)) {
        notifyListeners(this, {
          type: "update",
          object: this,
          newValue,
          oldValue
        });
      }
    };
    ObservableValue2.prototype.get = function() {
      this.reportObserved();
      return this.dehanceValue(this.value);
    };
    ObservableValue2.prototype.intercept = function(handler) {
      return registerInterceptor(this, handler);
    };
    ObservableValue2.prototype.observe = function(listener, fireImmediately) {
      if (fireImmediately)
        listener({
          object: this,
          type: "update",
          newValue: this.value,
          oldValue: void 0
        });
      return registerListener(this, listener);
    };
    ObservableValue2.prototype.toJSON = function() {
      return this.get();
    };
    ObservableValue2.prototype.toString = function() {
      return this.name + "[" + this.value + "]";
    };
    ObservableValue2.prototype.valueOf = function() {
      return toPrimitive(this.get());
    };
    ObservableValue2.prototype[Symbol.toPrimitive] = function() {
      return this.valueOf();
    };
    return ObservableValue2;
  }(Atom)
);
createInstanceofPredicate("ObservableValue", ObservableValue);
var ComputedValue = (
  /** @class */
  function() {
    function ComputedValue2(options2) {
      this.dependenciesState = IDerivationState.NOT_TRACKING;
      this.observing = [];
      this.newObserving = null;
      this.isBeingObserved = false;
      this.isPendingUnobservation = false;
      this.observers = /* @__PURE__ */ new Set();
      this.diffValue = 0;
      this.runId = 0;
      this.lastAccessedBy = 0;
      this.lowestObserverState = IDerivationState.UP_TO_DATE;
      this.unboundDepsCount = 0;
      this.__mapid = "#" + getNextId();
      this.value = new CaughtException(null);
      this.isComputing = false;
      this.isRunningSetter = false;
      this.isTracing = TraceMode.NONE;
      invariant(options2.get, "missing option for computed: get");
      this.derivation = options2.get;
      this.name = options2.name || "ComputedValue@" + getNextId();
      if (options2.set)
        this.setter = createAction(this.name + "-setter", options2.set);
      this.equals = options2.equals || (options2.compareStructural || options2.struct ? comparer.structural : comparer.default);
      this.scope = options2.context;
      this.requiresReaction = !!options2.requiresReaction;
      this.keepAlive = !!options2.keepAlive;
    }
    ComputedValue2.prototype.onBecomeStale = function() {
      propagateMaybeChanged(this);
    };
    ComputedValue2.prototype.onBecomeObserved = function() {
      if (this.onBecomeObservedListeners) {
        this.onBecomeObservedListeners.forEach(function(listener) {
          return listener();
        });
      }
    };
    ComputedValue2.prototype.onBecomeUnobserved = function() {
      if (this.onBecomeUnobservedListeners) {
        this.onBecomeUnobservedListeners.forEach(function(listener) {
          return listener();
        });
      }
    };
    ComputedValue2.prototype.get = function() {
      if (this.isComputing)
        fail("Cycle detected in computation " + this.name + ": " + this.derivation);
      if (globalState.inBatch === 0 && this.observers.size === 0 && !this.keepAlive) {
        if (shouldCompute(this)) {
          this.warnAboutUntrackedRead();
          startBatch();
          this.value = this.computeValue(false);
          endBatch();
        }
      } else {
        reportObserved(this);
        if (shouldCompute(this)) {
          if (this.trackAndCompute())
            propagateChangeConfirmed(this);
        }
      }
      var result = this.value;
      if (isCaughtException(result))
        throw result.cause;
      return result;
    };
    ComputedValue2.prototype.peek = function() {
      var res = this.computeValue(false);
      if (isCaughtException(res))
        throw res.cause;
      return res;
    };
    ComputedValue2.prototype.set = function(value) {
      if (this.setter) {
        invariant(!this.isRunningSetter, "The setter of computed value '" + this.name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?");
        this.isRunningSetter = true;
        try {
          this.setter.call(this.scope, value);
        } finally {
          this.isRunningSetter = false;
        }
      } else
        invariant(false, false);
    };
    ComputedValue2.prototype.trackAndCompute = function() {
      var oldValue = this.value;
      var wasSuspended = (
        /* see #1208 */
        this.dependenciesState === IDerivationState.NOT_TRACKING
      );
      var newValue = this.computeValue(true);
      var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals(oldValue, newValue);
      if (changed) {
        this.value = newValue;
      }
      return changed;
    };
    ComputedValue2.prototype.computeValue = function(track2) {
      this.isComputing = true;
      globalState.computationDepth++;
      var res;
      if (track2) {
        res = trackDerivedFunction(this, this.derivation, this.scope);
      } else {
        if (globalState.disableErrorBoundaries === true) {
          res = this.derivation.call(this.scope);
        } else {
          try {
            res = this.derivation.call(this.scope);
          } catch (e) {
            res = new CaughtException(e);
          }
        }
      }
      globalState.computationDepth--;
      this.isComputing = false;
      return res;
    };
    ComputedValue2.prototype.suspend = function() {
      if (!this.keepAlive) {
        clearObserving(this);
        this.value = void 0;
      }
    };
    ComputedValue2.prototype.observe = function(listener, fireImmediately) {
      var _this = this;
      var firstTime = true;
      var prevValue = void 0;
      return autorun(function() {
        var newValue = _this.get();
        if (!firstTime || fireImmediately) {
          var prevU = untrackedStart();
          listener({
            type: "update",
            object: _this,
            newValue,
            oldValue: prevValue
          });
          untrackedEnd(prevU);
        }
        firstTime = false;
        prevValue = newValue;
      });
    };
    ComputedValue2.prototype.warnAboutUntrackedRead = function() {
      return;
    };
    ComputedValue2.prototype.toJSON = function() {
      return this.get();
    };
    ComputedValue2.prototype.toString = function() {
      return this.name + "[" + this.derivation.toString() + "]";
    };
    ComputedValue2.prototype.valueOf = function() {
      return toPrimitive(this.get());
    };
    ComputedValue2.prototype[Symbol.toPrimitive] = function() {
      return this.valueOf();
    };
    return ComputedValue2;
  }()
);
var isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue);
var MobXGlobals = (
  /** @class */
  /* @__PURE__ */ function() {
    function MobXGlobals2() {
      this.version = 5;
      this.UNCHANGED = {};
      this.trackingDerivation = null;
      this.computationDepth = 0;
      this.runId = 0;
      this.mobxGuid = 0;
      this.inBatch = 0;
      this.pendingUnobservations = [];
      this.pendingReactions = [];
      this.isRunningReactions = false;
      this.allowStateChanges = true;
      this.allowStateReads = true;
      this.enforceActions = false;
      this.spyListeners = [];
      this.globalReactionErrorHandlers = [];
      this.computedRequiresReaction = false;
      this.reactionRequiresObservable = false;
      this.observableRequiresReaction = false;
      this.computedConfigurable = false;
      this.disableErrorBoundaries = false;
      this.suppressReactionErrors = false;
    }
    return MobXGlobals2;
  }()
);
var mockGlobal = {};
function getGlobal$1() {
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}
var canMergeGlobalState = true;
var globalState = function() {
  var global2 = getGlobal$1();
  if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals)
    canMergeGlobalState = false;
  if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version)
    canMergeGlobalState = false;
  if (!canMergeGlobalState) {
    setTimeout(function() {
      {
        fail("There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`");
      }
    }, 1);
    return new MobXGlobals();
  } else if (global2.__mobxGlobals) {
    global2.__mobxInstanceCount += 1;
    if (!global2.__mobxGlobals.UNCHANGED)
      global2.__mobxGlobals.UNCHANGED = {};
    return global2.__mobxGlobals;
  } else {
    global2.__mobxInstanceCount = 1;
    return global2.__mobxGlobals = new MobXGlobals();
  }
}();
function addObserver(observable2, node) {
  observable2.observers.add(node);
  if (observable2.lowestObserverState > node.dependenciesState)
    observable2.lowestObserverState = node.dependenciesState;
}
function removeObserver(observable2, node) {
  observable2.observers.delete(node);
  if (observable2.observers.size === 0) {
    queueForUnobservation(observable2);
  }
}
function queueForUnobservation(observable2) {
  if (observable2.isPendingUnobservation === false) {
    observable2.isPendingUnobservation = true;
    globalState.pendingUnobservations.push(observable2);
  }
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i = 0; i < list.length; i++) {
      var observable2 = list[i];
      observable2.isPendingUnobservation = false;
      if (observable2.observers.size === 0) {
        if (observable2.isBeingObserved) {
          observable2.isBeingObserved = false;
          observable2.onBecomeUnobserved();
        }
        if (observable2 instanceof ComputedValue) {
          observable2.suspend();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable2) {
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId !== observable2.lastAccessedBy) {
      observable2.lastAccessedBy = derivation.runId;
      derivation.newObserving[derivation.unboundDepsCount++] = observable2;
      if (!observable2.isBeingObserved) {
        observable2.isBeingObserved = true;
        observable2.onBecomeObserved();
      }
    }
    return true;
  } else if (observable2.observers.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable2);
  }
  return false;
}
function propagateChanged(observable2) {
  if (observable2.lowestObserverState === IDerivationState.STALE)
    return;
  observable2.lowestObserverState = IDerivationState.STALE;
  observable2.observers.forEach(function(d2) {
    if (d2.dependenciesState === IDerivationState.UP_TO_DATE) {
      if (d2.isTracing !== TraceMode.NONE) {
        logTraceInfo(d2, observable2);
      }
      d2.onBecomeStale();
    }
    d2.dependenciesState = IDerivationState.STALE;
  });
}
function propagateChangeConfirmed(observable2) {
  if (observable2.lowestObserverState === IDerivationState.STALE)
    return;
  observable2.lowestObserverState = IDerivationState.STALE;
  observable2.observers.forEach(function(d2) {
    if (d2.dependenciesState === IDerivationState.POSSIBLY_STALE)
      d2.dependenciesState = IDerivationState.STALE;
    else if (d2.dependenciesState === IDerivationState.UP_TO_DATE)
      observable2.lowestObserverState = IDerivationState.UP_TO_DATE;
  });
}
function propagateMaybeChanged(observable2) {
  if (observable2.lowestObserverState !== IDerivationState.UP_TO_DATE)
    return;
  observable2.lowestObserverState = IDerivationState.POSSIBLY_STALE;
  observable2.observers.forEach(function(d2) {
    if (d2.dependenciesState === IDerivationState.UP_TO_DATE) {
      d2.dependenciesState = IDerivationState.POSSIBLY_STALE;
      if (d2.isTracing !== TraceMode.NONE) {
        logTraceInfo(d2, observable2);
      }
      d2.onBecomeStale();
    }
  });
}
function logTraceInfo(derivation, observable2) {
  console.log("[mobx.trace] '" + derivation.name + "' is invalidated due to a change in: '" + observable2.name + "'");
  if (derivation.isTracing === TraceMode.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree(derivation), lines, 1);
    new Function("debugger;\n/*\nTracing '" + derivation.name + "'\n\nYou are entering this break point because derivation '" + derivation.name + "' is being traced and '" + observable2.name + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}
function printDepTree(tree, lines, depth) {
  if (lines.length >= 1e3) {
    lines.push("(and many more)");
    return;
  }
  lines.push("" + new Array(depth).join("	") + tree.name);
  if (tree.dependencies)
    tree.dependencies.forEach(function(child) {
      return printDepTree(child, lines, depth + 1);
    });
}
var Reaction = (
  /** @class */
  function() {
    function Reaction2(name2, onInvalidate, errorHandler, requiresObservable) {
      if (name2 === void 0) {
        name2 = "Reaction@" + getNextId();
      }
      if (requiresObservable === void 0) {
        requiresObservable = false;
      }
      this.name = name2;
      this.onInvalidate = onInvalidate;
      this.errorHandler = errorHandler;
      this.requiresObservable = requiresObservable;
      this.observing = [];
      this.newObserving = [];
      this.dependenciesState = IDerivationState.NOT_TRACKING;
      this.diffValue = 0;
      this.runId = 0;
      this.unboundDepsCount = 0;
      this.__mapid = "#" + getNextId();
      this.isDisposed = false;
      this._isScheduled = false;
      this._isTrackPending = false;
      this._isRunning = false;
      this.isTracing = TraceMode.NONE;
    }
    Reaction2.prototype.onBecomeStale = function() {
      this.schedule();
    };
    Reaction2.prototype.schedule = function() {
      if (!this._isScheduled) {
        this._isScheduled = true;
        globalState.pendingReactions.push(this);
        runReactions();
      }
    };
    Reaction2.prototype.isScheduled = function() {
      return this._isScheduled;
    };
    Reaction2.prototype.runReaction = function() {
      if (!this.isDisposed) {
        startBatch();
        this._isScheduled = false;
        if (shouldCompute(this)) {
          this._isTrackPending = true;
          try {
            this.onInvalidate();
            if (this._isTrackPending && isSpyEnabled() && false) {
              spyReport({
                name: this.name,
                type: "scheduled-reaction"
              });
            }
          } catch (e) {
            this.reportExceptionInDerivation(e);
          }
        }
        endBatch();
      }
    };
    Reaction2.prototype.track = function(fn2) {
      if (this.isDisposed) {
        return;
      }
      startBatch();
      this._isRunning = true;
      var result = trackDerivedFunction(this, fn2, void 0);
      this._isRunning = false;
      this._isTrackPending = false;
      if (this.isDisposed) {
        clearObserving(this);
      }
      if (isCaughtException(result))
        this.reportExceptionInDerivation(result.cause);
      endBatch();
    };
    Reaction2.prototype.reportExceptionInDerivation = function(error) {
      var _this = this;
      if (this.errorHandler) {
        this.errorHandler(error, this);
        return;
      }
      if (globalState.disableErrorBoundaries)
        throw error;
      var message = "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'";
      if (globalState.suppressReactionErrors) {
        console.warn("[mobx] (error in reaction '" + this.name + "' suppressed, fix error of causing action below)");
      } else {
        console.error(message, error);
      }
      globalState.globalReactionErrorHandlers.forEach(function(f2) {
        return f2(error, _this);
      });
    };
    Reaction2.prototype.dispose = function() {
      if (!this.isDisposed) {
        this.isDisposed = true;
        if (!this._isRunning) {
          startBatch();
          clearObserving(this);
          endBatch();
        }
      }
    };
    Reaction2.prototype.getDisposer = function() {
      var r2 = this.dispose.bind(this);
      r2[$mobx] = this;
      return r2;
    };
    Reaction2.prototype.toString = function() {
      return "Reaction[" + this.name + "]";
    };
    Reaction2.prototype.trace = function(enterBreakPoint) {
      if (enterBreakPoint === void 0) {
        enterBreakPoint = false;
      }
      trace$1(this, enterBreakPoint);
    };
    return Reaction2;
  }()
);
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function(f2) {
  return f2();
};
function runReactions() {
  if (globalState.inBatch > 0 || globalState.isRunningReactions)
    return;
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0;
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error("Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]));
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i = 0, l2 = remainingReactions.length; i < l2; i++)
      remainingReactions[i].runReaction();
  }
  globalState.isRunningReactions = false;
}
var isReaction = createInstanceofPredicate("Reaction", Reaction);
function isSpyEnabled() {
  return false;
}
function spyReport(event) {
  return;
}
function spyReportStart(event) {
  return;
}
function spyReportEnd(change) {
  return;
}
function spy(listener) {
  {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  }
}
function dontReassignFields() {
  fail(false);
}
function namedActionDecorator(name2) {
  return function(target, prop, descriptor) {
    if (descriptor) {
      if (descriptor.value) {
        return {
          value: createAction(name2, descriptor.value),
          enumerable: false,
          configurable: true,
          writable: true
          // for typescript, this must be writable, otherwise it cannot inherit :/ (see inheritable actions test)
        };
      }
      var initializer_1 = descriptor.initializer;
      return {
        enumerable: false,
        configurable: true,
        writable: true,
        initializer: function() {
          return createAction(name2, initializer_1.call(this));
        }
      };
    }
    return actionFieldDecorator(name2).apply(this, arguments);
  };
}
function actionFieldDecorator(name2) {
  return function(target, prop, descriptor) {
    Object.defineProperty(target, prop, {
      configurable: true,
      enumerable: false,
      get: function() {
        return void 0;
      },
      set: function(value) {
        addHiddenProp(this, prop, action(name2, value));
      }
    });
  };
}
function boundActionDecorator(target, propertyName, descriptor, applyToInstance) {
  if (applyToInstance === true) {
    defineBoundAction(target, propertyName, descriptor.value);
    return null;
  }
  if (descriptor) {
    return {
      configurable: true,
      enumerable: false,
      get: function() {
        defineBoundAction(this, propertyName, descriptor.value || descriptor.initializer.call(this));
        return this[propertyName];
      },
      set: dontReassignFields
    };
  }
  return {
    enumerable: false,
    configurable: true,
    set: function(v) {
      defineBoundAction(this, propertyName, v);
    },
    get: function() {
      return void 0;
    }
  };
}
var action = function action2(arg1, arg2, arg3, arg4) {
  if (arguments.length === 1 && typeof arg1 === "function")
    return createAction(arg1.name || "<unnamed action>", arg1);
  if (arguments.length === 2 && typeof arg2 === "function")
    return createAction(arg1, arg2);
  if (arguments.length === 1 && typeof arg1 === "string")
    return namedActionDecorator(arg1);
  if (arg4 === true) {
    addHiddenProp(arg1, arg2, createAction(arg1.name || arg2, arg3.value, this));
  } else {
    return namedActionDecorator(arg2).apply(null, arguments);
  }
};
action.bound = boundActionDecorator;
function defineBoundAction(target, propertyName, fn2) {
  addHiddenProp(target, propertyName, createAction(propertyName, fn2.bind(target)));
}
function autorun(view, opts) {
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  var name2 = opts && opts.name || view.name || "Autorun@" + getNextId();
  var runSync = !opts.scheduler && !opts.delay;
  var reaction2;
  if (runSync) {
    reaction2 = new Reaction(name2, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler_1 = createSchedulerFromOptions(opts);
    var isScheduled_1 = false;
    reaction2 = new Reaction(name2, function() {
      if (!isScheduled_1) {
        isScheduled_1 = true;
        scheduler_1(function() {
          isScheduled_1 = false;
          if (!reaction2.isDisposed)
            reaction2.track(reactionRunner);
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction2);
  }
  reaction2.schedule();
  return reaction2.getDisposer();
}
var run = function(f2) {
  return f2();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f2) {
    return setTimeout(f2, opts.delay);
  } : run;
}
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook("onBecomeObserved", thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook("onBecomeUnobserved", thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = typeof arg3 === "function" ? arg3 : arg2;
  var listenersKey = hook + "Listeners";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = /* @__PURE__ */ new Set([cb]);
  }
  var orig = atom[hook];
  if (typeof orig !== "function")
    return fail(false);
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners.delete(cb);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
function extendObservable(target, properties, decorators, options2) {
  options2 = asCreateObservableOptions(options2);
  var defaultDecorator = getDefaultDecoratorFromObjectOptions(options2);
  initializeInstance(target);
  asObservableObject(target, options2.name, defaultDecorator.enhancer);
  if (properties)
    extendObservableObjectWithProperties(target, properties, decorators, defaultDecorator);
  return target;
}
function getDefaultDecoratorFromObjectOptions(options2) {
  return options2.defaultDecorator || (options2.deep === false ? refDecorator : deepDecorator);
}
function extendObservableObjectWithProperties(target, properties, decorators, defaultDecorator) {
  var e_2, _b2;
  var keys2, key;
  startBatch();
  try {
    var keys2 = getPlainObjectKeys(properties);
    try {
      for (var keys_2 = __values$6(keys2), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {
        var key = keys_2_1.value;
        var descriptor = Object.getOwnPropertyDescriptor(properties, key);
        if (false)
          ;
        var decorator = decorators && key in decorators ? decorators[key] : descriptor.get ? computedDecorator : defaultDecorator;
        if (false)
          ;
        var resultDescriptor = decorator(target, key, descriptor, true);
        if (resultDescriptor)
          Object.defineProperty(target, key, resultDescriptor);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (keys_2_1 && !keys_2_1.done && (_b2 = keys_2.return))
          _b2.call(keys_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  } finally {
    endBatch();
  }
}
function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
  var result = {
    name: node.name
  };
  if (node.observing && node.observing.length > 0)
    result.dependencies = unique(node.observing).map(nodeToDependencyTree);
  return result;
}
function _isComputed(value, property) {
  if (value === null || value === void 0)
    return false;
  if (property !== void 0) {
    if (isObservableObject(value) === false)
      return false;
    if (!value[$mobx].values.has(property))
      return false;
    var atom = getAtom(value, property);
    return isComputedValue(atom);
  }
  return isComputedValue(value);
}
function isComputed(value) {
  if (arguments.length > 1)
    return fail(false);
  return _isComputed(value);
}
function _isObservable(value, property) {
  if (value === null || value === void 0)
    return false;
  if (property !== void 0) {
    if (isObservableObject(value)) {
      return value[$mobx].values.has(property);
    }
    return false;
  }
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  if (arguments.length !== 1)
    fail(false);
  return _isObservable(value);
}
function set(obj, key, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var values_1 = key;
    try {
      for (var key_1 in values_1)
        set(obj, key_1, values_1[key_1]);
    } finally {
      endBatch();
    }
    return;
  }
  if (isObservableObject(obj)) {
    var adm = obj[$mobx];
    var existingObservable = adm.values.get(key);
    if (existingObservable) {
      adm.write(key, value);
    } else {
      adm.addObservableProp(key, value, adm.defaultEnhancer);
    }
  } else if (isObservableMap(obj)) {
    obj.set(key, value);
  } else if (isObservableSet(obj)) {
    obj.add(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number")
      key = parseInt(key, 10);
    invariant(key >= 0, "Not a valid index: '" + key + "'");
    startBatch();
    if (key >= obj.length)
      obj.length = key + 1;
    obj[key] = value;
    endBatch();
  } else {
    return fail(false);
  }
}
function trace$1() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var enterBreakPoint = false;
  if (typeof args[args.length - 1] === "boolean")
    enterBreakPoint = args.pop();
  var derivation = getAtomFromArgs(args);
  if (!derivation) {
    return fail(false);
  }
  if (derivation.isTracing === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name + "' tracing enabled");
  }
  derivation.isTracing = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}
function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;
    case 1:
      return getAtom(args[0]);
    case 2:
      return getAtom(args[0], args[1]);
  }
}
function transaction(action3, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch();
  try {
    return action3.apply(thisArg);
  } finally {
    endBatch();
  }
}
function getAdm(target) {
  return target[$mobx];
}
function isPropertyKey(val) {
  return typeof val === "string" || typeof val === "number" || typeof val === "symbol";
}
var objectProxyTraps = {
  has: function(target, name2) {
    if (name2 === $mobx || name2 === "constructor" || name2 === mobxDidRunLazyInitializersSymbol)
      return true;
    var adm = getAdm(target);
    if (isPropertyKey(name2))
      return adm.has(name2);
    return name2 in target;
  },
  get: function(target, name2) {
    if (name2 === $mobx || name2 === "constructor" || name2 === mobxDidRunLazyInitializersSymbol)
      return target[name2];
    var adm = getAdm(target);
    var observable2 = adm.values.get(name2);
    if (observable2 instanceof Atom) {
      var result = observable2.get();
      if (result === void 0) {
        adm.has(name2);
      }
      return result;
    }
    if (isPropertyKey(name2))
      adm.has(name2);
    return target[name2];
  },
  set: function(target, name2, value) {
    if (!isPropertyKey(name2))
      return false;
    set(target, name2, value);
    return true;
  },
  deleteProperty: function(target, name2) {
    if (!isPropertyKey(name2))
      return false;
    var adm = getAdm(target);
    adm.remove(name2);
    return true;
  },
  ownKeys: function(target) {
    var adm = getAdm(target);
    adm.keysAtom.reportObserved();
    return Reflect.ownKeys(target);
  },
  preventExtensions: function(target) {
    fail("Dynamic observable objects cannot be frozen");
    return false;
  }
};
function createDynamicObservableObject(base) {
  var proxy = new Proxy(base, objectProxyTraps);
  base[$mobx].proxy = proxy;
  return proxy;
}
function hasInterceptors(interceptable) {
  return interceptable.interceptors !== void 0 && interceptable.interceptors.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors || (interceptable.interceptors = []);
  interceptors.push(handler);
  return once$1(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1)
      interceptors.splice(idx, 1);
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    var interceptors = __spread(interceptable.interceptors || []);
    for (var i = 0, l2 = interceptors.length; i < l2; i++) {
      change = interceptors[i](change);
      invariant(!change || change.type, "Intercept handlers should return nothing or a change object");
      if (!change)
        break;
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return listenable.changeListeners !== void 0 && listenable.changeListeners.length > 0;
}
function registerListener(listenable, handler) {
  var listeners2 = listenable.changeListeners || (listenable.changeListeners = []);
  listeners2.push(handler);
  return once$1(function() {
    var idx = listeners2.indexOf(handler);
    if (idx !== -1)
      listeners2.splice(idx, 1);
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners2 = listenable.changeListeners;
  if (!listeners2)
    return;
  listeners2 = listeners2.slice();
  for (var i = 0, l2 = listeners2.length; i < l2; i++) {
    listeners2[i](change);
  }
  untrackedEnd(prevU);
}
var MAX_SPLICE_SIZE = 1e4;
var arrayTraps = {
  get: function(target, name2) {
    if (name2 === $mobx)
      return target[$mobx];
    if (name2 === "length")
      return target[$mobx].getArrayLength();
    if (typeof name2 === "number") {
      return arrayExtensions.get.call(target, name2);
    }
    if (typeof name2 === "string" && !isNaN(name2)) {
      return arrayExtensions.get.call(target, parseInt(name2));
    }
    if (arrayExtensions.hasOwnProperty(name2)) {
      return arrayExtensions[name2];
    }
    return target[name2];
  },
  set: function(target, name2, value) {
    if (name2 === "length") {
      target[$mobx].setArrayLength(value);
    }
    if (typeof name2 === "number") {
      arrayExtensions.set.call(target, name2, value);
    }
    if (typeof name2 === "symbol" || isNaN(name2)) {
      target[name2] = value;
    } else {
      arrayExtensions.set.call(target, parseInt(name2), value);
    }
    return true;
  },
  preventExtensions: function(target) {
    fail("Observable arrays cannot be frozen");
    return false;
  }
};
function createObservableArray(initialValues, enhancer, name2, owned) {
  if (name2 === void 0) {
    name2 = "ObservableArray@" + getNextId();
  }
  if (owned === void 0) {
    owned = false;
  }
  var adm = new ObservableArrayAdministration(name2, enhancer, owned);
  addHiddenFinalProp(adm.values, $mobx, adm);
  var proxy = new Proxy(adm.values, arrayTraps);
  adm.proxy = proxy;
  if (initialValues && initialValues.length) {
    var prev2 = allowStateChangesStart(true);
    adm.spliceWithArray(0, 0, initialValues);
    allowStateChangesEnd(prev2);
  }
  return proxy;
}
var ObservableArrayAdministration = (
  /** @class */
  function() {
    function ObservableArrayAdministration2(name2, enhancer, owned) {
      this.owned = owned;
      this.values = [];
      this.proxy = void 0;
      this.lastKnownLength = 0;
      this.atom = new Atom(name2 || "ObservableArray@" + getNextId());
      this.enhancer = function(newV, oldV) {
        return enhancer(newV, oldV, name2 + "[..]");
      };
    }
    ObservableArrayAdministration2.prototype.dehanceValue = function(value) {
      if (this.dehancer !== void 0)
        return this.dehancer(value);
      return value;
    };
    ObservableArrayAdministration2.prototype.dehanceValues = function(values2) {
      if (this.dehancer !== void 0 && values2.length > 0)
        return values2.map(this.dehancer);
      return values2;
    };
    ObservableArrayAdministration2.prototype.intercept = function(handler) {
      return registerInterceptor(this, handler);
    };
    ObservableArrayAdministration2.prototype.observe = function(listener, fireImmediately) {
      if (fireImmediately === void 0) {
        fireImmediately = false;
      }
      if (fireImmediately) {
        listener({
          object: this.proxy,
          type: "splice",
          index: 0,
          added: this.values.slice(),
          addedCount: this.values.length,
          removed: [],
          removedCount: 0
        });
      }
      return registerListener(this, listener);
    };
    ObservableArrayAdministration2.prototype.getArrayLength = function() {
      this.atom.reportObserved();
      return this.values.length;
    };
    ObservableArrayAdministration2.prototype.setArrayLength = function(newLength) {
      if (typeof newLength !== "number" || newLength < 0)
        throw new Error("[mobx.array] Out of range: " + newLength);
      var currentLength = this.values.length;
      if (newLength === currentLength)
        return;
      else if (newLength > currentLength) {
        var newItems = new Array(newLength - currentLength);
        for (var i = 0; i < newLength - currentLength; i++)
          newItems[i] = void 0;
        this.spliceWithArray(currentLength, 0, newItems);
      } else
        this.spliceWithArray(newLength, currentLength - newLength);
    };
    ObservableArrayAdministration2.prototype.updateArrayLength = function(oldLength, delta) {
      if (oldLength !== this.lastKnownLength)
        throw new Error("[mobx] Modification exception: the internal structure of an observable array was changed.");
      this.lastKnownLength += delta;
    };
    ObservableArrayAdministration2.prototype.spliceWithArray = function(index, deleteCount, newItems) {
      var _this = this;
      checkIfStateModificationsAreAllowed(this.atom);
      var length2 = this.values.length;
      if (index === void 0)
        index = 0;
      else if (index > length2)
        index = length2;
      else if (index < 0)
        index = Math.max(0, length2 + index);
      if (arguments.length === 1)
        deleteCount = length2 - index;
      else if (deleteCount === void 0 || deleteCount === null)
        deleteCount = 0;
      else
        deleteCount = Math.max(0, Math.min(deleteCount, length2 - index));
      if (newItems === void 0)
        newItems = EMPTY_ARRAY;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy,
          type: "splice",
          index,
          removedCount: deleteCount,
          added: newItems
        });
        if (!change)
          return EMPTY_ARRAY;
        deleteCount = change.removedCount;
        newItems = change.added;
      }
      newItems = newItems.length === 0 ? newItems : newItems.map(function(v) {
        return _this.enhancer(v, void 0);
      });
      var res = this.spliceItemsIntoValues(index, deleteCount, newItems);
      if (deleteCount !== 0 || newItems.length !== 0)
        this.notifyArraySplice(index, newItems, res);
      return this.dehanceValues(res);
    };
    ObservableArrayAdministration2.prototype.spliceItemsIntoValues = function(index, deleteCount, newItems) {
      var _a2;
      if (newItems.length < MAX_SPLICE_SIZE) {
        return (_a2 = this.values).splice.apply(_a2, __spread([index, deleteCount], newItems));
      } else {
        var res = this.values.slice(index, index + deleteCount);
        this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));
        return res;
      }
    };
    ObservableArrayAdministration2.prototype.notifyArrayChildUpdate = function(index, newValue, oldValue) {
      var notifySpy = !this.owned && isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        object: this.proxy,
        type: "update",
        index,
        newValue,
        oldValue
      } : null;
      if (notifySpy && false)
        spyReportStart(__assign$3(__assign$3({}, change), { name: this.atom.name }));
      this.atom.reportChanged();
      if (notify)
        notifyListeners(this, change);
    };
    ObservableArrayAdministration2.prototype.notifyArraySplice = function(index, added, removed) {
      var notifySpy = !this.owned && isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        object: this.proxy,
        type: "splice",
        index,
        removed,
        added,
        removedCount: removed.length,
        addedCount: added.length
      } : null;
      if (notifySpy && false)
        spyReportStart(__assign$3(__assign$3({}, change), { name: this.atom.name }));
      this.atom.reportChanged();
      if (notify)
        notifyListeners(this, change);
    };
    return ObservableArrayAdministration2;
  }()
);
var arrayExtensions = {
  intercept: function(handler) {
    return this[$mobx].intercept(handler);
  },
  observe: function(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    var adm = this[$mobx];
    return adm.observe(listener, fireImmediately);
  },
  clear: function() {
    return this.splice(0);
  },
  replace: function(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray(0, adm.values.length, newItems);
  },
  /**
   * Converts this array back to a (shallow) javascript structure.
   * For a deep clone use mobx.toJS
   */
  toJS: function() {
    return this.slice();
  },
  toJSON: function() {
    return this.toJS();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function(index, deleteCount) {
    var newItems = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      newItems[_i - 2] = arguments[_i];
    }
    var adm = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray(index);
      case 2:
        return adm.spliceWithArray(index, deleteCount);
    }
    return adm.spliceWithArray(index, deleteCount, newItems);
  },
  spliceWithArray: function(index, deleteCount, newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray(index, deleteCount, newItems);
  },
  push: function() {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var adm = this[$mobx];
    adm.spliceWithArray(adm.values.length, 0, items);
    return adm.values.length;
  },
  pop: function() {
    return this.splice(Math.max(this[$mobx].values.length - 1, 0), 1)[0];
  },
  shift: function() {
    return this.splice(0, 1)[0];
  },
  unshift: function() {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var adm = this[$mobx];
    adm.spliceWithArray(0, 0, items);
    return adm.values.length;
  },
  reverse: function() {
    var clone2 = this.slice();
    return clone2.reverse.apply(clone2, arguments);
  },
  sort: function(compareFn) {
    var clone2 = this.slice();
    return clone2.sort.apply(clone2, arguments);
  },
  remove: function(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues(adm.values).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  },
  get: function(index) {
    var adm = this[$mobx];
    if (adm) {
      if (index < adm.values.length) {
        adm.atom.reportObserved();
        return adm.dehanceValue(adm.values[index]);
      }
      console.warn("[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + adm.values.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
    }
    return void 0;
  },
  set: function(index, newValue) {
    var adm = this[$mobx];
    var values2 = adm.values;
    if (index < values2.length) {
      checkIfStateModificationsAreAllowed(adm.atom);
      var oldValue = values2[index];
      if (hasInterceptors(adm)) {
        var change = interceptChange(adm, {
          type: "update",
          object: adm.proxy,
          index,
          newValue
        });
        if (!change)
          return;
        newValue = change.newValue;
      }
      newValue = adm.enhancer(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values2[index] = newValue;
        adm.notifyArrayChildUpdate(index, newValue, oldValue);
      }
    } else if (index === values2.length) {
      adm.spliceWithArray(index, 0, [newValue]);
    } else {
      throw new Error("[mobx.array] Index out of bounds, " + index + " is larger than " + values2.length);
    }
  }
};
[
  "concat",
  "every",
  "filter",
  "forEach",
  "indexOf",
  "join",
  "lastIndexOf",
  "map",
  "reduce",
  "reduceRight",
  "slice",
  "some",
  "toString",
  "toLocaleString"
].forEach(function(funcName) {
  arrayExtensions[funcName] = function() {
    var adm = this[$mobx];
    adm.atom.reportObserved();
    var res = adm.dehanceValues(adm.values);
    return res[funcName].apply(res, arguments);
  };
});
var isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject$1(thing) && isObservableArrayAdministration(thing[$mobx]);
}
var _a$1;
var ObservableMapMarker = {};
var ObservableMap = (
  /** @class */
  function() {
    function ObservableMap2(initialData, enhancer, name2) {
      if (enhancer === void 0) {
        enhancer = deepEnhancer;
      }
      if (name2 === void 0) {
        name2 = "ObservableMap@" + getNextId();
      }
      this.enhancer = enhancer;
      this.name = name2;
      this[_a$1] = ObservableMapMarker;
      this._keysAtom = createAtom(this.name + ".keys()");
      this[Symbol.toStringTag] = "Map";
      if (typeof Map !== "function") {
        throw new Error("mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js");
      }
      this._data = /* @__PURE__ */ new Map();
      this._hasMap = /* @__PURE__ */ new Map();
      this.merge(initialData);
    }
    ObservableMap2.prototype._has = function(key) {
      return this._data.has(key);
    };
    ObservableMap2.prototype.has = function(key) {
      var _this = this;
      if (!globalState.trackingDerivation)
        return this._has(key);
      var entry = this._hasMap.get(key);
      if (!entry) {
        var newEntry = entry = new ObservableValue(this._has(key), referenceEnhancer, this.name + "." + stringifyKey(key) + "?", false);
        this._hasMap.set(key, newEntry);
        onBecomeUnobserved(newEntry, function() {
          return _this._hasMap.delete(key);
        });
      }
      return entry.get();
    };
    ObservableMap2.prototype.set = function(key, value) {
      var hasKey = this._has(key);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: hasKey ? "update" : "add",
          object: this,
          newValue: value,
          name: key
        });
        if (!change)
          return this;
        value = change.newValue;
      }
      if (hasKey) {
        this._updateValue(key, value);
      } else {
        this._addValue(key, value);
      }
      return this;
    };
    ObservableMap2.prototype.delete = function(key) {
      var _this = this;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: "delete",
          object: this,
          name: key
        });
        if (!change)
          return false;
      }
      if (this._has(key)) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          type: "delete",
          object: this,
          oldValue: this._data.get(key).value,
          name: key
        } : null;
        if (notifySpy && false)
          spyReportStart(__assign$3(__assign$3({}, change), { name: this.name, key }));
        transaction(function() {
          _this._keysAtom.reportChanged();
          _this._updateHasMapEntry(key, false);
          var observable2 = _this._data.get(key);
          observable2.setNewValue(void 0);
          _this._data.delete(key);
        });
        if (notify)
          notifyListeners(this, change);
        return true;
      }
      return false;
    };
    ObservableMap2.prototype._updateHasMapEntry = function(key, value) {
      var entry = this._hasMap.get(key);
      if (entry) {
        entry.setNewValue(value);
      }
    };
    ObservableMap2.prototype._updateValue = function(key, newValue) {
      var observable2 = this._data.get(key);
      newValue = observable2.prepareNewValue(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          type: "update",
          object: this,
          oldValue: observable2.value,
          name: key,
          newValue
        } : null;
        if (notifySpy && false)
          spyReportStart(__assign$3(__assign$3({}, change), { name: this.name, key }));
        observable2.setNewValue(newValue);
        if (notify)
          notifyListeners(this, change);
      }
    };
    ObservableMap2.prototype._addValue = function(key, newValue) {
      var _this = this;
      checkIfStateModificationsAreAllowed(this._keysAtom);
      transaction(function() {
        var observable2 = new ObservableValue(newValue, _this.enhancer, _this.name + "." + stringifyKey(key), false);
        _this._data.set(key, observable2);
        newValue = observable2.value;
        _this._updateHasMapEntry(key, true);
        _this._keysAtom.reportChanged();
      });
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        type: "add",
        object: this,
        name: key,
        newValue
      } : null;
      if (notify)
        notifyListeners(this, change);
    };
    ObservableMap2.prototype.get = function(key) {
      if (this.has(key))
        return this.dehanceValue(this._data.get(key).get());
      return this.dehanceValue(void 0);
    };
    ObservableMap2.prototype.dehanceValue = function(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    ObservableMap2.prototype.keys = function() {
      this._keysAtom.reportObserved();
      return this._data.keys();
    };
    ObservableMap2.prototype.values = function() {
      var self2 = this;
      var nextIndex = 0;
      var keys2 = Array.from(this.keys());
      return makeIterable({
        next: function() {
          return nextIndex < keys2.length ? { value: self2.get(keys2[nextIndex++]), done: false } : { done: true };
        }
      });
    };
    ObservableMap2.prototype.entries = function() {
      var self2 = this;
      var nextIndex = 0;
      var keys2 = Array.from(this.keys());
      return makeIterable({
        next: function() {
          if (nextIndex < keys2.length) {
            var key = keys2[nextIndex++];
            return {
              value: [key, self2.get(key)],
              done: false
            };
          }
          return { done: true };
        }
      });
    };
    ObservableMap2.prototype[_a$1 = $mobx, Symbol.iterator] = function() {
      return this.entries();
    };
    ObservableMap2.prototype.forEach = function(callback, thisArg) {
      var e_1, _b2;
      try {
        for (var _c = __values$6(this), _d = _c.next(); !_d.done; _d = _c.next()) {
          var _e = __read$f(_d.value, 2), key = _e[0], value = _e[1];
          callback.call(thisArg, value, key, this);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_b2 = _c.return))
            _b2.call(_c);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    ObservableMap2.prototype.merge = function(other) {
      var _this = this;
      if (isObservableMap(other)) {
        other = other.toJS();
      }
      transaction(function() {
        if (isPlainObject$1(other))
          getPlainObjectKeys(other).forEach(function(key) {
            return _this.set(key, other[key]);
          });
        else if (Array.isArray(other))
          other.forEach(function(_b2) {
            var _c = __read$f(_b2, 2), key = _c[0], value = _c[1];
            return _this.set(key, value);
          });
        else if (isES6Map(other)) {
          if (other.constructor !== Map)
            fail("Cannot initialize from classes that inherit from Map: " + other.constructor.name);
          other.forEach(function(value, key) {
            return _this.set(key, value);
          });
        } else if (other !== null && other !== void 0)
          fail("Cannot initialize map from " + other);
      });
      return this;
    };
    ObservableMap2.prototype.clear = function() {
      var _this = this;
      transaction(function() {
        untracked(function() {
          var e_2, _b2;
          try {
            for (var _c = __values$6(_this.keys()), _d = _c.next(); !_d.done; _d = _c.next()) {
              var key = _d.value;
              _this.delete(key);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_d && !_d.done && (_b2 = _c.return))
                _b2.call(_c);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        });
      });
    };
    ObservableMap2.prototype.replace = function(values2) {
      var _this = this;
      transaction(function() {
        var newKeys = getMapLikeKeys(values2);
        var oldKeys = Array.from(_this.keys());
        var missingKeys = oldKeys.filter(function(k) {
          return newKeys.indexOf(k) === -1;
        });
        missingKeys.forEach(function(k) {
          return _this.delete(k);
        });
        _this.merge(values2);
      });
      return this;
    };
    Object.defineProperty(ObservableMap2.prototype, "size", {
      get: function() {
        this._keysAtom.reportObserved();
        return this._data.size;
      },
      enumerable: true,
      configurable: true
    });
    ObservableMap2.prototype.toPOJO = function() {
      var e_3, _b2;
      var res = {};
      try {
        for (var _c = __values$6(this), _d = _c.next(); !_d.done; _d = _c.next()) {
          var _e = __read$f(_d.value, 2), key = _e[0], value = _e[1];
          res[typeof key === "symbol" ? key : stringifyKey(key)] = value;
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_d && !_d.done && (_b2 = _c.return))
            _b2.call(_c);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return res;
    };
    ObservableMap2.prototype.toJS = function() {
      return new Map(this);
    };
    ObservableMap2.prototype.toJSON = function() {
      return this.toPOJO();
    };
    ObservableMap2.prototype.toString = function() {
      var _this = this;
      return this.name + "[{ " + Array.from(this.keys()).map(function(key) {
        return stringifyKey(key) + ": " + ("" + _this.get(key));
      }).join(", ") + " }]";
    };
    ObservableMap2.prototype.observe = function(listener, fireImmediately) {
      return registerListener(this, listener);
    };
    ObservableMap2.prototype.intercept = function(handler) {
      return registerInterceptor(this, handler);
    };
    return ObservableMap2;
  }()
);
var isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap);
var _a$1$1;
var ObservableSetMarker = {};
var ObservableSet = (
  /** @class */
  function() {
    function ObservableSet2(initialData, enhancer, name2) {
      if (enhancer === void 0) {
        enhancer = deepEnhancer;
      }
      if (name2 === void 0) {
        name2 = "ObservableSet@" + getNextId();
      }
      this.name = name2;
      this[_a$1$1] = ObservableSetMarker;
      this._data = /* @__PURE__ */ new Set();
      this._atom = createAtom(this.name);
      this[Symbol.toStringTag] = "Set";
      if (typeof Set !== "function") {
        throw new Error("mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js");
      }
      this.enhancer = function(newV, oldV) {
        return enhancer(newV, oldV, name2);
      };
      if (initialData) {
        this.replace(initialData);
      }
    }
    ObservableSet2.prototype.dehanceValue = function(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    ObservableSet2.prototype.clear = function() {
      var _this = this;
      transaction(function() {
        untracked(function() {
          var e_1, _b2;
          try {
            for (var _c = __values$6(_this._data.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
              var value = _d.value;
              _this.delete(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_d && !_d.done && (_b2 = _c.return))
                _b2.call(_c);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        });
      });
    };
    ObservableSet2.prototype.forEach = function(callbackFn, thisArg) {
      var e_2, _b2;
      try {
        for (var _c = __values$6(this), _d = _c.next(); !_d.done; _d = _c.next()) {
          var value = _d.value;
          callbackFn.call(thisArg, value, value, this);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_d && !_d.done && (_b2 = _c.return))
            _b2.call(_c);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    };
    Object.defineProperty(ObservableSet2.prototype, "size", {
      get: function() {
        this._atom.reportObserved();
        return this._data.size;
      },
      enumerable: true,
      configurable: true
    });
    ObservableSet2.prototype.add = function(value) {
      var _this = this;
      checkIfStateModificationsAreAllowed(this._atom);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: "add",
          object: this,
          newValue: value
        });
        if (!change)
          return this;
      }
      if (!this.has(value)) {
        transaction(function() {
          _this._data.add(_this.enhancer(value, void 0));
          _this._atom.reportChanged();
        });
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          type: "add",
          object: this,
          newValue: value
        } : null;
        if (notify)
          notifyListeners(this, change);
      }
      return this;
    };
    ObservableSet2.prototype.delete = function(value) {
      var _this = this;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: "delete",
          object: this,
          oldValue: value
        });
        if (!change)
          return false;
      }
      if (this.has(value)) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          type: "delete",
          object: this,
          oldValue: value
        } : null;
        if (notifySpy && false)
          spyReportStart(__assign$3(__assign$3({}, change), { name: this.name }));
        transaction(function() {
          _this._atom.reportChanged();
          _this._data.delete(value);
        });
        if (notify)
          notifyListeners(this, change);
        return true;
      }
      return false;
    };
    ObservableSet2.prototype.has = function(value) {
      this._atom.reportObserved();
      return this._data.has(this.dehanceValue(value));
    };
    ObservableSet2.prototype.entries = function() {
      var nextIndex = 0;
      var keys2 = Array.from(this.keys());
      var values2 = Array.from(this.values());
      return makeIterable({
        next: function() {
          var index = nextIndex;
          nextIndex += 1;
          return index < values2.length ? { value: [keys2[index], values2[index]], done: false } : { done: true };
        }
      });
    };
    ObservableSet2.prototype.keys = function() {
      return this.values();
    };
    ObservableSet2.prototype.values = function() {
      this._atom.reportObserved();
      var self2 = this;
      var nextIndex = 0;
      var observableValues = Array.from(this._data.values());
      return makeIterable({
        next: function() {
          return nextIndex < observableValues.length ? { value: self2.dehanceValue(observableValues[nextIndex++]), done: false } : { done: true };
        }
      });
    };
    ObservableSet2.prototype.replace = function(other) {
      var _this = this;
      if (isObservableSet(other)) {
        other = other.toJS();
      }
      transaction(function() {
        if (Array.isArray(other)) {
          _this.clear();
          other.forEach(function(value) {
            return _this.add(value);
          });
        } else if (isES6Set(other)) {
          _this.clear();
          other.forEach(function(value) {
            return _this.add(value);
          });
        } else if (other !== null && other !== void 0) {
          fail("Cannot initialize set from " + other);
        }
      });
      return this;
    };
    ObservableSet2.prototype.observe = function(listener, fireImmediately) {
      return registerListener(this, listener);
    };
    ObservableSet2.prototype.intercept = function(handler) {
      return registerInterceptor(this, handler);
    };
    ObservableSet2.prototype.toJS = function() {
      return new Set(this);
    };
    ObservableSet2.prototype.toString = function() {
      return this.name + "[ " + Array.from(this).join(", ") + " ]";
    };
    ObservableSet2.prototype[_a$1$1 = $mobx, Symbol.iterator] = function() {
      return this.values();
    };
    return ObservableSet2;
  }()
);
var isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet);
var ObservableObjectAdministration = (
  /** @class */
  function() {
    function ObservableObjectAdministration2(target, values2, name2, defaultEnhancer) {
      if (values2 === void 0) {
        values2 = /* @__PURE__ */ new Map();
      }
      this.target = target;
      this.values = values2;
      this.name = name2;
      this.defaultEnhancer = defaultEnhancer;
      this.keysAtom = new Atom(name2 + ".keys");
    }
    ObservableObjectAdministration2.prototype.read = function(key) {
      return this.values.get(key).get();
    };
    ObservableObjectAdministration2.prototype.write = function(key, newValue) {
      var instance = this.target;
      var observable2 = this.values.get(key);
      if (observable2 instanceof ComputedValue) {
        observable2.set(newValue);
        return;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: "update",
          object: this.proxy || instance,
          name: key,
          newValue
        });
        if (!change)
          return;
        newValue = change.newValue;
      }
      newValue = observable2.prepareNewValue(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notify = hasListeners(this);
        var notifySpy = isSpyEnabled();
        var change = notify || notifySpy ? {
          type: "update",
          object: this.proxy || instance,
          oldValue: observable2.value,
          name: key,
          newValue
        } : null;
        if (notifySpy && false)
          spyReportStart(__assign$3(__assign$3({}, change), { name: this.name, key }));
        observable2.setNewValue(newValue);
        if (notify)
          notifyListeners(this, change);
      }
    };
    ObservableObjectAdministration2.prototype.has = function(key) {
      var map2 = this.pendingKeys || (this.pendingKeys = /* @__PURE__ */ new Map());
      var entry = map2.get(key);
      if (entry)
        return entry.get();
      else {
        var exists = !!this.values.get(key);
        entry = new ObservableValue(exists, referenceEnhancer, this.name + "." + stringifyKey(key) + "?", false);
        map2.set(key, entry);
        return entry.get();
      }
    };
    ObservableObjectAdministration2.prototype.addObservableProp = function(propName, newValue, enhancer) {
      if (enhancer === void 0) {
        enhancer = this.defaultEnhancer;
      }
      var target = this.target;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy || target,
          name: propName,
          type: "add",
          newValue
        });
        if (!change)
          return;
        newValue = change.newValue;
      }
      var observable2 = new ObservableValue(newValue, enhancer, this.name + "." + stringifyKey(propName), false);
      this.values.set(propName, observable2);
      newValue = observable2.value;
      Object.defineProperty(target, propName, generateObservablePropConfig(propName));
      this.notifyPropertyAddition(propName, newValue);
    };
    ObservableObjectAdministration2.prototype.addComputedProp = function(propertyOwner, propName, options2) {
      var target = this.target;
      options2.name = options2.name || this.name + "." + stringifyKey(propName);
      this.values.set(propName, new ComputedValue(options2));
      if (propertyOwner === target || isPropertyConfigurable(propertyOwner, propName))
        Object.defineProperty(propertyOwner, propName, generateComputedPropConfig(propName));
    };
    ObservableObjectAdministration2.prototype.remove = function(key) {
      if (!this.values.has(key))
        return;
      var target = this.target;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy || target,
          name: key,
          type: "remove"
        });
        if (!change)
          return;
      }
      try {
        startBatch();
        var notify = hasListeners(this);
        var notifySpy = isSpyEnabled();
        var oldObservable = this.values.get(key);
        var oldValue = oldObservable && oldObservable.get();
        oldObservable && oldObservable.set(void 0);
        this.keysAtom.reportChanged();
        this.values.delete(key);
        if (this.pendingKeys) {
          var entry = this.pendingKeys.get(key);
          if (entry)
            entry.set(false);
        }
        delete this.target[key];
        var change = notify || notifySpy ? {
          type: "remove",
          object: this.proxy || target,
          oldValue,
          name: key
        } : null;
        if (notifySpy && false)
          spyReportStart(__assign$3(__assign$3({}, change), { name: this.name, key }));
        if (notify)
          notifyListeners(this, change);
        if (notifySpy && false)
          spyReportEnd();
      } finally {
        endBatch();
      }
    };
    ObservableObjectAdministration2.prototype.illegalAccess = function(owner, propName) {
      console.warn("Property '" + propName + "' of '" + owner + "' was accessed through the prototype chain. Use 'decorate' instead to declare the prop or access it statically through it's owner");
    };
    ObservableObjectAdministration2.prototype.observe = function(callback, fireImmediately) {
      return registerListener(this, callback);
    };
    ObservableObjectAdministration2.prototype.intercept = function(handler) {
      return registerInterceptor(this, handler);
    };
    ObservableObjectAdministration2.prototype.notifyPropertyAddition = function(key, newValue) {
      var notify = hasListeners(this);
      var notifySpy = isSpyEnabled();
      var change = notify || notifySpy ? {
        type: "add",
        object: this.proxy || this.target,
        name: key,
        newValue
      } : null;
      if (notify)
        notifyListeners(this, change);
      if (this.pendingKeys) {
        var entry = this.pendingKeys.get(key);
        if (entry)
          entry.set(true);
      }
      this.keysAtom.reportChanged();
    };
    ObservableObjectAdministration2.prototype.getKeys = function() {
      var e_1, _a2;
      this.keysAtom.reportObserved();
      var res = [];
      try {
        for (var _b2 = __values$6(this.values), _c = _b2.next(); !_c.done; _c = _b2.next()) {
          var _d = __read$f(_c.value, 2), key = _d[0], value = _d[1];
          if (value instanceof ObservableValue)
            res.push(key);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b2.return))
            _a2.call(_b2);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return res;
    };
    return ObservableObjectAdministration2;
  }()
);
function asObservableObject(target, name2, defaultEnhancer) {
  if (name2 === void 0) {
    name2 = "";
  }
  if (defaultEnhancer === void 0) {
    defaultEnhancer = deepEnhancer;
  }
  if (Object.prototype.hasOwnProperty.call(target, $mobx))
    return target[$mobx];
  if (!isPlainObject$1(target))
    name2 = (target.constructor.name || "ObservableObject") + "@" + getNextId();
  if (!name2)
    name2 = "ObservableObject@" + getNextId();
  var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), stringifyKey(name2), defaultEnhancer);
  addHiddenProp(target, $mobx, adm);
  return adm;
}
var observablePropertyConfigs = /* @__PURE__ */ Object.create(null);
var computedPropertyConfigs = /* @__PURE__ */ Object.create(null);
function generateObservablePropConfig(propName) {
  return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {
    configurable: true,
    enumerable: true,
    get: function() {
      return this[$mobx].read(propName);
    },
    set: function(v) {
      this[$mobx].write(propName, v);
    }
  });
}
function getAdministrationForComputedPropOwner(owner) {
  var adm = owner[$mobx];
  if (!adm) {
    initializeInstance(owner);
    return owner[$mobx];
  }
  return adm;
}
function generateComputedPropConfig(propName) {
  return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {
    configurable: globalState.computedConfigurable,
    enumerable: false,
    get: function() {
      return getAdministrationForComputedPropOwner(this).read(propName);
    },
    set: function(v) {
      getAdministrationForComputedPropOwner(this).write(propName, v);
    }
  });
}
var isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function isObservableObject(thing) {
  if (isObject$1(thing)) {
    initializeInstance(thing);
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== void 0)
        fail(false);
      return thing[$mobx].atom;
    }
    if (isObservableSet(thing)) {
      return thing[$mobx];
    }
    if (isObservableMap(thing)) {
      var anyThing = thing;
      if (property === void 0)
        return anyThing._keysAtom;
      var observable2 = anyThing._data.get(property) || anyThing._hasMap.get(property);
      if (!observable2)
        fail(false);
      return observable2;
    }
    initializeInstance(thing);
    if (property && !thing[$mobx])
      thing[property];
    if (isObservableObject(thing)) {
      if (!property)
        return fail(false);
      var observable2 = thing[$mobx].values.get(property);
      if (!observable2)
        fail(false);
      return observable2;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (typeof thing === "function") {
    if (isReaction(thing[$mobx])) {
      return thing[$mobx];
    }
  }
  return fail(false);
}
function getAdministration(thing, property) {
  if (!thing)
    fail("Expecting some object");
  if (property !== void 0)
    return getAdministration(getAtom(thing, property));
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing))
    return thing;
  if (isObservableMap(thing) || isObservableSet(thing))
    return thing;
  initializeInstance(thing);
  if (thing[$mobx])
    return thing[$mobx];
  fail(false);
}
function getDebugName(thing, property) {
  var named;
  if (property !== void 0)
    named = getAtom(thing, property);
  else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing))
    named = getAdministration(thing);
  else
    named = getAtom(thing);
  return named.name;
}
var toString$1 = Object.prototype.toString;
function deepEqual(a2, b2, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a2, b2, depth);
}
function eq(a2, b2, depth, aStack, bStack) {
  if (a2 === b2)
    return a2 !== 0 || 1 / a2 === 1 / b2;
  if (a2 == null || b2 == null)
    return false;
  if (a2 !== a2)
    return b2 !== b2;
  var type2 = typeof a2;
  if (type2 !== "function" && type2 !== "object" && typeof b2 != "object")
    return false;
  var className = toString$1.call(a2);
  if (className !== toString$1.call(b2))
    return false;
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a2 === "" + b2;
    case "[object Number]":
      if (+a2 !== +a2)
        return +b2 !== +b2;
      return +a2 === 0 ? 1 / +a2 === 1 / b2 : +a2 === +b2;
    case "[object Date]":
    case "[object Boolean]":
      return +a2 === +b2;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a2) === Symbol.valueOf.call(b2);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a2 = unwrap(a2);
  b2 = unwrap(b2);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a2 != "object" || typeof b2 != "object")
      return false;
    var aCtor = a2.constructor, bCtor = b2.constructor;
    if (aCtor !== bCtor && !(typeof aCtor === "function" && aCtor instanceof aCtor && typeof bCtor === "function" && bCtor instanceof bCtor) && ("constructor" in a2 && "constructor" in b2)) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length2 = aStack.length;
  while (length2--) {
    if (aStack[length2] === a2)
      return bStack[length2] === b2;
  }
  aStack.push(a2);
  bStack.push(b2);
  if (areArrays) {
    length2 = a2.length;
    if (length2 !== b2.length)
      return false;
    while (length2--) {
      if (!eq(a2[length2], b2[length2], depth - 1, aStack, bStack))
        return false;
    }
  } else {
    var keys2 = Object.keys(a2);
    var key = void 0;
    length2 = keys2.length;
    if (Object.keys(b2).length !== length2)
      return false;
    while (length2--) {
      key = keys2[length2];
      if (!(has$1(b2, key) && eq(a2[key], b2[key], depth - 1, aStack, bStack)))
        return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a2) {
  if (isObservableArray(a2))
    return a2.slice();
  if (isES6Map(a2) || isObservableMap(a2))
    return Array.from(a2.entries());
  if (isES6Set(a2) || isObservableSet(a2))
    return Array.from(a2.entries());
  return a2;
}
function has$1(a2, key) {
  return Object.prototype.hasOwnProperty.call(a2, key);
}
function makeIterable(iterator2) {
  iterator2[Symbol.iterator] = getSelf;
  return iterator2;
}
function getSelf() {
  return this;
}
if (typeof Proxy === "undefined" || typeof Symbol === "undefined") {
  throw new Error("[mobx] MobX 5+ requires Proxy and Symbol objects. If your environment doesn't support Symbol or Proxy objects, please downgrade to MobX 4. For React Native Android, consider upgrading JSCore.");
}
(function() {
  function testCodeMinification() {
  }
  if (testCodeMinification.name !== "testCodeMinification" && false) {
    var varName = ["process", "env", "NODE_ENV"].join(".");
    console.warn("[mobx] you are running a minified build, but '" + varName + "' was not set to 'production' in your bundler. This results in an unnecessarily large and slow bundle");
  }
})();
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy,
    extras: {
      getDebugName
    },
    $mobx
  });
}
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
const defaults = {
  url: "",
  component: {
    height: 500,
    width: 500
  },
  e2e: {
    height: 660,
    width: 1e3
  }
};
class MobxRunnerStore {
  constructor(testingType) {
    this.specs = [];
    this.isLoading = true;
    this.canSaveStudioLogs = false;
    this.width = defaults[testingType].width;
    this.height = defaults[testingType].height;
  }
  setCanSaveStudioLogs(canSave) {
    this.canSaveStudioLogs = canSave;
  }
  setSpec(spec) {
    this.spec = spec;
    this.specRunId = nanoid();
  }
  checkCurrentSpecStillExists(specs) {
    const newSpecsAbsolutes = new Set(specs.map((spec) => spec.absolute));
    this.specs.forEach((oldSpec) => {
      var _a2;
      if (!newSpecsAbsolutes.has(oldSpec.absolute) && ((_a2 = this.spec) == null ? void 0 : _a2.absolute) === oldSpec.absolute) {
        this.spec = void 0;
      }
    });
  }
  setSpecs(specs) {
    this.checkCurrentSpecStillExists(specs);
    this.specs = specs;
  }
  setIsLoading(isLoading) {
    this.isLoading = isLoading;
  }
  updateDimensions(width, height) {
    this.height = height;
    this.width = width;
  }
}
__decorateClass([
  observable
], MobxRunnerStore.prototype, "spec", 2);
__decorateClass([
  observable
], MobxRunnerStore.prototype, "specs", 2);
__decorateClass([
  observable
], MobxRunnerStore.prototype, "specRunId", 2);
__decorateClass([
  observable
], MobxRunnerStore.prototype, "isLoading", 2);
__decorateClass([
  observable
], MobxRunnerStore.prototype, "width", 2);
__decorateClass([
  observable
], MobxRunnerStore.prototype, "height", 2);
__decorateClass([
  observable
], MobxRunnerStore.prototype, "automation", 2);
__decorateClass([
  observable
], MobxRunnerStore.prototype, "canSaveStudioLogs", 2);
__decorateClass([
  action
], MobxRunnerStore.prototype, "setCanSaveStudioLogs", 1);
__decorateClass([
  action
], MobxRunnerStore.prototype, "setSpec", 1);
__decorateClass([
  action
], MobxRunnerStore.prototype, "checkCurrentSpecStillExists", 1);
__decorateClass([
  action
], MobxRunnerStore.prototype, "setSpecs", 1);
__decorateClass([
  action
], MobxRunnerStore.prototype, "setIsLoading", 1);
__decorateClass([
  action
], MobxRunnerStore.prototype, "updateDimensions", 1);
function getMobxRunnerStore() {
  if (!mobxRunnerStore) {
    throw Error("mobxRunnerStore is undefined! Need to call initializeMobxStore");
  }
  return mobxRunnerStore;
}
const initializeMobxStore = (testingType) => {
  mobxRunnerStore = new MobxRunnerStore(testingType);
  return mobxRunnerStore;
};
let mobxRunnerStore;
const useSelectorPlaygroundStore = defineStore({
  id: "selector-playground-store",
  state: () => {
    return {
      show: false,
      getSelector: "body",
      containsSelector: "Hello, World",
      isShowingHighlight: false,
      isOpen: false,
      isEnabled: false,
      isValid: true,
      numElements: 0,
      method: "get"
    };
  },
  actions: {
    setShow(show) {
      this.show = show;
    },
    toggleMethod() {
      this.method = this.method === "get" ? "contains" : "get";
    },
    setEnabled(isEnabled) {
      this.isEnabled = isEnabled;
      if (!this.isEnabled) {
        this.isShowingHighlight = false;
      }
    },
    toggleOpen() {
      this.setOpen(!this.isOpen);
    },
    setOpen(isOpen) {
      this.isOpen = isOpen;
      this.setEnabled(this.isOpen);
    },
    setSelector(selector) {
      if (this.method === "get") {
        this.getSelector = selector;
      } else {
        this.containsSelector = selector;
      }
    },
    setShowingHighlight(isShowingHighlight) {
      this.isShowingHighlight = isShowingHighlight;
    },
    setNumElements(numElements) {
      this.numElements = numElements;
    },
    setValidity(isValid) {
      this.isValid = isValid;
    },
    setMethod(method) {
      this.method = method;
    },
    resetMethod() {
      this.method = "get";
    }
  },
  getters: {
    selector(state) {
      return state.method === "get" ? state.getSelector : state.containsSelector;
    },
    infoHelp(state) {
      if (!state.isValid) {
        return "Invalid selector";
      }
      return state.numElements === 1 ? "1 matched element" : `${state.numElements} matched elements`;
    },
    command(state) {
      return `cy.${state.method}('${this.selector}')`;
    }
  }
});
const useScreenshotStore = defineStore({
  id: "screenshot",
  state: () => {
    return {
      isScreenshotting: false
    };
  },
  actions: {
    setScreenshotting(isScreenshotting) {
      updateScreenshotStyles(isScreenshotting);
      this.isScreenshotting = isScreenshotting;
    }
  }
});
function updateScreenshotStyles(isScreenshotting) {
  if (isScreenshotting) {
    document.body.classList.add("is-screenshotting");
  } else {
    document.body.classList.remove("is-screenshotting");
  }
}
const createPinia = () => {
  return createPinia$1();
};
const RUNNER_ID = "unified-runner";
const REPORTER_ID = "unified-reporter";
function getRunnerElement() {
  const runnerElement = document.getElementById(RUNNER_ID);
  if (!runnerElement) {
    throw Error(`Expected runner element with #${RUNNER_ID} but did not find it.`);
  }
  return runnerElement;
}
function getReporterElement() {
  return document.getElementById(REPORTER_ID);
}
function empty(el) {
  while (el.lastChild) {
    if (el && el.firstChild) {
      el.removeChild(el.firstChild);
    }
  }
}
const togglePlayground = (autIframe) => {
  const selectorPlaygroundStore = useSelectorPlaygroundStore();
  if (selectorPlaygroundStore.show) {
    selectorPlaygroundStore.setShow(false);
    autIframe.toggleSelectorPlayground(false);
    selectorPlaygroundStore.setEnabled(false);
    selectorPlaygroundStore.setShowingHighlight(false);
    autIframe.toggleSelectorHighlight(false);
  } else {
    selectorPlaygroundStore.setShow(true);
    autIframe.toggleSelectorPlayground(true);
    selectorPlaygroundStore.setEnabled(true);
    selectorPlaygroundStore.setShowingHighlight(true);
    autIframe.toggleSelectorHighlight(true);
  }
};
function decodeBase64Unicode(str) {
  return decodeURIComponent(atob(str).split("").map((char) => {
    return `%${`00${char.charCodeAt(0).toString(16)}`.slice(-2)}`;
  }).join(""));
}
function getRunnerConfigFromWindow() {
  var _a2;
  return JSON.parse(decodeBase64Unicode((_a2 = window.__CYPRESS_CONFIG__) == null ? void 0 : _a2.base64Config));
}
let hasInitializeReporter = false;
function setInitializedReporter(val) {
  hasInitializeReporter = val;
}
async function unmountReporter() {
  window.UnifiedRunner.ReactDOM.unmountComponentAtNode(getReporterElement());
}
async function resetReporter() {
  if (hasInitializeReporter) {
    await getEventManager().resetReporter();
  }
}
function setupReporter() {
  const $reporterRoot = getReporterElement();
  if (hasInitializeReporter || !$reporterRoot)
    return;
  renderReporter($reporterRoot, getMobxRunnerStore(), getEventManager());
  hasInitializeReporter = true;
}
function renderReporter(root, store, eventManager) {
  const runnerUiStore = useRunnerUiStore();
  const specsStore = useSpecStore();
  const config2 = getRunnerConfigFromWindow();
  const reporter = window.UnifiedRunner.React.createElement(window.UnifiedRunner.Reporter, {
    runMode: "single",
    runner: eventManager.reporterBus,
    autoScrollingEnabled: runnerUiStore.autoScrollingEnabled,
    isSpecsListOpen: runnerUiStore.isSpecsListOpen,
    error: null,
    resetStatsOnSpecChange: true,
    // Studio can only be enabled for e2e testing
    studioEnabled: window.__CYPRESS_TESTING_TYPE__ === "e2e" && config2.experimentalStudio,
    runnerStore: store,
    testFilter: specsStore.testFilter
  });
  window.UnifiedRunner.ReactDOM.render(reporter, root);
}
const UnifiedReporterAPI = {
  unmountReporter,
  setupReporter,
  hasInitializeReporter,
  resetReporter,
  setInitializedReporter
};
const useSnapshotStore = defineStore({
  id: "snapshots",
  state: () => {
    return {
      messageTitle: void 0,
      isSnapshotPinned: false,
      snapshot: void 0,
      snapshotProps: void 0
    };
  },
  actions: {
    setSnapshotPinned(isSnapshotPinned) {
      this.isSnapshotPinned = isSnapshotPinned;
    },
    pinSnapshot(snapshotProps) {
      this.messageTitle = defaultMessages.runner.snapshot.pinnedTitle;
      this.isSnapshotPinned = true;
      this.snapshotProps = snapshotProps;
      this.snapshot = {
        showingHighlights: true,
        stateIndex: 0
      };
    },
    clearMessage() {
      this.messageTitle = void 0;
    },
    unpinSnapshot() {
      this.$reset();
    },
    showSnapshot(messageDescription = defaultMessages.runner.snapshot.defaultTitle) {
      this.messageTitle = messageDescription;
    },
    toggleHighlights(autIframe) {
      if (!this.snapshot) {
        return;
      }
      this.snapshot.showingHighlights = !this.snapshot.showingHighlights;
      this.updateHighlighting(autIframe);
    },
    updateHighlighting(autIframe) {
      if (!this.snapshot) {
        throw Error("Cannot update highlighting if this.snapshot not defined");
      }
      if (this.snapshot.showingHighlights && this.snapshotProps) {
        const snapshot = this.snapshotProps.snapshots[this.snapshot.stateIndex];
        autIframe.highlightEl(snapshot, this.snapshotProps);
      } else {
        autIframe.removeHighlights();
      }
    },
    changeState(index, autIframe) {
      var _a2;
      if (!this.snapshot) {
        throw Error("Cannot change state without first assigning this.snapshot");
      }
      const snapshot = (_a2 = this.snapshotProps) == null ? void 0 : _a2.snapshots[index];
      if (!snapshot) {
        throw Error(`Could not find snapshot index ${index}`);
      }
      this.snapshot.stateIndex = index;
      autIframe.restoreDom(snapshot);
      this.updateHighlighting(autIframe);
    },
    setTestsRunningError() {
      this.messageTitle = defaultMessages.runner.snapshot.testsRunningError;
    },
    setMessage(messageTitle) {
      this.messageTitle = messageTitle;
    },
    setMissingSnapshotMessage() {
      this.messageTitle = defaultMessages.runner.snapshot.snapshotMissingError;
    }
  }
});
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read$1 = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read$1, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name2) {
    var style = state.styles[name2] || {};
    var attributes = state.attributes[name2] || {};
    var element = state.elements[name2];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name3) {
      var value = attributes[name3];
      if (value === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name2) {
      var element = state.elements[name2];
      var attributes = state.attributes[name2] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE2 = /Trident/i.test(getUAString());
  if (isIE2 && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$12, value, max$12) {
  return max(min$12, min(value, max$12));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name2 = _ref.name, options2 = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options2.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options2 = _ref2.options;
  var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x2 = _ref.x, y2 = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options2 = _ref5.options;
  var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options2 = _ref.options;
  var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$12 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$12.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$12;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options2 = _ref.options, name2 = _ref.name;
  if (state.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name2]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name2 = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options2 = _ref2.options, name2 = _ref2.name;
  var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name2] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name2 = _ref.name;
  state.modifiersData[name2] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options2 = _ref.options, name2 = _ref.name;
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$12 = offset2 + overflow[mainSide];
    var max$12 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$12, tetherMin) : min$12, offset2, tether ? max(max$12, tetherMax) : max$12);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name2] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve3) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve3(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options2) {
    if (options2 === void 0) {
      options2 = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options22 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options22);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference22 = _state$elements.reference, popper22 = _state$elements.popper;
        if (!areValidElements(reference22, popper22)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference22, getOffsetParent(popper22), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper22)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name: name2,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve3) {
          instance.forceUpdate();
          resolve3(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options2).then(function(state2) {
      if (!isDestroyed && options2.onFirstUpdate) {
        options2.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name2 = _ref3.name, _ref3$options = _ref3.options, options22 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name: name2,
            instance,
            options: options22
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
const _hoisted_1$2 = ["onClick"];
const _hoisted_2$2 = {
  key: 0,
  class: "assertion-option-name"
};
const _hoisted_3$2 = {
  key: 1,
  class: "assertion-option-value"
};
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "AssertionOptions.ce",
  props: {
    type: null,
    options: null
  },
  emits: ["addAssertion", "setPopperElement"],
  setup(__props, { emit: emit3 }) {
    const props = __props;
    const truncate = (str) => {
      if (str && str.length > 80) {
        return `${str.substr(0, 77)}...`;
      }
      return str;
    };
    const popper2 = ref(null);
    onMounted(() => {
      nextTick(() => {
        const popperEl = popper2.value;
        const reference2 = popperEl.parentElement;
        createPopper(reference2, popperEl, {
          placement: "right-start"
        });
        emit3("setPopperElement", popperEl);
      });
    });
    const onClick = (name2, value) => {
      emit3("addAssertion", { type: props.type, name: name2, value });
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "popper",
        ref: popper2,
        class: "assertion-options"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, ({ name: name2, value }) => {
          return openBlock(), createElementBlock("div", {
            key: `${name2}${value}`,
            class: "assertion-option",
            onClick: withModifiers(() => onClick(name2, value), ["stop"])
          }, [
            name2 ? (openBlock(), createElementBlock("span", _hoisted_2$2, toDisplayString$1(truncate(name2)) + ":" + toDisplayString$1(" "), 1)) : (openBlock(), createElementBlock("span", _hoisted_3$2, toDisplayString$1(typeof value === "string" && truncate(value)), 1))
          ], 8, _hoisted_1$2);
        }), 128))
      ], 512);
    };
  }
});
const _style_0$3 = ".assertion-options {\n  background: #fff;\n  border: 1px solid #DDD;\n  box-shadow: 2px 5px 12px rgba(0, 0, 0, 0.2);\n  border-radius: 4px;\n  font-size: 14px;\n  max-width: 150px;\n  overflow: hidden;\n  overflow-wrap: break-word;\n  position: absolute;\n}\n.assertion-options .assertion-option {\n  cursor: pointer;\n  padding: 0.4rem 0.6rem;\n}\n.assertion-options .assertion-option:hover {\n  background-color: #e9ecef;\n}\n.assertion-options .assertion-option .assertion-option-value {\n  font-weight: 600;\n}";
const AssertionOptions = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["styles", [_style_0$3]]]);
const _hoisted_1$1 = ["onClick", "onMouseover", "onMouseout"];
const _hoisted_2$1 = { class: "assertion-type-text" };
const _hoisted_3$1 = {
  key: 0,
  class: "dropdown-arrow"
};
const _hoisted_4$1 = /* @__PURE__ */ createBaseVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  fill: "currentColor",
  viewBox: "0 0 16 16"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    fillRule: "evenodd",
    d: "M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"
  })
], -1);
const _hoisted_5$1 = [
  _hoisted_4$1
];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "AssertionType.ce",
  props: {
    type: null,
    options: null
  },
  emits: ["addAssertion"],
  setup(__props, { emit: emit3 }) {
    const props = __props;
    const isOpen = ref(false);
    const hasOptions = props.options && !!props.options.length;
    const popperElement = ref(null);
    const onOpen = () => {
      isOpen.value = true;
    };
    const onClose = (e) => {
      if (e.relatedTarget instanceof Element && popperElement.value && popperElement.value.contains(e.relatedTarget)) {
        return;
      }
      isOpen.value = false;
    };
    const onClick = () => {
      if (!hasOptions) {
        emit3("addAssertion", { type: props.type });
      }
    };
    const setPopperElement = (el) => {
      popperElement.value = el;
    };
    const addAssertion = ({ type: type2, name: name2, value }) => {
      emit3("addAssertion", { type: type2, name: name2, value });
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["assertion-type", { "single-assertion": !unref(hasOptions) }]),
        onClick: withModifiers(onClick, ["stop"]),
        onMouseover: withModifiers(onOpen, ["stop"]),
        onMouseout: withModifiers(onClose, ["stop"])
      }, [
        createBaseVNode("div", _hoisted_2$1, [
          createBaseVNode("span", null, toDisplayString$1(__props.type.replace(/\./g, " ")), 1),
          unref(hasOptions) ? (openBlock(), createElementBlock("span", _hoisted_3$1, _hoisted_5$1)) : createCommentVNode("", true)
        ]),
        unref(hasOptions) && isOpen.value ? (openBlock(), createBlock(AssertionOptions, {
          key: 0,
          type: __props.type,
          options: __props.options,
          onSetPopperElement: setPopperElement,
          onAddAssertion: addAssertion
        }, null, 8, ["type", "options"])) : createCommentVNode("", true)
      ], 42, _hoisted_1$1);
    };
  }
});
const _style_0$2 = ".assertion-type {\n  color: #202020;\n  cursor: default;\n  font-size: 14px;\n  padding: 0.4rem 0.4rem 0.4rem 0.7rem;\n  position: static;\n}\n.assertion-type:first-of-type {\n  padding-top: 0.5rem;\n}\n.assertion-type:last-of-type {\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  padding-bottom: 0.5rem;\n}\n.assertion-type:hover {\n  background-color: #e9ecef;\n}\n.assertion-type.single-assertion {\n  cursor: pointer;\n  font-weight: 600;\n}\n.assertion-type .assertion-type-text {\n  align-items: center;\n  display: flex;\n}\n.assertion-type .assertion-type-text .dropdown-arrow {\n  margin-left: auto;\n}";
const AssertionType = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["styles", [_style_0$2]]]);
const _hoisted_1 = { class: "header" };
const _hoisted_2 = /* @__PURE__ */ createBaseVNode("div", { class: "title" }, [
  /* @__PURE__ */ createBaseVNode("span", null, "Add Assertion")
], -1);
const _hoisted_3 = { class: "close-wrapper" };
const _hoisted_4 = ["onClick"];
const _hoisted_5 = { class: "assertions-list" };
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "AssertionsMenu.ce",
  props: {
    jqueryElement: null,
    possibleAssertions: null,
    addAssertion: null,
    closeMenu: { type: Function },
    highlightStyle: null
  },
  setup(__props) {
    const props = __props;
    const onAddAssertion = ({ type: type2, name: name2, value }) => {
      let args = [type2, name2, value];
      args = _$1.compact(args);
      props.addAssertion(props.jqueryElement, ...args);
    };
    const onClose = () => {
      props.closeMenu();
    };
    const tagName = `<${props.jqueryElement.prop("tagName").toLowerCase()}>`;
    const highlight = ref(null);
    const assertionsMenu = ref(null);
    onMounted(() => {
      nextTick(() => {
        const highlightEl = highlight.value;
        const assertionsMenuEl = assertionsMenu.value;
        createPopper(highlightEl, assertionsMenuEl, {
          modifiers: [
            {
              name: "preventOverflow",
              options: {
                altAxis: true
              }
            }
          ]
        });
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", {
          ref_key: "highlight",
          ref: highlight,
          class: "highlight",
          style: normalizeStyle(__props.highlightStyle)
        }, null, 4),
        createBaseVNode("div", {
          ref_key: "assertionsMenu",
          ref: assertionsMenu,
          class: "assertions-menu"
        }, [
          createBaseVNode("div", _hoisted_1, [
            _hoisted_2,
            createBaseVNode("div", _hoisted_3, [
              createBaseVNode("a", {
                class: "close",
                onClick: withModifiers(onClose, ["stop"])
              }, "", 8, _hoisted_4)
            ])
          ]),
          createBaseVNode("div", { class: "subtitle" }, [
            createTextVNode(" expect " + toDisplayString$1(" ") + " "),
            createBaseVNode("code", null, toDisplayString$1(tagName)),
            createTextVNode(" " + toDisplayString$1(" ") + " to ")
          ]),
          createBaseVNode("div", _hoisted_5, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(__props.possibleAssertions, (assertion) => {
              return openBlock(), createBlock(AssertionType, {
                key: assertion.type,
                type: assertion.type,
                options: assertion.options,
                onAddAssertion
              }, null, 8, ["type", "options"]);
            }), 128))
          ])
        ], 512)
      ], 64);
    };
  }
});
const _style_0$1 = '.highlight {\n  background: rgba(159, 196, 231, 0.6);\n  border: solid 2px #9FC4E7;\n  cursor: pointer;\n}\n.assertions-menu {\n  background: #fff;\n  border: 1px solid #DDD;\n  box-shadow: 2px 5px 12px rgba(0, 0, 0, 0.2);\n  border-radius: 4px;\n  font-family: "Helvetica Neue", "Arial", sans-serif;\n  z-index: 2147483647;\n  width: 175px;\n  position: absolute;\n}\n.assertions-menu .header {\n  align-items: center;\n  background: #07b282;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  color: #fff;\n  display: flex;\n  padding: 0.5rem 0.7rem;\n}\n.assertions-menu .header .title {\n  font-size: 14px;\n  font-weight: 600;\n}\n.assertions-menu .header .close-wrapper {\n  margin-left: auto;\n  margin-top: -2.5px;\n}\n.assertions-menu .header .close-wrapper .close {\n  font-size: 18px;\n  font-weight: 500;\n}\n.assertions-menu .header .close-wrapper .close:hover, .assertions-menu .header .close-wrapper .close:focus, .assertions-menu .header .close-wrapper .close:active {\n  cursor: pointer;\n  color: #eee;\n}\n.assertions-menu .subtitle {\n  border-bottom: 1px solid #c4c4c4;\n  color: #6b6b6b;\n  font-size: 13px;\n  font-style: italic;\n  font-weight: 400;\n  padding: 0.5rem 0.7rem;\n}\n.assertions-menu .subtitle code {\n  font-weight: 600;\n}';
const AssertionsMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["styles", [_style_0$1]]]);
const getElementDimensions = (el) => {
  const { offsetHeight, offsetWidth } = el;
  const paddingTop = getStylePropertyNumber(el, "padding-top");
  const paddingRight = getStylePropertyNumber(el, "padding-right");
  const paddingBottom = getStylePropertyNumber(el, "padding-bottom");
  const paddingLeft = getStylePropertyNumber(el, "padding-left");
  const borderTop = getStylePropertyNumber(el, "border-top-width");
  const borderRight = getStylePropertyNumber(el, "border-right-width");
  const borderBottom = getStylePropertyNumber(el, "border-bottom-width");
  const borderLeft = getStylePropertyNumber(el, "border-left-width");
  const marginTop = getStylePropertyNumber(el, "margin-top");
  const marginRight = getStylePropertyNumber(el, "margin-right");
  const marginBottom = getStylePropertyNumber(el, "margin-bottom");
  const marginLeft = getStylePropertyNumber(el, "margin-left");
  const width = offsetWidth - (paddingLeft + paddingRight + borderLeft + borderRight);
  const height = offsetHeight - (paddingTop + paddingBottom + borderTop + borderBottom);
  const heightWithPadding = height + paddingTop + paddingBottom;
  const heightWithBorder = heightWithPadding + borderTop + borderBottom;
  const heightWithMargin = heightWithBorder + marginTop + marginBottom;
  const widthWithPadding = width + paddingLeft + paddingRight;
  const widthWithBorder = widthWithPadding + borderLeft + borderRight;
  const widthWithMargin = widthWithBorder + marginLeft + marginRight;
  return {
    // offset disregards margin but takes into account border + padding
    offset: getOffset(el),
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    borderTop,
    borderRight,
    borderBottom,
    borderLeft,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    width,
    height,
    heightWithPadding,
    heightWithBorder,
    heightWithMargin,
    widthWithPadding,
    widthWithBorder,
    widthWithMargin
  };
};
const setOffset = (el, offset2) => {
  const curOffset = getOffset(el);
  const curTop = parseFloat(getComputedStyle(el, null).top);
  const curLeft = parseFloat(getComputedStyle(el, null).left);
  el.style.top = `${offset2.top - curOffset.top + curTop}px`;
  el.style.left = `${offset2.left - curOffset.left + curLeft}px`;
};
const getOffset = (el) => {
  const rect = el.getBoundingClientRect();
  const win = el.ownerDocument.defaultView;
  return {
    top: rect.top + win.scrollY,
    left: rect.left + win.scrollX
  };
};
const getStylePropertyNumber = (el, property) => {
  const value = parseFloat(getComputedStyle(el, null).getPropertyValue(property));
  if (isNaN(value)) {
    throw new Error("Element attr did not return a valid number");
  }
  return value;
};
const INT32_MAX = 2147483647;
function getZIndex(el) {
  const value = getComputedStyle(el, null).getPropertyValue("z-index");
  if (/^(auto|0)$/.test(value)) {
    return INT32_MAX;
  }
  return parseFloat(value);
}
function getOrCreateHelperDom({ body, className, css }) {
  let containers = body.querySelectorAll(`.${className}`);
  if (containers.length > 0) {
    const shadowRoot2 = containers[0].shadowRoot;
    return {
      container: containers[0],
      vueContainer: shadowRoot2.querySelector(".vue-container")
    };
  }
  const container = document.createElement("div");
  container.classList.add(className);
  container.style.position = "static";
  body.appendChild(container);
  const shadowRoot = container.attachShadow({ mode: "open" });
  const vueContainer = document.createElement("div");
  vueContainer.classList.add("vue-container");
  shadowRoot.appendChild(vueContainer);
  const style = document.createElement("style");
  style.innerHTML = css.toString();
  shadowRoot.prepend(style);
  return {
    container,
    vueContainer,
    shadowRoot
  };
}
function getSelectorHighlightStyles(elements) {
  const borderSize = 2;
  return elements.map((el) => {
    const offset2 = getOffset(el);
    return {
      position: "absolute",
      margin: `0px`,
      padding: `0px`,
      width: `${el.offsetWidth}px`,
      height: `${el.offsetHeight}px`,
      top: `${offset2.top - borderSize}px`,
      left: `${offset2.left - borderSize}px`,
      transform: getComputedStyle(el, null).transform,
      zIndex: getZIndex(el)
    };
  });
}
function getStudioAssertionsMenuDom(body) {
  return getOrCreateHelperDom({
    body,
    className: "__cypress-studio-assertions-menu",
    css: `${AssertionsMenu.styles}
${AssertionType.styles}
${AssertionOptions.styles}`
  });
}
function openStudioAssertionsMenu({ $el, $body, props }) {
  const { vueContainer } = getStudioAssertionsMenuDom($body.get(0));
  vueContainerListeners(vueContainer);
  const selectorHighlightStyles = getSelectorHighlightStyles([$el.get(0)])[0];
  mountAssertionsMenu(vueContainer, $el, props.possibleAssertions, props.addAssertion, props.closeMenu, selectorHighlightStyles);
}
function closeStudioAssertionsMenu($body) {
  const { container } = getStudioAssertionsMenuDom($body.get(0));
  unmountAssertionsMenu();
  container.remove();
}
let app$2 = null;
const mountAssertionsMenu = (container, jqueryElement, possibleAssertions, addAssertion, closeMenu, highlightStyle) => {
  app$2 = createApp(AssertionsMenu, {
    jqueryElement,
    possibleAssertions,
    addAssertion,
    closeMenu,
    highlightStyle
  });
  app$2.mount(container);
};
const unmountAssertionsMenu = () => {
  if (app$2) {
    app$2.unmount();
    app$2 = null;
  }
};
let lastTarget = null;
let lastTimeStamp = -1;
function vueContainerListeners(vueContainer) {
  vueContainer.addEventListener("click", (e) => {
    const paths = e.composedPath();
    for (let i = 0; i < paths.length; i++) {
      const el = paths[i];
      if (classIncludes(el, "single-assertion") || classIncludes(el, "assertion-option") || el.tagName === "A" && classIncludes(el, "close")) {
        el.dispatchEvent(new MouseEvent("click", e));
        break;
      }
    }
  });
  vueContainer.addEventListener("mouseover", (e) => {
    const paths = e.composedPath();
    for (let i = 0; i < paths.length; i++) {
      const el = paths[i];
      if (classIncludes(el, "assertion-type")) {
        el.dispatchEvent(new MouseEvent("mouseover", e));
        break;
      }
    }
  });
  vueContainer.addEventListener("mouseout", (e) => {
    if (lastTarget === e.target && lastTimeStamp - e.timeStamp < 100) {
      return;
    }
    lastTarget = e.target;
    lastTimeStamp = e.timeStamp;
    const paths = e.composedPath();
    for (let i = 0; i < paths.length; i++) {
      const el = paths[i];
      if (classIncludes(el, "assertion-type")) {
        el.dispatchEvent(new MouseEvent("mouseout", e));
        break;
      }
    }
  });
}
function classIncludes(el, className) {
  return typeof el.className === "string" && el.className.includes(className);
}
function getCypress() {
  const eventManager = getEventManager();
  return eventManager.getCypress();
}
function stringifyActual(val) {
  return Cypress.utils.stringifyActual(val);
}
const saveErrorMessage = (message) => {
  return `${message}

Cypress was unable to save these commands to your spec file. You can use the copy button below to copy the commands to your clipboard. 

Cypress Studio is still in beta and the team is working hard to resolve issues like this. To help us fix this issue more quickly, you can provide us with more information by clicking 'Learn more' below.`;
};
function assertNonNullish(value, message) {
  if (value === null || value === void 0) {
    throw Error(message);
  }
}
const eventTypes = [
  "click",
  // 'dblclick',
  "change",
  "keydown",
  "keyup"
];
const eventsWithValue = [
  "change",
  "keydown",
  "keyup"
];
const internalMouseEvents = [
  "mousedown",
  "mouseover",
  "mouseout"
];
const tagNamesWithoutText = [
  "SELECT",
  "INPUT",
  "TEXTAREA"
];
const tagNamesWithValue = [
  "BUTTON",
  "INPUT",
  "METER",
  "LI",
  "OPTION",
  "PROGRESS",
  "TEXTAREA"
];
const useStudioStore = defineStore("studioRecorder", {
  state: () => {
    return {
      saveModalIsOpen: false,
      instructionModalIsOpen: false,
      logs: [],
      url: "",
      isLoading: false,
      isActive: false,
      isFailed: false,
      _hasStarted: false,
      _currentId: 1
    };
  },
  actions: {
    setTestId(testId) {
      this.testId = testId;
    },
    setSuiteId(suiteId) {
      this.suiteId = suiteId;
      this.testId = void 0;
    },
    clearRunnableIds() {
      this.testId = void 0;
      this.suiteId = void 0;
    },
    openInstructionModal() {
      this.instructionModalIsOpen = true;
    },
    closeInstructionModal() {
      this.instructionModalIsOpen = false;
    },
    showSaveModal() {
      this.saveModalIsOpen = true;
    },
    closeSaveModal() {
      this.saveModalIsOpen = false;
    },
    startLoading() {
      this.isLoading = true;
    },
    setInactive() {
      this.isActive = false;
    },
    setUrl(url2) {
      this.url = url2;
    },
    testFailed() {
      this.isFailed = true;
    },
    initialize(config2, state) {
      const { studio } = state;
      if (studio) {
        if (studio.testId) {
          this.setTestId(studio.testId);
        }
        if (studio.suiteId) {
          this.setSuiteId(studio.suiteId);
        }
        if (studio.url) {
          this.setUrl(studio.url);
        }
      }
      if (this.testId || this.suiteId) {
        this.setAbsoluteFile(config2.spec.absolute);
        this.startLoading();
        if (this.suiteId) {
          getCypress().runner.setOnlySuiteId(this.suiteId);
        } else if (this.testId) {
          getCypress().runner.setOnlyTestId(this.testId);
        }
      }
    },
    interceptTest(test) {
      if (this.suiteId) {
        this.setTestId(test.id);
      }
      if (this.testId || this.suiteId) {
        if (test.invocationDetails) {
          this.setFileDetails(test.invocationDetails);
        }
        if (this.suiteId) {
          if (test.parent && test.parent.id !== "r1") {
            this.setRunnableTitle(test.parent.title);
          }
        } else {
          this.setRunnableTitle(test.title);
        }
      }
    },
    start(body) {
      this.isActive = true;
      this.isLoading = false;
      this.logs = [];
      this._currentId = 1;
      this._hasStarted = true;
      const autStore = useAutStore();
      if (this.url) {
        this.visitUrl();
      }
      if (!this.url && autStore.url) {
        this.setUrl(autStore.url);
      }
      this.attachListeners(body);
    },
    stop() {
      this.removeListeners();
      this.isActive = false;
      this.isLoading = false;
    },
    reset() {
      this.stop();
      this.logs = [];
      this.url = void 0;
      this._hasStarted = false;
      this._currentId = 1;
      this.isFailed = false;
    },
    cancel() {
      this.reset();
      this.clearRunnableIds();
    },
    startSave() {
      if (this.suiteId) {
        this.showSaveModal();
      } else {
        this.save();
      }
    },
    save(testName) {
      this.closeSaveModal();
      this.stop();
      assertNonNullish(this.absoluteFile, `absoluteFile should exist`);
      const payload = {
        fileDetails: this.fileDetails,
        absoluteFile: this.absoluteFile,
        runnableTitle: this.runnableTitle,
        commands: this.logs,
        isSuite: !!this.suiteId,
        isRoot: this.suiteId === "r1",
        testName
      };
      getEventManager().emit("studio:save", payload);
    },
    visitUrl(url2) {
      this.setUrl(url2 ?? this.url);
      getCypress().cy.visit(this.url);
      this.logs.push({
        id: this._getId(),
        selector: void 0,
        name: "visit",
        message: this.url
      });
    },
    _recordEvent(event) {
      var _a2;
      if (this.isFailed || !this._trustEvent(event))
        return;
      const $el = window.UnifiedRunner.CypressJQuery(event.target);
      if (this._isAssertionsMenu($el)) {
        return;
      }
      this._closeAssertionsMenu();
      if (!this._shouldRecordEvent(event, $el)) {
        return;
      }
      const name2 = this._getName(event, $el);
      const message = this._getMessage(event, $el);
      if (name2 === "change") {
        return;
      }
      let selector = "";
      if (name2 === "click" && this._matchPreviousMouseEvent($el)) {
        selector = (_a2 = this._previousMouseEvent) == null ? void 0 : _a2.selector;
      } else {
        selector = getCypress().SelectorPlayground.getSelector($el);
      }
      this._clearPreviousMouseEvent();
      if (name2 === "type" && !message) {
        return this._removeLastLogIfType(selector);
      }
      const updateOnly = this._updateLastLog(selector, name2, message);
      if (updateOnly) {
        return;
      }
      if (name2 === "type") {
        this._addClearLog(selector);
      }
      this._addLog({
        selector,
        name: name2,
        message
      });
    },
    _removeLastLogIfType(selector) {
      const lastLog = this.logs[this.logs.length - 1];
      if (lastLog.selector === selector && lastLog.name === "type") {
        return this.removeLog(lastLog.id);
      }
    },
    removeLog(commandId) {
      const index = this.logs.findIndex((command) => command.id === commandId);
      const log = this.logs[index];
      this.logs.splice(index, 1);
      this._generateBothLogs(log).forEach((commandLog) => {
        getEventManager().emit("reporter:log:remove", commandLog);
      });
    },
    _addLog(log) {
      log.id = this._getId();
      this.logs.push(log);
      this._generateBothLogs(log).forEach((commandLog) => {
        getEventManager().emit("reporter:log:add", commandLog);
      });
    },
    _addAssertion($el, ...args) {
      const id2 = this._getId();
      const selector = getCypress().SelectorPlayground.getSelector($el);
      const log = {
        id: id2,
        selector,
        name: "should",
        message: args,
        isAssertion: true
      };
      this.logs.push(log);
      const reporterLog = {
        id: id2,
        selector,
        name: "assert",
        message: this._generateAssertionMessage($el, ...args)
      };
      this._generateBothLogs(reporterLog).forEach((commandLog) => {
        getEventManager().emit("reporter:log:add", commandLog);
      });
      this._closeAssertionsMenu();
    },
    saveError(err) {
      return {
        id: this.testId,
        err: {
          ...err,
          message: saveErrorMessage(err.message),
          docsUrl: "https://on.cypress.io/studio-beta"
        }
      };
    },
    setFileDetails(fileDetails) {
      this.fileDetails = fileDetails;
    },
    setAbsoluteFile(absoluteFile) {
      this.absoluteFile = absoluteFile;
    },
    setRunnableTitle(runnableTitle) {
      this.runnableTitle = runnableTitle;
    },
    _clearPreviousMouseEvent() {
      this._previousMouseEvent = void 0;
    },
    _matchPreviousMouseEvent(el) {
      return this._previousMouseEvent && window.UnifiedRunner.CypressJQuery(el).is(this._previousMouseEvent.element);
    },
    attachListeners(body) {
      if (this.isFailed) {
        return;
      }
      this._body = body;
      for (const event of eventTypes) {
        this._body.addEventListener(event, this._recordEvent, {
          capture: true,
          passive: true
        });
      }
      for (const event of internalMouseEvents) {
        this._body.addEventListener(event, this._recordMouseEvent, {
          capture: true,
          passive: true
        });
      }
      this._body.addEventListener("contextmenu", this._openAssertionsMenu, {
        capture: true
      });
      this._clearPreviousMouseEvent();
    },
    removeListeners() {
      if (!this._body)
        return;
      for (const event of eventTypes) {
        this._body.removeEventListener(event, this._recordEvent, {
          capture: true
        });
      }
      for (const event of internalMouseEvents) {
        this._body.removeEventListener(event, this._recordMouseEvent, {
          capture: true
        });
      }
      this._body.removeEventListener("contextmenu", this._openAssertionsMenu, {
        capture: true
      });
      this._clearPreviousMouseEvent();
    },
    copyToClipboard(commandsText) {
      if (window.isSecureContext && navigator.clipboard) {
        return navigator.clipboard.writeText(commandsText);
      }
      const textArea = document.createElement("textarea");
      textArea.value = commandsText;
      textArea.style.position = "fixed";
      textArea.style.opacity = "0";
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand("copy");
      textArea.remove();
      return Promise.resolve();
    },
    _trustEvent(event) {
      return event.isTrusted || getCypress().env("INTERNAL_E2E_TESTS") === 1;
    },
    _recordMouseEvent(event) {
      if (!this._trustEvent(event))
        return;
      const { type: type2, target } = event;
      if (type2 === "mouseout") {
        return this._clearPreviousMouseEvent();
      }
      if (!this._matchPreviousMouseEvent(target)) {
        this._previousMouseEvent = {
          element: target,
          selector: getCypress().SelectorPlayground.getSelector(window.UnifiedRunner.CypressJQuery(target))
        };
      }
    },
    _getId() {
      return this._currentId++;
    },
    _getName(event, $el) {
      const tagName = $el.prop("tagName");
      const { type: type2 } = event;
      if (tagName === "SELECT" && type2 === "change") {
        return "select";
      }
      if (type2 === "keydown" || type2 === "keyup") {
        return "type";
      }
      if (type2 === "click" && tagName === "INPUT") {
        const inputType = $el.prop("type");
        const checked = $el.prop("checked");
        if (inputType === "radio" || inputType === "checkbox" && checked) {
          return "check";
        }
        if (inputType === "checkbox") {
          return "uncheck";
        }
      }
      return type2;
    },
    _getMessage(event, $el) {
      if (!eventsWithValue.includes(event.type)) {
        return void 0;
      }
      let val = $el.val();
      if (event.type === "keydown" || event.type === "keyup") {
        val = val.replace(/{/g, "{{}");
        if (event.key === "Enter") {
          val = `${val}{enter}`;
        }
      }
      return val;
    },
    _shouldRecordEvent(event, $el) {
      const tagName = $el.prop("tagName");
      if ((event.type === "keydown" || event.type === "keyup") && tagName !== "INPUT") {
        return false;
      }
      if (event.type === "keyup" && event.key === "Enter") {
        return false;
      }
      if (event.type === "keydown" && event.key !== "Enter") {
        return false;
      }
      if (tagName === "SELECT" && event.type === "click") {
        return false;
      }
      if (tagName === "OPTION") {
        return false;
      }
      return true;
    },
    _generateLog({ id: id2, name: name2, message, type: type2, number: number2 }) {
      return {
        id: id2,
        testId: this.testId,
        hookId: this.hookId,
        name: name2,
        message: message ? stringifyActual(message) : void 0,
        type: type2,
        state: "passed",
        instrument: "command",
        number: number2,
        numElements: 1,
        isStudio: true
      };
    },
    _generateBothLogs(log) {
      return [
        this._generateLog({
          id: `s${log.id}-get`,
          name: "get",
          message: log.selector,
          type: "parent",
          number: log.id
        }),
        this._generateLog({
          id: `s${log.id}`,
          name: log.name,
          message: log.message,
          type: "child"
        })
      ];
    },
    _addClearLog(selector) {
      const lastLog = this.logs[this.logs.length - 1];
      if (lastLog && lastLog.name === "clear" && lastLog.selector === selector) {
        return;
      }
      this._addLog({
        selector,
        name: "clear",
        message: void 0
      });
    },
    _updateLog(log) {
      const { id: id2, name: name2, message } = log;
      getEventManager().emit("reporter:log:state:changed", this._generateLog({
        id: `s${id2}`,
        name: name2,
        message,
        type: "child"
      }));
    },
    _updateLastLog(selector, name2, message) {
      const { length: length2 } = this.logs;
      if (!length2) {
        return false;
      }
      const lastLog = this.logs[length2 - 1];
      const updateLog = (newName = name2, newMessage = message) => {
        lastLog.message = newMessage;
        lastLog.name = newName;
        this._updateLog(lastLog);
      };
      if (selector === lastLog.selector) {
        if (name2 === "type" && lastLog.name === "type") {
          updateLog();
          return true;
        }
        if (name2 === "type" && lastLog.name === "click") {
          updateLog("clear", void 0);
          return false;
        }
      }
      return false;
    },
    _generateAssertionMessage($el, ...args) {
      const elementString = stringifyActual($el);
      const assertionString = args[0].replace(/\./g, " ");
      let message = `expected **${elementString}** to ${assertionString}`;
      if (args[1]) {
        message = `${message} **${args[1]}**`;
      }
      if (args[2]) {
        message = `${message} with the value **${args[2]}**`;
      }
      return message;
    },
    _isAssertionsMenu($el) {
      return $el.hasClass("__cypress-studio-assertions-menu");
    },
    _openAssertionsMenu(event) {
      if (!this._body) {
        throw Error("this._body was not defined");
      }
      event.preventDefault();
      event.stopPropagation();
      const $el = window.UnifiedRunner.CypressJQuery(event.target);
      if (this._isAssertionsMenu($el)) {
        return;
      }
      this._closeAssertionsMenu();
      openStudioAssertionsMenu({
        $el,
        $body: window.UnifiedRunner.CypressJQuery(this._body),
        props: {
          possibleAssertions: this._generatePossibleAssertions($el),
          addAssertion: this._addAssertion,
          closeMenu: this._closeAssertionsMenu
        }
      });
    },
    _closeAssertionsMenu() {
      if (!this._body) {
        throw Error("this._body was not defined");
      }
      closeStudioAssertionsMenu(window.UnifiedRunner.CypressJQuery(this._body));
    },
    _generatePossibleAssertions($el) {
      const tagName = $el.prop("tagName");
      const possibleAssertions = [];
      if (!tagNamesWithoutText.includes(tagName)) {
        const text = $el.text();
        if (text) {
          possibleAssertions.push({
            type: "have.text",
            options: [{
              value: text
            }]
          });
        }
      }
      if (tagNamesWithValue.includes(tagName)) {
        const val = $el.val();
        if (val !== void 0 && val !== "") {
          possibleAssertions.push({
            type: "have.value",
            options: [{
              value: val
            }]
          });
        }
      }
      const attributes = Array.from($el[0].attributes).reduce((acc, { name: name2, value }) => {
        if (name2 === "value" || name2 === "disabled") {
          return acc;
        }
        if (name2 === "class") {
          possibleAssertions.push({
            type: "have.class",
            options: value.split(" ").map((value2) => ({ value: value2 }))
          });
          return acc;
        }
        if (name2 === "id") {
          possibleAssertions.push({
            type: "have.id",
            options: [{
              value
            }]
          });
          return acc;
        }
        if (name2 !== void 0 && name2 !== "" && value !== void 0 && value !== "") {
          return acc.concat({
            name: name2,
            value
          });
        }
        return acc;
      }, []);
      if (attributes.length > 0) {
        possibleAssertions.push({
          type: "have.attr",
          options: attributes
        });
      }
      possibleAssertions.push({
        type: "be.visible"
      });
      const isDisabled = $el.prop("disabled");
      if (isDisabled !== void 0) {
        possibleAssertions.push({
          type: isDisabled ? "be.disabled" : "be.enabled"
        });
      }
      const isChecked = $el.prop("checked");
      if (isChecked !== void 0) {
        possibleAssertions.push({
          type: isChecked ? "be.checked" : "not.be.checked"
        });
      }
      return possibleAssertions;
    }
  },
  getters: {
    hasRunnableId(state) {
      return !!state.testId || !!state.suiteId;
    },
    isOpen: (state) => {
      return state.isActive || state.isLoading || state._hasStarted;
    },
    isEmpty: (state) => {
      return state.logs.length === 0;
    },
    isReady(state) {
      return this.isOpen && this.isEmpty && !state.isLoading && !state.isFailed;
    },
    hookId: (state) => {
      return `${state.testId}-studio`;
    },
    needsUrl: (state) => {
      return state.isActive && !state.url && !state.isFailed;
    },
    testError: (state) => {
      return {
        id: state.testId,
        state: "failed"
      };
    }
  }
});
class IframeModel {
  constructor(detachDom, restoreDom, highlightEl, isAUTSameOrigin, eventManager, studio) {
    this.detachDom = detachDom;
    this.restoreDom = restoreDom;
    this.highlightEl = highlightEl;
    this.isAUTSameOrigin = isAUTSameOrigin;
    this.eventManager = eventManager;
    this.studio = studio;
    this.isSnapshotPinned = false;
    this._beforeRun = () => {
      const autStore = useAutStore();
      autStore.setIsLoading(false);
      autStore.setIsRunning(true);
      autStore.resetUrl();
      this._reset();
    };
    this._afterRun = () => {
      const autStore = useAutStore();
      autStore.setIsRunning(false);
    };
    this._updateViewport = ({ viewportWidth, viewportHeight }, cb) => {
      const autStore = useAutStore();
      autStore.updateDimensions(viewportWidth, viewportHeight);
      if (cb) {
        autStore.setViewportUpdatedCallback(cb);
      }
    };
    this._updateLoadingUrl = (isLoadingUrl) => {
      const autStore = useAutStore();
      autStore.setIsLoadingUrl(isLoadingUrl);
    };
    this.setSnapshots = (snapshotProps) => {
      const snapshotStore = useSnapshotStore();
      const autStore = useAutStore();
      const studioStore = useStudioStore();
      if (snapshotStore.isSnapshotPinned) {
        return;
      }
      if (autStore.isRunning) {
        return snapshotStore.setTestsRunningError();
      }
      if (studioStore.isOpen) {
        return this._studioOpenError();
      }
      const { snapshots } = snapshotProps;
      if (!snapshots || !snapshots.length) {
        this._clearSnapshots();
        snapshotStore.setMissingSnapshotMessage();
        return;
      }
      autStore.setHighlightUrl(false);
      if (!this.originalState) {
        this._storeOriginalState();
      }
      this.detachedId = snapshotProps.id;
      this._updateViewport(snapshotProps);
      autStore.updateUrl(snapshotProps.url);
      clearInterval(this.intervalId);
      if (snapshots.length > 1) {
        let i = 0;
        this.intervalId = window.setInterval(() => {
          if (this.isSnapshotPinned)
            return;
          i += 1;
          if (!snapshots[i]) {
            i = 0;
          }
          this._showSnapshotVue(snapshots[i], snapshotProps);
        }, 800);
      }
      this._showSnapshotVue(snapshots[0], snapshotProps);
    };
    this._showSnapshotVue = (snapshot, snapshotProps) => {
      const snapshotStore = useSnapshotStore();
      snapshotStore.showSnapshot(snapshot.name);
      this._restoreDom(snapshot, snapshotProps);
    };
    this._clearSnapshots = () => {
      const snapshotStore = useSnapshotStore();
      const autStore = useAutStore();
      if (snapshotStore.isSnapshotPinned)
        return;
      clearInterval(this.intervalId);
      autStore.setHighlightUrl(false);
      if (!this.originalState || !this.originalState.body) {
        return snapshotStore.clearMessage();
      }
      const previousDetachedId = this.detachedId;
      setTimeout(() => {
        if (!this.originalState) {
          return;
        }
        if (previousDetachedId !== this.detachedId)
          return;
        this._updateViewport(this.originalState);
        autStore.updateUrl(this.originalState.url);
        this.restoreDom(this.originalState.snapshot);
        snapshotStore.clearMessage();
        this.originalState = void 0;
        this.detachedId = void 0;
      });
    };
    this._pinSnapshot = (snapshotProps) => {
      const snapshotStore = useSnapshotStore();
      const { snapshots } = snapshotProps;
      if (!snapshots || !snapshots.length) {
        this.eventManager.snapshotUnpinned();
        snapshotStore.setMissingSnapshotMessage();
        return;
      }
      snapshotStore.pinSnapshot(snapshotProps);
      clearInterval(this.intervalId);
      this._restoreDom(snapshots[0], snapshotProps);
    };
    this._unpinSnapshot = () => {
      useSnapshotStore().$reset();
    };
    this._reset();
  }
  listen() {
    this.eventManager.on("run:start", this._beforeRun);
    this.eventManager.on("run:end", this._afterRun);
    this.eventManager.on("viewport:changed", this._updateViewport);
    this.eventManager.on("config", (config2) => {
      const { viewportWidth, viewportHeight } = config2;
      return this._updateViewport({ viewportHeight, viewportWidth });
    });
    const autStore = useAutStore();
    this.eventManager.on("url:changed", (url2) => {
      autStore.updateUrl(url2);
    });
    this.eventManager.on("page:loading", this._updateLoadingUrl);
    this.eventManager.on("show:snapshot", this.setSnapshots);
    this.eventManager.on("hide:snapshot", this._clearSnapshots);
    this.eventManager.on("pin:snapshot", this._pinSnapshot);
    this.eventManager.on("unpin:snapshot", this._unpinSnapshot);
  }
  _restoreDom(snapshot, snapshotProps) {
    this.restoreDom(snapshot);
    if (snapshotProps.$el) {
      this.highlightEl(snapshot, snapshotProps);
    }
  }
  _studioOpenError() {
    const snapshotStore = useSnapshotStore();
    snapshotStore.setMessage(
      defaultMessages.runner.snapshot.studioActiveError
    );
  }
  _storeOriginalState() {
    const autStore = useAutStore();
    if (!this.isAUTSameOrigin()) {
      const Cypress2 = this.eventManager.getCypress();
      Cypress2.primaryOriginCommunicator.toAllSpecBridges("generate:final:snapshot", autStore.url || "");
      Cypress2.primaryOriginCommunicator.once("snapshot:final:generated", (finalSnapshot2) => {
        this.originalState = {
          body: finalSnapshot2.body,
          htmlAttrs: finalSnapshot2.htmlAttrs,
          snapshot: finalSnapshot2,
          snapshots: [],
          url: autStore.url || "",
          // TODO: use same attr for both runner and runner-ct states.
          // these refer to the same thing - the viewport dimensions.
          viewportWidth: autStore.viewportWidth,
          viewportHeight: autStore.viewportHeight
        };
      });
      return;
    }
    const finalSnapshot = this.detachDom();
    if (!finalSnapshot)
      return;
    const { body, htmlAttrs } = finalSnapshot;
    this.originalState = {
      body,
      htmlAttrs,
      snapshot: finalSnapshot,
      snapshots: [],
      url: autStore.url || "",
      // TODO: UNIFY-1318 - use same attr for both runner and runner-ct states.
      // these refer to the same thing - the viewport dimensions.
      viewportWidth: autStore.viewportWidth,
      viewportHeight: autStore.viewportHeight
    };
  }
  _reset() {
    this.detachedId = void 0;
    this.intervalId = void 0;
    this.originalState = void 0;
    useSnapshotStore().$reset();
  }
}
const svgCy = `<svg data-cy="cypress-logo" width="49" height="48" viewBox="0 0 49 48" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M17.7571 19.0494C19.6992 19.0494 21.2811 20.085 22.094 21.8915L22.1583 22.0329L25.42 20.9253L25.3505 20.7583C24.0875 17.6823 21.1783 15.7704 17.7571 15.7704C15.352 15.7704 13.397 16.5414 11.7816 18.1243C10.1765 19.697 9.36366 21.6757 9.36366 24.0064C9.36366 26.3166 10.1765 28.285 11.7816 29.8577C13.397 31.4407 15.352 32.2116 17.7571 32.2116C21.1783 32.2116 24.0875 30.2997 25.3505 27.2263L25.42 27.0593L22.1531 25.9491L22.0914 26.0956C21.3635 27.8713 19.7429 28.9326 17.7571 28.9326C16.4041 28.9326 15.2619 28.4598 14.3565 27.5295C13.4407 26.5864 12.9777 25.4018 12.9777 24.009C12.9777 22.6059 13.4304 21.4444 14.3565 20.4576C15.2594 19.5222 16.4041 19.0494 17.7571 19.0494Z" fill="#BFC2D4"/>
<path d="M38.1863 16.0737L33.5381 27.8353L28.8591 16.0737H25.0315L31.5934 32.1268L26.9247 43.449L26.7081 43.963C26.559 44.3224 26.2335 44.5752 25.8578 44.6273C25.5338 44.6423 25.2078 44.65 24.8801 44.65C24.8124 44.65 24.7448 44.6497 24.6773 44.649C13.366 44.5402 4.23013 35.337 4.23013 24C4.23013 12.5953 13.4754 3.35 24.8801 3.35C36.2848 3.35 45.5301 12.5953 45.5301 24C45.5301 32.5719 40.3072 39.924 32.8701 43.0474L31.6574 45.9958C31.4788 46.43 31.2556 46.8377 30.9942 47.2142C41.2877 44.5105 48.8801 35.1419 48.8801 24C48.8801 10.7452 38.135 0 24.8801 0C11.6253 0 0.880127 10.7452 0.880127 24C0.880127 37.1872 11.5158 47.8902 24.6773 47.9992C24.7048 47.9994 25.8997 47.9794 25.8978 47.9794C27.6161 47.9075 29.1518 46.8308 29.8077 45.235L30.3495 43.9179L41.8029 16.0737H38.1863Z" fill="#BFC2D4"/>
</svg>
`;
const svgWarning = `<svg viewBox="0 0 32 30"><path d="M18.286 24.554v-3.393q0-0.25-0.17-0.42t-0.402-0.17h-3.429q-0.232 0-0.402 0.17t-0.17 0.42v3.393q0 0.25 0.17 0.42t0.402 0.17h3.429q0.232 0 0.402-0.17t0.17-0.42zM18.25 17.875l0.321-8.196q0-0.214-0.179-0.339-0.232-0.196-0.429-0.196h-3.929q-0.196 0-0.429 0.196-0.179 0.125-0.179 0.375l0.304 8.161q0 0.179 0.179 0.295t0.429 0.116h3.304q0.25 0 0.42-0.116t0.188-0.295zM18 1.196l13.714 25.143q0.625 1.125-0.036 2.25-0.304 0.518-0.83 0.821t-1.134 0.304h-27.429q-0.607 0-1.134-0.304t-0.83-0.821q-0.661-1.125-0.036-2.25l13.714-25.143q0.304-0.554 0.839-0.875t1.161-0.321 1.161 0.321 0.839 0.875z"></path></svg>`;
const defaultStyles = `
  body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img,a img{border:none;}address,caption,cite,code,dfn,em,strong,th,var,optgroup{font-style:inherit;font-weight:inherit;}del,ins{text-decoration:none;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:'';}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:baseline;}sub{vertical-align:baseline;}legend{color:#000;}

  * {
    box-sizing: border-box;
  }

  body {
    color: #1b1e2e;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.4;
    padding: 20px;
    width: 100%;
    height: 100%;
  }

  .container {
    background-color: #f3f4fa;
    border-radius: 8px;
    border: 2px dashed #e1e3ed;
    padding: 32px 16px;
    text-align: center;
    height: 100%;
  }

  svg {
    display: inline-block;
    stroke-width: 0;
    stroke: currentColor;
    fill: currentColor;
    margin: 16px 0;
    width: 64px;
  }

  p {
    font-size: 21px;
    font-weight: 200;
    line-height: 1.4;
  }

  a,
  a:hover,
  a:focus,
  a:active {
    color: currentColor;
    text-decoration: underline;
  }
`;
const blankStyles = `
  * { 
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
    min-height: 100vh;
    background-color: #f3f4fa;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  svg {
    display: inline-block;
    stroke-width: 0;
    margin: 0 0 24px;
  }

  .inner-container {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    margin: 32px;
  }

  .text {
    font-style: normal;
    font-weight: 500;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    color: #2E3247;
    margin: 0 0 4px;
  }

  .subtext {
    font-style: normal;
    font-weight: 500;
    font-size: 14px;
    line-height: 20px;
    text-align: center;
    color: #747994;
  }
`;
const blankContentsHtml = (text = "", subtext = "") => {
  return `
    <style>
      ${blankStyles}
    </style>

    <div class='inner-container'>
      ${svgCy}
      <p data-cy="text" class="text">${text}</p>
      <p data-cy="subtext" class="subtext">${subtext}</p>
    </div>
  `;
};
const blankPageHeader = "Default blank page";
const blankPageSubtext = "This page was cleared by navigating to about:blank.";
const initial = () => {
  return blankContentsHtml();
};
const testIsolationBlankPage = () => {
  return blankContentsHtml(blankPageHeader, `${blankPageSubtext}<br>All active session data (cookies, localStorage and sessionStorage) across all domains are cleared.`);
};
const visitFailure = (props) => {
  const {
    status,
    statusText,
    contentType
  } = props;
  const getContentType = () => {
    if (!contentType) {
      return "";
    }
    return `(${contentType})`;
  };
  const getStatus = () => {
    if (!status) {
      return "";
    }
    return `<p>${status} - ${statusText} ${getContentType()}</p>`;
  };
  return `
  <style>
    ${defaultStyles}

    .container {
      background: #f5f4d7;
    }

    p {
      margin-bottom: 15px;
    }

    a {
      color: #4956e3;
      font-weight: bold;
      text-decoration: none;
    }

    a:hover,
    a:focus,
    a:active {
      color: #3a46cc;
      text-decoration: underline;
    }

  </style>

  <div class='container'>
    ${svgWarning}
    <p>Sorry, we could not load:</p>
    <p>
      <a href="${props.url}" target="_blank" rel="noopener noreferrer">${props.url}</a>
    </p>
    ${getStatus()}

  </div>
  `;
};
const blankContents = {
  initial,
  testIsolationBlankPage,
  visitFailure
};
const logger = {
  log(...args) {
    console.log(...args);
  },
  logError(...args) {
    console.error(...args);
  },
  clearLog() {
    var _a2;
    (_a2 = console.clear) == null ? void 0 : _a2.call(console);
  },
  logFormatted(consoleProps) {
    if (_$1.isEmpty(consoleProps))
      return;
    this._logValues(consoleProps);
    this._logArgs(consoleProps);
    this._logGroups(consoleProps);
    this._logTables(consoleProps);
  },
  _logValues(consoleProps) {
    consoleProps || (consoleProps = {});
    const formattedLog = this._formatted({
      [consoleProps.type]: consoleProps.name,
      ..._$1.pick(consoleProps, "error", "snapshot"),
      ...consoleProps.props
    });
    _$1.each(formattedLog, (value, key) => {
      if (_$1.isString(value) && _$1.trim(value) === "")
        return;
      if (typeof value !== "object" && _$1.trim(value) === "" && !_$1.isArray(value))
        return;
      this.log(`%c${key}`, "font-weight: bold", value);
    });
  },
  _formatted(consoleProps) {
    const maxKeyLength = this._getMaxKeyLength(consoleProps);
    return _$1.reduce(consoleProps, (memo, value, key) => {
      if (!key || key === "undefined")
        return memo;
      const append = ": ";
      key = _$1.capitalize(key + append).padEnd(maxKeyLength + append.length, " ");
      memo[key] = value;
      return memo;
    }, {});
  },
  _getMaxKeyLength(obj) {
    const lengths = Object.keys(obj).map((x2) => x2.length);
    return Math.max(...lengths);
  },
  _logArgs(consoleProps) {
    const args = this._getArgs(consoleProps);
    if (!args)
      return;
    this.log(`%cArgs:`, "font-weight: bold");
    args.forEach((arg, index) => {
      this.log(`%c  [${index}]:`, "font-weight: bold", arg);
    });
  },
  _getArgs(consoleProps) {
    const args = _$1.result(consoleProps, "args");
    if (!args)
      return;
    return args;
  },
  _logGroups(consoleProps) {
    const groups = this._getGroups(consoleProps);
    _$1.each(groups, (group) => {
      if (group.expand) {
        console.group(group.name);
      } else {
        console.groupCollapsed(group.name);
      }
      _$1.each(group.items, (value, key) => {
        if (group.label === false) {
          this.log(value);
        } else {
          this.log(`%c${key}`, "color: blue", value);
        }
      });
      this._logGroups(group);
      console.groupEnd();
    });
  },
  _getGroups(consoleProps) {
    const groups = _$1.result(consoleProps, "groups");
    if (!groups)
      return;
    return _$1.map(groups, (group) => {
      group.items = this._formatted(group.items || {});
      return group;
    });
  },
  _logTables(consoleProps) {
    const logTable = ({ name: name2, data, columns }) => {
      let tableData = data;
      if (Cypress.isBrowser("webkit")) {
        const getSimplifiedElementDisplay = (element) => {
          let display = element.tagName.toLowerCase();
          if (element.id) {
            display += `#${element.id}`;
          }
          element.classList.forEach((className) => {
            display += `.${className}`;
          });
          return display;
        };
        tableData = data.map((rowObj) => {
          return Object.entries(rowObj).reduce((acc, value) => {
            acc[value[0]] = _$1.isElement(value[1]) ? getSimplifiedElementDisplay(value[1]) : value[1];
            return acc;
          }, {});
        });
      }
      console.group(name2);
      console.table(tableData, columns);
      console.groupEnd();
    };
    _$1.each(_$1.sortBy(consoleProps.table, (val, key) => key), (getTableData) => {
      return logTable(getTableData());
    });
  }
};
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "Highlight.ce",
  props: {
    selector: null,
    style: null
  },
  setup(__props) {
    const props = __props;
    const highlightStyle = props.style || {};
    const highlightTop = parseFloat(highlightStyle.top);
    const highlightLeft = parseFloat(highlightStyle.left);
    const highlightHeight = parseFloat(highlightStyle.height);
    const placeOnBottom = highlightTop < 35;
    const tooltipStyle = placeOnBottom ? {
      top: `${highlightTop + highlightHeight + 10}px`,
      left: `${highlightLeft}px`
    } : {
      top: `${highlightTop - 33}px`,
      left: `${highlightLeft}px`
    };
    const arrowStyle = placeOnBottom ? {
      left: `8px`,
      top: `-6px`,
      transform: "rotate(0deg)"
    } : {
      left: `8px`,
      top: `24px`,
      transform: "rotate(180deg)"
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", {
          class: "highlight",
          style: normalizeStyle(unref(highlightStyle))
        }, null, 4),
        createBaseVNode("div", {
          class: "tooltip",
          style: normalizeStyle(unref(tooltipStyle))
        }, [
          createBaseVNode("span", null, toDisplayString$1(__props.selector), 1),
          createBaseVNode("div", {
            class: "arrow",
            style: normalizeStyle(unref(arrowStyle))
          }, null, 4)
        ], 4)
      ], 64);
    };
  }
});
const _style_0 = "\n.highlight {\n  background: rgba(159, 196, 231, 0.6);\n  border: solid 2px #9FC4E7;\n  cursor: pointer;\n}\n.tooltip {\n  position: absolute;\n  background: #333;\n  border: solid 1px #333;\n  border-radius: 3px;\n  color: #e3e3e3;\n  font-size: 12px;\n  padding: 4px 6px;\n  text-align: center;\n}\n.arrow {\n  position: absolute;\n  width: 0;\n  height: 0;\n  border-style: solid;\n  border-width: 0 6px 6px 6px;\n  border-color: transparent transparent #333 transparent;\n}\n";
const Highlight = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["styles", [_style_0]]]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "HighlightApp.ce",
  props: {
    selector: null,
    styles: null
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(true), createElementBlock(Fragment, null, renderList(__props.styles, (style, i) => {
        return openBlock(), createBlock(Highlight, {
          key: i,
          selector: __props.selector,
          style: normalizeStyle(style)
        }, null, 8, ["selector", "style"]);
      }), 128);
    };
  }
});
let app$1 = null;
const highlightMounter = {
  mount(container, selector, styles) {
    if (app$1) {
      app$1.unmount();
    }
    app$1 = createApp(_sfc_main, {
      selector,
      styles
    });
    app$1.mount(container);
  }
};
const sizzleRe = /sizzle/i;
class AutIframe {
  constructor(projectName, eventManager, $2) {
    this.projectName = projectName;
    this.eventManager = eventManager;
    this.$ = $2;
    this.showVisitFailure = (props) => {
      this._showContents(blankContents.visitFailure(props));
    };
    this.detachDom = () => {
      const Cypress2 = this.eventManager.getCypress();
      if (!Cypress2)
        return;
      return Cypress2.cy.detachDom(this._contents());
    };
    this.doesAUTMatchTopSuperDomainOrigin = () => {
      const Cypress2 = this.eventManager.getCypress();
      if (!Cypress2)
        return true;
      try {
        const { href: currentHref } = this.$iframe[0].contentWindow.document.location;
        const locationTop = Cypress2.Location.create(window.location.href);
        const locationAUT = Cypress2.Location.create(currentHref);
        return locationTop.superDomainOrigin === locationAUT.superDomainOrigin || locationAUT.superDomainOrigin === "about://blank";
      } catch (err) {
        if (err.name === "SecurityError") {
          return false;
        }
        throw err;
      }
    };
    this.removeSrcAttribute = () => {
      var _a2;
      (_a2 = this.$iframe) == null ? void 0 : _a2.removeAttr("src");
    };
    this.visitBlankPage = (testIsolation) => {
      return new Promise((resolve3) => {
        if (!this.$iframe) {
          return;
        }
        this.$iframe[0].src = "about:blank";
        this.$iframe.one("load", () => {
          if (testIsolation) {
            this._showTestIsolationBlankPage();
          } else {
            this._showInitialBlankPage();
          }
          resolve3();
        });
      });
    };
    this.restoreDom = (snapshot) => {
      var _a2, _b2;
      if (!this.doesAUTMatchTopSuperDomainOrigin()) {
        (_a2 = this.$iframe) == null ? void 0 : _a2.one("load", () => {
          this.restoreDom(snapshot);
        });
        this.removeSrcAttribute();
        return;
      }
      const Cypress2 = this.eventManager.getCypress();
      const { headStyles = void 0, bodyStyles = void 0 } = Cypress2 ? Cypress2.cy.getStyles(snapshot) : {};
      const { body, htmlAttrs } = snapshot;
      const contents = this._contents();
      const $html = contents == null ? void 0 : contents.find("html");
      if ($html) {
        this._replaceHtmlAttrs($html, htmlAttrs);
      }
      this._replaceHeadStyles(headStyles);
      (_b2 = this._body()) == null ? void 0 : _b2.remove();
      this._insertBodyStyles(body.get(), bodyStyles);
      $html == null ? void 0 : $html.append(body.get());
      const selectorPlaygroundStore = useSelectorPlaygroundStore();
      this.debouncedToggleSelectorPlayground(selectorPlaygroundStore.isEnabled);
    };
    this.highlightEl = ({ body }, { $el, coords, highlightAttr, scrollBy }) => {
      var _a2;
      this.removeHighlights();
      if (body) {
        $el = body.get().find(`[${highlightAttr}]`);
      } else {
        body = { get: () => this._body() };
      }
      const el = $el.get(0);
      const $body = body.get();
      body = $body.get(0);
      if (el) {
        el.scrollIntoView();
        if (scrollBy) {
          (_a2 = this.$iframe) == null ? void 0 : _a2.prop("contentWindow").scrollBy(scrollBy.x, scrollBy.y);
        }
      }
      $el.each((__, element) => {
        const $_el = this.$(element);
        if (!this.$.contains(body, element))
          return;
        const dimensions = this._getOffsetSize($_el.get(0));
        if (dimensions.width === 0 || dimensions.height === 0 || $_el.css("display") === "none") {
          return;
        }
        this._addElementBoxModelLayers($_el, $body).setAttribute("data-highlight-el", `true`);
      });
      if (coords) {
        requestAnimationFrame(() => {
          this._addHitBoxLayer(coords, $body.get(0)).setAttribute("data-highlight-hitbox", "true");
        });
      }
    };
    this.removeHighlights = () => {
      var _a2;
      this._contents() && ((_a2 = this._contents()) == null ? void 0 : _a2.find(".__cypress-highlight").remove());
    };
    this.toggleSelectorPlayground = (isEnabled) => {
      const $body = this._body();
      if (!$body)
        return;
      if (isEnabled) {
        $body.on("mouseenter", this._resetShowHighlight);
        $body.on("mousemove", this._onSelectorMouseMove);
        $body.on("mouseleave", this._clearHighlight);
      } else {
        $body.off("mouseenter", this._resetShowHighlight);
        $body.off("mousemove", this._onSelectorMouseMove);
        $body.off("mouseleave", this._clearHighlight);
        if (this._highlightedEl) {
          this._clearHighlight();
        }
      }
    };
    this._resetShowHighlight = () => {
      const selectorPlaygroundStore = useSelectorPlaygroundStore();
      selectorPlaygroundStore.setShowingHighlight(false);
    };
    this._onSelectorMouseMove = (e) => {
      const $body = this._body();
      if (!$body)
        return;
      let el = e.target;
      let $el = this.$(el);
      const $ancestorHighlight = $el.closest(".__cypress-selector-playground");
      if ($ancestorHighlight.length) {
        $el = $ancestorHighlight;
      }
      if ($ancestorHighlight.length || $el.hasClass("__cypress-selector-playground")) {
        const $highlight = $el;
        $highlight.css("display", "none");
        el = this._document().elementFromPoint(e.clientX, e.clientY);
        $el = this.$(el);
        $highlight.css("display", "block");
      }
      if (this._highlightedEl === el)
        return;
      this._highlightedEl = el;
      const Cypress2 = this.eventManager.getCypress();
      const selector = Cypress2.SelectorPlayground.getSelector($el);
      const selectorPlaygroundStore = useSelectorPlaygroundStore();
      this._addOrUpdateSelectorPlaygroundHighlight({
        $el,
        $body,
        selector,
        showTooltip: true,
        onClick: () => {
          selectorPlaygroundStore.setNumElements(1);
          selectorPlaygroundStore.resetMethod();
          selectorPlaygroundStore.setSelector(selector);
          selectorPlaygroundStore.setValidity(!!el);
        }
      });
    };
    this._clearHighlight = () => {
      const $body = this._body();
      if (!$body)
        return;
      this._addOrUpdateSelectorPlaygroundHighlight({
        $el: null,
        $body
      });
      if (this._highlightedEl) {
        this._highlightedEl = void 0;
      }
    };
    this._isInViewport = (win, el) => {
      let rect = el.getBoundingClientRect();
      return rect.top >= 0 && rect.left >= 0 && rect.bottom <= win.innerHeight && rect.right <= win.innerWidth;
    };
    this.listeners = [];
    this.debouncedToggleSelectorPlayground = _$1.debounce(this.toggleSelectorPlayground, 300);
  }
  create() {
    const $iframe = this.$("<iframe>", {
      id: `Your project: '${this.projectName}'`,
      title: `Your project: '${this.projectName}'`,
      class: "aut-iframe"
    });
    this.$iframe = $iframe;
    return $iframe;
  }
  destroy() {
    if (!this.$iframe) {
      throw Error(`Cannot call #remove without first calling #create`);
    }
    this.$iframe.remove();
  }
  _showInitialBlankPage() {
    this._showContents(blankContents.initial());
  }
  _showTestIsolationBlankPage() {
    this._showContents(blankContents.testIsolationBlankPage());
  }
  _showContents(contents) {
    var _a2;
    (_a2 = this._body()) == null ? void 0 : _a2.html(contents);
  }
  _contents() {
    return this.$iframe && this.$iframe.contents();
  }
  _window() {
    var _a2;
    return (_a2 = this.$iframe) == null ? void 0 : _a2.prop("contentWindow");
  }
  _document() {
    var _a2;
    return (_a2 = this.$iframe) == null ? void 0 : _a2.prop("contentDocument");
  }
  _body() {
    var _a2;
    return (_a2 = this._contents()) == null ? void 0 : _a2.find("body");
  }
  // note htmlAttrs is actually `NamedNodeMap`: https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap
  // but typing it correctly gives a lot more weird typing errors
  _replaceHtmlAttrs($html, htmlAttrs) {
    let oldAttrs = {};
    if ($html[0]) {
      oldAttrs = _$1.map($html[0].attributes, (attr) => {
        return attr.name;
      });
    }
    _$1.each(oldAttrs, (attr) => {
      $html.removeAttr(attr);
    });
    _$1.each(htmlAttrs, (value, key) => {
      $html.attr(key, value);
    });
  }
  _replaceHeadStyles(styles = {}) {
    var _a2;
    const $head = (_a2 = this._contents()) == null ? void 0 : _a2.find("head");
    const existingStyles = $head == null ? void 0 : $head.find('link[rel="stylesheet"],style');
    _$1.each(styles, (style, index) => {
      if (style.href) {
        this._replaceLink($head, existingStyles == null ? void 0 : existingStyles[index], style);
      } else {
        this._replaceStyle($head, existingStyles == null ? void 0 : existingStyles[index], style);
      }
    });
    if (existingStyles && existingStyles.length > styles.length) {
      existingStyles.slice(styles.length).remove();
    }
  }
  _replaceLink($head, existingStyle, style) {
    const linkTag = this._linkTag(style);
    if (!existingStyle) {
      $head.append(linkTag);
      return;
    }
    if (existingStyle.href !== style.href) {
      this.$(existingStyle).replaceWith(linkTag);
    }
  }
  _replaceStyle($head, existingStyle, style) {
    const styleTag = this._styleTag(style);
    if (existingStyle) {
      this.$(existingStyle).replaceWith(styleTag);
    } else {
      $head.append(styleTag);
    }
  }
  _insertBodyStyles($body, styles = {}) {
    _$1.each(styles, (style) => {
      $body.append(style.href ? this._linkTag(style) : this._styleTag(style));
    });
  }
  _linkTag(style) {
    return `<link rel="stylesheet" href="${style.href}" />`;
  }
  _styleTag(style) {
    return `<style>${style}</style>`;
  }
  toggleSelectorHighlight(isShowingHighlight) {
    const selectorPlaygroundStore = useSelectorPlaygroundStore();
    if (!isShowingHighlight) {
      this._clearHighlight();
      return;
    }
    const Cypress2 = this.eventManager.getCypress();
    const $el = this.getElements(Cypress2.dom);
    selectorPlaygroundStore.setValidity(!!$el);
    if ($el) {
      selectorPlaygroundStore.setNumElements($el.length);
      if ($el.length) {
        this._scrollIntoView(this._window(), $el[0]);
      }
    }
    this._addOrUpdateSelectorPlaygroundHighlight({
      $el: $el && $el.length ? $el : null,
      $body: this._body(),
      selector: selectorPlaygroundStore.selector,
      showTooltip: false
    });
  }
  getElements(cypressDom) {
    const selectorPlaygroundStore = useSelectorPlaygroundStore();
    const $contents = this._contents();
    if (!$contents || !selectorPlaygroundStore.selector)
      return;
    return this._getElementsForSelector({
      method: selectorPlaygroundStore.method,
      selector: selectorPlaygroundStore.selector,
      cypressDom,
      $root: $contents
    });
  }
  printSelectorElementsToConsole() {
    logger.clearLog();
    const Cypress2 = this.eventManager.getCypress();
    const $el = this.getElements(Cypress2.dom);
    const selectorPlaygroundStore = useSelectorPlaygroundStore();
    if (!$el) {
      return logger.logFormatted({
        name: selectorPlaygroundStore.command,
        type: "command",
        props: {
          Yielded: "Nothing"
        }
      });
    }
    logger.logFormatted({
      name: selectorPlaygroundStore.command,
      type: "command",
      props: {
        Elements: $el.length,
        Yielded: Cypress2.dom.getElements($el)
      }
    });
  }
  startStudio() {
    var _a2;
    const studioStore = useStudioStore();
    if (studioStore.isLoading) {
      studioStore.start((_a2 = this._body()) == null ? void 0 : _a2[0]);
    }
  }
  reattachStudio() {
    var _a2;
    const studioStore = useStudioStore();
    if (studioStore.isActive) {
      const body = (_a2 = this._body()) == null ? void 0 : _a2[0];
      if (!body) {
        throw Error(`Cannot reattach Studio without the HTMLBodyElement for the app`);
      }
      studioStore.attachListeners(body);
    }
  }
  _scrollIntoView(win, el) {
    if (!el || this._isInViewport(win, el))
      return;
    el.scrollIntoView();
  }
  _getElementsForSelector({ $root, selector, method, cypressDom }) {
    let $el = null;
    try {
      if (method === "contains") {
        $el = $root.find(cypressDom.getContainsSelector(selector));
        if ($el.length) {
          $el = cypressDom.getFirstDeepestElement($el);
        }
      } else {
        $el = $root.find(selector);
      }
    } catch (err) {
      if (!sizzleRe.test(err.stack))
        throw err;
    }
    return $el;
  }
  _addHitBoxLayer(coords, body) {
    const height = 10;
    const width = 10;
    const dotHeight = 4;
    const dotWidth = 4;
    const top2 = coords.y - height / 2;
    const left2 = coords.x - width / 2;
    const dotTop = height / 2 - dotHeight / 2;
    const dotLeft = width / 2 - dotWidth / 2;
    const resetStyles = {
      border: "none !important",
      margin: "0 !important",
      padding: "0 !important"
    };
    const boxStyles = {
      ...resetStyles,
      position: "absolute",
      top: `${top2}px`,
      left: `${left2}px`,
      width: `${width}px`,
      height: `${height}px`,
      backgroundColor: "red",
      borderRadius: "5px",
      boxShadow: "0 0 5px #333",
      zIndex: "2147483647"
    };
    const box = document.createElement("div");
    box.classList.add("__cypress-highlight");
    for (const key in boxStyles) {
      box.style[key] = boxStyles[key];
    }
    const wrapperStyles = {
      ...resetStyles,
      position: "relative"
    };
    const wrapper = document.createElement("div");
    for (const key in wrapperStyles) {
      wrapper.style[key] = wrapperStyles[key];
    }
    const dotStyles = {
      ...resetStyles,
      position: "absolute",
      top: `${dotTop}px`,
      left: `${dotLeft}px`,
      height: `${dotHeight}px`,
      width: `${dotWidth}px`,
      backgroundColor: "pink",
      borderRadius: "5px"
    };
    const dot = document.createElement("div");
    for (const key in dotStyles) {
      dot.style[key] = dotStyles[key];
    }
    body.appendChild(box);
    box.appendChild(wrapper);
    wrapper.appendChild(dot);
    return box;
  }
  _getOffsetSize(el) {
    return {
      width: el.offsetWidth,
      height: el.offsetHeight
    };
  }
  _addElementBoxModelLayers($el, $body) {
    $body = $body || $("body");
    const el = $el.get(0);
    const body = $body.get(0);
    const dimensions = getElementDimensions(el);
    const container = document.createElement("div");
    container.classList.add("__cypress-highlight");
    container.style.opacity = `0.7`;
    container.style.position = "absolute";
    container.style.zIndex = `${INT32_MAX}`;
    const layers = {
      Content: "#9FC4E7",
      Padding: "#C1CD89",
      Border: "#FCDB9A",
      Margin: "#F9CC9D"
    };
    _$1.each(layers, (color, attr) => {
      let obj;
      switch (attr) {
        case "Content":
          obj = {
            width: dimensions.width,
            height: dimensions.height,
            top: dimensions.offset.top + dimensions.borderTop + dimensions.paddingTop,
            left: dimensions.offset.left + dimensions.borderLeft + dimensions.paddingLeft
          };
          break;
        default:
          obj = {
            width: this._getDimensionsFor(dimensions, attr, "width"),
            height: this._getDimensionsFor(dimensions, attr, "height"),
            top: dimensions.offset.top,
            left: dimensions.offset.left
          };
      }
      if (attr === "Margin") {
        obj.top -= dimensions.marginTop;
        obj.left -= dimensions.marginLeft;
      }
      if (attr === "Padding") {
        obj.top += dimensions.borderTop;
        obj.left += dimensions.borderLeft;
      }
      if (this._dimensionsMatchPreviousLayer(obj, container))
        return;
      this._createLayer($el.get(0), attr, color, container, obj);
    });
    body.appendChild(container);
    for (let i = 0; i < container.children.length; i++) {
      const el2 = container.children[i];
      const top2 = parseFloat(el2.getAttribute("data-top"));
      const left2 = parseFloat(el2.getAttribute("data-left"));
      setOffset(el2, { top: top2, left: left2 });
    }
    return container;
  }
  _createLayer(el, attr, color, container, dimensions) {
    const div = document.createElement("div");
    div.style.transform = getComputedStyle(el, null).transform;
    div.style.width = `${dimensions.width}px`;
    div.style.height = `${dimensions.height}px`;
    div.style.position = "absolute";
    div.style.zIndex = `${getZIndex(el)}`;
    div.style.backgroundColor = color;
    div.setAttribute("data-top", dimensions.top);
    div.setAttribute("data-left", dimensions.left);
    div.setAttribute("data-layer", attr);
    container.prepend(div);
    return div;
  }
  _dimensionsMatchPreviousLayer(obj, container) {
    const previousLayer = container.childNodes[0];
    if (!previousLayer) {
      return;
    }
    return obj.width === previousLayer.offsetWidth && obj.height === previousLayer.offsetHeight;
  }
  _getDimensionsFor(dimensions, attr, dimension) {
    return dimensions[`${dimension}With${attr}`];
  }
  _addOrUpdateSelectorPlaygroundHighlight({ $el, $body, selector, showTooltip, onClick }) {
    const { container, vueContainer } = getOrCreateHelperDom({
      body: ($body == null ? void 0 : $body.get(0)) || document.body,
      className: "__cypress-selector-playground",
      css: Highlight.styles[0]
    });
    const removeContainerClickListeners = () => {
      this.listeners.forEach((listener) => {
        vueContainer.removeEventListener("click", listener);
      });
      this.listeners = [];
    };
    if (!$el) {
      removeContainerClickListeners();
      container.remove();
      return;
    }
    const elements = $el.get();
    const styles = getSelectorHighlightStyles(elements);
    if (elements.length === 1) {
      removeContainerClickListeners();
      if (onClick) {
        vueContainer.addEventListener("click", onClick);
        this.listeners.push(onClick);
      }
    }
    highlightMounter.mount(vueContainer, selector, styles);
  }
}
var bluebird = { exports: {} };
(function(module, exports) {
  var define_process_env_default2 = { CYPRESS_INTERNAL_ENV: "development", NODE_ENV: "production" };
  var define_setImmediate_default = {};
  /* @preserve
   * The MIT License (MIT)
   * 
   * Copyright (c) 2013-2018 Petka Antonov
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   * 
   */
  !function(e) {
    module.exports = e();
  }(function() {
    return function e(t2, n, r2) {
      function s2(o22, u2) {
        if (!n[o22]) {
          if (!t2[o22]) {
            var a2 = typeof _dereq_ == "function" && _dereq_;
            if (!u2 && a2)
              return a2(o22, true);
            if (i)
              return i(o22, true);
            var f2 = new Error("Cannot find module '" + o22 + "'");
            throw f2.code = "MODULE_NOT_FOUND", f2;
          }
          var l2 = n[o22] = { exports: {} };
          t2[o22][0].call(l2.exports, function(e2) {
            var n2 = t2[o22][1][e2];
            return s2(n2 ? n2 : e2);
          }, l2, l2.exports, e, t2, n, r2);
        }
        return n[o22].exports;
      }
      var i = typeof _dereq_ == "function" && _dereq_;
      for (var o2 = 0; o2 < r2.length; o2++)
        s2(r2[o2]);
      return s2;
    }({ 1: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2) {
        var SomePromiseArray = Promise2._SomePromiseArray;
        function any(promises) {
          var ret2 = new SomePromiseArray(promises);
          var promise = ret2.promise();
          ret2.setHowMany(1);
          ret2.setUnwrap();
          ret2.init();
          return promise;
        }
        Promise2.any = function(promises) {
          return any(promises);
        };
        Promise2.prototype.any = function() {
          return any(this);
        };
      };
    }, {}], 2: [function(_dereq_2, module2, exports2) {
      var firstLineError;
      try {
        throw new Error();
      } catch (e) {
        firstLineError = e;
      }
      var schedule = _dereq_2("./schedule");
      var Queue = _dereq_2("./queue");
      var util2 = _dereq_2("./util");
      function Async() {
        this._customScheduler = false;
        this._isTickUsed = false;
        this._lateQueue = new Queue(16);
        this._normalQueue = new Queue(16);
        this._haveDrainedQueues = false;
        this._trampolineEnabled = true;
        var self2 = this;
        this.drainQueues = function() {
          self2._drainQueues();
        };
        this._schedule = schedule;
      }
      Async.prototype.setScheduler = function(fn2) {
        var prev2 = this._schedule;
        this._schedule = fn2;
        this._customScheduler = true;
        return prev2;
      };
      Async.prototype.hasCustomScheduler = function() {
        return this._customScheduler;
      };
      Async.prototype.enableTrampoline = function() {
        this._trampolineEnabled = true;
      };
      Async.prototype.disableTrampolineIfNecessary = function() {
        if (util2.hasDevTools) {
          this._trampolineEnabled = false;
        }
      };
      Async.prototype.haveItemsQueued = function() {
        return this._isTickUsed || this._haveDrainedQueues;
      };
      Async.prototype.fatalError = function(e, isNode2) {
        if (isNode2) {
          process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
          process.exit(2);
        } else {
          this.throwLater(e);
        }
      };
      Async.prototype.throwLater = function(fn2, arg) {
        if (arguments.length === 1) {
          arg = fn2;
          fn2 = function() {
            throw arg;
          };
        }
        if (typeof setTimeout !== "undefined") {
          setTimeout(function() {
            fn2(arg);
          }, 0);
        } else
          try {
            this._schedule(function() {
              fn2(arg);
            });
          } catch (e) {
            throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
          }
      };
      function AsyncInvokeLater(fn2, receiver2, arg) {
        this._lateQueue.push(fn2, receiver2, arg);
        this._queueTick();
      }
      function AsyncInvoke(fn2, receiver2, arg) {
        this._normalQueue.push(fn2, receiver2, arg);
        this._queueTick();
      }
      function AsyncSettlePromises(promise) {
        this._normalQueue._pushOne(promise);
        this._queueTick();
      }
      if (!util2.hasDevTools) {
        Async.prototype.invokeLater = AsyncInvokeLater;
        Async.prototype.invoke = AsyncInvoke;
        Async.prototype.settlePromises = AsyncSettlePromises;
      } else {
        Async.prototype.invokeLater = function(fn2, receiver2, arg) {
          if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn2, receiver2, arg);
          } else {
            this._schedule(function() {
              setTimeout(function() {
                fn2.call(receiver2, arg);
              }, 100);
            });
          }
        };
        Async.prototype.invoke = function(fn2, receiver2, arg) {
          if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn2, receiver2, arg);
          } else {
            this._schedule(function() {
              fn2.call(receiver2, arg);
            });
          }
        };
        Async.prototype.settlePromises = function(promise) {
          if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
          } else {
            this._schedule(function() {
              promise._settlePromises();
            });
          }
        };
      }
      function _drainQueue(queue2) {
        while (queue2.length() > 0) {
          _drainQueueStep(queue2);
        }
      }
      function _drainQueueStep(queue2) {
        var fn2 = queue2.shift();
        if (typeof fn2 !== "function") {
          fn2._settlePromises();
        } else {
          var receiver2 = queue2.shift();
          var arg = queue2.shift();
          fn2.call(receiver2, arg);
        }
      }
      Async.prototype._drainQueues = function() {
        _drainQueue(this._normalQueue);
        this._reset();
        this._haveDrainedQueues = true;
        _drainQueue(this._lateQueue);
      };
      Async.prototype._queueTick = function() {
        if (!this._isTickUsed) {
          this._isTickUsed = true;
          this._schedule(this.drainQueues);
        }
      };
      Async.prototype._reset = function() {
        this._isTickUsed = false;
      };
      module2.exports = Async;
      module2.exports.firstLineError = firstLineError;
    }, { "./queue": 26, "./schedule": 29, "./util": 36 }], 3: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug2) {
        var calledBind = false;
        var rejectThis = function(_2, e) {
          this._reject(e);
        };
        var targetRejected = function(e, context2) {
          context2.promiseRejectionQueued = true;
          context2.bindingPromise._then(rejectThis, rejectThis, null, this, e);
        };
        var bindingResolved = function(thisArg, context2) {
          if ((this._bitField & 50397184) === 0) {
            this._resolveCallback(context2.target);
          }
        };
        var bindingRejected = function(e, context2) {
          if (!context2.promiseRejectionQueued)
            this._reject(e);
        };
        Promise2.prototype.bind = function(thisArg) {
          if (!calledBind) {
            calledBind = true;
            Promise2.prototype._propagateFrom = debug2.propagateFromFunction();
            Promise2.prototype._boundValue = debug2.boundValueFunction();
          }
          var maybePromise = tryConvertToPromise(thisArg);
          var ret2 = new Promise2(INTERNAL);
          ret2._propagateFrom(this, 1);
          var target = this._target();
          ret2._setBoundTo(maybePromise);
          if (maybePromise instanceof Promise2) {
            var context2 = {
              promiseRejectionQueued: false,
              promise: ret2,
              target,
              bindingPromise: maybePromise
            };
            target._then(INTERNAL, targetRejected, void 0, ret2, context2);
            maybePromise._then(
              bindingResolved,
              bindingRejected,
              void 0,
              ret2,
              context2
            );
            ret2._setOnCancel(maybePromise);
          } else {
            ret2._resolveCallback(target);
          }
          return ret2;
        };
        Promise2.prototype._setBoundTo = function(obj2) {
          if (obj2 !== void 0) {
            this._bitField = this._bitField | 2097152;
            this._boundTo = obj2;
          } else {
            this._bitField = this._bitField & ~2097152;
          }
        };
        Promise2.prototype._isBound = function() {
          return (this._bitField & 2097152) === 2097152;
        };
        Promise2.bind = function(thisArg, value) {
          return Promise2.resolve(value).bind(thisArg);
        };
      };
    }, {}], 4: [function(_dereq_2, module2, exports2) {
      var old;
      if (typeof Promise !== "undefined")
        old = Promise;
      function noConflict() {
        try {
          if (Promise === bluebird2)
            Promise = old;
        } catch (e) {
        }
        return bluebird2;
      }
      var bluebird2 = _dereq_2("./promise")();
      bluebird2.noConflict = noConflict;
      module2.exports = bluebird2;
    }, { "./promise": 22 }], 5: [function(_dereq_2, module2, exports2) {
      var cr = Object.create;
      if (cr) {
        var callerCache = cr(null);
        var getterCache = cr(null);
        callerCache[" size"] = getterCache[" size"] = 0;
      }
      module2.exports = function(Promise2) {
        var util2 = _dereq_2("./util");
        var canEvaluate2 = util2.canEvaluate;
        util2.isIdentifier;
        var getGetter;
        function ensureMethod(obj2, methodName) {
          var fn2;
          if (obj2 != null)
            fn2 = obj2[methodName];
          if (typeof fn2 !== "function") {
            var message = "Object " + util2.classString(obj2) + " has no method '" + util2.toString(methodName) + "'";
            throw new Promise2.TypeError(message);
          }
          return fn2;
        }
        function caller(obj2) {
          var methodName = this.pop();
          var fn2 = ensureMethod(obj2, methodName);
          return fn2.apply(obj2, this);
        }
        Promise2.prototype.call = function(methodName) {
          var args = [].slice.call(arguments, 1);
          args.push(methodName);
          return this._then(caller, void 0, void 0, args, void 0);
        };
        function namedGetter(obj2) {
          return obj2[this];
        }
        function indexedGetter(obj2) {
          var index = +this;
          if (index < 0)
            index = Math.max(0, index + obj2.length);
          return obj2[index];
        }
        Promise2.prototype.get = function(propertyName) {
          var isIndex = typeof propertyName === "number";
          var getter;
          if (!isIndex) {
            if (canEvaluate2) {
              var maybeGetter = getGetter(propertyName);
              getter = maybeGetter !== null ? maybeGetter : namedGetter;
            } else {
              getter = namedGetter;
            }
          } else {
            getter = indexedGetter;
          }
          return this._then(getter, void 0, void 0, propertyName, void 0);
        };
      };
    }, { "./util": 36 }], 6: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, PromiseArray, apiRejection, debug2) {
        var util2 = _dereq_2("./util");
        var tryCatch2 = util2.tryCatch;
        var errorObj2 = util2.errorObj;
        var async = Promise2._async;
        Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
          if (!debug2.cancellation())
            return this._warn("cancellation is disabled");
          var promise = this;
          var child = promise;
          while (promise._isCancellable()) {
            if (!promise._cancelBy(child)) {
              if (child._isFollowing()) {
                child._followee().cancel();
              } else {
                child._cancelBranched();
              }
              break;
            }
            var parent = promise._cancellationParent;
            if (parent == null || !parent._isCancellable()) {
              if (promise._isFollowing()) {
                promise._followee().cancel();
              } else {
                promise._cancelBranched();
              }
              break;
            } else {
              if (promise._isFollowing())
                promise._followee().cancel();
              promise._setWillBeCancelled();
              child = promise;
              promise = parent;
            }
          }
        };
        Promise2.prototype._branchHasCancelled = function() {
          this._branchesRemainingToCancel--;
        };
        Promise2.prototype._enoughBranchesHaveCancelled = function() {
          return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
        };
        Promise2.prototype._cancelBy = function(canceller) {
          if (canceller === this) {
            this._branchesRemainingToCancel = 0;
            this._invokeOnCancel();
            return true;
          } else {
            this._branchHasCancelled();
            if (this._enoughBranchesHaveCancelled()) {
              this._invokeOnCancel();
              return true;
            }
          }
          return false;
        };
        Promise2.prototype._cancelBranched = function() {
          if (this._enoughBranchesHaveCancelled()) {
            this._cancel();
          }
        };
        Promise2.prototype._cancel = function() {
          if (!this._isCancellable())
            return;
          this._setCancelled();
          async.invoke(this._cancelPromises, this, void 0);
        };
        Promise2.prototype._cancelPromises = function() {
          if (this._length() > 0)
            this._settlePromises();
        };
        Promise2.prototype._unsetOnCancel = function() {
          this._onCancelField = void 0;
        };
        Promise2.prototype._isCancellable = function() {
          return this.isPending() && !this._isCancelled();
        };
        Promise2.prototype.isCancellable = function() {
          return this.isPending() && !this.isCancelled();
        };
        Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
          if (util2.isArray(onCancelCallback)) {
            for (var i = 0; i < onCancelCallback.length; ++i) {
              this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
            }
          } else if (onCancelCallback !== void 0) {
            if (typeof onCancelCallback === "function") {
              if (!internalOnly) {
                var e = tryCatch2(onCancelCallback).call(this._boundValue());
                if (e === errorObj2) {
                  this._attachExtraTrace(e.e);
                  async.throwLater(e.e);
                }
              }
            } else {
              onCancelCallback._resultCancelled(this);
            }
          }
        };
        Promise2.prototype._invokeOnCancel = function() {
          var onCancelCallback = this._onCancel();
          this._unsetOnCancel();
          async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
        };
        Promise2.prototype._invokeInternalOnCancel = function() {
          if (this._isCancellable()) {
            this._doInvokeOnCancel(this._onCancel(), true);
            this._unsetOnCancel();
          }
        };
        Promise2.prototype._resultCancelled = function() {
          this.cancel();
        };
      };
    }, { "./util": 36 }], 7: [function(_dereq_2, module2, exports2) {
      module2.exports = function(NEXT_FILTER) {
        var util2 = _dereq_2("./util");
        var getKeys = _dereq_2("./es5").keys;
        var tryCatch2 = util2.tryCatch;
        var errorObj2 = util2.errorObj;
        function catchFilter(instances, cb, promise) {
          return function(e) {
            var boundTo = promise._boundValue();
            predicateLoop:
              for (var i = 0; i < instances.length; ++i) {
                var item = instances[i];
                if (item === Error || item != null && item.prototype instanceof Error) {
                  if (e instanceof item) {
                    return tryCatch2(cb).call(boundTo, e);
                  }
                } else if (typeof item === "function") {
                  var matchesPredicate = tryCatch2(item).call(boundTo, e);
                  if (matchesPredicate === errorObj2) {
                    return matchesPredicate;
                  } else if (matchesPredicate) {
                    return tryCatch2(cb).call(boundTo, e);
                  }
                } else if (util2.isObject(e)) {
                  var keys2 = getKeys(item);
                  for (var j = 0; j < keys2.length; ++j) {
                    var key = keys2[j];
                    if (item[key] != e[key]) {
                      continue predicateLoop;
                    }
                  }
                  return tryCatch2(cb).call(boundTo, e);
                }
              }
            return NEXT_FILTER;
          };
        }
        return catchFilter;
      };
    }, { "./es5": 13, "./util": 36 }], 8: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2) {
        var longStackTraces = false;
        var contextStack = [];
        Promise2.prototype._promiseCreated = function() {
        };
        Promise2.prototype._pushContext = function() {
        };
        Promise2.prototype._popContext = function() {
          return null;
        };
        Promise2._peekContext = Promise2.prototype._peekContext = function() {
        };
        function Context2() {
          this._trace = new Context2.CapturedTrace(peekContext());
        }
        Context2.prototype._pushContext = function() {
          if (this._trace !== void 0) {
            this._trace._promiseCreated = null;
            contextStack.push(this._trace);
          }
        };
        Context2.prototype._popContext = function() {
          if (this._trace !== void 0) {
            var trace2 = contextStack.pop();
            var ret2 = trace2._promiseCreated;
            trace2._promiseCreated = null;
            return ret2;
          }
          return null;
        };
        function createContext() {
          if (longStackTraces)
            return new Context2();
        }
        function peekContext() {
          var lastIndex = contextStack.length - 1;
          if (lastIndex >= 0) {
            return contextStack[lastIndex];
          }
          return void 0;
        }
        Context2.CapturedTrace = null;
        Context2.create = createContext;
        Context2.deactivateLongStackTraces = function() {
        };
        Context2.activateLongStackTraces = function() {
          var Promise_pushContext = Promise2.prototype._pushContext;
          var Promise_popContext = Promise2.prototype._popContext;
          var Promise_PeekContext = Promise2._peekContext;
          var Promise_peekContext = Promise2.prototype._peekContext;
          var Promise_promiseCreated = Promise2.prototype._promiseCreated;
          Context2.deactivateLongStackTraces = function() {
            Promise2.prototype._pushContext = Promise_pushContext;
            Promise2.prototype._popContext = Promise_popContext;
            Promise2._peekContext = Promise_PeekContext;
            Promise2.prototype._peekContext = Promise_peekContext;
            Promise2.prototype._promiseCreated = Promise_promiseCreated;
            longStackTraces = false;
          };
          longStackTraces = true;
          Promise2.prototype._pushContext = Context2.prototype._pushContext;
          Promise2.prototype._popContext = Context2.prototype._popContext;
          Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
          Promise2.prototype._promiseCreated = function() {
            var ctx = this._peekContext();
            if (ctx && ctx._promiseCreated == null)
              ctx._promiseCreated = this;
          };
        };
        return Context2;
      };
    }, {}], 9: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, Context2) {
        var getDomain = Promise2._getDomain;
        var async = Promise2._async;
        var Warning = _dereq_2("./errors").Warning;
        var util2 = _dereq_2("./util");
        var es52 = _dereq_2("./es5");
        var canAttachTrace2 = util2.canAttachTrace;
        var unhandledRejectionHandled;
        var possiblyUnhandledRejection;
        var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
        var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
        var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
        var stackFramePattern = null;
        var formatStack = null;
        var indentStackFrames = false;
        var printWarning;
        var debugging = !!(util2.env("BLUEBIRD_DEBUG") != 0 && true);
        var warnings = !!(util2.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util2.env("BLUEBIRD_WARNINGS")));
        var longStackTraces = !!(util2.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util2.env("BLUEBIRD_LONG_STACK_TRACES")));
        var wForgottenReturn = util2.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util2.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
        Promise2.prototype.suppressUnhandledRejections = function() {
          var target = this._target();
          target._bitField = target._bitField & ~1048576 | 524288;
        };
        Promise2.prototype._ensurePossibleRejectionHandled = function() {
          if ((this._bitField & 524288) !== 0)
            return;
          this._setRejectionIsUnhandled();
          var self2 = this;
          setTimeout(function() {
            self2._notifyUnhandledRejection();
          }, 1);
        };
        Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
          fireRejectionEvent(
            "rejectionHandled",
            unhandledRejectionHandled,
            void 0,
            this
          );
        };
        Promise2.prototype._setReturnedNonUndefined = function() {
          this._bitField = this._bitField | 268435456;
        };
        Promise2.prototype._returnedNonUndefined = function() {
          return (this._bitField & 268435456) !== 0;
        };
        Promise2.prototype._notifyUnhandledRejection = function() {
          if (this._isRejectionUnhandled()) {
            var reason = this._settledValue();
            this._setUnhandledRejectionIsNotified();
            fireRejectionEvent(
              "unhandledRejection",
              possiblyUnhandledRejection,
              reason,
              this
            );
          }
        };
        Promise2.prototype._setUnhandledRejectionIsNotified = function() {
          this._bitField = this._bitField | 262144;
        };
        Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
          this._bitField = this._bitField & ~262144;
        };
        Promise2.prototype._isUnhandledRejectionNotified = function() {
          return (this._bitField & 262144) > 0;
        };
        Promise2.prototype._setRejectionIsUnhandled = function() {
          this._bitField = this._bitField | 1048576;
        };
        Promise2.prototype._unsetRejectionIsUnhandled = function() {
          this._bitField = this._bitField & ~1048576;
          if (this._isUnhandledRejectionNotified()) {
            this._unsetUnhandledRejectionIsNotified();
            this._notifyUnhandledRejectionIsHandled();
          }
        };
        Promise2.prototype._isRejectionUnhandled = function() {
          return (this._bitField & 1048576) > 0;
        };
        Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
          return warn2(message, shouldUseOwnTrace, promise || this);
        };
        Promise2.onPossiblyUnhandledRejection = function(fn2) {
          var domain = getDomain();
          possiblyUnhandledRejection = typeof fn2 === "function" ? domain === null ? fn2 : util2.domainBind(domain, fn2) : void 0;
        };
        Promise2.onUnhandledRejectionHandled = function(fn2) {
          var domain = getDomain();
          unhandledRejectionHandled = typeof fn2 === "function" ? domain === null ? fn2 : util2.domainBind(domain, fn2) : void 0;
        };
        var disableLongStackTraces = function() {
        };
        Promise2.longStackTraces = function() {
          if (async.haveItemsQueued() && !config2.longStackTraces) {
            throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
          }
          if (!config2.longStackTraces && longStackTracesIsSupported()) {
            var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
            var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
            var Promise_dereferenceTrace = Promise2.prototype._dereferenceTrace;
            config2.longStackTraces = true;
            disableLongStackTraces = function() {
              if (async.haveItemsQueued() && !config2.longStackTraces) {
                throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
              }
              Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
              Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
              Promise2.prototype._dereferenceTrace = Promise_dereferenceTrace;
              Context2.deactivateLongStackTraces();
              async.enableTrampoline();
              config2.longStackTraces = false;
            };
            Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
            Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
            Promise2.prototype._dereferenceTrace = longStackTracesDereferenceTrace;
            Context2.activateLongStackTraces();
            async.disableTrampolineIfNecessary();
          }
        };
        Promise2.hasLongStackTraces = function() {
          return config2.longStackTraces && longStackTracesIsSupported();
        };
        var fireDomEvent = function() {
          try {
            if (typeof CustomEvent === "function") {
              var event = new CustomEvent("CustomEvent");
              util2.global.dispatchEvent(event);
              return function(name2, event2) {
                var eventData = {
                  detail: event2,
                  cancelable: true
                };
                es52.defineProperty(
                  eventData,
                  "promise",
                  { value: event2.promise }
                );
                es52.defineProperty(eventData, "reason", { value: event2.reason });
                var domEvent = new CustomEvent(name2.toLowerCase(), eventData);
                return !util2.global.dispatchEvent(domEvent);
              };
            } else if (typeof Event === "function") {
              var event = new Event("CustomEvent");
              util2.global.dispatchEvent(event);
              return function(name2, event2) {
                var domEvent = new Event(name2.toLowerCase(), {
                  cancelable: true
                });
                domEvent.detail = event2;
                es52.defineProperty(domEvent, "promise", { value: event2.promise });
                es52.defineProperty(domEvent, "reason", { value: event2.reason });
                return !util2.global.dispatchEvent(domEvent);
              };
            } else {
              var event = document.createEvent("CustomEvent");
              event.initCustomEvent("testingtheevent", false, true, {});
              util2.global.dispatchEvent(event);
              return function(name2, event2) {
                var domEvent = document.createEvent("CustomEvent");
                domEvent.initCustomEvent(
                  name2.toLowerCase(),
                  false,
                  true,
                  event2
                );
                return !util2.global.dispatchEvent(domEvent);
              };
            }
          } catch (e) {
          }
          return function() {
            return false;
          };
        }();
        var fireGlobalEvent = function() {
          if (util2.isNode) {
            return function() {
              return process.emit.apply(process, arguments);
            };
          } else {
            if (!util2.global) {
              return function() {
                return false;
              };
            }
            return function(name2) {
              var methodName = "on" + name2.toLowerCase();
              var method = util2.global[methodName];
              if (!method)
                return false;
              method.apply(util2.global, [].slice.call(arguments, 1));
              return true;
            };
          }
        }();
        function generatePromiseLifecycleEventObject(name2, promise) {
          return { promise };
        }
        var eventToObjectGenerator = {
          promiseCreated: generatePromiseLifecycleEventObject,
          promiseFulfilled: generatePromiseLifecycleEventObject,
          promiseRejected: generatePromiseLifecycleEventObject,
          promiseResolved: generatePromiseLifecycleEventObject,
          promiseCancelled: generatePromiseLifecycleEventObject,
          promiseChained: function(name2, promise, child) {
            return { promise, child };
          },
          warning: function(name2, warning) {
            return { warning };
          },
          unhandledRejection: function(name2, reason, promise) {
            return { reason, promise };
          },
          rejectionHandled: generatePromiseLifecycleEventObject
        };
        var activeFireEvent = function(name2) {
          var globalEventFired = false;
          try {
            globalEventFired = fireGlobalEvent.apply(null, arguments);
          } catch (e) {
            async.throwLater(e);
            globalEventFired = true;
          }
          var domEventFired = false;
          try {
            domEventFired = fireDomEvent(
              name2,
              eventToObjectGenerator[name2].apply(null, arguments)
            );
          } catch (e) {
            async.throwLater(e);
            domEventFired = true;
          }
          return domEventFired || globalEventFired;
        };
        Promise2.config = function(opts) {
          opts = Object(opts);
          if ("longStackTraces" in opts) {
            if (opts.longStackTraces) {
              Promise2.longStackTraces();
            } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
              disableLongStackTraces();
            }
          }
          if ("warnings" in opts) {
            var warningsOption = opts.warnings;
            config2.warnings = !!warningsOption;
            wForgottenReturn = config2.warnings;
            if (util2.isObject(warningsOption)) {
              if ("wForgottenReturn" in warningsOption) {
                wForgottenReturn = !!warningsOption.wForgottenReturn;
              }
            }
          }
          if ("cancellation" in opts && opts.cancellation && !config2.cancellation) {
            if (async.haveItemsQueued()) {
              throw new Error(
                "cannot enable cancellation after promises are in use"
              );
            }
            Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
            Promise2.prototype._propagateFrom = cancellationPropagateFrom;
            Promise2.prototype._onCancel = cancellationOnCancel;
            Promise2.prototype._setOnCancel = cancellationSetOnCancel;
            Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
            Promise2.prototype._execute = cancellationExecute;
            propagateFromFunction = cancellationPropagateFrom;
            config2.cancellation = true;
          }
          if ("monitoring" in opts) {
            if (opts.monitoring && !config2.monitoring) {
              config2.monitoring = true;
              Promise2.prototype._fireEvent = activeFireEvent;
            } else if (!opts.monitoring && config2.monitoring) {
              config2.monitoring = false;
              Promise2.prototype._fireEvent = defaultFireEvent;
            }
          }
          return Promise2;
        };
        function defaultFireEvent() {
          return false;
        }
        Promise2.prototype._fireEvent = defaultFireEvent;
        Promise2.prototype._execute = function(executor, resolve3, reject) {
          try {
            executor(resolve3, reject);
          } catch (e) {
            return e;
          }
        };
        Promise2.prototype._onCancel = function() {
        };
        Promise2.prototype._setOnCancel = function(handler) {
        };
        Promise2.prototype._attachCancellationCallback = function(onCancel) {
        };
        Promise2.prototype._captureStackTrace = function() {
        };
        Promise2.prototype._attachExtraTrace = function() {
        };
        Promise2.prototype._dereferenceTrace = function() {
        };
        Promise2.prototype._clearCancellationData = function() {
        };
        Promise2.prototype._propagateFrom = function(parent, flags) {
        };
        function cancellationExecute(executor, resolve3, reject) {
          var promise = this;
          try {
            executor(resolve3, reject, function(onCancel) {
              if (typeof onCancel !== "function") {
                throw new TypeError("onCancel must be a function, got: " + util2.toString(onCancel));
              }
              promise._attachCancellationCallback(onCancel);
            });
          } catch (e) {
            return e;
          }
        }
        function cancellationAttachCancellationCallback(onCancel) {
          if (!this._isCancellable())
            return this;
          var previousOnCancel = this._onCancel();
          if (previousOnCancel !== void 0) {
            if (util2.isArray(previousOnCancel)) {
              previousOnCancel.push(onCancel);
            } else {
              this._setOnCancel([previousOnCancel, onCancel]);
            }
          } else {
            this._setOnCancel(onCancel);
          }
        }
        function cancellationOnCancel() {
          return this._onCancelField;
        }
        function cancellationSetOnCancel(onCancel) {
          this._onCancelField = onCancel;
        }
        function cancellationClearCancellationData() {
          this._cancellationParent = void 0;
          this._onCancelField = void 0;
        }
        function cancellationPropagateFrom(parent, flags) {
          if ((flags & 1) !== 0) {
            this._cancellationParent = parent;
            var branchesRemainingToCancel = parent._branchesRemainingToCancel;
            if (branchesRemainingToCancel === void 0) {
              branchesRemainingToCancel = 0;
            }
            parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
          }
          if ((flags & 2) !== 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
          }
        }
        function bindingPropagateFrom(parent, flags) {
          if ((flags & 2) !== 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
          }
        }
        var propagateFromFunction = bindingPropagateFrom;
        function boundValueFunction() {
          var ret2 = this._boundTo;
          if (ret2 !== void 0) {
            if (ret2 instanceof Promise2) {
              if (ret2.isFulfilled()) {
                return ret2.value();
              } else {
                return void 0;
              }
            }
          }
          return ret2;
        }
        function longStackTracesCaptureStackTrace() {
          this._trace = new CapturedTrace(this._peekContext());
        }
        function longStackTracesAttachExtraTrace(error, ignoreSelf) {
          if (canAttachTrace2(error)) {
            var trace2 = this._trace;
            if (trace2 !== void 0) {
              if (ignoreSelf)
                trace2 = trace2._parent;
            }
            if (trace2 !== void 0) {
              trace2.attachExtraTrace(error);
            } else if (!error.__stackCleaned__) {
              var parsed = parseStackAndMessage(error);
              util2.notEnumerableProp(
                error,
                "stack",
                parsed.message + "\n" + parsed.stack.join("\n")
              );
              util2.notEnumerableProp(error, "__stackCleaned__", true);
            }
          }
        }
        function longStackTracesDereferenceTrace() {
          this._trace = void 0;
        }
        function checkForgottenReturns(returnValue, promiseCreated, name2, promise, parent) {
          if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
            if (parent !== void 0 && parent._returnedNonUndefined())
              return;
            if ((promise._bitField & 65535) === 0)
              return;
            if (name2)
              name2 = name2 + " ";
            var handlerLine = "";
            var creatorLine = "";
            if (promiseCreated._trace) {
              var traceLines = promiseCreated._trace.stack.split("\n");
              var stack = cleanStack(traceLines);
              for (var i = stack.length - 1; i >= 0; --i) {
                var line = stack[i];
                if (!nodeFramePattern.test(line)) {
                  var lineMatches = line.match(parseLinePattern);
                  if (lineMatches) {
                    handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                  }
                  break;
                }
              }
              if (stack.length > 0) {
                var firstUserLine = stack[0];
                for (var i = 0; i < traceLines.length; ++i) {
                  if (traceLines[i] === firstUserLine) {
                    if (i > 0) {
                      creatorLine = "\n" + traceLines[i - 1];
                    }
                    break;
                  }
                }
              }
            }
            var msg = "a promise was created in a " + name2 + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
            promise._warn(msg, true, promiseCreated);
          }
        }
        function deprecated(name2, replacement) {
          var message = name2 + " is deprecated and will be removed in a future version.";
          if (replacement)
            message += " Use " + replacement + " instead.";
          return warn2(message);
        }
        function warn2(message, shouldUseOwnTrace, promise) {
          if (!config2.warnings)
            return;
          var warning = new Warning(message);
          var ctx;
          if (shouldUseOwnTrace) {
            promise._attachExtraTrace(warning);
          } else if (config2.longStackTraces && (ctx = Promise2._peekContext())) {
            ctx.attachExtraTrace(warning);
          } else {
            var parsed = parseStackAndMessage(warning);
            warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
          }
          if (!activeFireEvent("warning", warning)) {
            formatAndLogError(warning, "", true);
          }
        }
        function reconstructStack(message, stacks) {
          for (var i = 0; i < stacks.length - 1; ++i) {
            stacks[i].push("From previous event:");
            stacks[i] = stacks[i].join("\n");
          }
          if (i < stacks.length) {
            stacks[i] = stacks[i].join("\n");
          }
          return message + "\n" + stacks.join("\n");
        }
        function removeDuplicateOrEmptyJumps(stacks) {
          for (var i = 0; i < stacks.length; ++i) {
            if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
              stacks.splice(i, 1);
              i--;
            }
          }
        }
        function removeCommonRoots(stacks) {
          var current = stacks[0];
          for (var i = 1; i < stacks.length; ++i) {
            var prev2 = stacks[i];
            var currentLastIndex = current.length - 1;
            var currentLastLine = current[currentLastIndex];
            var commonRootMeetPoint = -1;
            for (var j = prev2.length - 1; j >= 0; --j) {
              if (prev2[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
              }
            }
            for (var j = commonRootMeetPoint; j >= 0; --j) {
              var line = prev2[j];
              if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
              } else {
                break;
              }
            }
            current = prev2;
          }
        }
        function cleanStack(stack) {
          var ret2 = [];
          for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
            var isInternalFrame = isTraceLine && shouldIgnore(line);
            if (isTraceLine && !isInternalFrame) {
              if (indentStackFrames && line.charAt(0) !== " ") {
                line = "    " + line;
              }
              ret2.push(line);
            }
          }
          return ret2;
        }
        function stackFramesAsArray(error) {
          var stack = error.stack.replace(/\s+$/g, "").split("\n");
          for (var i = 0; i < stack.length; ++i) {
            var line = stack[i];
            if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
              break;
            }
          }
          if (i > 0 && error.name != "SyntaxError") {
            stack = stack.slice(i);
          }
          return stack;
        }
        function parseStackAndMessage(error) {
          var stack = error.stack;
          var message = error.toString();
          stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
          return {
            message,
            stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
          };
        }
        function formatAndLogError(error, title, isSoft) {
          if (typeof console !== "undefined") {
            var message;
            if (util2.isObject(error)) {
              var stack = error.stack;
              message = title + formatStack(stack, error);
            } else {
              message = title + String(error);
            }
            if (typeof printWarning === "function") {
              printWarning(message, isSoft);
            } else if (typeof console.log === "function" || typeof console.log === "object") {
              console.log(message);
            }
          }
        }
        function fireRejectionEvent(name2, localHandler, reason, promise) {
          var localEventFired = false;
          try {
            if (typeof localHandler === "function") {
              localEventFired = true;
              if (name2 === "rejectionHandled") {
                localHandler(promise);
              } else {
                localHandler(reason, promise);
              }
            }
          } catch (e) {
            async.throwLater(e);
          }
          if (name2 === "unhandledRejection") {
            if (!activeFireEvent(name2, reason, promise) && !localEventFired) {
              formatAndLogError(reason, "Unhandled rejection ");
            }
          } else {
            activeFireEvent(name2, promise);
          }
        }
        function formatNonError(obj2) {
          var str;
          if (typeof obj2 === "function") {
            str = "[function " + (obj2.name || "anonymous") + "]";
          } else {
            str = obj2 && typeof obj2.toString === "function" ? obj2.toString() : util2.toString(obj2);
            var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
            if (ruselessToString.test(str)) {
              try {
                var newStr = JSON.stringify(obj2);
                str = newStr;
              } catch (e) {
              }
            }
            if (str.length === 0) {
              str = "(empty array)";
            }
          }
          return "(<" + snip(str) + ">, no stack trace)";
        }
        function snip(str) {
          var maxChars = 41;
          if (str.length < maxChars) {
            return str;
          }
          return str.substr(0, maxChars - 3) + "...";
        }
        function longStackTracesIsSupported() {
          return typeof captureStackTrace === "function";
        }
        var shouldIgnore = function() {
          return false;
        };
        var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
        function parseLineInfo(line) {
          var matches2 = line.match(parseLineInfoRegex);
          if (matches2) {
            return {
              fileName: matches2[1],
              line: parseInt(matches2[2], 10)
            };
          }
        }
        function setBounds(firstLineError, lastLineError) {
          if (!longStackTracesIsSupported())
            return;
          var firstStackLines = firstLineError.stack.split("\n");
          var lastStackLines = lastLineError.stack.split("\n");
          var firstIndex = -1;
          var lastIndex = -1;
          var firstFileName;
          var lastFileName;
          for (var i = 0; i < firstStackLines.length; ++i) {
            var result = parseLineInfo(firstStackLines[i]);
            if (result) {
              firstFileName = result.fileName;
              firstIndex = result.line;
              break;
            }
          }
          for (var i = 0; i < lastStackLines.length; ++i) {
            var result = parseLineInfo(lastStackLines[i]);
            if (result) {
              lastFileName = result.fileName;
              lastIndex = result.line;
              break;
            }
          }
          if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
            return;
          }
          shouldIgnore = function(line) {
            if (bluebirdFramePattern.test(line))
              return true;
            var info = parseLineInfo(line);
            if (info) {
              if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
                return true;
              }
            }
            return false;
          };
        }
        function CapturedTrace(parent) {
          this._parent = parent;
          this._promisesCreated = 0;
          var length2 = this._length = 1 + (parent === void 0 ? 0 : parent._length);
          captureStackTrace(this, CapturedTrace);
          if (length2 > 32)
            this.uncycle();
        }
        util2.inherits(CapturedTrace, Error);
        Context2.CapturedTrace = CapturedTrace;
        CapturedTrace.prototype.uncycle = function() {
          var length2 = this._length;
          if (length2 < 2)
            return;
          var nodes = [];
          var stackToIndex = {};
          for (var i = 0, node = this; node !== void 0; ++i) {
            nodes.push(node);
            node = node._parent;
          }
          length2 = this._length = i;
          for (var i = length2 - 1; i >= 0; --i) {
            var stack = nodes[i].stack;
            if (stackToIndex[stack] === void 0) {
              stackToIndex[stack] = i;
            }
          }
          for (var i = 0; i < length2; ++i) {
            var currentStack = nodes[i].stack;
            var index = stackToIndex[currentStack];
            if (index !== void 0 && index !== i) {
              if (index > 0) {
                nodes[index - 1]._parent = void 0;
                nodes[index - 1]._length = 1;
              }
              nodes[i]._parent = void 0;
              nodes[i]._length = 1;
              var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
              if (index < length2 - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
              } else {
                cycleEdgeNode._parent = void 0;
                cycleEdgeNode._length = 1;
              }
              var currentChildLength = cycleEdgeNode._length + 1;
              for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
              }
              return;
            }
          }
        };
        CapturedTrace.prototype.attachExtraTrace = function(error) {
          if (error.__stackCleaned__)
            return;
          this.uncycle();
          var parsed = parseStackAndMessage(error);
          var message = parsed.message;
          var stacks = [parsed.stack];
          var trace2 = this;
          while (trace2 !== void 0) {
            stacks.push(cleanStack(trace2.stack.split("\n")));
            trace2 = trace2._parent;
          }
          removeCommonRoots(stacks);
          removeDuplicateOrEmptyJumps(stacks);
          util2.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
          util2.notEnumerableProp(error, "__stackCleaned__", true);
        };
        var captureStackTrace = function stackDetection() {
          var v8stackFramePattern = /^\s*at\s*/;
          var v8stackFormatter = function(stack, error) {
            if (typeof stack === "string")
              return stack;
            if (error.name !== void 0 && error.message !== void 0) {
              return error.toString();
            }
            return formatNonError(error);
          };
          if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
            Error.stackTraceLimit += 6;
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            var captureStackTrace2 = Error.captureStackTrace;
            shouldIgnore = function(line) {
              return bluebirdFramePattern.test(line);
            };
            return function(receiver2, ignoreUntil) {
              Error.stackTraceLimit += 6;
              captureStackTrace2(receiver2, ignoreUntil);
              Error.stackTraceLimit -= 6;
            };
          }
          var err = new Error();
          if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
            stackFramePattern = /@/;
            formatStack = v8stackFormatter;
            indentStackFrames = true;
            return function captureStackTrace3(o2) {
              o2.stack = new Error().stack;
            };
          }
          var hasStackAfterThrow;
          try {
            throw new Error();
          } catch (e) {
            hasStackAfterThrow = "stack" in e;
          }
          if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            return function captureStackTrace3(o2) {
              Error.stackTraceLimit += 6;
              try {
                throw new Error();
              } catch (e) {
                o2.stack = e.stack;
              }
              Error.stackTraceLimit -= 6;
            };
          }
          formatStack = function(stack, error) {
            if (typeof stack === "string")
              return stack;
            if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
              return error.toString();
            }
            return formatNonError(error);
          };
          return null;
        }();
        if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
          printWarning = function(message) {
            console.warn(message);
          };
          if (util2.isNode && process.stderr.isTTY) {
            printWarning = function(message, isSoft) {
              var color = isSoft ? "\x1B[33m" : "\x1B[31m";
              console.warn(color + message + "\x1B[0m\n");
            };
          } else if (!util2.isNode && typeof new Error().stack === "string") {
            printWarning = function(message, isSoft) {
              console.warn(
                "%c" + message,
                isSoft ? "color: darkorange" : "color: red"
              );
            };
          }
        }
        var config2 = {
          warnings,
          longStackTraces: false,
          cancellation: false,
          monitoring: false
        };
        if (longStackTraces)
          Promise2.longStackTraces();
        return {
          longStackTraces: function() {
            return config2.longStackTraces;
          },
          warnings: function() {
            return config2.warnings;
          },
          cancellation: function() {
            return config2.cancellation;
          },
          monitoring: function() {
            return config2.monitoring;
          },
          propagateFromFunction: function() {
            return propagateFromFunction;
          },
          boundValueFunction: function() {
            return boundValueFunction;
          },
          checkForgottenReturns,
          setBounds,
          warn: warn2,
          deprecated,
          CapturedTrace,
          fireDomEvent,
          fireGlobalEvent
        };
      };
    }, { "./errors": 12, "./es5": 13, "./util": 36 }], 10: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2) {
        function returner() {
          return this.value;
        }
        function thrower2() {
          throw this.reason;
        }
        Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
          if (value instanceof Promise2)
            value.suppressUnhandledRejections();
          return this._then(
            returner,
            void 0,
            void 0,
            { value },
            void 0
          );
        };
        Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
          return this._then(
            thrower2,
            void 0,
            void 0,
            { reason },
            void 0
          );
        };
        Promise2.prototype.catchThrow = function(reason) {
          if (arguments.length <= 1) {
            return this._then(
              void 0,
              thrower2,
              void 0,
              { reason },
              void 0
            );
          } else {
            var _reason = arguments[1];
            var handler = function() {
              throw _reason;
            };
            return this.caught(reason, handler);
          }
        };
        Promise2.prototype.catchReturn = function(value) {
          if (arguments.length <= 1) {
            if (value instanceof Promise2)
              value.suppressUnhandledRejections();
            return this._then(
              void 0,
              returner,
              void 0,
              { value },
              void 0
            );
          } else {
            var _value = arguments[1];
            if (_value instanceof Promise2)
              _value.suppressUnhandledRejections();
            var handler = function() {
              return _value;
            };
            return this.caught(value, handler);
          }
        };
      };
    }, {}], 11: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, INTERNAL) {
        var PromiseReduce = Promise2.reduce;
        var PromiseAll = Promise2.all;
        function promiseAllThis() {
          return PromiseAll(this);
        }
        function PromiseMapSeries(promises, fn2) {
          return PromiseReduce(promises, fn2, INTERNAL, INTERNAL);
        }
        Promise2.prototype.each = function(fn2) {
          return PromiseReduce(this, fn2, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
        };
        Promise2.prototype.mapSeries = function(fn2) {
          return PromiseReduce(this, fn2, INTERNAL, INTERNAL);
        };
        Promise2.each = function(promises, fn2) {
          return PromiseReduce(promises, fn2, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
        };
        Promise2.mapSeries = PromiseMapSeries;
      };
    }, {}], 12: [function(_dereq_2, module2, exports2) {
      var es52 = _dereq_2("./es5");
      var Objectfreeze = es52.freeze;
      var util2 = _dereq_2("./util");
      var inherits2 = util2.inherits;
      var notEnumerableProp2 = util2.notEnumerableProp;
      function subError(nameProperty, defaultMessage) {
        function SubError(message) {
          if (!(this instanceof SubError))
            return new SubError(message);
          notEnumerableProp2(
            this,
            "message",
            typeof message === "string" ? message : defaultMessage
          );
          notEnumerableProp2(this, "name", nameProperty);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          } else {
            Error.call(this);
          }
        }
        inherits2(SubError, Error);
        return SubError;
      }
      var _TypeError, _RangeError;
      var Warning = subError("Warning", "warning");
      var CancellationError = subError("CancellationError", "cancellation error");
      var TimeoutError = subError("TimeoutError", "timeout error");
      var AggregateError = subError("AggregateError", "aggregate error");
      try {
        _TypeError = TypeError;
        _RangeError = RangeError;
      } catch (e) {
        _TypeError = subError("TypeError", "type error");
        _RangeError = subError("RangeError", "range error");
      }
      var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
      for (var i = 0; i < methods.length; ++i) {
        if (typeof Array.prototype[methods[i]] === "function") {
          AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
        }
      }
      es52.defineProperty(AggregateError.prototype, "length", {
        value: 0,
        configurable: false,
        writable: true,
        enumerable: true
      });
      AggregateError.prototype["isOperational"] = true;
      var level = 0;
      AggregateError.prototype.toString = function() {
        var indent2 = Array(level * 4 + 1).join(" ");
        var ret2 = "\n" + indent2 + "AggregateError of:\n";
        level++;
        indent2 = Array(level * 4 + 1).join(" ");
        for (var i2 = 0; i2 < this.length; ++i2) {
          var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
          var lines = str.split("\n");
          for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent2 + lines[j];
          }
          str = lines.join("\n");
          ret2 += str + "\n";
        }
        level--;
        return ret2;
      };
      function OperationalError(message) {
        if (!(this instanceof OperationalError))
          return new OperationalError(message);
        notEnumerableProp2(this, "name", "OperationalError");
        notEnumerableProp2(this, "message", message);
        this.cause = message;
        this["isOperational"] = true;
        if (message instanceof Error) {
          notEnumerableProp2(this, "message", message.message);
          notEnumerableProp2(this, "stack", message.stack);
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
      inherits2(OperationalError, Error);
      var errorTypes = Error["__BluebirdErrorTypes__"];
      if (!errorTypes) {
        errorTypes = Objectfreeze({
          CancellationError,
          TimeoutError,
          OperationalError,
          RejectionError: OperationalError,
          AggregateError
        });
        es52.defineProperty(Error, "__BluebirdErrorTypes__", {
          value: errorTypes,
          writable: false,
          enumerable: false,
          configurable: false
        });
      }
      module2.exports = {
        Error,
        TypeError: _TypeError,
        RangeError: _RangeError,
        CancellationError: errorTypes.CancellationError,
        OperationalError: errorTypes.OperationalError,
        TimeoutError: errorTypes.TimeoutError,
        AggregateError: errorTypes.AggregateError,
        Warning
      };
    }, { "./es5": 13, "./util": 36 }], 13: [function(_dereq_2, module2, exports2) {
      var isES5 = /* @__PURE__ */ function() {
        return this === void 0;
      }();
      if (isES5) {
        module2.exports = {
          freeze: Object.freeze,
          defineProperty: Object.defineProperty,
          getDescriptor: Object.getOwnPropertyDescriptor,
          keys: Object.keys,
          names: Object.getOwnPropertyNames,
          getPrototypeOf: Object.getPrototypeOf,
          isArray: Array.isArray,
          isES5,
          propertyIsWritable: function(obj2, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
          }
        };
      } else {
        var has2 = {}.hasOwnProperty;
        var str = {}.toString;
        var proto = {}.constructor.prototype;
        var ObjectKeys = function(o2) {
          var ret2 = [];
          for (var key in o2) {
            if (has2.call(o2, key)) {
              ret2.push(key);
            }
          }
          return ret2;
        };
        var ObjectGetDescriptor = function(o2, key) {
          return { value: o2[key] };
        };
        var ObjectDefineProperty = function(o2, key, desc) {
          o2[key] = desc.value;
          return o2;
        };
        var ObjectFreeze = function(obj2) {
          return obj2;
        };
        var ObjectGetPrototypeOf = function(obj2) {
          try {
            return Object(obj2).constructor.prototype;
          } catch (e) {
            return proto;
          }
        };
        var ArrayIsArray = function(obj2) {
          try {
            return str.call(obj2) === "[object Array]";
          } catch (e) {
            return false;
          }
        };
        module2.exports = {
          isArray: ArrayIsArray,
          keys: ObjectKeys,
          names: ObjectKeys,
          defineProperty: ObjectDefineProperty,
          getDescriptor: ObjectGetDescriptor,
          freeze: ObjectFreeze,
          getPrototypeOf: ObjectGetPrototypeOf,
          isES5,
          propertyIsWritable: function() {
            return true;
          }
        };
      }
    }, {}], 14: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, INTERNAL) {
        var PromiseMap = Promise2.map;
        Promise2.prototype.filter = function(fn2, options2) {
          return PromiseMap(this, fn2, options2, INTERNAL);
        };
        Promise2.filter = function(promises, fn2, options2) {
          return PromiseMap(promises, fn2, options2, INTERNAL);
        };
      };
    }, {}], 15: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, tryConvertToPromise, NEXT_FILTER) {
        var util2 = _dereq_2("./util");
        var CancellationError = Promise2.CancellationError;
        var errorObj2 = util2.errorObj;
        var catchFilter = _dereq_2("./catch_filter")(NEXT_FILTER);
        function PassThroughHandlerContext(promise, type2, handler) {
          this.promise = promise;
          this.type = type2;
          this.handler = handler;
          this.called = false;
          this.cancelPromise = null;
        }
        PassThroughHandlerContext.prototype.isFinallyHandler = function() {
          return this.type === 0;
        };
        function FinallyHandlerCancelReaction(finallyHandler2) {
          this.finallyHandler = finallyHandler2;
        }
        FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
          checkCancel(this.finallyHandler);
        };
        function checkCancel(ctx, reason) {
          if (ctx.cancelPromise != null) {
            if (arguments.length > 1) {
              ctx.cancelPromise._reject(reason);
            } else {
              ctx.cancelPromise._cancel();
            }
            ctx.cancelPromise = null;
            return true;
          }
          return false;
        }
        function succeed() {
          return finallyHandler.call(this, this.promise._target()._settledValue());
        }
        function fail2(reason) {
          if (checkCancel(this, reason))
            return;
          errorObj2.e = reason;
          return errorObj2;
        }
        function finallyHandler(reasonOrValue) {
          var promise = this.promise;
          var handler = this.handler;
          if (!this.called) {
            this.called = true;
            var ret2 = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
            if (ret2 === NEXT_FILTER) {
              return ret2;
            } else if (ret2 !== void 0) {
              promise._setReturnedNonUndefined();
              var maybePromise = tryConvertToPromise(ret2, promise);
              if (maybePromise instanceof Promise2) {
                if (this.cancelPromise != null) {
                  if (maybePromise._isCancelled()) {
                    var reason = new CancellationError("late cancellation observer");
                    promise._attachExtraTrace(reason);
                    errorObj2.e = reason;
                    return errorObj2;
                  } else if (maybePromise.isPending()) {
                    maybePromise._attachCancellationCallback(
                      new FinallyHandlerCancelReaction(this)
                    );
                  }
                }
                return maybePromise._then(
                  succeed,
                  fail2,
                  void 0,
                  this,
                  void 0
                );
              }
            }
          }
          if (promise.isRejected()) {
            checkCancel(this);
            errorObj2.e = reasonOrValue;
            return errorObj2;
          } else {
            checkCancel(this);
            return reasonOrValue;
          }
        }
        Promise2.prototype._passThrough = function(handler, type2, success, fail22) {
          if (typeof handler !== "function")
            return this.then();
          return this._then(
            success,
            fail22,
            void 0,
            new PassThroughHandlerContext(this, type2, handler),
            void 0
          );
        };
        Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
          return this._passThrough(
            handler,
            0,
            finallyHandler,
            finallyHandler
          );
        };
        Promise2.prototype.tap = function(handler) {
          return this._passThrough(handler, 1, finallyHandler);
        };
        Promise2.prototype.tapCatch = function(handlerOrPredicate) {
          var len = arguments.length;
          if (len === 1) {
            return this._passThrough(
              handlerOrPredicate,
              1,
              void 0,
              finallyHandler
            );
          } else {
            var catchInstances = new Array(len - 1), j = 0, i;
            for (i = 0; i < len - 1; ++i) {
              var item = arguments[i];
              if (util2.isObject(item)) {
                catchInstances[j++] = item;
              } else {
                return Promise2.reject(new TypeError(
                  "tapCatch statement predicate: expecting an object but got " + util2.classString(item)
                ));
              }
            }
            catchInstances.length = j;
            var handler = arguments[i];
            return this._passThrough(
              catchFilter(catchInstances, handler, this),
              1,
              void 0,
              finallyHandler
            );
          }
        };
        return PassThroughHandlerContext;
      };
    }, { "./catch_filter": 7, "./util": 36 }], 16: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug2) {
        var errors = _dereq_2("./errors");
        var TypeError2 = errors.TypeError;
        var util2 = _dereq_2("./util");
        var errorObj2 = util2.errorObj;
        var tryCatch2 = util2.tryCatch;
        var yieldHandlers = [];
        function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
          for (var i = 0; i < yieldHandlers2.length; ++i) {
            traceParent._pushContext();
            var result = tryCatch2(yieldHandlers2[i])(value);
            traceParent._popContext();
            if (result === errorObj2) {
              traceParent._pushContext();
              var ret2 = Promise2.reject(errorObj2.e);
              traceParent._popContext();
              return ret2;
            }
            var maybePromise = tryConvertToPromise(result, traceParent);
            if (maybePromise instanceof Promise2)
              return maybePromise;
          }
          return null;
        }
        function PromiseSpawn(generatorFunction, receiver2, yieldHandler, stack) {
          if (debug2.cancellation()) {
            var internal2 = new Promise2(INTERNAL);
            var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
            this._promise = internal2.lastly(function() {
              return _finallyPromise;
            });
            internal2._captureStackTrace();
            internal2._setOnCancel(this);
          } else {
            var promise = this._promise = new Promise2(INTERNAL);
            promise._captureStackTrace();
          }
          this._stack = stack;
          this._generatorFunction = generatorFunction;
          this._receiver = receiver2;
          this._generator = void 0;
          this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
          this._yieldedPromise = null;
          this._cancellationPhase = false;
        }
        util2.inherits(PromiseSpawn, Proxyable);
        PromiseSpawn.prototype._isResolved = function() {
          return this._promise === null;
        };
        PromiseSpawn.prototype._cleanup = function() {
          this._promise = this._generator = null;
          if (debug2.cancellation() && this._finallyPromise !== null) {
            this._finallyPromise._fulfill();
            this._finallyPromise = null;
          }
        };
        PromiseSpawn.prototype._promiseCancelled = function() {
          if (this._isResolved())
            return;
          var implementsReturn = typeof this._generator["return"] !== "undefined";
          var result;
          if (!implementsReturn) {
            var reason = new Promise2.CancellationError(
              "generator .return() sentinel"
            );
            Promise2.coroutine.returnSentinel = reason;
            this._promise._attachExtraTrace(reason);
            this._promise._pushContext();
            result = tryCatch2(this._generator["throw"]).call(
              this._generator,
              reason
            );
            this._promise._popContext();
          } else {
            this._promise._pushContext();
            result = tryCatch2(this._generator["return"]).call(
              this._generator,
              void 0
            );
            this._promise._popContext();
          }
          this._cancellationPhase = true;
          this._yieldedPromise = null;
          this._continue(result);
        };
        PromiseSpawn.prototype._promiseFulfilled = function(value) {
          this._yieldedPromise = null;
          this._promise._pushContext();
          var result = tryCatch2(this._generator.next).call(this._generator, value);
          this._promise._popContext();
          this._continue(result);
        };
        PromiseSpawn.prototype._promiseRejected = function(reason) {
          this._yieldedPromise = null;
          this._promise._attachExtraTrace(reason);
          this._promise._pushContext();
          var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
          this._promise._popContext();
          this._continue(result);
        };
        PromiseSpawn.prototype._resultCancelled = function() {
          if (this._yieldedPromise instanceof Promise2) {
            var promise = this._yieldedPromise;
            this._yieldedPromise = null;
            promise.cancel();
          }
        };
        PromiseSpawn.prototype.promise = function() {
          return this._promise;
        };
        PromiseSpawn.prototype._run = function() {
          this._generator = this._generatorFunction.call(this._receiver);
          this._receiver = this._generatorFunction = void 0;
          this._promiseFulfilled(void 0);
        };
        PromiseSpawn.prototype._continue = function(result) {
          var promise = this._promise;
          if (result === errorObj2) {
            this._cleanup();
            if (this._cancellationPhase) {
              return promise.cancel();
            } else {
              return promise._rejectCallback(result.e, false);
            }
          }
          var value = result.value;
          if (result.done === true) {
            this._cleanup();
            if (this._cancellationPhase) {
              return promise.cancel();
            } else {
              return promise._resolveCallback(value);
            }
          } else {
            var maybePromise = tryConvertToPromise(value, this._promise);
            if (!(maybePromise instanceof Promise2)) {
              maybePromise = promiseFromYieldHandler(
                maybePromise,
                this._yieldHandlers,
                this._promise
              );
              if (maybePromise === null) {
                this._promiseRejected(
                  new TypeError2(
                    "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
                  )
                );
                return;
              }
            }
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            if ((bitField & 50397184) === 0) {
              this._yieldedPromise = maybePromise;
              maybePromise._proxy(this, null);
            } else if ((bitField & 33554432) !== 0) {
              Promise2._async.invoke(
                this._promiseFulfilled,
                this,
                maybePromise._value()
              );
            } else if ((bitField & 16777216) !== 0) {
              Promise2._async.invoke(
                this._promiseRejected,
                this,
                maybePromise._reason()
              );
            } else {
              this._promiseCancelled();
            }
          }
        };
        Promise2.coroutine = function(generatorFunction, options2) {
          if (typeof generatorFunction !== "function") {
            throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
          }
          var yieldHandler = Object(options2).yieldHandler;
          var PromiseSpawn$ = PromiseSpawn;
          var stack = new Error().stack;
          return function() {
            var generator = generatorFunction.apply(this, arguments);
            var spawn = new PromiseSpawn$(
              void 0,
              void 0,
              yieldHandler,
              stack
            );
            var ret2 = spawn.promise();
            spawn._generator = generator;
            spawn._promiseFulfilled(void 0);
            return ret2;
          };
        };
        Promise2.coroutine.addYieldHandler = function(fn2) {
          if (typeof fn2 !== "function") {
            throw new TypeError2("expecting a function but got " + util2.classString(fn2));
          }
          yieldHandlers.push(fn2);
        };
        Promise2.spawn = function(generatorFunction) {
          debug2.deprecated("Promise.spawn()", "Promise.coroutine()");
          if (typeof generatorFunction !== "function") {
            return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
          }
          var spawn = new PromiseSpawn(generatorFunction, this);
          var ret2 = spawn.promise();
          spawn._run(Promise2.spawn);
          return ret2;
        };
      };
    }, { "./errors": 12, "./util": 36 }], 17: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
        var util2 = _dereq_2("./util");
        util2.canEvaluate;
        util2.tryCatch;
        util2.errorObj;
        Promise2.join = function() {
          var last = arguments.length - 1;
          var fn2;
          if (last > 0 && typeof arguments[last] === "function") {
            fn2 = arguments[last];
            var ret2;
          }
          var args = [].slice.call(arguments);
          if (fn2)
            args.pop();
          var ret2 = new PromiseArray(args).promise();
          return fn2 !== void 0 ? ret2.spread(fn2) : ret2;
        };
      };
    }, { "./util": 36 }], 18: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2) {
        var getDomain = Promise2._getDomain;
        var util2 = _dereq_2("./util");
        var tryCatch2 = util2.tryCatch;
        var errorObj2 = util2.errorObj;
        var async = Promise2._async;
        function MappingPromiseArray(promises, fn2, limit, _filter) {
          this.constructor$(promises);
          this._promise._captureStackTrace();
          var domain = getDomain();
          this._callback = domain === null ? fn2 : util2.domainBind(domain, fn2);
          this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
          this._limit = limit;
          this._inFlight = 0;
          this._queue = [];
          async.invoke(this._asyncInit, this, void 0);
        }
        util2.inherits(MappingPromiseArray, PromiseArray);
        MappingPromiseArray.prototype._asyncInit = function() {
          this._init$(void 0, -2);
        };
        MappingPromiseArray.prototype._init = function() {
        };
        MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
          var values = this._values;
          var length2 = this.length();
          var preservedValues = this._preservedValues;
          var limit = this._limit;
          if (index < 0) {
            index = index * -1 - 1;
            values[index] = value;
            if (limit >= 1) {
              this._inFlight--;
              this._drainQueue();
              if (this._isResolved())
                return true;
            }
          } else {
            if (limit >= 1 && this._inFlight >= limit) {
              values[index] = value;
              this._queue.push(index);
              return false;
            }
            if (preservedValues !== null)
              preservedValues[index] = value;
            var promise = this._promise;
            var callback = this._callback;
            var receiver2 = promise._boundValue();
            promise._pushContext();
            var ret2 = tryCatch2(callback).call(receiver2, value, index, length2);
            var promiseCreated = promise._popContext();
            debug2.checkForgottenReturns(
              ret2,
              promiseCreated,
              preservedValues !== null ? "Promise.filter" : "Promise.map",
              promise
            );
            if (ret2 === errorObj2) {
              this._reject(ret2.e);
              return true;
            }
            var maybePromise = tryConvertToPromise(ret2, this._promise);
            if (maybePromise instanceof Promise2) {
              maybePromise = maybePromise._target();
              var bitField = maybePromise._bitField;
              if ((bitField & 50397184) === 0) {
                if (limit >= 1)
                  this._inFlight++;
                values[index] = maybePromise;
                maybePromise._proxy(this, (index + 1) * -1);
                return false;
              } else if ((bitField & 33554432) !== 0) {
                ret2 = maybePromise._value();
              } else if ((bitField & 16777216) !== 0) {
                this._reject(maybePromise._reason());
                return true;
              } else {
                this._cancel();
                return true;
              }
            }
            values[index] = ret2;
          }
          var totalResolved = ++this._totalResolved;
          if (totalResolved >= length2) {
            if (preservedValues !== null) {
              this._filter(values, preservedValues);
            } else {
              this._resolve(values);
            }
            return true;
          }
          return false;
        };
        MappingPromiseArray.prototype._drainQueue = function() {
          var queue2 = this._queue;
          var limit = this._limit;
          var values = this._values;
          while (queue2.length > 0 && this._inFlight < limit) {
            if (this._isResolved())
              return;
            var index = queue2.pop();
            this._promiseFulfilled(values[index], index);
          }
        };
        MappingPromiseArray.prototype._filter = function(booleans, values) {
          var len = values.length;
          var ret2 = new Array(len);
          var j = 0;
          for (var i = 0; i < len; ++i) {
            if (booleans[i])
              ret2[j++] = values[i];
          }
          ret2.length = j;
          this._resolve(ret2);
        };
        MappingPromiseArray.prototype.preservedValues = function() {
          return this._preservedValues;
        };
        function map2(promises, fn2, options2, _filter) {
          if (typeof fn2 !== "function") {
            return apiRejection("expecting a function but got " + util2.classString(fn2));
          }
          var limit = 0;
          if (options2 !== void 0) {
            if (typeof options2 === "object" && options2 !== null) {
              if (typeof options2.concurrency !== "number") {
                return Promise2.reject(
                  new TypeError("'concurrency' must be a number but it is " + util2.classString(options2.concurrency))
                );
              }
              limit = options2.concurrency;
            } else {
              return Promise2.reject(new TypeError(
                "options argument must be an object but it is " + util2.classString(options2)
              ));
            }
          }
          limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
          return new MappingPromiseArray(promises, fn2, limit, _filter).promise();
        }
        Promise2.prototype.map = function(fn2, options2) {
          return map2(this, fn2, options2, null);
        };
        Promise2.map = function(promises, fn2, options2, _filter) {
          return map2(promises, fn2, options2, _filter);
        };
      };
    }, { "./util": 36 }], 19: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug2) {
        var util2 = _dereq_2("./util");
        var tryCatch2 = util2.tryCatch;
        Promise2.method = function(fn2) {
          if (typeof fn2 !== "function") {
            throw new Promise2.TypeError("expecting a function but got " + util2.classString(fn2));
          }
          return function() {
            var ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._pushContext();
            var value = tryCatch2(fn2).apply(this, arguments);
            var promiseCreated = ret2._popContext();
            debug2.checkForgottenReturns(
              value,
              promiseCreated,
              "Promise.method",
              ret2
            );
            ret2._resolveFromSyncValue(value);
            return ret2;
          };
        };
        Promise2.attempt = Promise2["try"] = function(fn2) {
          if (typeof fn2 !== "function") {
            return apiRejection("expecting a function but got " + util2.classString(fn2));
          }
          var ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._pushContext();
          var value;
          if (arguments.length > 1) {
            debug2.deprecated("calling Promise.try with more than 1 argument");
            var arg = arguments[1];
            var ctx = arguments[2];
            value = util2.isArray(arg) ? tryCatch2(fn2).apply(ctx, arg) : tryCatch2(fn2).call(ctx, arg);
          } else {
            value = tryCatch2(fn2)();
          }
          var promiseCreated = ret2._popContext();
          debug2.checkForgottenReturns(
            value,
            promiseCreated,
            "Promise.try",
            ret2
          );
          ret2._resolveFromSyncValue(value);
          return ret2;
        };
        Promise2.prototype._resolveFromSyncValue = function(value) {
          if (value === util2.errorObj) {
            this._rejectCallback(value.e, false);
          } else {
            this._resolveCallback(value, true);
          }
        };
      };
    }, { "./util": 36 }], 20: [function(_dereq_2, module2, exports2) {
      var util2 = _dereq_2("./util");
      var maybeWrapAsError2 = util2.maybeWrapAsError;
      var errors = _dereq_2("./errors");
      var OperationalError = errors.OperationalError;
      var es52 = _dereq_2("./es5");
      function isUntypedError(obj2) {
        return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
      }
      var rErrorKey = /^(?:name|message|stack|cause)$/;
      function wrapAsOperationalError(obj2) {
        var ret2;
        if (isUntypedError(obj2)) {
          ret2 = new OperationalError(obj2);
          ret2.name = obj2.name;
          ret2.message = obj2.message;
          ret2.stack = obj2.stack;
          var keys2 = es52.keys(obj2);
          for (var i = 0; i < keys2.length; ++i) {
            var key = keys2[i];
            if (!rErrorKey.test(key)) {
              ret2[key] = obj2[key];
            }
          }
          return ret2;
        }
        util2.markAsOriginatingFromRejection(obj2);
        return obj2;
      }
      function nodebackForPromise(promise, multiArgs) {
        return function(err, value) {
          if (promise === null)
            return;
          if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
          } else if (!multiArgs) {
            promise._fulfill(value);
          } else {
            var args = [].slice.call(arguments, 1);
            promise._fulfill(args);
          }
          promise = null;
        };
      }
      module2.exports = nodebackForPromise;
    }, { "./errors": 12, "./es5": 13, "./util": 36 }], 21: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2) {
        var util2 = _dereq_2("./util");
        var async = Promise2._async;
        var tryCatch2 = util2.tryCatch;
        var errorObj2 = util2.errorObj;
        function spreadAdapter(val, nodeback) {
          var promise = this;
          if (!util2.isArray(val))
            return successAdapter.call(promise, val, nodeback);
          var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
          if (ret2 === errorObj2) {
            async.throwLater(ret2.e);
          }
        }
        function successAdapter(val, nodeback) {
          var promise = this;
          var receiver2 = promise._boundValue();
          var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver2, null) : tryCatch2(nodeback).call(receiver2, null, val);
          if (ret2 === errorObj2) {
            async.throwLater(ret2.e);
          }
        }
        function errorAdapter(reason, nodeback) {
          var promise = this;
          if (!reason) {
            var newReason = new Error(reason + "");
            newReason.cause = reason;
            reason = newReason;
          }
          var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
          if (ret2 === errorObj2) {
            async.throwLater(ret2.e);
          }
        }
        Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options2) {
          if (typeof nodeback == "function") {
            var adapter = successAdapter;
            if (options2 !== void 0 && Object(options2).spread) {
              adapter = spreadAdapter;
            }
            this._then(
              adapter,
              errorAdapter,
              void 0,
              this,
              nodeback
            );
          }
          return this;
        };
      };
    }, { "./util": 36 }], 22: [function(_dereq_2, module2, exports2) {
      module2.exports = function() {
        var makeSelfResolutionError = function() {
          return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
        };
        var reflectHandler = function() {
          return new Promise2.PromiseInspection(this._target());
        };
        var apiRejection = function(msg) {
          return Promise2.reject(new TypeError2(msg));
        };
        function Proxyable() {
        }
        var UNDEFINED_BINDING = {};
        var util2 = _dereq_2("./util");
        var getDomain;
        if (util2.isNode) {
          getDomain = function() {
            var ret2 = process.domain;
            if (ret2 === void 0)
              ret2 = null;
            return ret2;
          };
        } else {
          getDomain = function() {
            return null;
          };
        }
        util2.notEnumerableProp(Promise2, "_getDomain", getDomain);
        var es52 = _dereq_2("./es5");
        var Async = _dereq_2("./async");
        var async = new Async();
        es52.defineProperty(Promise2, "_async", { value: async });
        var errors = _dereq_2("./errors");
        var TypeError2 = Promise2.TypeError = errors.TypeError;
        Promise2.RangeError = errors.RangeError;
        var CancellationError = Promise2.CancellationError = errors.CancellationError;
        Promise2.TimeoutError = errors.TimeoutError;
        Promise2.OperationalError = errors.OperationalError;
        Promise2.RejectionError = errors.OperationalError;
        Promise2.AggregateError = errors.AggregateError;
        var INTERNAL = function() {
        };
        var APPLY = {};
        var NEXT_FILTER = {};
        var tryConvertToPromise = _dereq_2("./thenables")(Promise2, INTERNAL);
        var PromiseArray = _dereq_2("./promise_array")(
          Promise2,
          INTERNAL,
          tryConvertToPromise,
          apiRejection,
          Proxyable
        );
        var Context2 = _dereq_2("./context")(Promise2);
        var createContext = Context2.create;
        var debug2 = _dereq_2("./debuggability")(Promise2, Context2);
        debug2.CapturedTrace;
        var PassThroughHandlerContext = _dereq_2("./finally")(Promise2, tryConvertToPromise, NEXT_FILTER);
        var catchFilter = _dereq_2("./catch_filter")(NEXT_FILTER);
        var nodebackForPromise = _dereq_2("./nodeback");
        var errorObj2 = util2.errorObj;
        var tryCatch2 = util2.tryCatch;
        function check(self2, executor) {
          if (self2 == null || self2.constructor !== Promise2) {
            throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
          }
          if (typeof executor !== "function") {
            throw new TypeError2("expecting a function but got " + util2.classString(executor));
          }
        }
        function Promise2(executor) {
          if (executor !== INTERNAL) {
            check(this, executor);
          }
          this._bitField = 0;
          this._fulfillmentHandler0 = void 0;
          this._rejectionHandler0 = void 0;
          this._promise0 = void 0;
          this._receiver0 = void 0;
          this._resolveFromExecutor(executor);
          this._promiseCreated();
          this._fireEvent("promiseCreated", this);
        }
        Promise2.prototype.toString = function() {
          return "[object Promise]";
        };
        Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn2) {
          var len = arguments.length;
          if (len > 1) {
            var catchInstances = new Array(len - 1), j = 0, i;
            for (i = 0; i < len - 1; ++i) {
              var item = arguments[i];
              if (util2.isObject(item)) {
                catchInstances[j++] = item;
              } else {
                return apiRejection("Catch statement predicate: expecting an object but got " + util2.classString(item));
              }
            }
            catchInstances.length = j;
            fn2 = arguments[i];
            return this.then(void 0, catchFilter(catchInstances, fn2, this));
          }
          return this.then(void 0, fn2);
        };
        Promise2.prototype.reflect = function() {
          return this._then(
            reflectHandler,
            reflectHandler,
            void 0,
            this,
            void 0
          );
        };
        Promise2.prototype.then = function(didFulfill, didReject) {
          if (debug2.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
            var msg = ".then() only accepts functions but was passed: " + util2.classString(didFulfill);
            if (arguments.length > 1) {
              msg += ", " + util2.classString(didReject);
            }
            this._warn(msg);
          }
          return this._then(didFulfill, didReject, void 0, void 0, void 0);
        };
        Promise2.prototype.done = function(didFulfill, didReject) {
          var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
          promise._setIsFinal();
        };
        Promise2.prototype.spread = function(fn2) {
          if (typeof fn2 !== "function") {
            return apiRejection("expecting a function but got " + util2.classString(fn2));
          }
          return this.all()._then(fn2, void 0, void 0, APPLY, void 0);
        };
        Promise2.prototype.toJSON = function() {
          var ret2 = {
            isFulfilled: false,
            isRejected: false,
            fulfillmentValue: void 0,
            rejectionReason: void 0
          };
          if (this.isFulfilled()) {
            ret2.fulfillmentValue = this.value();
            ret2.isFulfilled = true;
          } else if (this.isRejected()) {
            ret2.rejectionReason = this.reason();
            ret2.isRejected = true;
          }
          return ret2;
        };
        Promise2.prototype.all = function() {
          if (arguments.length > 0) {
            this._warn(".all() was passed arguments but it does not take any");
          }
          return new PromiseArray(this).promise();
        };
        Promise2.prototype.error = function(fn2) {
          return this.caught(util2.originatesFromRejection, fn2);
        };
        Promise2.getNewLibraryCopy = module2.exports;
        Promise2.is = function(val) {
          return val instanceof Promise2;
        };
        Promise2.fromNode = Promise2.fromCallback = function(fn2) {
          var ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
          var result = tryCatch2(fn2)(nodebackForPromise(ret2, multiArgs));
          if (result === errorObj2) {
            ret2._rejectCallback(result.e, true);
          }
          if (!ret2._isFateSealed())
            ret2._setAsyncGuaranteed();
          return ret2;
        };
        Promise2.all = function(promises) {
          return new PromiseArray(promises).promise();
        };
        Promise2.cast = function(obj2) {
          var ret2 = tryConvertToPromise(obj2);
          if (!(ret2 instanceof Promise2)) {
            ret2 = new Promise2(INTERNAL);
            ret2._captureStackTrace();
            ret2._setFulfilled();
            ret2._rejectionHandler0 = obj2;
          }
          return ret2;
        };
        Promise2.resolve = Promise2.fulfilled = Promise2.cast;
        Promise2.reject = Promise2.rejected = function(reason) {
          var ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._rejectCallback(reason, true);
          return ret2;
        };
        Promise2.setScheduler = function(fn2) {
          if (typeof fn2 !== "function") {
            throw new TypeError2("expecting a function but got " + util2.classString(fn2));
          }
          return async.setScheduler(fn2);
        };
        Promise2.prototype._then = function(didFulfill, didReject, _2, receiver2, internalData) {
          var haveInternalData = internalData !== void 0;
          var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
          var target = this._target();
          var bitField = target._bitField;
          if (!haveInternalData) {
            promise._propagateFrom(this, 3);
            promise._captureStackTrace();
            if (receiver2 === void 0 && (this._bitField & 2097152) !== 0) {
              if (!((bitField & 50397184) === 0)) {
                receiver2 = this._boundValue();
              } else {
                receiver2 = target === this ? void 0 : this._boundTo;
              }
            }
            this._fireEvent("promiseChained", this, promise);
          }
          var domain = getDomain();
          if (!((bitField & 50397184) === 0)) {
            var handler, value, settler = target._settlePromiseCtx;
            if ((bitField & 33554432) !== 0) {
              value = target._rejectionHandler0;
              handler = didFulfill;
            } else if ((bitField & 16777216) !== 0) {
              value = target._fulfillmentHandler0;
              handler = didReject;
              target._unsetRejectionIsUnhandled();
            } else {
              settler = target._settlePromiseLateCancellationObserver;
              value = new CancellationError("late cancellation observer");
              target._attachExtraTrace(value);
              handler = didReject;
            }
            async.invoke(settler, target, {
              handler: domain === null ? handler : typeof handler === "function" && util2.domainBind(domain, handler),
              promise,
              receiver: receiver2,
              value
            });
          } else {
            target._addCallbacks(didFulfill, didReject, promise, receiver2, domain);
          }
          return promise;
        };
        Promise2.prototype._length = function() {
          return this._bitField & 65535;
        };
        Promise2.prototype._isFateSealed = function() {
          return (this._bitField & 117506048) !== 0;
        };
        Promise2.prototype._isFollowing = function() {
          return (this._bitField & 67108864) === 67108864;
        };
        Promise2.prototype._setLength = function(len) {
          this._bitField = this._bitField & -65536 | len & 65535;
        };
        Promise2.prototype._setFulfilled = function() {
          this._bitField = this._bitField | 33554432;
          this._fireEvent("promiseFulfilled", this);
        };
        Promise2.prototype._setRejected = function() {
          this._bitField = this._bitField | 16777216;
          this._fireEvent("promiseRejected", this);
        };
        Promise2.prototype._setFollowing = function() {
          this._bitField = this._bitField | 67108864;
          this._fireEvent("promiseResolved", this);
        };
        Promise2.prototype._setIsFinal = function() {
          this._bitField = this._bitField | 4194304;
        };
        Promise2.prototype._isFinal = function() {
          return (this._bitField & 4194304) > 0;
        };
        Promise2.prototype._unsetCancelled = function() {
          this._bitField = this._bitField & ~65536;
        };
        Promise2.prototype._setCancelled = function() {
          this._bitField = this._bitField | 65536;
          this._fireEvent("promiseCancelled", this);
        };
        Promise2.prototype._setWillBeCancelled = function() {
          this._bitField = this._bitField | 8388608;
        };
        Promise2.prototype._setAsyncGuaranteed = function() {
          if (async.hasCustomScheduler())
            return;
          this._bitField = this._bitField | 134217728;
        };
        Promise2.prototype._receiverAt = function(index) {
          var ret2 = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
          if (ret2 === UNDEFINED_BINDING) {
            return void 0;
          } else if (ret2 === void 0 && this._isBound()) {
            return this._boundValue();
          }
          return ret2;
        };
        Promise2.prototype._promiseAt = function(index) {
          return this[index * 4 - 4 + 2];
        };
        Promise2.prototype._fulfillmentHandlerAt = function(index) {
          return this[index * 4 - 4 + 0];
        };
        Promise2.prototype._rejectionHandlerAt = function(index) {
          return this[index * 4 - 4 + 1];
        };
        Promise2.prototype._boundValue = function() {
        };
        Promise2.prototype._migrateCallback0 = function(follower) {
          follower._bitField;
          var fulfill = follower._fulfillmentHandler0;
          var reject = follower._rejectionHandler0;
          var promise = follower._promise0;
          var receiver2 = follower._receiverAt(0);
          if (receiver2 === void 0)
            receiver2 = UNDEFINED_BINDING;
          this._addCallbacks(fulfill, reject, promise, receiver2, null);
        };
        Promise2.prototype._migrateCallbackAt = function(follower, index) {
          var fulfill = follower._fulfillmentHandlerAt(index);
          var reject = follower._rejectionHandlerAt(index);
          var promise = follower._promiseAt(index);
          var receiver2 = follower._receiverAt(index);
          if (receiver2 === void 0)
            receiver2 = UNDEFINED_BINDING;
          this._addCallbacks(fulfill, reject, promise, receiver2, null);
        };
        Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver2, domain) {
          var index = this._length();
          if (index >= 65535 - 4) {
            index = 0;
            this._setLength(0);
          }
          if (index === 0) {
            this._promise0 = promise;
            this._receiver0 = receiver2;
            if (typeof fulfill === "function") {
              this._fulfillmentHandler0 = domain === null ? fulfill : util2.domainBind(domain, fulfill);
            }
            if (typeof reject === "function") {
              this._rejectionHandler0 = domain === null ? reject : util2.domainBind(domain, reject);
            }
          } else {
            var base = index * 4 - 4;
            this[base + 2] = promise;
            this[base + 3] = receiver2;
            if (typeof fulfill === "function") {
              this[base + 0] = domain === null ? fulfill : util2.domainBind(domain, fulfill);
            }
            if (typeof reject === "function") {
              this[base + 1] = domain === null ? reject : util2.domainBind(domain, reject);
            }
          }
          this._setLength(index + 1);
          return index;
        };
        Promise2.prototype._proxy = function(proxyable, arg) {
          this._addCallbacks(void 0, void 0, arg, proxyable, null);
        };
        Promise2.prototype._resolveCallback = function(value, shouldBind) {
          if ((this._bitField & 117506048) !== 0)
            return;
          if (value === this)
            return this._rejectCallback(makeSelfResolutionError(), false);
          var maybePromise = tryConvertToPromise(value, this);
          if (!(maybePromise instanceof Promise2))
            return this._fulfill(value);
          if (shouldBind)
            this._propagateFrom(maybePromise, 2);
          var promise = maybePromise._target();
          if (promise === this) {
            this._reject(makeSelfResolutionError());
            return;
          }
          var bitField = promise._bitField;
          if ((bitField & 50397184) === 0) {
            var len = this._length();
            if (len > 0)
              promise._migrateCallback0(this);
            for (var i = 1; i < len; ++i) {
              promise._migrateCallbackAt(this, i);
            }
            this._setFollowing();
            this._setLength(0);
            this._setFollowee(promise);
          } else if ((bitField & 33554432) !== 0) {
            this._fulfill(promise._value());
          } else if ((bitField & 16777216) !== 0) {
            this._reject(promise._reason());
          } else {
            var reason = new CancellationError("late cancellation observer");
            promise._attachExtraTrace(reason);
            this._reject(reason);
          }
        };
        Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
          var trace2 = util2.ensureErrorObject(reason);
          var hasStack = trace2 === reason;
          if (!hasStack && !ignoreNonErrorWarnings && debug2.warnings()) {
            var message = "a promise was rejected with a non-error: " + util2.classString(reason);
            this._warn(message, true);
          }
          this._attachExtraTrace(trace2, synchronous ? hasStack : false);
          this._reject(reason);
        };
        Promise2.prototype._resolveFromExecutor = function(executor) {
          if (executor === INTERNAL)
            return;
          var promise = this;
          this._captureStackTrace();
          this._pushContext();
          var synchronous = true;
          var r2 = this._execute(executor, function(value) {
            promise._resolveCallback(value);
          }, function(reason) {
            promise._rejectCallback(reason, synchronous);
          });
          synchronous = false;
          this._popContext();
          if (r2 !== void 0) {
            promise._rejectCallback(r2, true);
          }
        };
        Promise2.prototype._settlePromiseFromHandler = function(handler, receiver2, value, promise) {
          var bitField = promise._bitField;
          if ((bitField & 65536) !== 0)
            return;
          promise._pushContext();
          var x2;
          if (receiver2 === APPLY) {
            if (!value || typeof value.length !== "number") {
              x2 = errorObj2;
              x2.e = new TypeError2("cannot .spread() a non-array: " + util2.classString(value));
            } else {
              x2 = tryCatch2(handler).apply(this._boundValue(), value);
            }
          } else {
            x2 = tryCatch2(handler).call(receiver2, value);
          }
          var promiseCreated = promise._popContext();
          bitField = promise._bitField;
          if ((bitField & 65536) !== 0)
            return;
          if (x2 === NEXT_FILTER) {
            promise._reject(value);
          } else if (x2 === errorObj2) {
            promise._rejectCallback(x2.e, false);
          } else {
            debug2.checkForgottenReturns(x2, promiseCreated, "", promise, this);
            promise._resolveCallback(x2);
          }
        };
        Promise2.prototype._target = function() {
          var ret2 = this;
          while (ret2._isFollowing())
            ret2 = ret2._followee();
          return ret2;
        };
        Promise2.prototype._followee = function() {
          return this._rejectionHandler0;
        };
        Promise2.prototype._setFollowee = function(promise) {
          this._rejectionHandler0 = promise;
        };
        Promise2.prototype._settlePromise = function(promise, handler, receiver2, value) {
          var isPromise2 = promise instanceof Promise2;
          var bitField = this._bitField;
          var asyncGuaranteed = (bitField & 134217728) !== 0;
          if ((bitField & 65536) !== 0) {
            if (isPromise2)
              promise._invokeInternalOnCancel();
            if (receiver2 instanceof PassThroughHandlerContext && receiver2.isFinallyHandler()) {
              receiver2.cancelPromise = promise;
              if (tryCatch2(handler).call(receiver2, value) === errorObj2) {
                promise._reject(errorObj2.e);
              }
            } else if (handler === reflectHandler) {
              promise._fulfill(reflectHandler.call(receiver2));
            } else if (receiver2 instanceof Proxyable) {
              receiver2._promiseCancelled(promise);
            } else if (isPromise2 || promise instanceof PromiseArray) {
              promise._cancel();
            } else {
              receiver2.cancel();
            }
          } else if (typeof handler === "function") {
            if (!isPromise2) {
              handler.call(receiver2, value, promise);
            } else {
              if (asyncGuaranteed)
                promise._setAsyncGuaranteed();
              this._settlePromiseFromHandler(handler, receiver2, value, promise);
            }
          } else if (receiver2 instanceof Proxyable) {
            if (!receiver2._isResolved()) {
              if ((bitField & 33554432) !== 0) {
                receiver2._promiseFulfilled(value, promise);
              } else {
                receiver2._promiseRejected(value, promise);
              }
            }
          } else if (isPromise2) {
            if (asyncGuaranteed)
              promise._setAsyncGuaranteed();
            if ((bitField & 33554432) !== 0) {
              promise._fulfill(value);
            } else {
              promise._reject(value);
            }
          }
        };
        Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
          var handler = ctx.handler;
          var promise = ctx.promise;
          var receiver2 = ctx.receiver;
          var value = ctx.value;
          if (typeof handler === "function") {
            if (!(promise instanceof Promise2)) {
              handler.call(receiver2, value, promise);
            } else {
              this._settlePromiseFromHandler(handler, receiver2, value, promise);
            }
          } else if (promise instanceof Promise2) {
            promise._reject(value);
          }
        };
        Promise2.prototype._settlePromiseCtx = function(ctx) {
          this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
        };
        Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
          var promise = this._promise0;
          var receiver2 = this._receiverAt(0);
          this._promise0 = void 0;
          this._receiver0 = void 0;
          this._settlePromise(promise, handler, receiver2, value);
        };
        Promise2.prototype._clearCallbackDataAtIndex = function(index) {
          var base = index * 4 - 4;
          this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
        };
        Promise2.prototype._fulfill = function(value) {
          var bitField = this._bitField;
          if ((bitField & 117506048) >>> 16)
            return;
          if (value === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._reject(err);
          }
          this._setFulfilled();
          this._rejectionHandler0 = value;
          if ((bitField & 65535) > 0) {
            if ((bitField & 134217728) !== 0) {
              this._settlePromises();
            } else {
              async.settlePromises(this);
            }
            this._dereferenceTrace();
          }
        };
        Promise2.prototype._reject = function(reason) {
          var bitField = this._bitField;
          if ((bitField & 117506048) >>> 16)
            return;
          this._setRejected();
          this._fulfillmentHandler0 = reason;
          if (this._isFinal()) {
            return async.fatalError(reason, util2.isNode);
          }
          if ((bitField & 65535) > 0) {
            async.settlePromises(this);
          } else {
            this._ensurePossibleRejectionHandled();
          }
        };
        Promise2.prototype._fulfillPromises = function(len, value) {
          for (var i = 1; i < len; i++) {
            var handler = this._fulfillmentHandlerAt(i);
            var promise = this._promiseAt(i);
            var receiver2 = this._receiverAt(i);
            this._clearCallbackDataAtIndex(i);
            this._settlePromise(promise, handler, receiver2, value);
          }
        };
        Promise2.prototype._rejectPromises = function(len, reason) {
          for (var i = 1; i < len; i++) {
            var handler = this._rejectionHandlerAt(i);
            var promise = this._promiseAt(i);
            var receiver2 = this._receiverAt(i);
            this._clearCallbackDataAtIndex(i);
            this._settlePromise(promise, handler, receiver2, reason);
          }
        };
        Promise2.prototype._settlePromises = function() {
          var bitField = this._bitField;
          var len = bitField & 65535;
          if (len > 0) {
            if ((bitField & 16842752) !== 0) {
              var reason = this._fulfillmentHandler0;
              this._settlePromise0(this._rejectionHandler0, reason, bitField);
              this._rejectPromises(len, reason);
            } else {
              var value = this._rejectionHandler0;
              this._settlePromise0(this._fulfillmentHandler0, value, bitField);
              this._fulfillPromises(len, value);
            }
            this._setLength(0);
          }
          this._clearCancellationData();
        };
        Promise2.prototype._settledValue = function() {
          var bitField = this._bitField;
          if ((bitField & 33554432) !== 0) {
            return this._rejectionHandler0;
          } else if ((bitField & 16777216) !== 0) {
            return this._fulfillmentHandler0;
          }
        };
        function deferResolve(v) {
          this.promise._resolveCallback(v);
        }
        function deferReject(v) {
          this.promise._rejectCallback(v, false);
        }
        Promise2.defer = Promise2.pending = function() {
          debug2.deprecated("Promise.defer", "new Promise");
          var promise = new Promise2(INTERNAL);
          return {
            promise,
            resolve: deferResolve,
            reject: deferReject
          };
        };
        util2.notEnumerableProp(
          Promise2,
          "_makeSelfResolutionError",
          makeSelfResolutionError
        );
        _dereq_2("./method")(
          Promise2,
          INTERNAL,
          tryConvertToPromise,
          apiRejection,
          debug2
        );
        _dereq_2("./bind")(Promise2, INTERNAL, tryConvertToPromise, debug2);
        _dereq_2("./cancel")(Promise2, PromiseArray, apiRejection, debug2);
        _dereq_2("./direct_resolve")(Promise2);
        _dereq_2("./synchronous_inspection")(Promise2);
        _dereq_2("./join")(
          Promise2,
          PromiseArray,
          tryConvertToPromise,
          INTERNAL,
          async,
          getDomain
        );
        Promise2.Promise = Promise2;
        Promise2.version = "3.5.3";
        _dereq_2("./map.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2);
        _dereq_2("./call_get.js")(Promise2);
        _dereq_2("./using.js")(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug2);
        _dereq_2("./timers.js")(Promise2, INTERNAL, debug2);
        _dereq_2("./generators.js")(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug2);
        _dereq_2("./nodeify.js")(Promise2);
        _dereq_2("./promisify.js")(Promise2, INTERNAL);
        _dereq_2("./props.js")(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
        _dereq_2("./race.js")(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
        _dereq_2("./reduce.js")(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2);
        _dereq_2("./settle.js")(Promise2, PromiseArray, debug2);
        _dereq_2("./some.js")(Promise2, PromiseArray, apiRejection);
        _dereq_2("./filter.js")(Promise2, INTERNAL);
        _dereq_2("./each.js")(Promise2, INTERNAL);
        _dereq_2("./any.js")(Promise2);
        util2.toFastProperties(Promise2);
        util2.toFastProperties(Promise2.prototype);
        function fillTypes(value) {
          var p2 = new Promise2(INTERNAL);
          p2._fulfillmentHandler0 = value;
          p2._rejectionHandler0 = value;
          p2._promise0 = value;
          p2._receiver0 = value;
        }
        fillTypes({ a: 1 });
        fillTypes({ b: 2 });
        fillTypes({ c: 3 });
        fillTypes(1);
        fillTypes(function() {
        });
        fillTypes(void 0);
        fillTypes(false);
        fillTypes(new Promise2(INTERNAL));
        debug2.setBounds(Async.firstLineError, util2.lastLineError);
        return Promise2;
      };
    }, { "./any.js": 1, "./async": 2, "./bind": 3, "./call_get.js": 5, "./cancel": 6, "./catch_filter": 7, "./context": 8, "./debuggability": 9, "./direct_resolve": 10, "./each.js": 11, "./errors": 12, "./es5": 13, "./filter.js": 14, "./finally": 15, "./generators.js": 16, "./join": 17, "./map.js": 18, "./method": 19, "./nodeback": 20, "./nodeify.js": 21, "./promise_array": 23, "./promisify.js": 24, "./props.js": 25, "./race.js": 27, "./reduce.js": 28, "./settle.js": 30, "./some.js": 31, "./synchronous_inspection": 32, "./thenables": 33, "./timers.js": 34, "./using.js": 35, "./util": 36 }], 23: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
        var util2 = _dereq_2("./util");
        util2.isArray;
        function toResolutionValue(val) {
          switch (val) {
            case -2:
              return [];
            case -3:
              return {};
            case -6:
              return /* @__PURE__ */ new Map();
          }
        }
        function PromiseArray(values) {
          var promise = this._promise = new Promise2(INTERNAL);
          if (values instanceof Promise2) {
            promise._propagateFrom(values, 3);
          }
          promise._setOnCancel(this);
          this._values = values;
          this._length = 0;
          this._totalResolved = 0;
          this._init(void 0, -2);
        }
        util2.inherits(PromiseArray, Proxyable);
        PromiseArray.prototype.length = function() {
          return this._length;
        };
        PromiseArray.prototype.promise = function() {
          return this._promise;
        };
        PromiseArray.prototype._init = function init2(_2, resolveValueIfEmpty) {
          var values = tryConvertToPromise(this._values, this._promise);
          if (values instanceof Promise2) {
            values = values._target();
            var bitField = values._bitField;
            this._values = values;
            if ((bitField & 50397184) === 0) {
              this._promise._setAsyncGuaranteed();
              return values._then(
                init2,
                this._reject,
                void 0,
                this,
                resolveValueIfEmpty
              );
            } else if ((bitField & 33554432) !== 0) {
              values = values._value();
            } else if ((bitField & 16777216) !== 0) {
              return this._reject(values._reason());
            } else {
              return this._cancel();
            }
          }
          values = util2.asArray(values);
          if (values === null) {
            var err = apiRejection(
              "expecting an array or an iterable object but got " + util2.classString(values)
            ).reason();
            this._promise._rejectCallback(err, false);
            return;
          }
          if (values.length === 0) {
            if (resolveValueIfEmpty === -5) {
              this._resolveEmptyArray();
            } else {
              this._resolve(toResolutionValue(resolveValueIfEmpty));
            }
            return;
          }
          this._iterate(values);
        };
        PromiseArray.prototype._iterate = function(values) {
          var len = this.getActualLength(values.length);
          this._length = len;
          this._values = this.shouldCopyValues() ? new Array(len) : this._values;
          var result = this._promise;
          var isResolved = false;
          var bitField = null;
          for (var i = 0; i < len; ++i) {
            var maybePromise = tryConvertToPromise(values[i], result);
            if (maybePromise instanceof Promise2) {
              maybePromise = maybePromise._target();
              bitField = maybePromise._bitField;
            } else {
              bitField = null;
            }
            if (isResolved) {
              if (bitField !== null) {
                maybePromise.suppressUnhandledRejections();
              }
            } else if (bitField !== null) {
              if ((bitField & 50397184) === 0) {
                maybePromise._proxy(this, i);
                this._values[i] = maybePromise;
              } else if ((bitField & 33554432) !== 0) {
                isResolved = this._promiseFulfilled(maybePromise._value(), i);
              } else if ((bitField & 16777216) !== 0) {
                isResolved = this._promiseRejected(maybePromise._reason(), i);
              } else {
                isResolved = this._promiseCancelled(i);
              }
            } else {
              isResolved = this._promiseFulfilled(maybePromise, i);
            }
          }
          if (!isResolved)
            result._setAsyncGuaranteed();
        };
        PromiseArray.prototype._isResolved = function() {
          return this._values === null;
        };
        PromiseArray.prototype._resolve = function(value) {
          this._values = null;
          this._promise._fulfill(value);
        };
        PromiseArray.prototype._cancel = function() {
          if (this._isResolved() || !this._promise._isCancellable())
            return;
          this._values = null;
          this._promise._cancel();
        };
        PromiseArray.prototype._reject = function(reason) {
          this._values = null;
          this._promise._rejectCallback(reason, false);
        };
        PromiseArray.prototype._promiseFulfilled = function(value, index) {
          this._values[index] = value;
          var totalResolved = ++this._totalResolved;
          if (totalResolved >= this._length) {
            this._resolve(this._values);
            return true;
          }
          return false;
        };
        PromiseArray.prototype._promiseCancelled = function() {
          this._cancel();
          return true;
        };
        PromiseArray.prototype._promiseRejected = function(reason) {
          this._totalResolved++;
          this._reject(reason);
          return true;
        };
        PromiseArray.prototype._resultCancelled = function() {
          if (this._isResolved())
            return;
          var values = this._values;
          this._cancel();
          if (values instanceof Promise2) {
            values.cancel();
          } else {
            for (var i = 0; i < values.length; ++i) {
              if (values[i] instanceof Promise2) {
                values[i].cancel();
              }
            }
          }
        };
        PromiseArray.prototype.shouldCopyValues = function() {
          return true;
        };
        PromiseArray.prototype.getActualLength = function(len) {
          return len;
        };
        return PromiseArray;
      };
    }, { "./util": 36 }], 24: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, INTERNAL) {
        var THIS = {};
        var util2 = _dereq_2("./util");
        var nodebackForPromise = _dereq_2("./nodeback");
        var withAppended2 = util2.withAppended;
        var maybeWrapAsError2 = util2.maybeWrapAsError;
        var canEvaluate2 = util2.canEvaluate;
        var TypeError2 = _dereq_2("./errors").TypeError;
        var defaultSuffix = "Async";
        var defaultPromisified = { __isPromisified__: true };
        var noCopyProps = [
          "arity",
          "length",
          "name",
          "arguments",
          "caller",
          "callee",
          "prototype",
          "__isPromisified__"
        ];
        var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
        var defaultFilter = function(name2) {
          return util2.isIdentifier(name2) && name2.charAt(0) !== "_" && name2 !== "constructor";
        };
        function propsFilter(key) {
          return !noCopyPropsPattern.test(key);
        }
        function isPromisified(fn2) {
          try {
            return fn2.__isPromisified__ === true;
          } catch (e) {
            return false;
          }
        }
        function hasPromisified(obj2, key, suffix) {
          var val = util2.getDataPropertyOrDefault(
            obj2,
            key + suffix,
            defaultPromisified
          );
          return val ? isPromisified(val) : false;
        }
        function checkValid(ret2, suffix, suffixRegexp) {
          for (var i = 0; i < ret2.length; i += 2) {
            var key = ret2[i];
            if (suffixRegexp.test(key)) {
              var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
              for (var j = 0; j < ret2.length; j += 2) {
                if (ret2[j] === keyWithoutAsyncSuffix) {
                  throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
                }
              }
            }
          }
        }
        function promisifiableMethods(obj2, suffix, suffixRegexp, filter) {
          var keys2 = util2.inheritedDataKeys(obj2);
          var ret2 = [];
          for (var i = 0; i < keys2.length; ++i) {
            var key = keys2[i];
            var value = obj2[key];
            var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key);
            if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter(key, value, obj2, passesDefaultFilter)) {
              ret2.push(key, value);
            }
          }
          checkValid(ret2, suffix, suffixRegexp);
          return ret2;
        }
        var escapeIdentRegex = function(str) {
          return str.replace(/([$])/, "\\$");
        };
        var makeNodePromisifiedEval;
        function makeNodePromisifiedClosure(callback, receiver2, _2, fn2, __, multiArgs) {
          var defaultThis = /* @__PURE__ */ function() {
            return this;
          }();
          var method = callback;
          if (typeof method === "string") {
            callback = fn2;
          }
          function promisified() {
            var _receiver = receiver2;
            if (receiver2 === THIS)
              _receiver = this;
            var promise = new Promise2(INTERNAL);
            promise._captureStackTrace();
            var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
            var fn22 = nodebackForPromise(promise, multiArgs);
            try {
              cb.apply(_receiver, withAppended2(arguments, fn22));
            } catch (e) {
              promise._rejectCallback(maybeWrapAsError2(e), true, true);
            }
            if (!promise._isFateSealed())
              promise._setAsyncGuaranteed();
            return promise;
          }
          util2.notEnumerableProp(promisified, "__isPromisified__", true);
          return promisified;
        }
        var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
        function promisifyAll(obj2, suffix, filter, promisifier, multiArgs) {
          var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
          var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter);
          for (var i = 0, len = methods.length; i < len; i += 2) {
            var key = methods[i];
            var fn2 = methods[i + 1];
            var promisifiedKey = key + suffix;
            if (promisifier === makeNodePromisified) {
              obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn2, suffix, multiArgs);
            } else {
              var promisified = promisifier(fn2, function() {
                return makeNodePromisified(
                  key,
                  THIS,
                  key,
                  fn2,
                  suffix,
                  multiArgs
                );
              });
              util2.notEnumerableProp(promisified, "__isPromisified__", true);
              obj2[promisifiedKey] = promisified;
            }
          }
          util2.toFastProperties(obj2);
          return obj2;
        }
        function promisify(callback, receiver2, multiArgs) {
          return makeNodePromisified(
            callback,
            receiver2,
            void 0,
            callback,
            null,
            multiArgs
          );
        }
        Promise2.promisify = function(fn2, options2) {
          if (typeof fn2 !== "function") {
            throw new TypeError2("expecting a function but got " + util2.classString(fn2));
          }
          if (isPromisified(fn2)) {
            return fn2;
          }
          options2 = Object(options2);
          var receiver2 = options2.context === void 0 ? THIS : options2.context;
          var multiArgs = !!options2.multiArgs;
          var ret2 = promisify(fn2, receiver2, multiArgs);
          util2.copyDescriptors(fn2, ret2, propsFilter);
          return ret2;
        };
        Promise2.promisifyAll = function(target, options2) {
          if (typeof target !== "function" && typeof target !== "object") {
            throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
          }
          options2 = Object(options2);
          var multiArgs = !!options2.multiArgs;
          var suffix = options2.suffix;
          if (typeof suffix !== "string")
            suffix = defaultSuffix;
          var filter = options2.filter;
          if (typeof filter !== "function")
            filter = defaultFilter;
          var promisifier = options2.promisifier;
          if (typeof promisifier !== "function")
            promisifier = makeNodePromisified;
          if (!util2.isIdentifier(suffix)) {
            throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
          }
          var keys2 = util2.inheritedDataKeys(target);
          for (var i = 0; i < keys2.length; ++i) {
            var value = target[keys2[i]];
            if (keys2[i] !== "constructor" && util2.isClass(value)) {
              promisifyAll(
                value.prototype,
                suffix,
                filter,
                promisifier,
                multiArgs
              );
              promisifyAll(value, suffix, filter, promisifier, multiArgs);
            }
          }
          return promisifyAll(target, suffix, filter, promisifier, multiArgs);
        };
      };
    }, { "./errors": 12, "./nodeback": 20, "./util": 36 }], 25: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
        var util2 = _dereq_2("./util");
        var isObject2 = util2.isObject;
        var es52 = _dereq_2("./es5");
        var Es6Map;
        if (typeof Map === "function")
          Es6Map = Map;
        var mapToEntries = /* @__PURE__ */ function() {
          var index = 0;
          var size2 = 0;
          function extractEntry(value, key) {
            this[index] = value;
            this[index + size2] = key;
            index++;
          }
          return function mapToEntries2(map2) {
            size2 = map2.size;
            index = 0;
            var ret2 = new Array(map2.size * 2);
            map2.forEach(extractEntry, ret2);
            return ret2;
          };
        }();
        var entriesToMap = function(entries) {
          var ret2 = new Es6Map();
          var length2 = entries.length / 2 | 0;
          for (var i = 0; i < length2; ++i) {
            var key = entries[length2 + i];
            var value = entries[i];
            ret2.set(key, value);
          }
          return ret2;
        };
        function PropertiesPromiseArray(obj2) {
          var isMap2 = false;
          var entries;
          if (Es6Map !== void 0 && obj2 instanceof Es6Map) {
            entries = mapToEntries(obj2);
            isMap2 = true;
          } else {
            var keys2 = es52.keys(obj2);
            var len = keys2.length;
            entries = new Array(len * 2);
            for (var i = 0; i < len; ++i) {
              var key = keys2[i];
              entries[i] = obj2[key];
              entries[i + len] = key;
            }
          }
          this.constructor$(entries);
          this._isMap = isMap2;
          this._init$(void 0, isMap2 ? -6 : -3);
        }
        util2.inherits(PropertiesPromiseArray, PromiseArray);
        PropertiesPromiseArray.prototype._init = function() {
        };
        PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
          this._values[index] = value;
          var totalResolved = ++this._totalResolved;
          if (totalResolved >= this._length) {
            var val;
            if (this._isMap) {
              val = entriesToMap(this._values);
            } else {
              val = {};
              var keyOffset = this.length();
              for (var i = 0, len = this.length(); i < len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
              }
            }
            this._resolve(val);
            return true;
          }
          return false;
        };
        PropertiesPromiseArray.prototype.shouldCopyValues = function() {
          return false;
        };
        PropertiesPromiseArray.prototype.getActualLength = function(len) {
          return len >> 1;
        };
        function props(promises) {
          var ret2;
          var castValue = tryConvertToPromise(promises);
          if (!isObject2(castValue)) {
            return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
          } else if (castValue instanceof Promise2) {
            ret2 = castValue._then(
              Promise2.props,
              void 0,
              void 0,
              void 0,
              void 0
            );
          } else {
            ret2 = new PropertiesPromiseArray(castValue).promise();
          }
          if (castValue instanceof Promise2) {
            ret2._propagateFrom(castValue, 2);
          }
          return ret2;
        }
        Promise2.prototype.props = function() {
          return props(this);
        };
        Promise2.props = function(promises) {
          return props(promises);
        };
      };
    }, { "./es5": 13, "./util": 36 }], 26: [function(_dereq_2, module2, exports2) {
      function arrayMove(src, srcIndex, dst, dstIndex, len) {
        for (var j = 0; j < len; ++j) {
          dst[j + dstIndex] = src[j + srcIndex];
          src[j + srcIndex] = void 0;
        }
      }
      function Queue(capacity) {
        this._capacity = capacity;
        this._length = 0;
        this._front = 0;
      }
      Queue.prototype._willBeOverCapacity = function(size2) {
        return this._capacity < size2;
      };
      Queue.prototype._pushOne = function(arg) {
        var length2 = this.length();
        this._checkCapacity(length2 + 1);
        var i = this._front + length2 & this._capacity - 1;
        this[i] = arg;
        this._length = length2 + 1;
      };
      Queue.prototype.push = function(fn2, receiver2, arg) {
        var length2 = this.length() + 3;
        if (this._willBeOverCapacity(length2)) {
          this._pushOne(fn2);
          this._pushOne(receiver2);
          this._pushOne(arg);
          return;
        }
        var j = this._front + length2 - 3;
        this._checkCapacity(length2);
        var wrapMask = this._capacity - 1;
        this[j + 0 & wrapMask] = fn2;
        this[j + 1 & wrapMask] = receiver2;
        this[j + 2 & wrapMask] = arg;
        this._length = length2;
      };
      Queue.prototype.shift = function() {
        var front = this._front, ret2 = this[front];
        this[front] = void 0;
        this._front = front + 1 & this._capacity - 1;
        this._length--;
        return ret2;
      };
      Queue.prototype.length = function() {
        return this._length;
      };
      Queue.prototype._checkCapacity = function(size2) {
        if (this._capacity < size2) {
          this._resizeTo(this._capacity << 1);
        }
      };
      Queue.prototype._resizeTo = function(capacity) {
        var oldCapacity = this._capacity;
        this._capacity = capacity;
        var front = this._front;
        var length2 = this._length;
        var moveItemsCount = front + length2 & oldCapacity - 1;
        arrayMove(this, 0, this, oldCapacity, moveItemsCount);
      };
      module2.exports = Queue;
    }, {}], 27: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
        var util2 = _dereq_2("./util");
        var raceLater = function(promise) {
          return promise.then(function(array) {
            return race(array, promise);
          });
        };
        function race(promises, parent) {
          var maybePromise = tryConvertToPromise(promises);
          if (maybePromise instanceof Promise2) {
            return raceLater(maybePromise);
          } else {
            promises = util2.asArray(promises);
            if (promises === null)
              return apiRejection("expecting an array or an iterable object but got " + util2.classString(promises));
          }
          var ret2 = new Promise2(INTERNAL);
          if (parent !== void 0) {
            ret2._propagateFrom(parent, 3);
          }
          var fulfill = ret2._fulfill;
          var reject = ret2._reject;
          for (var i = 0, len = promises.length; i < len; ++i) {
            var val = promises[i];
            if (val === void 0 && !(i in promises)) {
              continue;
            }
            Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
          }
          return ret2;
        }
        Promise2.race = function(promises) {
          return race(promises, void 0);
        };
        Promise2.prototype.race = function() {
          return race(this, void 0);
        };
      };
    }, { "./util": 36 }], 28: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug2) {
        var getDomain = Promise2._getDomain;
        var util2 = _dereq_2("./util");
        var tryCatch2 = util2.tryCatch;
        function ReductionPromiseArray(promises, fn2, initialValue, _each) {
          this.constructor$(promises);
          var domain = getDomain();
          this._fn = domain === null ? fn2 : util2.domainBind(domain, fn2);
          if (initialValue !== void 0) {
            initialValue = Promise2.resolve(initialValue);
            initialValue._attachCancellationCallback(this);
          }
          this._initialValue = initialValue;
          this._currentCancellable = null;
          if (_each === INTERNAL) {
            this._eachValues = Array(this._length);
          } else if (_each === 0) {
            this._eachValues = null;
          } else {
            this._eachValues = void 0;
          }
          this._promise._captureStackTrace();
          this._init$(void 0, -5);
        }
        util2.inherits(ReductionPromiseArray, PromiseArray);
        ReductionPromiseArray.prototype._gotAccum = function(accum) {
          if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
            this._eachValues.push(accum);
          }
        };
        ReductionPromiseArray.prototype._eachComplete = function(value) {
          if (this._eachValues !== null) {
            this._eachValues.push(value);
          }
          return this._eachValues;
        };
        ReductionPromiseArray.prototype._init = function() {
        };
        ReductionPromiseArray.prototype._resolveEmptyArray = function() {
          this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
        };
        ReductionPromiseArray.prototype.shouldCopyValues = function() {
          return false;
        };
        ReductionPromiseArray.prototype._resolve = function(value) {
          this._promise._resolveCallback(value);
          this._values = null;
        };
        ReductionPromiseArray.prototype._resultCancelled = function(sender) {
          if (sender === this._initialValue)
            return this._cancel();
          if (this._isResolved())
            return;
          this._resultCancelled$();
          if (this._currentCancellable instanceof Promise2) {
            this._currentCancellable.cancel();
          }
          if (this._initialValue instanceof Promise2) {
            this._initialValue.cancel();
          }
        };
        ReductionPromiseArray.prototype._iterate = function(values) {
          this._values = values;
          var value;
          var i;
          var length2 = values.length;
          if (this._initialValue !== void 0) {
            value = this._initialValue;
            i = 0;
          } else {
            value = Promise2.resolve(values[0]);
            i = 1;
          }
          this._currentCancellable = value;
          if (!value.isRejected()) {
            for (; i < length2; ++i) {
              var ctx = {
                accum: null,
                value: values[i],
                index: i,
                length: length2,
                array: this
              };
              value = value._then(gotAccum, void 0, void 0, ctx, void 0);
            }
          }
          if (this._eachValues !== void 0) {
            value = value._then(this._eachComplete, void 0, void 0, this, void 0);
          }
          value._then(completed, completed, void 0, value, this);
        };
        Promise2.prototype.reduce = function(fn2, initialValue) {
          return reduce(this, fn2, initialValue, null);
        };
        Promise2.reduce = function(promises, fn2, initialValue, _each) {
          return reduce(promises, fn2, initialValue, _each);
        };
        function completed(valueOrReason, array) {
          if (this.isFulfilled()) {
            array._resolve(valueOrReason);
          } else {
            array._reject(valueOrReason);
          }
        }
        function reduce(promises, fn2, initialValue, _each) {
          if (typeof fn2 !== "function") {
            return apiRejection("expecting a function but got " + util2.classString(fn2));
          }
          var array = new ReductionPromiseArray(promises, fn2, initialValue, _each);
          return array.promise();
        }
        function gotAccum(accum) {
          this.accum = accum;
          this.array._gotAccum(accum);
          var value = tryConvertToPromise(this.value, this.array._promise);
          if (value instanceof Promise2) {
            this.array._currentCancellable = value;
            return value._then(gotValue, void 0, void 0, this, void 0);
          } else {
            return gotValue.call(this, value);
          }
        }
        function gotValue(value) {
          var array = this.array;
          var promise = array._promise;
          var fn2 = tryCatch2(array._fn);
          promise._pushContext();
          var ret2;
          if (array._eachValues !== void 0) {
            ret2 = fn2.call(promise._boundValue(), value, this.index, this.length);
          } else {
            ret2 = fn2.call(
              promise._boundValue(),
              this.accum,
              value,
              this.index,
              this.length
            );
          }
          if (ret2 instanceof Promise2) {
            array._currentCancellable = ret2;
          }
          var promiseCreated = promise._popContext();
          debug2.checkForgottenReturns(
            ret2,
            promiseCreated,
            array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
            promise
          );
          return ret2;
        }
      };
    }, { "./util": 36 }], 29: [function(_dereq_2, module2, exports2) {
      var util2 = _dereq_2("./util");
      var schedule;
      var noAsyncScheduler = function() {
        throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
      };
      var NativePromise = util2.getNativePromise();
      if (util2.isNode && typeof MutationObserver === "undefined") {
        var GlobalSetImmediate = commonjsGlobal.setImmediate;
        var ProcessNextTick = process.nextTick;
        schedule = util2.isRecentNode ? function(fn2) {
          GlobalSetImmediate.call(commonjsGlobal, fn2);
        } : function(fn2) {
          ProcessNextTick.call(process, fn2);
        };
      } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
        var nativePromise = NativePromise.resolve();
        schedule = function(fn2) {
          nativePromise.then(fn2);
        };
      } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
        schedule = function() {
          var div = document.createElement("div");
          var opts = { attributes: true };
          var toggleScheduled = false;
          var div2 = document.createElement("div");
          var o2 = new MutationObserver(function() {
            div.classList.toggle("foo");
            toggleScheduled = false;
          });
          o2.observe(div2, opts);
          var scheduleToggle = function() {
            if (toggleScheduled)
              return;
            toggleScheduled = true;
            div2.classList.toggle("foo");
          };
          return function schedule2(fn2) {
            var o3 = new MutationObserver(function() {
              o3.disconnect();
              fn2();
            });
            o3.observe(div, opts);
            scheduleToggle();
          };
        }();
      } else if (typeof define_setImmediate_default !== "undefined") {
        schedule = function(fn2) {
          define_setImmediate_default(fn2);
        };
      } else if (typeof setTimeout !== "undefined") {
        schedule = function(fn2) {
          setTimeout(fn2, 0);
        };
      } else {
        schedule = noAsyncScheduler;
      }
      module2.exports = schedule;
    }, { "./util": 36 }], 30: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, PromiseArray, debug2) {
        var PromiseInspection = Promise2.PromiseInspection;
        var util2 = _dereq_2("./util");
        function SettledPromiseArray(values) {
          this.constructor$(values);
        }
        util2.inherits(SettledPromiseArray, PromiseArray);
        SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
          this._values[index] = inspection;
          var totalResolved = ++this._totalResolved;
          if (totalResolved >= this._length) {
            this._resolve(this._values);
            return true;
          }
          return false;
        };
        SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
          var ret2 = new PromiseInspection();
          ret2._bitField = 33554432;
          ret2._settledValueField = value;
          return this._promiseResolved(index, ret2);
        };
        SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
          var ret2 = new PromiseInspection();
          ret2._bitField = 16777216;
          ret2._settledValueField = reason;
          return this._promiseResolved(index, ret2);
        };
        Promise2.settle = function(promises) {
          debug2.deprecated(".settle()", ".reflect()");
          return new SettledPromiseArray(promises).promise();
        };
        Promise2.prototype.settle = function() {
          return Promise2.settle(this);
        };
      };
    }, { "./util": 36 }], 31: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, PromiseArray, apiRejection) {
        var util2 = _dereq_2("./util");
        var RangeError2 = _dereq_2("./errors").RangeError;
        var AggregateError = _dereq_2("./errors").AggregateError;
        var isArray2 = util2.isArray;
        var CANCELLATION = {};
        function SomePromiseArray(values) {
          this.constructor$(values);
          this._howMany = 0;
          this._unwrap = false;
          this._initialized = false;
        }
        util2.inherits(SomePromiseArray, PromiseArray);
        SomePromiseArray.prototype._init = function() {
          if (!this._initialized) {
            return;
          }
          if (this._howMany === 0) {
            this._resolve([]);
            return;
          }
          this._init$(void 0, -5);
          var isArrayResolved = isArray2(this._values);
          if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
            this._reject(this._getRangeError(this.length()));
          }
        };
        SomePromiseArray.prototype.init = function() {
          this._initialized = true;
          this._init();
        };
        SomePromiseArray.prototype.setUnwrap = function() {
          this._unwrap = true;
        };
        SomePromiseArray.prototype.howMany = function() {
          return this._howMany;
        };
        SomePromiseArray.prototype.setHowMany = function(count) {
          this._howMany = count;
        };
        SomePromiseArray.prototype._promiseFulfilled = function(value) {
          this._addFulfilled(value);
          if (this._fulfilled() === this.howMany()) {
            this._values.length = this.howMany();
            if (this.howMany() === 1 && this._unwrap) {
              this._resolve(this._values[0]);
            } else {
              this._resolve(this._values);
            }
            return true;
          }
          return false;
        };
        SomePromiseArray.prototype._promiseRejected = function(reason) {
          this._addRejected(reason);
          return this._checkOutcome();
        };
        SomePromiseArray.prototype._promiseCancelled = function() {
          if (this._values instanceof Promise2 || this._values == null) {
            return this._cancel();
          }
          this._addRejected(CANCELLATION);
          return this._checkOutcome();
        };
        SomePromiseArray.prototype._checkOutcome = function() {
          if (this.howMany() > this._canPossiblyFulfill()) {
            var e = new AggregateError();
            for (var i = this.length(); i < this._values.length; ++i) {
              if (this._values[i] !== CANCELLATION) {
                e.push(this._values[i]);
              }
            }
            if (e.length > 0) {
              this._reject(e);
            } else {
              this._cancel();
            }
            return true;
          }
          return false;
        };
        SomePromiseArray.prototype._fulfilled = function() {
          return this._totalResolved;
        };
        SomePromiseArray.prototype._rejected = function() {
          return this._values.length - this.length();
        };
        SomePromiseArray.prototype._addRejected = function(reason) {
          this._values.push(reason);
        };
        SomePromiseArray.prototype._addFulfilled = function(value) {
          this._values[this._totalResolved++] = value;
        };
        SomePromiseArray.prototype._canPossiblyFulfill = function() {
          return this.length() - this._rejected();
        };
        SomePromiseArray.prototype._getRangeError = function(count) {
          var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
          return new RangeError2(message);
        };
        SomePromiseArray.prototype._resolveEmptyArray = function() {
          this._reject(this._getRangeError(0));
        };
        function some(promises, howMany) {
          if ((howMany | 0) !== howMany || howMany < 0) {
            return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
          }
          var ret2 = new SomePromiseArray(promises);
          var promise = ret2.promise();
          ret2.setHowMany(howMany);
          ret2.init();
          return promise;
        }
        Promise2.some = function(promises, howMany) {
          return some(promises, howMany);
        };
        Promise2.prototype.some = function(howMany) {
          return some(this, howMany);
        };
        Promise2._SomePromiseArray = SomePromiseArray;
      };
    }, { "./errors": 12, "./util": 36 }], 32: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2) {
        function PromiseInspection(promise) {
          if (promise !== void 0) {
            promise = promise._target();
            this._bitField = promise._bitField;
            this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
          } else {
            this._bitField = 0;
            this._settledValueField = void 0;
          }
        }
        PromiseInspection.prototype._settledValue = function() {
          return this._settledValueField;
        };
        var value = PromiseInspection.prototype.value = function() {
          if (!this.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
          }
          return this._settledValue();
        };
        var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
          if (!this.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
          }
          return this._settledValue();
        };
        var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
          return (this._bitField & 33554432) !== 0;
        };
        var isRejected = PromiseInspection.prototype.isRejected = function() {
          return (this._bitField & 16777216) !== 0;
        };
        var isPending = PromiseInspection.prototype.isPending = function() {
          return (this._bitField & 50397184) === 0;
        };
        var isResolved = PromiseInspection.prototype.isResolved = function() {
          return (this._bitField & 50331648) !== 0;
        };
        PromiseInspection.prototype.isCancelled = function() {
          return (this._bitField & 8454144) !== 0;
        };
        Promise2.prototype.__isCancelled = function() {
          return (this._bitField & 65536) === 65536;
        };
        Promise2.prototype._isCancelled = function() {
          return this._target().__isCancelled();
        };
        Promise2.prototype.isCancelled = function() {
          return (this._target()._bitField & 8454144) !== 0;
        };
        Promise2.prototype.isPending = function() {
          return isPending.call(this._target());
        };
        Promise2.prototype.isRejected = function() {
          return isRejected.call(this._target());
        };
        Promise2.prototype.isFulfilled = function() {
          return isFulfilled.call(this._target());
        };
        Promise2.prototype.isResolved = function() {
          return isResolved.call(this._target());
        };
        Promise2.prototype.value = function() {
          return value.call(this._target());
        };
        Promise2.prototype.reason = function() {
          var target = this._target();
          target._unsetRejectionIsUnhandled();
          return reason.call(target);
        };
        Promise2.prototype._value = function() {
          return this._settledValue();
        };
        Promise2.prototype._reason = function() {
          this._unsetRejectionIsUnhandled();
          return this._settledValue();
        };
        Promise2.PromiseInspection = PromiseInspection;
      };
    }, {}], 33: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, INTERNAL) {
        var util2 = _dereq_2("./util");
        var errorObj2 = util2.errorObj;
        var isObject2 = util2.isObject;
        function tryConvertToPromise(obj2, context2) {
          if (isObject2(obj2)) {
            if (obj2 instanceof Promise2)
              return obj2;
            var then = getThen(obj2);
            if (then === errorObj2) {
              if (context2)
                context2._pushContext();
              var ret2 = Promise2.reject(then.e);
              if (context2)
                context2._popContext();
              return ret2;
            } else if (typeof then === "function") {
              if (isAnyBluebirdPromise(obj2)) {
                var ret2 = new Promise2(INTERNAL);
                obj2._then(
                  ret2._fulfill,
                  ret2._reject,
                  void 0,
                  ret2,
                  null
                );
                return ret2;
              }
              return doThenable(obj2, then, context2);
            }
          }
          return obj2;
        }
        function doGetThen(obj2) {
          return obj2.then;
        }
        function getThen(obj2) {
          try {
            return doGetThen(obj2);
          } catch (e) {
            errorObj2.e = e;
            return errorObj2;
          }
        }
        var hasProp2 = {}.hasOwnProperty;
        function isAnyBluebirdPromise(obj2) {
          try {
            return hasProp2.call(obj2, "_promise0");
          } catch (e) {
            return false;
          }
        }
        function doThenable(x2, then, context2) {
          var promise = new Promise2(INTERNAL);
          var ret2 = promise;
          if (context2)
            context2._pushContext();
          promise._captureStackTrace();
          if (context2)
            context2._popContext();
          var synchronous = true;
          var result = util2.tryCatch(then).call(x2, resolve3, reject);
          synchronous = false;
          if (promise && result === errorObj2) {
            promise._rejectCallback(result.e, true, true);
            promise = null;
          }
          function resolve3(value) {
            if (!promise)
              return;
            promise._resolveCallback(value);
            promise = null;
          }
          function reject(reason) {
            if (!promise)
              return;
            promise._rejectCallback(reason, synchronous, true);
            promise = null;
          }
          return ret2;
        }
        return tryConvertToPromise;
      };
    }, { "./util": 36 }], 34: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, INTERNAL, debug2) {
        var util2 = _dereq_2("./util");
        var TimeoutError = Promise2.TimeoutError;
        function HandleWrapper(handle) {
          this.handle = handle;
        }
        HandleWrapper.prototype._resultCancelled = function() {
          clearTimeout(this.handle);
        };
        var afterValue = function(value) {
          return delay(+this).thenReturn(value);
        };
        var delay = Promise2.delay = function(ms2, value) {
          var ret2;
          var handle;
          if (value !== void 0) {
            ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms2, void 0);
            if (debug2.cancellation() && value instanceof Promise2) {
              ret2._setOnCancel(value);
            }
          } else {
            ret2 = new Promise2(INTERNAL);
            handle = setTimeout(function() {
              ret2._fulfill();
            }, +ms2);
            if (debug2.cancellation()) {
              ret2._setOnCancel(new HandleWrapper(handle));
            }
            ret2._captureStackTrace();
          }
          ret2._setAsyncGuaranteed();
          return ret2;
        };
        Promise2.prototype.delay = function(ms2) {
          return delay(ms2, this);
        };
        var afterTimeout = function(promise, message, parent) {
          var err;
          if (typeof message !== "string") {
            if (message instanceof Error) {
              err = message;
            } else {
              err = new TimeoutError("operation timed out");
            }
          } else {
            err = new TimeoutError(message);
          }
          util2.markAsOriginatingFromRejection(err);
          promise._attachExtraTrace(err);
          promise._reject(err);
          if (parent != null) {
            parent.cancel();
          }
        };
        function successClear(value) {
          clearTimeout(this.handle);
          return value;
        }
        function failureClear(reason) {
          clearTimeout(this.handle);
          throw reason;
        }
        Promise2.prototype.timeout = function(ms2, message) {
          ms2 = +ms2;
          var ret2, parent;
          var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
            if (ret2.isPending()) {
              afterTimeout(ret2, message, parent);
            }
          }, ms2));
          if (debug2.cancellation()) {
            parent = this.then();
            ret2 = parent._then(
              successClear,
              failureClear,
              void 0,
              handleWrapper,
              void 0
            );
            ret2._setOnCancel(handleWrapper);
          } else {
            ret2 = this._then(
              successClear,
              failureClear,
              void 0,
              handleWrapper,
              void 0
            );
          }
          return ret2;
        };
      };
    }, { "./util": 36 }], 35: [function(_dereq_2, module2, exports2) {
      module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug2) {
        var util2 = _dereq_2("./util");
        var TypeError2 = _dereq_2("./errors").TypeError;
        var inherits2 = _dereq_2("./util").inherits;
        var errorObj2 = util2.errorObj;
        var tryCatch2 = util2.tryCatch;
        var NULL = {};
        function thrower2(e) {
          setTimeout(function() {
            throw e;
          }, 0);
        }
        function castPreservingDisposable(thenable) {
          var maybePromise = tryConvertToPromise(thenable);
          if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
          }
          return maybePromise;
        }
        function dispose(resources, inspection) {
          var i = 0;
          var len = resources.length;
          var ret2 = new Promise2(INTERNAL);
          function iterator2() {
            if (i >= len)
              return ret2._fulfill();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
              try {
                maybePromise = tryConvertToPromise(
                  maybePromise._getDisposer().tryDispose(inspection),
                  resources.promise
                );
              } catch (e) {
                return thrower2(e);
              }
              if (maybePromise instanceof Promise2) {
                return maybePromise._then(
                  iterator2,
                  thrower2,
                  null,
                  null,
                  null
                );
              }
            }
            iterator2();
          }
          iterator2();
          return ret2;
        }
        function Disposer(data, promise, context2) {
          this._data = data;
          this._promise = promise;
          this._context = context2;
        }
        Disposer.prototype.data = function() {
          return this._data;
        };
        Disposer.prototype.promise = function() {
          return this._promise;
        };
        Disposer.prototype.resource = function() {
          if (this.promise().isFulfilled()) {
            return this.promise().value();
          }
          return NULL;
        };
        Disposer.prototype.tryDispose = function(inspection) {
          var resource = this.resource();
          var context2 = this._context;
          if (context2 !== void 0)
            context2._pushContext();
          var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
          if (context2 !== void 0)
            context2._popContext();
          this._promise._unsetDisposable();
          this._data = null;
          return ret2;
        };
        Disposer.isDisposer = function(d2) {
          return d2 != null && typeof d2.resource === "function" && typeof d2.tryDispose === "function";
        };
        function FunctionDisposer(fn2, promise, context2) {
          this.constructor$(fn2, promise, context2);
        }
        inherits2(FunctionDisposer, Disposer);
        FunctionDisposer.prototype.doDispose = function(resource, inspection) {
          var fn2 = this.data();
          return fn2.call(resource, resource, inspection);
        };
        function maybeUnwrapDisposer(value) {
          if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
          }
          return value;
        }
        function ResourceList(length2) {
          this.length = length2;
          this.promise = null;
          this[length2 - 1] = null;
        }
        ResourceList.prototype._resultCancelled = function() {
          var len = this.length;
          for (var i = 0; i < len; ++i) {
            var item = this[i];
            if (item instanceof Promise2) {
              item.cancel();
            }
          }
        };
        Promise2.using = function() {
          var len = arguments.length;
          if (len < 2)
            return apiRejection(
              "you must pass at least 2 arguments to Promise.using"
            );
          var fn2 = arguments[len - 1];
          if (typeof fn2 !== "function") {
            return apiRejection("expecting a function but got " + util2.classString(fn2));
          }
          var input;
          var spreadArgs = true;
          if (len === 2 && Array.isArray(arguments[0])) {
            input = arguments[0];
            len = input.length;
            spreadArgs = false;
          } else {
            input = arguments;
            len--;
          }
          var resources = new ResourceList(len);
          for (var i = 0; i < len; ++i) {
            var resource = input[i];
            if (Disposer.isDisposer(resource)) {
              var disposer = resource;
              resource = resource.promise();
              resource._setDisposable(disposer);
            } else {
              var maybePromise = tryConvertToPromise(resource);
              if (maybePromise instanceof Promise2) {
                resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                  resources,
                  index: i
                }, void 0);
              }
            }
            resources[i] = resource;
          }
          var reflectedResources = new Array(resources.length);
          for (var i = 0; i < reflectedResources.length; ++i) {
            reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
          }
          var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
            for (var i2 = 0; i2 < inspections.length; ++i2) {
              var inspection = inspections[i2];
              if (inspection.isRejected()) {
                errorObj2.e = inspection.error();
                return errorObj2;
              } else if (!inspection.isFulfilled()) {
                resultPromise.cancel();
                return;
              }
              inspections[i2] = inspection.value();
            }
            promise._pushContext();
            fn2 = tryCatch2(fn2);
            var ret2 = spreadArgs ? fn2.apply(void 0, inspections) : fn2(inspections);
            var promiseCreated = promise._popContext();
            debug2.checkForgottenReturns(
              ret2,
              promiseCreated,
              "Promise.using",
              promise
            );
            return ret2;
          });
          var promise = resultPromise.lastly(function() {
            var inspection = new Promise2.PromiseInspection(resultPromise);
            return dispose(resources, inspection);
          });
          resources.promise = promise;
          promise._setOnCancel(resources);
          return promise;
        };
        Promise2.prototype._setDisposable = function(disposer) {
          this._bitField = this._bitField | 131072;
          this._disposer = disposer;
        };
        Promise2.prototype._isDisposable = function() {
          return (this._bitField & 131072) > 0;
        };
        Promise2.prototype._getDisposer = function() {
          return this._disposer;
        };
        Promise2.prototype._unsetDisposable = function() {
          this._bitField = this._bitField & ~131072;
          this._disposer = void 0;
        };
        Promise2.prototype.disposer = function(fn2) {
          if (typeof fn2 === "function") {
            return new FunctionDisposer(fn2, this, createContext());
          }
          throw new TypeError2();
        };
      };
    }, { "./errors": 12, "./util": 36 }], 36: [function(_dereq_2, module2, exports2) {
      var es5 = _dereq_2("./es5");
      var canEvaluate = typeof navigator == "undefined";
      var errorObj = { e: {} };
      var tryCatchTarget;
      var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : this !== void 0 ? this : null;
      function tryCatcher() {
        try {
          var target = tryCatchTarget;
          tryCatchTarget = null;
          return target.apply(this, arguments);
        } catch (e) {
          errorObj.e = e;
          return errorObj;
        }
      }
      function tryCatch(fn2) {
        tryCatchTarget = fn2;
        return tryCatcher;
      }
      var inherits = function(Child, Parent) {
        var hasProp2 = {}.hasOwnProperty;
        function T() {
          this.constructor = Child;
          this.constructor$ = Parent;
          for (var propertyName in Parent.prototype) {
            if (hasProp2.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
              this[propertyName + "$"] = Parent.prototype[propertyName];
            }
          }
        }
        T.prototype = Parent.prototype;
        Child.prototype = new T();
        return Child.prototype;
      };
      function isPrimitive2(val) {
        return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
      }
      function isObject2(value) {
        return typeof value === "function" || typeof value === "object" && value !== null;
      }
      function maybeWrapAsError(maybeError) {
        if (!isPrimitive2(maybeError))
          return maybeError;
        return new Error(safeToString(maybeError));
      }
      function withAppended(target, appendee) {
        var len = target.length;
        var ret2 = new Array(len + 1);
        var i;
        for (i = 0; i < len; ++i) {
          ret2[i] = target[i];
        }
        ret2[i] = appendee;
        return ret2;
      }
      function getDataPropertyOrDefault(obj2, key, defaultValue) {
        if (es5.isES5) {
          var desc = Object.getOwnPropertyDescriptor(obj2, key);
          if (desc != null) {
            return desc.get == null && desc.set == null ? desc.value : defaultValue;
          }
        } else {
          return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
        }
      }
      function notEnumerableProp(obj2, name2, value) {
        if (isPrimitive2(obj2))
          return obj2;
        var descriptor = {
          value,
          configurable: true,
          enumerable: false,
          writable: true
        };
        es5.defineProperty(obj2, name2, descriptor);
        return obj2;
      }
      function thrower(r2) {
        throw r2;
      }
      var inheritedDataKeys = function() {
        var excludedPrototypes = [
          Array.prototype,
          Object.prototype,
          Function.prototype
        ];
        var isExcludedProto = function(val) {
          for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
              return true;
            }
          }
          return false;
        };
        if (es5.isES5) {
          var getKeys = Object.getOwnPropertyNames;
          return function(obj2) {
            var ret2 = [];
            var visitedKeys = /* @__PURE__ */ Object.create(null);
            while (obj2 != null && !isExcludedProto(obj2)) {
              var keys2;
              try {
                keys2 = getKeys(obj2);
              } catch (e) {
                return ret2;
              }
              for (var i = 0; i < keys2.length; ++i) {
                var key = keys2[i];
                if (visitedKeys[key])
                  continue;
                visitedKeys[key] = true;
                var desc = Object.getOwnPropertyDescriptor(obj2, key);
                if (desc != null && desc.get == null && desc.set == null) {
                  ret2.push(key);
                }
              }
              obj2 = es5.getPrototypeOf(obj2);
            }
            return ret2;
          };
        } else {
          var hasProp2 = {}.hasOwnProperty;
          return function(obj2) {
            if (isExcludedProto(obj2))
              return [];
            var ret2 = [];
            enumeration:
              for (var key in obj2) {
                if (hasProp2.call(obj2, key)) {
                  ret2.push(key);
                } else {
                  for (var i = 0; i < excludedPrototypes.length; ++i) {
                    if (hasProp2.call(excludedPrototypes[i], key)) {
                      continue enumeration;
                    }
                  }
                  ret2.push(key);
                }
              }
            return ret2;
          };
        }
      }();
      var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
      function isClass(fn2) {
        try {
          if (typeof fn2 === "function") {
            var keys2 = es5.names(fn2.prototype);
            var hasMethods = es5.isES5 && keys2.length > 1;
            var hasMethodsOtherThanConstructor = keys2.length > 0 && !(keys2.length === 1 && keys2[0] === "constructor");
            var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn2 + "") && es5.names(fn2).length > 0;
            if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
              return true;
            }
          }
          return false;
        } catch (e) {
          return false;
        }
      }
      function toFastProperties(obj) {
        function FakeConstructor() {
        }
        FakeConstructor.prototype = obj;
        var receiver = new FakeConstructor();
        function ic() {
          return typeof receiver.foo;
        }
        ic();
        ic();
        return obj;
      }
      var rident = /^[a-z$_][a-z$_0-9]*$/i;
      function isIdentifier(str) {
        return rident.test(str);
      }
      function filledRange(count, prefix, suffix) {
        var ret2 = new Array(count);
        for (var i = 0; i < count; ++i) {
          ret2[i] = prefix + i + suffix;
        }
        return ret2;
      }
      function safeToString(obj2) {
        try {
          return obj2 + "";
        } catch (e) {
          return "[no string representation]";
        }
      }
      function isError(obj2) {
        return obj2 instanceof Error || obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
      }
      function markAsOriginatingFromRejection(e) {
        try {
          notEnumerableProp(e, "isOperational", true);
        } catch (ignore2) {
        }
      }
      function originatesFromRejection(e) {
        if (e == null)
          return false;
        return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
      }
      function canAttachTrace(obj2) {
        return isError(obj2) && es5.propertyIsWritable(obj2, "stack");
      }
      var ensureErrorObject = function() {
        if (!("stack" in new Error())) {
          return function(value) {
            if (canAttachTrace(value))
              return value;
            try {
              throw new Error(safeToString(value));
            } catch (err) {
              return err;
            }
          };
        } else {
          return function(value) {
            if (canAttachTrace(value))
              return value;
            return new Error(safeToString(value));
          };
        }
      }();
      function classString(obj2) {
        return {}.toString.call(obj2);
      }
      function copyDescriptors(from, to, filter) {
        var keys2 = es5.names(from);
        for (var i = 0; i < keys2.length; ++i) {
          var key = keys2[i];
          if (filter(key)) {
            try {
              es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore2) {
            }
          }
        }
      }
      var asArray = function(v) {
        if (es5.isArray(v)) {
          return v;
        }
        return null;
      };
      if (typeof Symbol !== "undefined" && Symbol.iterator) {
        var ArrayFrom = typeof Array.from === "function" ? function(v) {
          return Array.from(v);
        } : function(v) {
          var ret2 = [];
          var it = v[Symbol.iterator]();
          var itResult;
          while (!(itResult = it.next()).done) {
            ret2.push(itResult.value);
          }
          return ret2;
        };
        asArray = function(v) {
          if (es5.isArray(v)) {
            return v;
          } else if (v != null && typeof v[Symbol.iterator] === "function") {
            return ArrayFrom(v);
          }
          return null;
        };
      }
      var isNode2 = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
      var hasEnvVariables = typeof process !== "undefined" && typeof define_process_env_default2 !== "undefined";
      function env2(key) {
        return hasEnvVariables ? define_process_env_default2[key] : void 0;
      }
      function getNativePromise() {
        if (typeof Promise === "function") {
          try {
            var promise = new Promise(function() {
            });
            if ({}.toString.call(promise) === "[object Promise]") {
              return Promise;
            }
          } catch (e) {
          }
        }
      }
      function domainBind(self2, cb) {
        return self2.bind(cb);
      }
      var ret = {
        isClass,
        isIdentifier,
        inheritedDataKeys,
        getDataPropertyOrDefault,
        thrower,
        isArray: es5.isArray,
        asArray,
        notEnumerableProp,
        isPrimitive: isPrimitive2,
        isObject: isObject2,
        isError,
        canEvaluate,
        errorObj,
        tryCatch,
        inherits,
        withAppended,
        maybeWrapAsError,
        toFastProperties,
        filledRange,
        toString: safeToString,
        canAttachTrace,
        ensureErrorObject,
        originatesFromRejection,
        markAsOriginatingFromRejection,
        classString,
        copyDescriptors,
        hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
        isNode: isNode2,
        hasEnvVariables,
        env: env2,
        global: globalObject,
        getNativePromise,
        domainBind
      };
      ret.isRecentNode = ret.isNode && function() {
        var version2 = process.versions.node.split(".").map(Number);
        return version2[0] === 0 && version2[1] > 10 || version2[0] > 0;
      }();
      if (ret.isNode)
        ret.toFastProperties(process);
      try {
        throw new Error();
      } catch (e) {
        ret.lastLineError = e;
      }
      module2.exports = ret;
    }, { "./es5": 13 }] }, {}, [4])(4);
  });
  if (typeof window !== "undefined" && window !== null) {
    window.P = window.Promise;
  } else if (typeof self !== "undefined" && self !== null) {
    self.P = self.Promise;
  }
})(bluebird);
var bluebirdExports = bluebird.exports;
const Bluebird = /* @__PURE__ */ getDefaultExportFromCjs(bluebirdExports);
var events = { exports: {} };
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit2(type2) {
  var args = [];
  for (var i = 1; i < arguments.length; i++)
    args.push(arguments[i]);
  var doError = type2 === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type2];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners2[i], this, args);
  }
  return true;
};
function _addListener(target, type2, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type2,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type2];
  }
  if (existing === void 0) {
    existing = events2[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type2;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type2, listener) {
  return _addListener(this, type2, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
  return _addListener(this, type2, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type2, listener) {
  var state = { fired: false, wrapFn: void 0, target, type: type2, listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type2, listener) {
  checkListener(listener);
  this.on(type2, _onceWrap(this, type2, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
  checkListener(listener);
  this.prependListener(type2, _onceWrap(this, type2, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type2, listener) {
  var list, events2, position, i, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type2];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type2];
      if (events2.removeListener)
        this.emit("removeListener", type2, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type2] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type2, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
  var listeners2, events2, i;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type2] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type2];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    var key;
    for (i = 0; i < keys2.length; ++i) {
      key = keys2[i];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type2];
  if (typeof listeners2 === "function") {
    this.removeListener(type2, listeners2);
  } else if (listeners2 !== void 0) {
    for (i = listeners2.length - 1; i >= 0; i--) {
      this.removeListener(type2, listeners2[i]);
    }
  }
  return this;
};
function _listeners(target, type2, unwrap2) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type2];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap2 ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap2 ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type2) {
  return _listeners(this, type2, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type2) {
  return _listeners(this, type2, false);
};
EventEmitter.listenerCount = function(emitter, type2) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type2);
  } else {
    return listenerCount.call(emitter, type2);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type2) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once2(emitter, name2) {
  return new Promise(function(resolve3, reject) {
    function errorListener(err) {
      emitter.removeListener(name2, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve3([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
    if (name2 !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name2, listener);
    } else {
      emitter.on(name2, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name2, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name2, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var eventsExports = events.exports;
const handlePausing = (getCypress2, reporterBus) => {
  const Cypress2 = getCypress2();
  let sendEventsToOrigin = null;
  reporterBus.on("runner:next", () => {
    const Cypress22 = getCypress2();
    if (!Cypress22)
      return;
    if (sendEventsToOrigin) {
      Cypress22.primaryOriginCommunicator.toSpecBridge(sendEventsToOrigin, "resume:next");
    } else {
      Cypress22.emit("resume:next");
    }
  });
  reporterBus.on("runner:resume", () => {
    const Cypress22 = getCypress2();
    if (!Cypress22)
      return;
    if (sendEventsToOrigin) {
      Cypress22.primaryOriginCommunicator.toSpecBridge(sendEventsToOrigin, "resume:all");
    } else {
      Cypress22.emit("resume:all");
    }
    sendEventsToOrigin = null;
  });
  Cypress2.on("paused", (nextCommandName) => {
    reporterBus.emit("paused", nextCommandName);
  });
  Cypress2.primaryOriginCommunicator.on("paused", ({ nextCommandName, origin }) => {
    sendEventsToOrigin = origin;
    reporterBus.emit("paused", nextCommandName);
  });
};
var _globalThis$1 = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
var VERSION$2 = "1.4.1";
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible = _makeCompatibilityCheck(VERSION$2);
var major = VERSION$2.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis$1;
function registerGlobal(type2, instance, diag2, allowOverride) {
  var _a2;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a2 !== void 0 ? _a2 : {
    version: VERSION$2
  };
  if (!allowOverride && api[type2]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type2);
    diag2.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION$2) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type2 + " does not match previously registered API v" + VERSION$2);
    diag2.error(err.stack || err.message);
    return false;
  }
  api[type2] = instance;
  diag2.debug("@opentelemetry/api: Registered a global for " + type2 + " v" + VERSION$2 + ".");
  return true;
}
function getGlobal(type2) {
  var _a2, _b2;
  var globalVersion = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a2 === void 0 ? void 0 : _a2.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b2 === void 0 ? void 0 : _b2[type2];
}
function unregisterGlobal(type2, diag2) {
  diag2.debug("@opentelemetry/api: Unregistering a global for " + type2 + " v" + VERSION$2 + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type2];
  }
}
var __read$e = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$5 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger = (
  /** @class */
  function() {
    function DiagComponentLogger2(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger2.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("debug", this._namespace, args);
    };
    DiagComponentLogger2.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("error", this._namespace, args);
    };
    DiagComponentLogger2.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("info", this._namespace, args);
    };
    DiagComponentLogger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("warn", this._namespace, args);
    };
    DiagComponentLogger2.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("verbose", this._namespace, args);
    };
    return DiagComponentLogger2;
  }()
);
function logProxy(funcName, namespace, args) {
  var logger2 = getGlobal("diag");
  if (!logger2) {
    return;
  }
  args.unshift(namespace);
  return logger2[funcName].apply(logger2, __spreadArray$5([], __read$e(args), false));
}
var DiagLogLevel;
(function(DiagLogLevel2) {
  DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
  DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
  DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
  DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
  DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));
function createLogLevelDiagLogger(maxLevel, logger2) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger2 = logger2 || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger2[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger2);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var __read$d = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$4 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME$4 = "diag";
var DiagAPI = (
  /** @class */
  function() {
    function DiagAPI2() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger2 = getGlobal("diag");
          if (!logger2)
            return;
          return logger2[funcName].apply(logger2, __spreadArray$4([], __read$d(args), false));
        };
      }
      var self2 = this;
      var setLogger = function(logger2, optionsOrLogLevel) {
        var _a2, _b2, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
        }
        if (logger2 === self2) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a2 = err.stack) !== null && _a2 !== void 0 ? _a2 : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal("diag");
        var newLogger = createLogLevelDiagLogger((_b2 = optionsOrLogLevel.logLevel) !== null && _b2 !== void 0 ? _b2 : DiagLogLevel.INFO, logger2);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal("diag", newLogger, self2, true);
      };
      self2.setLogger = setLogger;
      self2.disable = function() {
        unregisterGlobal(API_NAME$4, self2);
      };
      self2.createComponentLogger = function(options2) {
        return new DiagComponentLogger(options2);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    DiagAPI2.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI2();
      }
      return this._instance;
    };
    return DiagAPI2;
  }()
);
var __read$c = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __values$5 = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var BaggageImpl = (
  /** @class */
  function() {
    function BaggageImpl2(entries) {
      this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
    }
    BaggageImpl2.prototype.getEntry = function(key) {
      var entry = this._entries.get(key);
      if (!entry) {
        return void 0;
      }
      return Object.assign({}, entry);
    };
    BaggageImpl2.prototype.getAllEntries = function() {
      return Array.from(this._entries.entries()).map(function(_a2) {
        var _b2 = __read$c(_a2, 2), k = _b2[0], v = _b2[1];
        return [k, v];
      });
    };
    BaggageImpl2.prototype.setEntry = function(key, entry) {
      var newBaggage = new BaggageImpl2(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    };
    BaggageImpl2.prototype.removeEntry = function(key) {
      var newBaggage = new BaggageImpl2(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    };
    BaggageImpl2.prototype.removeEntries = function() {
      var e_1, _a2;
      var keys2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        keys2[_i] = arguments[_i];
      }
      var newBaggage = new BaggageImpl2(this._entries);
      try {
        for (var keys_1 = __values$5(keys2), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
          var key = keys_1_1.value;
          newBaggage._entries.delete(key);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (keys_1_1 && !keys_1_1.done && (_a2 = keys_1.return))
            _a2.call(keys_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return newBaggage;
    };
    BaggageImpl2.prototype.clear = function() {
      return new BaggageImpl2();
    };
    return BaggageImpl2;
  }()
);
var baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
var diag$1 = DiagAPI.instance();
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
function baggageEntryMetadataFromString(str) {
  if (typeof str !== "string") {
    diag$1.error("Cannot create baggage metadata from unknown type: " + typeof str);
    str = "";
  }
  return {
    __TYPE__: baggageEntryMetadataSymbol,
    toString: function() {
      return str;
    }
  };
}
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext = (
  /** @class */
  /* @__PURE__ */ function() {
    function BaseContext2(parentContext) {
      var self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self2.getValue = function(key) {
        return self2._currentContext.get(key);
      };
      self2.setValue = function(key, value) {
        var context2 = new BaseContext2(self2._currentContext);
        context2._currentContext.set(key, value);
        return context2;
      };
      self2.deleteValue = function(key) {
        var context2 = new BaseContext2(self2._currentContext);
        context2._currentContext.delete(key);
        return context2;
      };
    }
    return BaseContext2;
  }()
);
var ROOT_CONTEXT = new BaseContext();
var __extends$5 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var NoopMeter = (
  /** @class */
  function() {
    function NoopMeter2() {
    }
    NoopMeter2.prototype.createHistogram = function(_name, _options) {
      return NOOP_HISTOGRAM_METRIC;
    };
    NoopMeter2.prototype.createCounter = function(_name, _options) {
      return NOOP_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
      return NOOP_UP_DOWN_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
      return NOOP_OBSERVABLE_GAUGE_METRIC;
    };
    NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
      return NOOP_OBSERVABLE_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
      return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    };
    NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
    };
    NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
    };
    return NoopMeter2;
  }()
);
var NoopMetric = (
  /** @class */
  /* @__PURE__ */ function() {
    function NoopMetric2() {
    }
    return NoopMetric2;
  }()
);
var NoopCounterMetric = (
  /** @class */
  function(_super) {
    __extends$5(NoopCounterMetric2, _super);
    function NoopCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopCounterMetric2.prototype.add = function(_value, _attributes) {
    };
    return NoopCounterMetric2;
  }(NoopMetric)
);
var NoopUpDownCounterMetric = (
  /** @class */
  function(_super) {
    __extends$5(NoopUpDownCounterMetric2, _super);
    function NoopUpDownCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
    };
    return NoopUpDownCounterMetric2;
  }(NoopMetric)
);
var NoopHistogramMetric = (
  /** @class */
  function(_super) {
    __extends$5(NoopHistogramMetric2, _super);
    function NoopHistogramMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
    };
    return NoopHistogramMetric2;
  }(NoopMetric)
);
var NoopObservableMetric = (
  /** @class */
  function() {
    function NoopObservableMetric2() {
    }
    NoopObservableMetric2.prototype.addCallback = function(_callback) {
    };
    NoopObservableMetric2.prototype.removeCallback = function(_callback) {
    };
    return NoopObservableMetric2;
  }()
);
var NoopObservableCounterMetric = (
  /** @class */
  function(_super) {
    __extends$5(NoopObservableCounterMetric2, _super);
    function NoopObservableCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableCounterMetric2;
  }(NoopObservableMetric)
);
var NoopObservableGaugeMetric = (
  /** @class */
  function(_super) {
    __extends$5(NoopObservableGaugeMetric2, _super);
    function NoopObservableGaugeMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableGaugeMetric2;
  }(NoopObservableMetric)
);
var NoopObservableUpDownCounterMetric = (
  /** @class */
  function(_super) {
    __extends$5(NoopObservableUpDownCounterMetric2, _super);
    function NoopObservableUpDownCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableUpDownCounterMetric2;
  }(NoopObservableMetric)
);
var NOOP_METER = new NoopMeter();
var NOOP_COUNTER_METRIC = new NoopCounterMetric();
var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
var defaultTextMapGetter = {
  get: function(carrier, key) {
    if (carrier == null) {
      return void 0;
    }
    return carrier[key];
  },
  keys: function(carrier) {
    if (carrier == null) {
      return [];
    }
    return Object.keys(carrier);
  }
};
var defaultTextMapSetter = {
  set: function(carrier, key, value) {
    if (carrier == null) {
      return;
    }
    carrier[key] = value;
  }
};
var __read$b = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$3 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = (
  /** @class */
  function() {
    function NoopContextManager2() {
    }
    NoopContextManager2.prototype.active = function() {
      return ROOT_CONTEXT;
    };
    NoopContextManager2.prototype.with = function(_context, fn2, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn2.call.apply(fn2, __spreadArray$3([thisArg], __read$b(args), false));
    };
    NoopContextManager2.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager2.prototype.enable = function() {
      return this;
    };
    NoopContextManager2.prototype.disable = function() {
      return this;
    };
    return NoopContextManager2;
  }()
);
var __read$a = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$2 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME$3 = "context";
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
var ContextAPI = (
  /** @class */
  function() {
    function ContextAPI2() {
    }
    ContextAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI2();
      }
      return this._instance;
    };
    ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal(API_NAME$3, contextManager, DiagAPI.instance());
    };
    ContextAPI2.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI2.prototype.with = function(context2, fn2, thisArg) {
      var _a2;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a2 = this._getContextManager()).with.apply(_a2, __spreadArray$2([context2, fn2, thisArg], __read$a(args), false));
    };
    ContextAPI2.prototype.bind = function(context2, target) {
      return this._getContextManager().bind(context2, target);
    };
    ContextAPI2.prototype._getContextManager = function() {
      return getGlobal(API_NAME$3) || NOOP_CONTEXT_MANAGER;
    };
    ContextAPI2.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal(API_NAME$3, DiagAPI.instance());
    };
    return ContextAPI2;
  }()
);
var TraceFlags;
(function(TraceFlags2) {
  TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
  TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));
var INVALID_SPANID = "0000000000000000";
var INVALID_TRACEID = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT = {
  traceId: INVALID_TRACEID,
  spanId: INVALID_SPANID,
  traceFlags: TraceFlags.NONE
};
var NonRecordingSpan = (
  /** @class */
  function() {
    function NonRecordingSpan2(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan2.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan2.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan2.prototype.end = function(_endTime) {
    };
    NonRecordingSpan2.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan2;
  }()
);
var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a2;
  return (_a2 = getSpan(context2)) === null || _a2 === void 0 ? void 0 : _a2.spanContext();
}
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var contextApi = ContextAPI.getInstance();
var NoopTracer = (
  /** @class */
  function() {
    function NoopTracer2() {
    }
    NoopTracer2.prototype.startSpan = function(name2, options2, context2) {
      if (context2 === void 0) {
        context2 = contextApi.active();
      }
      var root = Boolean(options2 === null || options2 === void 0 ? void 0 : options2.root);
      if (root) {
        return new NonRecordingSpan();
      }
      var parentFromContext = context2 && getSpanContext(context2);
      if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
        return new NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan();
      }
    };
    NoopTracer2.prototype.startActiveSpan = function(name2, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn2;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn2 = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn2 = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn2 = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
      var span = this.startSpan(name2, opts, parentContext);
      var contextWithSpanSet = setSpan(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn2, void 0, span);
    };
    return NoopTracer2;
  }()
);
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var NOOP_TRACER = new NoopTracer();
var ProxyTracer = (
  /** @class */
  function() {
    function ProxyTracer2(_provider, name2, version2, options2) {
      this._provider = _provider;
      this.name = name2;
      this.version = version2;
      this.options = options2;
    }
    ProxyTracer2.prototype.startSpan = function(name2, options2, context2) {
      return this._getTracer().startSpan(name2, options2, context2);
    };
    ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer2.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer2;
  }()
);
var NoopTracerProvider = (
  /** @class */
  function() {
    function NoopTracerProvider2() {
    }
    NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer();
    };
    return NoopTracerProvider2;
  }()
);
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
var ProxyTracerProvider = (
  /** @class */
  function() {
    function ProxyTracerProvider2() {
    }
    ProxyTracerProvider2.prototype.getTracer = function(name2, version2, options2) {
      var _a2;
      return (_a2 = this.getDelegateTracer(name2, version2, options2)) !== null && _a2 !== void 0 ? _a2 : new ProxyTracer(this, name2, version2, options2);
    };
    ProxyTracerProvider2.prototype.getDelegate = function() {
      var _a2;
      return (_a2 = this._delegate) !== null && _a2 !== void 0 ? _a2 : NOOP_TRACER_PROVIDER;
    };
    ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider2.prototype.getDelegateTracer = function(name2, version2, options2) {
      var _a2;
      return (_a2 = this._delegate) === null || _a2 === void 0 ? void 0 : _a2.getTracer(name2, version2, options2);
    };
    return ProxyTracerProvider2;
  }()
);
var SamplingDecision$1;
(function(SamplingDecision2) {
  SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
  SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
  SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision$1 || (SamplingDecision$1 = {}));
var SpanKind;
(function(SpanKind2) {
  SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
  SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
  SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
  SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
  SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind || (SpanKind = {}));
var SpanStatusCode;
(function(SpanStatusCode2) {
  SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
  SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
  SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));
var context = ContextAPI.getInstance();
var diag = DiagAPI.instance();
var NoopMeterProvider = (
  /** @class */
  function() {
    function NoopMeterProvider2() {
    }
    NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
      return NOOP_METER;
    };
    return NoopMeterProvider2;
  }()
);
var NOOP_METER_PROVIDER = new NoopMeterProvider();
var API_NAME$2 = "metrics";
var MetricsAPI = (
  /** @class */
  function() {
    function MetricsAPI2() {
    }
    MetricsAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new MetricsAPI2();
      }
      return this._instance;
    };
    MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
      return registerGlobal(API_NAME$2, provider, DiagAPI.instance());
    };
    MetricsAPI2.prototype.getMeterProvider = function() {
      return getGlobal(API_NAME$2) || NOOP_METER_PROVIDER;
    };
    MetricsAPI2.prototype.getMeter = function(name2, version2, options2) {
      return this.getMeterProvider().getMeter(name2, version2, options2);
    };
    MetricsAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME$2, DiagAPI.instance());
    };
    return MetricsAPI2;
  }()
);
var metrics = MetricsAPI.getInstance();
var NoopTextMapPropagator = (
  /** @class */
  function() {
    function NoopTextMapPropagator2() {
    }
    NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
    };
    NoopTextMapPropagator2.prototype.extract = function(context2, _carrier) {
      return context2;
    };
    NoopTextMapPropagator2.prototype.fields = function() {
      return [];
    };
    return NoopTextMapPropagator2;
  }()
);
var BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
function getBaggage(context2) {
  return context2.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context2, baggage) {
  return context2.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context2) {
  return context2.deleteValue(BAGGAGE_KEY);
}
var API_NAME$1 = "propagation";
var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
var PropagationAPI = (
  /** @class */
  function() {
    function PropagationAPI2() {
      this.createBaggage = createBaggage;
      this.getBaggage = getBaggage;
      this.getActiveBaggage = getActiveBaggage;
      this.setBaggage = setBaggage;
      this.deleteBaggage = deleteBaggage;
    }
    PropagationAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new PropagationAPI2();
      }
      return this._instance;
    };
    PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
      return registerGlobal(API_NAME$1, propagator, DiagAPI.instance());
    };
    PropagationAPI2.prototype.inject = function(context2, carrier, setter) {
      if (setter === void 0) {
        setter = defaultTextMapSetter;
      }
      return this._getGlobalPropagator().inject(context2, carrier, setter);
    };
    PropagationAPI2.prototype.extract = function(context2, carrier, getter) {
      if (getter === void 0) {
        getter = defaultTextMapGetter;
      }
      return this._getGlobalPropagator().extract(context2, carrier, getter);
    };
    PropagationAPI2.prototype.fields = function() {
      return this._getGlobalPropagator().fields();
    };
    PropagationAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME$1, DiagAPI.instance());
    };
    PropagationAPI2.prototype._getGlobalPropagator = function() {
      return getGlobal(API_NAME$1) || NOOP_TEXT_MAP_PROPAGATOR;
    };
    return PropagationAPI2;
  }()
);
var propagation = PropagationAPI.getInstance();
var API_NAME = "trace";
var TraceAPI = (
  /** @class */
  function() {
    function TraceAPI2() {
      this._proxyTracerProvider = new ProxyTracerProvider();
      this.wrapSpanContext = wrapSpanContext;
      this.isSpanContextValid = isSpanContextValid;
      this.deleteSpan = deleteSpan;
      this.getSpan = getSpan;
      this.getActiveSpan = getActiveSpan;
      this.getSpanContext = getSpanContext;
      this.setSpan = setSpan;
      this.setSpanContext = setSpanContext;
    }
    TraceAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI2();
      }
      return this._instance;
    };
    TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal(API_NAME, this._proxyTracerProvider, DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI2.prototype.getTracerProvider = function() {
      return getGlobal(API_NAME) || this._proxyTracerProvider;
    };
    TraceAPI2.prototype.getTracer = function(name2, version2) {
      return this.getTracerProvider().getTracer(name2, version2);
    };
    TraceAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME, DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI2;
  }()
);
var trace = TraceAPI.getInstance();
const openTelemetry = {
  context,
  diag,
  metrics,
  propagation,
  trace
};
var SemanticAttributes = {
  /**
   * The full invoked ARN as provided on the `Context` passed to the function (`Lambda-Runtime-Invoked-Function-Arn` header on the `/runtime/invocation/next` applicable).
   *
   * Note: This may be different from `faas.id` if an alias is involved.
   */
  AWS_LAMBDA_INVOKED_ARN: "aws.lambda.invoked_arn",
  /**
   * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.
   */
  DB_SYSTEM: "db.system",
  /**
   * The connection string used to connect to the database. It is recommended to remove embedded credentials.
   */
  DB_CONNECTION_STRING: "db.connection_string",
  /**
   * Username for accessing the database.
   */
  DB_USER: "db.user",
  /**
   * The fully-qualified class name of the [Java Database Connectivity (JDBC)](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/) driver used to connect.
   */
  DB_JDBC_DRIVER_CLASSNAME: "db.jdbc.driver_classname",
  /**
   * If no [tech-specific attribute](#call-level-attributes-for-specific-technologies) is defined, this attribute is used to report the name of the database being accessed. For commands that switch the database, this should be set to the target database (even if the command fails).
   *
   * Note: In some SQL databases, the database name to be used is called &#34;schema name&#34;.
   */
  DB_NAME: "db.name",
  /**
   * The database statement being executed.
   *
   * Note: The value may be sanitized to exclude sensitive information.
   */
  DB_STATEMENT: "db.statement",
  /**
   * The name of the operation being executed, e.g. the [MongoDB command name](https://docs.mongodb.com/manual/reference/command/#database-operations) such as `findAndModify`, or the SQL keyword.
   *
   * Note: When setting this to an SQL keyword, it is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if the operation name is provided by the library being instrumented. If the SQL statement has an ambiguous operation, or performs more than one operation, this value may be omitted.
   */
  DB_OPERATION: "db.operation",
  /**
   * The Microsoft SQL Server [instance name](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15) connecting to. This name is used to determine the port of a named instance.
   *
   * Note: If setting a `db.mssql.instance_name`, `net.peer.port` is no longer required (but still recommended if non-standard).
   */
  DB_MSSQL_INSTANCE_NAME: "db.mssql.instance_name",
  /**
   * The name of the keyspace being accessed. To be used instead of the generic `db.name` attribute.
   */
  DB_CASSANDRA_KEYSPACE: "db.cassandra.keyspace",
  /**
   * The fetch size used for paging, i.e. how many rows will be returned at once.
   */
  DB_CASSANDRA_PAGE_SIZE: "db.cassandra.page_size",
  /**
   * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
   */
  DB_CASSANDRA_CONSISTENCY_LEVEL: "db.cassandra.consistency_level",
  /**
   * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
   *
   * Note: This mirrors the db.sql.table attribute but references cassandra rather than sql. It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
   */
  DB_CASSANDRA_TABLE: "db.cassandra.table",
  /**
   * Whether or not the query is idempotent.
   */
  DB_CASSANDRA_IDEMPOTENCE: "db.cassandra.idempotence",
  /**
   * The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively.
   */
  DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: "db.cassandra.speculative_execution_count",
  /**
   * The ID of the coordinating node for a query.
   */
  DB_CASSANDRA_COORDINATOR_ID: "db.cassandra.coordinator.id",
  /**
   * The data center of the coordinating node for a query.
   */
  DB_CASSANDRA_COORDINATOR_DC: "db.cassandra.coordinator.dc",
  /**
   * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed. To be used instead of the generic `db.name` attribute.
   */
  DB_HBASE_NAMESPACE: "db.hbase.namespace",
  /**
   * The index of the database being accessed as used in the [`SELECT` command](https://redis.io/commands/select), provided as an integer. To be used instead of the generic `db.name` attribute.
   */
  DB_REDIS_DATABASE_INDEX: "db.redis.database_index",
  /**
   * The collection being accessed within the database stated in `db.name`.
   */
  DB_MONGODB_COLLECTION: "db.mongodb.collection",
  /**
   * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
   *
   * Note: It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
   */
  DB_SQL_TABLE: "db.sql.table",
  /**
   * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
   */
  EXCEPTION_TYPE: "exception.type",
  /**
   * The exception message.
   */
  EXCEPTION_MESSAGE: "exception.message",
  /**
   * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
   */
  EXCEPTION_STACKTRACE: "exception.stacktrace",
  /**
    * SHOULD be set to true if the exception event is recorded at a point where it is known that the exception is escaping the scope of the span.
    *
    * Note: An exception is considered to have escaped (or left) the scope of a span,
  if that span is ended while the exception is still logically &#34;in flight&#34;.
  This may be actually &#34;in flight&#34; in some languages (e.g. if the exception
  is passed to a Context manager&#39;s `__exit__` method in Python) but will
  usually be caught at the point of recording the exception in most languages.
  
  It is usually not possible to determine at the point where an exception is thrown
  whether it will escape the scope of a span.
  However, it is trivial to know that an exception
  will escape, if one checks for an active exception just before ending the span,
  as done in the [example above](#exception-end-example).
  
  It follows that an exception may still escape the scope of the span
  even if the `exception.escaped` attribute was not set or set to false,
  since the event might have been recorded at a time where it was not
  clear whether the exception will escape.
    */
  EXCEPTION_ESCAPED: "exception.escaped",
  /**
   * Type of the trigger on which the function is executed.
   */
  FAAS_TRIGGER: "faas.trigger",
  /**
   * The execution ID of the current function execution.
   */
  FAAS_EXECUTION: "faas.execution",
  /**
   * The name of the source on which the triggering operation was performed. For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.
   */
  FAAS_DOCUMENT_COLLECTION: "faas.document.collection",
  /**
   * Describes the type of the operation that was performed on the data.
   */
  FAAS_DOCUMENT_OPERATION: "faas.document.operation",
  /**
   * A string containing the time when the data was accessed in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
   */
  FAAS_DOCUMENT_TIME: "faas.document.time",
  /**
   * The document name/table subjected to the operation. For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.
   */
  FAAS_DOCUMENT_NAME: "faas.document.name",
  /**
   * A string containing the function invocation time in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
   */
  FAAS_TIME: "faas.time",
  /**
   * A string containing the schedule period as [Cron Expression](https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm).
   */
  FAAS_CRON: "faas.cron",
  /**
   * A boolean that is true if the serverless function is executed for the first time (aka cold-start).
   */
  FAAS_COLDSTART: "faas.coldstart",
  /**
   * The name of the invoked function.
   *
   * Note: SHOULD be equal to the `faas.name` resource attribute of the invoked function.
   */
  FAAS_INVOKED_NAME: "faas.invoked_name",
  /**
   * The cloud provider of the invoked function.
   *
   * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.
   */
  FAAS_INVOKED_PROVIDER: "faas.invoked_provider",
  /**
   * The cloud region of the invoked function.
   *
   * Note: SHOULD be equal to the `cloud.region` resource attribute of the invoked function.
   */
  FAAS_INVOKED_REGION: "faas.invoked_region",
  /**
   * Transport protocol used. See note below.
   */
  NET_TRANSPORT: "net.transport",
  /**
   * Remote address of the peer (dotted decimal for IPv4 or [RFC5952](https://tools.ietf.org/html/rfc5952) for IPv6).
   */
  NET_PEER_IP: "net.peer.ip",
  /**
   * Remote port number.
   */
  NET_PEER_PORT: "net.peer.port",
  /**
   * Remote hostname or similar, see note below.
   */
  NET_PEER_NAME: "net.peer.name",
  /**
   * Like `net.peer.ip` but for the host IP. Useful in case of a multi-IP host.
   */
  NET_HOST_IP: "net.host.ip",
  /**
   * Like `net.peer.port` but for the host port.
   */
  NET_HOST_PORT: "net.host.port",
  /**
   * Local hostname or similar, see note below.
   */
  NET_HOST_NAME: "net.host.name",
  /**
   * The internet connection type currently being used by the host.
   */
  NET_HOST_CONNECTION_TYPE: "net.host.connection.type",
  /**
   * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
   */
  NET_HOST_CONNECTION_SUBTYPE: "net.host.connection.subtype",
  /**
   * The name of the mobile carrier.
   */
  NET_HOST_CARRIER_NAME: "net.host.carrier.name",
  /**
   * The mobile carrier country code.
   */
  NET_HOST_CARRIER_MCC: "net.host.carrier.mcc",
  /**
   * The mobile carrier network code.
   */
  NET_HOST_CARRIER_MNC: "net.host.carrier.mnc",
  /**
   * The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network.
   */
  NET_HOST_CARRIER_ICC: "net.host.carrier.icc",
  /**
   * The [`service.name`](../../resource/semantic_conventions/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any.
   */
  PEER_SERVICE: "peer.service",
  /**
   * Username or client_id extracted from the access token or [Authorization](https://tools.ietf.org/html/rfc7235#section-4.2) header in the inbound request from outside the system.
   */
  ENDUSER_ID: "enduser.id",
  /**
   * Actual/assumed role the client is making the request under extracted from token or application security context.
   */
  ENDUSER_ROLE: "enduser.role",
  /**
   * Scopes or granted authorities the client currently possesses extracted from token or application security context. The value would come from the scope associated with an [OAuth 2.0 Access Token](https://tools.ietf.org/html/rfc6749#section-3.3) or an attribute value in a [SAML 2.0 Assertion](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html).
   */
  ENDUSER_SCOPE: "enduser.scope",
  /**
   * Current &#34;managed&#34; thread ID (as opposed to OS thread ID).
   */
  THREAD_ID: "thread.id",
  /**
   * Current thread name.
   */
  THREAD_NAME: "thread.name",
  /**
   * The method or function name, or equivalent (usually rightmost part of the code unit&#39;s name).
   */
  CODE_FUNCTION: "code.function",
  /**
   * The &#34;namespace&#34; within which `code.function` is defined. Usually the qualified class or module name, such that `code.namespace` + some separator + `code.function` form a unique identifier for the code unit.
   */
  CODE_NAMESPACE: "code.namespace",
  /**
   * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path).
   */
  CODE_FILEPATH: "code.filepath",
  /**
   * The line number in `code.filepath` best representing the operation. It SHOULD point within the code unit named in `code.function`.
   */
  CODE_LINENO: "code.lineno",
  /**
   * HTTP request method.
   */
  HTTP_METHOD: "http.method",
  /**
   * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
   *
   * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
   */
  HTTP_URL: "http.url",
  /**
   * The full request target as passed in a HTTP request line or equivalent.
   */
  HTTP_TARGET: "http.target",
  /**
   * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
   *
   * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
   */
  HTTP_HOST: "http.host",
  /**
   * The URI scheme identifying the used protocol.
   */
  HTTP_SCHEME: "http.scheme",
  /**
   * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
   */
  HTTP_STATUS_CODE: "http.status_code",
  /**
   * Kind of HTTP protocol used.
   *
   * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.
   */
  HTTP_FLAVOR: "http.flavor",
  /**
   * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
   */
  HTTP_USER_AGENT: "http.user_agent",
  /**
   * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
   */
  HTTP_REQUEST_CONTENT_LENGTH: "http.request_content_length",
  /**
   * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
   */
  HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: "http.request_content_length_uncompressed",
  /**
   * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
   */
  HTTP_RESPONSE_CONTENT_LENGTH: "http.response_content_length",
  /**
   * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.
   */
  HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: "http.response_content_length_uncompressed",
  /**
   * The primary server name of the matched virtual host. This should be obtained via configuration. If no such configuration can be obtained, this attribute MUST NOT be set ( `net.host.name` should be used instead).
   *
   * Note: `http.url` is usually not readily available on the server side but would have to be assembled in a cumbersome and sometimes lossy process from other information (see e.g. open-telemetry/opentelemetry-python/pull/148). It is thus preferred to supply the raw data that is available.
   */
  HTTP_SERVER_NAME: "http.server_name",
  /**
   * The matched route (path template).
   */
  HTTP_ROUTE: "http.route",
  /**
    * The IP address of the original client behind all proxies, if known (e.g. from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)).
    *
    * Note: This is not necessarily the same as `net.peer.ip`, which would
  identify the network-level peer, which may be a proxy.
  
  This attribute should be set when a source of information different
  from the one used for `net.peer.ip`, is available even if that other
  source just confirms the same value as `net.peer.ip`.
  Rationale: For `net.peer.ip`, one typically does not know if it
  comes from a proxy, reverse proxy, or the actual client. Setting
  `http.client_ip` when it&#39;s the same as `net.peer.ip` means that
  one is at least somewhat confident that the address is not that of
  the closest proxy.
    */
  HTTP_CLIENT_IP: "http.client_ip",
  /**
   * The keys in the `RequestItems` object field.
   */
  AWS_DYNAMODB_TABLE_NAMES: "aws.dynamodb.table_names",
  /**
   * The JSON-serialized value of each item in the `ConsumedCapacity` response field.
   */
  AWS_DYNAMODB_CONSUMED_CAPACITY: "aws.dynamodb.consumed_capacity",
  /**
   * The JSON-serialized value of the `ItemCollectionMetrics` response field.
   */
  AWS_DYNAMODB_ITEM_COLLECTION_METRICS: "aws.dynamodb.item_collection_metrics",
  /**
   * The value of the `ProvisionedThroughput.ReadCapacityUnits` request parameter.
   */
  AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: "aws.dynamodb.provisioned_read_capacity",
  /**
   * The value of the `ProvisionedThroughput.WriteCapacityUnits` request parameter.
   */
  AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: "aws.dynamodb.provisioned_write_capacity",
  /**
   * The value of the `ConsistentRead` request parameter.
   */
  AWS_DYNAMODB_CONSISTENT_READ: "aws.dynamodb.consistent_read",
  /**
   * The value of the `ProjectionExpression` request parameter.
   */
  AWS_DYNAMODB_PROJECTION: "aws.dynamodb.projection",
  /**
   * The value of the `Limit` request parameter.
   */
  AWS_DYNAMODB_LIMIT: "aws.dynamodb.limit",
  /**
   * The value of the `AttributesToGet` request parameter.
   */
  AWS_DYNAMODB_ATTRIBUTES_TO_GET: "aws.dynamodb.attributes_to_get",
  /**
   * The value of the `IndexName` request parameter.
   */
  AWS_DYNAMODB_INDEX_NAME: "aws.dynamodb.index_name",
  /**
   * The value of the `Select` request parameter.
   */
  AWS_DYNAMODB_SELECT: "aws.dynamodb.select",
  /**
   * The JSON-serialized value of each item of the `GlobalSecondaryIndexes` request field.
   */
  AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: "aws.dynamodb.global_secondary_indexes",
  /**
   * The JSON-serialized value of each item of the `LocalSecondaryIndexes` request field.
   */
  AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: "aws.dynamodb.local_secondary_indexes",
  /**
   * The value of the `ExclusiveStartTableName` request parameter.
   */
  AWS_DYNAMODB_EXCLUSIVE_START_TABLE: "aws.dynamodb.exclusive_start_table",
  /**
   * The the number of items in the `TableNames` response parameter.
   */
  AWS_DYNAMODB_TABLE_COUNT: "aws.dynamodb.table_count",
  /**
   * The value of the `ScanIndexForward` request parameter.
   */
  AWS_DYNAMODB_SCAN_FORWARD: "aws.dynamodb.scan_forward",
  /**
   * The value of the `Segment` request parameter.
   */
  AWS_DYNAMODB_SEGMENT: "aws.dynamodb.segment",
  /**
   * The value of the `TotalSegments` request parameter.
   */
  AWS_DYNAMODB_TOTAL_SEGMENTS: "aws.dynamodb.total_segments",
  /**
   * The value of the `Count` response parameter.
   */
  AWS_DYNAMODB_COUNT: "aws.dynamodb.count",
  /**
   * The value of the `ScannedCount` response parameter.
   */
  AWS_DYNAMODB_SCANNED_COUNT: "aws.dynamodb.scanned_count",
  /**
   * The JSON-serialized value of each item in the `AttributeDefinitions` request field.
   */
  AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: "aws.dynamodb.attribute_definitions",
  /**
   * The JSON-serialized value of each item in the the `GlobalSecondaryIndexUpdates` request field.
   */
  AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: "aws.dynamodb.global_secondary_index_updates",
  /**
   * A string identifying the messaging system.
   */
  MESSAGING_SYSTEM: "messaging.system",
  /**
   * The message destination name. This might be equal to the span name but is required nevertheless.
   */
  MESSAGING_DESTINATION: "messaging.destination",
  /**
   * The kind of message destination.
   */
  MESSAGING_DESTINATION_KIND: "messaging.destination_kind",
  /**
   * A boolean that is true if the message destination is temporary.
   */
  MESSAGING_TEMP_DESTINATION: "messaging.temp_destination",
  /**
   * The name of the transport protocol.
   */
  MESSAGING_PROTOCOL: "messaging.protocol",
  /**
   * The version of the transport protocol.
   */
  MESSAGING_PROTOCOL_VERSION: "messaging.protocol_version",
  /**
   * Connection string.
   */
  MESSAGING_URL: "messaging.url",
  /**
   * A value used by the messaging system as an identifier for the message, represented as a string.
   */
  MESSAGING_MESSAGE_ID: "messaging.message_id",
  /**
   * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.
   */
  MESSAGING_CONVERSATION_ID: "messaging.conversation_id",
  /**
   * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.
   */
  MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: "messaging.message_payload_size_bytes",
  /**
   * The compressed size of the message payload in bytes.
   */
  MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: "messaging.message_payload_compressed_size_bytes",
  /**
   * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.
   */
  MESSAGING_OPERATION: "messaging.operation",
  /**
   * The identifier for the consumer receiving a message. For Kafka, set it to `{messaging.kafka.consumer_group} - {messaging.kafka.client_id}`, if both are present, or only `messaging.kafka.consumer_group`. For brokers, such as RabbitMQ and Artemis, set it to the `client_id` of the client consuming the message.
   */
  MESSAGING_CONSUMER_ID: "messaging.consumer_id",
  /**
   * RabbitMQ message routing key.
   */
  MESSAGING_RABBITMQ_ROUTING_KEY: "messaging.rabbitmq.routing_key",
  /**
   * Message keys in Kafka are used for grouping alike messages to ensure they&#39;re processed on the same partition. They differ from `messaging.message_id` in that they&#39;re not unique. If the key is `null`, the attribute MUST NOT be set.
   *
   * Note: If the key type is not string, it&#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&#39;t include its value.
   */
  MESSAGING_KAFKA_MESSAGE_KEY: "messaging.kafka.message_key",
  /**
   * Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.
   */
  MESSAGING_KAFKA_CONSUMER_GROUP: "messaging.kafka.consumer_group",
  /**
   * Client Id for the Consumer or Producer that is handling the message.
   */
  MESSAGING_KAFKA_CLIENT_ID: "messaging.kafka.client_id",
  /**
   * Partition the message is sent to.
   */
  MESSAGING_KAFKA_PARTITION: "messaging.kafka.partition",
  /**
   * A boolean that is true if the message is a tombstone.
   */
  MESSAGING_KAFKA_TOMBSTONE: "messaging.kafka.tombstone",
  /**
   * A string identifying the remoting system.
   */
  RPC_SYSTEM: "rpc.system",
  /**
   * The full (logical) name of the service being called, including its package name, if applicable.
   *
   * Note: This is the logical name of the service from the RPC interface perspective, which can be different from the name of any implementing class. The `code.namespace` attribute may be used to store the latter (despite the attribute name, it may include a class name; e.g., class with method actually executing the call on the server side, RPC client stub class on the client side).
   */
  RPC_SERVICE: "rpc.service",
  /**
   * The name of the (logical) method being called, must be equal to the $method part in the span name.
   *
   * Note: This is the logical name of the method from the RPC interface perspective, which can be different from the name of any implementing method/function. The `code.function` attribute may be used to store the latter (e.g., method actually executing the call on the server side, RPC client stub method on the client side).
   */
  RPC_METHOD: "rpc.method",
  /**
   * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.
   */
  RPC_GRPC_STATUS_CODE: "rpc.grpc.status_code",
  /**
   * Protocol version as in `jsonrpc` property of request/response. Since JSON-RPC 1.0 does not specify this, the value can be omitted.
   */
  RPC_JSONRPC_VERSION: "rpc.jsonrpc.version",
  /**
   * `id` property of request or response. Since protocol allows id to be int, string, `null` or missing (for notifications), value is expected to be cast to string for simplicity. Use empty string in case of `null` value. Omit entirely if this is a notification.
   */
  RPC_JSONRPC_REQUEST_ID: "rpc.jsonrpc.request_id",
  /**
   * `error.code` property of response if it is an error response.
   */
  RPC_JSONRPC_ERROR_CODE: "rpc.jsonrpc.error_code",
  /**
   * `error.message` property of response if it is an error response.
   */
  RPC_JSONRPC_ERROR_MESSAGE: "rpc.jsonrpc.error_message",
  /**
   * Whether this is a received or sent message.
   */
  MESSAGE_TYPE: "message.type",
  /**
   * MUST be calculated as two different counters starting from `1` one for sent messages and one for received message.
   *
   * Note: This way we guarantee that the values will be consistent between different implementations.
   */
  MESSAGE_ID: "message.id",
  /**
   * Compressed size of the message in bytes.
   */
  MESSAGE_COMPRESSED_SIZE: "message.compressed_size",
  /**
   * Uncompressed size of the message in bytes.
   */
  MESSAGE_UNCOMPRESSED_SIZE: "message.uncompressed_size"
};
var SemanticResourceAttributes = {
  /**
   * Name of the cloud provider.
   */
  CLOUD_PROVIDER: "cloud.provider",
  /**
   * The cloud account ID the resource is assigned to.
   */
  CLOUD_ACCOUNT_ID: "cloud.account.id",
  /**
   * The geographical region the resource is running. Refer to your provider&#39;s docs to see the available regions, for example [Alibaba Cloud regions](https://www.alibabacloud.com/help/doc-detail/40654.htm), [AWS regions](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/), [Azure regions](https://azure.microsoft.com/en-us/global-infrastructure/geographies/), or [Google Cloud regions](https://cloud.google.com/about/locations).
   */
  CLOUD_REGION: "cloud.region",
  /**
   * Cloud regions often have multiple, isolated locations known as zones to increase availability. Availability zone represents the zone where the resource is running.
   *
   * Note: Availability zones are called &#34;zones&#34; on Alibaba Cloud and Google Cloud.
   */
  CLOUD_AVAILABILITY_ZONE: "cloud.availability_zone",
  /**
   * The cloud platform in use.
   *
   * Note: The prefix of the service SHOULD match the one specified in `cloud.provider`.
   */
  CLOUD_PLATFORM: "cloud.platform",
  /**
   * The Amazon Resource Name (ARN) of an [ECS container instance](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_instances.html).
   */
  AWS_ECS_CONTAINER_ARN: "aws.ecs.container.arn",
  /**
   * The ARN of an [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html).
   */
  AWS_ECS_CLUSTER_ARN: "aws.ecs.cluster.arn",
  /**
   * The [launch type](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) for an ECS task.
   */
  AWS_ECS_LAUNCHTYPE: "aws.ecs.launchtype",
  /**
   * The ARN of an [ECS task definition](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html).
   */
  AWS_ECS_TASK_ARN: "aws.ecs.task.arn",
  /**
   * The task definition family this task definition is a member of.
   */
  AWS_ECS_TASK_FAMILY: "aws.ecs.task.family",
  /**
   * The revision for this task definition.
   */
  AWS_ECS_TASK_REVISION: "aws.ecs.task.revision",
  /**
   * The ARN of an EKS cluster.
   */
  AWS_EKS_CLUSTER_ARN: "aws.eks.cluster.arn",
  /**
   * The name(s) of the AWS log group(s) an application is writing to.
   *
   * Note: Multiple log groups must be supported for cases like multi-container applications, where a single application has sidecar containers, and each write to their own log group.
   */
  AWS_LOG_GROUP_NAMES: "aws.log.group.names",
  /**
   * The Amazon Resource Name(s) (ARN) of the AWS log group(s).
   *
   * Note: See the [log group ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format).
   */
  AWS_LOG_GROUP_ARNS: "aws.log.group.arns",
  /**
   * The name(s) of the AWS log stream(s) an application is writing to.
   */
  AWS_LOG_STREAM_NAMES: "aws.log.stream.names",
  /**
   * The ARN(s) of the AWS log stream(s).
   *
   * Note: See the [log stream ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format). One log group can contain several log streams, so these ARNs necessarily identify both a log group and a log stream.
   */
  AWS_LOG_STREAM_ARNS: "aws.log.stream.arns",
  /**
   * Container name.
   */
  CONTAINER_NAME: "container.name",
  /**
   * Container ID. Usually a UUID, as for example used to [identify Docker containers](https://docs.docker.com/engine/reference/run/#container-identification). The UUID might be abbreviated.
   */
  CONTAINER_ID: "container.id",
  /**
   * The container runtime managing this container.
   */
  CONTAINER_RUNTIME: "container.runtime",
  /**
   * Name of the image the container was built on.
   */
  CONTAINER_IMAGE_NAME: "container.image.name",
  /**
   * Container image tag.
   */
  CONTAINER_IMAGE_TAG: "container.image.tag",
  /**
   * Name of the [deployment environment](https://en.wikipedia.org/wiki/Deployment_environment) (aka deployment tier).
   */
  DEPLOYMENT_ENVIRONMENT: "deployment.environment",
  /**
   * A unique identifier representing the device.
   *
   * Note: The device identifier MUST only be defined using the values outlined below. This value is not an advertising identifier and MUST NOT be used as such. On iOS (Swift or Objective-C), this value MUST be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor). On Android (Java or Kotlin), this value MUST be equal to the Firebase Installation ID or a globally unique UUID which is persisted across sessions in your application. More information can be found [here](https://developer.android.com/training/articles/user-data-ids) on best practices and exact implementation details. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply, ensure you do your own due diligence.
   */
  DEVICE_ID: "device.id",
  /**
   * The model identifier for the device.
   *
   * Note: It&#39;s recommended this value represents a machine readable version of the model identifier rather than the market or consumer-friendly name of the device.
   */
  DEVICE_MODEL_IDENTIFIER: "device.model.identifier",
  /**
   * The marketing name for the device model.
   *
   * Note: It&#39;s recommended this value represents a human readable version of the device model rather than a machine readable alternative.
   */
  DEVICE_MODEL_NAME: "device.model.name",
  /**
   * The name of the single function that this runtime instance executes.
   *
   * Note: This is the name of the function as configured/deployed on the FaaS platform and is usually different from the name of the callback function (which may be stored in the [`code.namespace`/`code.function`](../../trace/semantic_conventions/span-general.md#source-code-attributes) span attributes).
   */
  FAAS_NAME: "faas.name",
  /**
    * The unique ID of the single function that this runtime instance executes.
    *
    * Note: Depending on the cloud provider, use:
  
  * **AWS Lambda:** The function [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
  Take care not to use the &#34;invoked ARN&#34; directly but replace any
  [alias suffix](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html) with the resolved function version, as the same runtime instance may be invokable with multiple
  different aliases.
  * **GCP:** The [URI of the resource](https://cloud.google.com/iam/docs/full-resource-names)
  * **Azure:** The [Fully Qualified Resource ID](https://docs.microsoft.com/en-us/rest/api/resources/resources/get-by-id).
  
  On some providers, it may not be possible to determine the full ID at startup,
  which is why this field cannot be made required. For example, on AWS the account ID
  part of the ARN is not available without calling another AWS API
  which may be deemed too slow for a short-running lambda function.
  As an alternative, consider setting `faas.id` as a span attribute instead.
    */
  FAAS_ID: "faas.id",
  /**
    * The immutable version of the function being executed.
    *
    * Note: Depending on the cloud provider and platform, use:
  
  * **AWS Lambda:** The [function version](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
    (an integer represented as a decimal string).
  * **Google Cloud Run:** The [revision](https://cloud.google.com/run/docs/managing/revisions)
    (i.e., the function name plus the revision suffix).
  * **Google Cloud Functions:** The value of the
    [`K_REVISION` environment variable](https://cloud.google.com/functions/docs/env-var#runtime_environment_variables_set_automatically).
  * **Azure Functions:** Not applicable. Do not set this attribute.
    */
  FAAS_VERSION: "faas.version",
  /**
   * The execution environment ID as a string, that will be potentially reused for other invocations to the same function/function version.
   *
   * Note: * **AWS Lambda:** Use the (full) log stream name.
   */
  FAAS_INSTANCE: "faas.instance",
  /**
   * The amount of memory available to the serverless function in MiB.
   *
   * Note: It&#39;s recommended to set this attribute since e.g. too little memory can easily stop a Java AWS Lambda function from working correctly. On AWS Lambda, the environment variable `AWS_LAMBDA_FUNCTION_MEMORY_SIZE` provides this information.
   */
  FAAS_MAX_MEMORY: "faas.max_memory",
  /**
   * Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider.
   */
  HOST_ID: "host.id",
  /**
   * Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user.
   */
  HOST_NAME: "host.name",
  /**
   * Type of host. For Cloud, this must be the machine type.
   */
  HOST_TYPE: "host.type",
  /**
   * The CPU architecture the host system is running on.
   */
  HOST_ARCH: "host.arch",
  /**
   * Name of the VM image or OS install the host was instantiated from.
   */
  HOST_IMAGE_NAME: "host.image.name",
  /**
   * VM image ID. For Cloud, this value is from the provider.
   */
  HOST_IMAGE_ID: "host.image.id",
  /**
   * The version string of the VM image as defined in [Version SpanAttributes](README.md#version-attributes).
   */
  HOST_IMAGE_VERSION: "host.image.version",
  /**
   * The name of the cluster.
   */
  K8S_CLUSTER_NAME: "k8s.cluster.name",
  /**
   * The name of the Node.
   */
  K8S_NODE_NAME: "k8s.node.name",
  /**
   * The UID of the Node.
   */
  K8S_NODE_UID: "k8s.node.uid",
  /**
   * The name of the namespace that the pod is running in.
   */
  K8S_NAMESPACE_NAME: "k8s.namespace.name",
  /**
   * The UID of the Pod.
   */
  K8S_POD_UID: "k8s.pod.uid",
  /**
   * The name of the Pod.
   */
  K8S_POD_NAME: "k8s.pod.name",
  /**
   * The name of the Container in a Pod template.
   */
  K8S_CONTAINER_NAME: "k8s.container.name",
  /**
   * The UID of the ReplicaSet.
   */
  K8S_REPLICASET_UID: "k8s.replicaset.uid",
  /**
   * The name of the ReplicaSet.
   */
  K8S_REPLICASET_NAME: "k8s.replicaset.name",
  /**
   * The UID of the Deployment.
   */
  K8S_DEPLOYMENT_UID: "k8s.deployment.uid",
  /**
   * The name of the Deployment.
   */
  K8S_DEPLOYMENT_NAME: "k8s.deployment.name",
  /**
   * The UID of the StatefulSet.
   */
  K8S_STATEFULSET_UID: "k8s.statefulset.uid",
  /**
   * The name of the StatefulSet.
   */
  K8S_STATEFULSET_NAME: "k8s.statefulset.name",
  /**
   * The UID of the DaemonSet.
   */
  K8S_DAEMONSET_UID: "k8s.daemonset.uid",
  /**
   * The name of the DaemonSet.
   */
  K8S_DAEMONSET_NAME: "k8s.daemonset.name",
  /**
   * The UID of the Job.
   */
  K8S_JOB_UID: "k8s.job.uid",
  /**
   * The name of the Job.
   */
  K8S_JOB_NAME: "k8s.job.name",
  /**
   * The UID of the CronJob.
   */
  K8S_CRONJOB_UID: "k8s.cronjob.uid",
  /**
   * The name of the CronJob.
   */
  K8S_CRONJOB_NAME: "k8s.cronjob.name",
  /**
   * The operating system type.
   */
  OS_TYPE: "os.type",
  /**
   * Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands.
   */
  OS_DESCRIPTION: "os.description",
  /**
   * Human readable operating system name.
   */
  OS_NAME: "os.name",
  /**
   * The version string of the operating system as defined in [Version SpanAttributes](../../resource/semantic_conventions/README.md#version-attributes).
   */
  OS_VERSION: "os.version",
  /**
   * Process identifier (PID).
   */
  PROCESS_PID: "process.pid",
  /**
   * The name of the process executable. On Linux based systems, can be set to the `Name` in `proc/[pid]/status`. On Windows, can be set to the base name of `GetProcessImageFileNameW`.
   */
  PROCESS_EXECUTABLE_NAME: "process.executable.name",
  /**
   * The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`.
   */
  PROCESS_EXECUTABLE_PATH: "process.executable.path",
  /**
   * The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`.
   */
  PROCESS_COMMAND: "process.command",
  /**
   * The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead.
   */
  PROCESS_COMMAND_LINE: "process.command_line",
  /**
   * All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`.
   */
  PROCESS_COMMAND_ARGS: "process.command_args",
  /**
   * The username of the user that owns the process.
   */
  PROCESS_OWNER: "process.owner",
  /**
   * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
   */
  PROCESS_RUNTIME_NAME: "process.runtime.name",
  /**
   * The version of the runtime of this process, as returned by the runtime without modification.
   */
  PROCESS_RUNTIME_VERSION: "process.runtime.version",
  /**
   * An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment.
   */
  PROCESS_RUNTIME_DESCRIPTION: "process.runtime.description",
  /**
   * Logical name of the service.
   *
   * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
   */
  SERVICE_NAME: "service.name",
  /**
   * A namespace for `service.name`.
   *
   * Note: A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
   */
  SERVICE_NAMESPACE: "service.namespace",
  /**
   * The string ID of the service instance.
   *
   * Note: MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled service). It is preferable for the ID to be persistent and stay the same for the lifetime of the service instance, however it is acceptable that the ID is ephemeral and changes during important lifetime events for the service (e.g. service restarts). If the service has no inherent unique ID that can be used as the value of this attribute it is recommended to generate a random Version 1 or Version 4 RFC 4122 UUID (services aiming for reproducible UUIDs may also use Version 5, see RFC 4122 for more recommendations).
   */
  SERVICE_INSTANCE_ID: "service.instance.id",
  /**
   * The version string of the service API or implementation.
   */
  SERVICE_VERSION: "service.version",
  /**
   * The name of the telemetry SDK as defined above.
   */
  TELEMETRY_SDK_NAME: "telemetry.sdk.name",
  /**
   * The language of the telemetry SDK.
   */
  TELEMETRY_SDK_LANGUAGE: "telemetry.sdk.language",
  /**
   * The version string of the telemetry SDK.
   */
  TELEMETRY_SDK_VERSION: "telemetry.sdk.version",
  /**
   * The version string of the auto instrumentation agent, if used.
   */
  TELEMETRY_AUTO_VERSION: "telemetry.auto.version",
  /**
   * The name of the web engine.
   */
  WEBENGINE_NAME: "webengine.name",
  /**
   * The version of the web engine.
   */
  WEBENGINE_VERSION: "webengine.version",
  /**
   * Additional description of the web engine (e.g. detailed version and edition information).
   */
  WEBENGINE_DESCRIPTION: "webengine.description"
};
var TelemetrySdkLanguageValues = {
  /** cpp. */
  CPP: "cpp",
  /** dotnet. */
  DOTNET: "dotnet",
  /** erlang. */
  ERLANG: "erlang",
  /** go. */
  GO: "go",
  /** java. */
  JAVA: "java",
  /** nodejs. */
  NODEJS: "nodejs",
  /** php. */
  PHP: "php",
  /** python. */
  PYTHON: "python",
  /** ruby. */
  RUBY: "ruby",
  /** webjs. */
  WEBJS: "webjs"
};
var SUPPRESS_TRACING_KEY = createContextKey("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
function suppressTracing(context2) {
  return context2.setValue(SUPPRESS_TRACING_KEY, true);
}
function isTracingSuppressed(context2) {
  return context2.getValue(SUPPRESS_TRACING_KEY) === true;
}
var BAGGAGE_KEY_PAIR_SEPARATOR = "=";
var BAGGAGE_PROPERTIES_SEPARATOR = ";";
var BAGGAGE_ITEMS_SEPARATOR = ",";
var BAGGAGE_HEADER = "baggage";
var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
var BAGGAGE_MAX_TOTAL_LENGTH = 8192;
var __read$9 = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function serializeKeyPairs(keyPairs) {
  return keyPairs.reduce(function(hValue, current) {
    var value = "" + hValue + (hValue !== "" ? BAGGAGE_ITEMS_SEPARATOR : "") + current;
    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
  }, "");
}
function getKeyPairs(baggage) {
  return baggage.getAllEntries().map(function(_a2) {
    var _b2 = __read$9(_a2, 2), key = _b2[0], value = _b2[1];
    var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
    if (value.metadata !== void 0) {
      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
    }
    return entry;
  });
}
function parsePairKeyValue(entry) {
  var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);
  if (valueProps.length <= 0)
    return;
  var keyPairPart = valueProps.shift();
  if (!keyPairPart)
    return;
  var keyPair = keyPairPart.split(BAGGAGE_KEY_PAIR_SEPARATOR);
  if (keyPair.length !== 2)
    return;
  var key = decodeURIComponent(keyPair[0].trim());
  var value = decodeURIComponent(keyPair[1].trim());
  var metadata;
  if (valueProps.length > 0) {
    metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));
  }
  return { key, value, metadata };
}
function parseKeyPairsIntoRecord(value) {
  if (typeof value !== "string" || value.length === 0)
    return {};
  return value.split(BAGGAGE_ITEMS_SEPARATOR).map(function(entry) {
    return parsePairKeyValue(entry);
  }).filter(function(keyPair) {
    return keyPair !== void 0 && keyPair.value.length > 0;
  }).reduce(function(headers, keyPair) {
    headers[keyPair.key] = keyPair.value;
    return headers;
  }, {});
}
var W3CBaggagePropagator = (
  /** @class */
  function() {
    function W3CBaggagePropagator2() {
    }
    W3CBaggagePropagator2.prototype.inject = function(context2, carrier, setter) {
      var baggage = propagation.getBaggage(context2);
      if (!baggage || isTracingSuppressed(context2))
        return;
      var keyPairs = getKeyPairs(baggage).filter(function(pair) {
        return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
      }).slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);
      var headerValue = serializeKeyPairs(keyPairs);
      if (headerValue.length > 0) {
        setter.set(carrier, BAGGAGE_HEADER, headerValue);
      }
    };
    W3CBaggagePropagator2.prototype.extract = function(context2, carrier, getter) {
      var headerValue = getter.get(carrier, BAGGAGE_HEADER);
      var baggageString = Array.isArray(headerValue) ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR) : headerValue;
      if (!baggageString)
        return context2;
      var baggage = {};
      if (baggageString.length === 0) {
        return context2;
      }
      var pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);
      pairs.forEach(function(entry) {
        var keyPair = parsePairKeyValue(entry);
        if (keyPair) {
          var baggageEntry = { value: keyPair.value };
          if (keyPair.metadata) {
            baggageEntry.metadata = keyPair.metadata;
          }
          baggage[keyPair.key] = baggageEntry;
        }
      });
      if (Object.entries(baggage).length === 0) {
        return context2;
      }
      return propagation.setBaggage(context2, propagation.createBaggage(baggage));
    };
    W3CBaggagePropagator2.prototype.fields = function() {
      return [BAGGAGE_HEADER];
    };
    return W3CBaggagePropagator2;
  }()
);
var __values$4 = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read$8 = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function sanitizeAttributes(attributes) {
  var e_1, _a2;
  var out = {};
  if (typeof attributes !== "object" || attributes == null) {
    return out;
  }
  try {
    for (var _b2 = __values$4(Object.entries(attributes)), _c = _b2.next(); !_c.done; _c = _b2.next()) {
      var _d = __read$8(_c.value, 2), key = _d[0], val = _d[1];
      if (!isAttributeKey(key)) {
        diag.warn("Invalid attribute key: " + key);
        continue;
      }
      if (!isAttributeValue(val)) {
        diag.warn("Invalid attribute value set for key: " + key);
        continue;
      }
      if (Array.isArray(val)) {
        out[key] = val.slice();
      } else {
        out[key] = val;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b2.return))
        _a2.call(_b2);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return out;
}
function isAttributeKey(key) {
  return typeof key === "string" && key.length > 0;
}
function isAttributeValue(val) {
  if (val == null) {
    return true;
  }
  if (Array.isArray(val)) {
    return isHomogeneousAttributeValueArray(val);
  }
  return isValidPrimitiveAttributeValue(val);
}
function isHomogeneousAttributeValueArray(arr) {
  var e_2, _a2;
  var type2;
  try {
    for (var arr_1 = __values$4(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
      var element = arr_1_1.value;
      if (element == null)
        continue;
      if (!type2) {
        if (isValidPrimitiveAttributeValue(element)) {
          type2 = typeof element;
          continue;
        }
        return false;
      }
      if (typeof element === type2) {
        continue;
      }
      return false;
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (arr_1_1 && !arr_1_1.done && (_a2 = arr_1.return))
        _a2.call(arr_1);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
  return true;
}
function isValidPrimitiveAttributeValue(val) {
  switch (typeof val) {
    case "number":
    case "boolean":
    case "string":
      return true;
  }
  return false;
}
function loggingErrorHandler() {
  return function(ex) {
    diag.error(stringifyException(ex));
  };
}
function stringifyException(ex) {
  if (typeof ex === "string") {
    return ex;
  } else {
    return JSON.stringify(flattenException(ex));
  }
}
function flattenException(ex) {
  var result = {};
  var current = ex;
  while (current !== null) {
    Object.getOwnPropertyNames(current).forEach(function(propertyName) {
      if (result[propertyName])
        return;
      var value = current[propertyName];
      if (value) {
        result[propertyName] = String(value);
      }
    });
    current = Object.getPrototypeOf(current);
  }
  return result;
}
var delegateHandler = loggingErrorHandler();
function globalErrorHandler(ex) {
  try {
    delegateHandler(ex);
  } catch (_a2) {
  }
}
var TracesSamplerValues;
(function(TracesSamplerValues2) {
  TracesSamplerValues2["AlwaysOff"] = "always_off";
  TracesSamplerValues2["AlwaysOn"] = "always_on";
  TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
  TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
  TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
  TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
})(TracesSamplerValues || (TracesSamplerValues = {}));
var _globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
var define_process_env_default$1 = { CYPRESS_INTERNAL_ENV: "development", NODE_ENV: "production" };
var DEFAULT_LIST_SEPARATOR = ",";
var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
function isEnvVarABoolean(key) {
  return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
}
var ENVIRONMENT_NUMBERS_KEYS = [
  "OTEL_BSP_EXPORT_TIMEOUT",
  "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BSP_MAX_QUEUE_SIZE",
  "OTEL_BSP_SCHEDULE_DELAY",
  "OTEL_BLRP_EXPORT_TIMEOUT",
  "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
  "OTEL_BLRP_MAX_QUEUE_SIZE",
  "OTEL_BLRP_SCHEDULE_DELAY",
  "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
  "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
  "OTEL_SPAN_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_LINK_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
  "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
  "OTEL_EXPORTER_OTLP_TIMEOUT",
  "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
  "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
  "OTEL_EXPORTER_JAEGER_AGENT_PORT"
];
function isEnvVarANumber(key) {
  return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
}
var ENVIRONMENT_LISTS_KEYS = [
  "OTEL_NO_PATCH_MODULES",
  "OTEL_PROPAGATORS"
];
function isEnvVarAList(key) {
  return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
var DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
var DEFAULT_ENVIRONMENT = {
  OTEL_SDK_DISABLED: false,
  CONTAINER_NAME: "",
  ECS_CONTAINER_METADATA_URI_V4: "",
  ECS_CONTAINER_METADATA_URI: "",
  HOSTNAME: "",
  KUBERNETES_SERVICE_HOST: "",
  NAMESPACE: "",
  OTEL_BSP_EXPORT_TIMEOUT: 3e4,
  OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
  OTEL_BSP_MAX_QUEUE_SIZE: 2048,
  OTEL_BSP_SCHEDULE_DELAY: 5e3,
  OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
  OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
  OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
  OTEL_BLRP_SCHEDULE_DELAY: 5e3,
  OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
  OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
  OTEL_EXPORTER_JAEGER_ENDPOINT: "",
  OTEL_EXPORTER_JAEGER_PASSWORD: "",
  OTEL_EXPORTER_JAEGER_USER: "",
  OTEL_EXPORTER_OTLP_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
  OTEL_EXPORTER_OTLP_HEADERS: "",
  OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
  OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
  OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
  OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
  OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
  OTEL_LOG_LEVEL: DiagLogLevel.INFO,
  OTEL_NO_PATCH_MODULES: [],
  OTEL_PROPAGATORS: ["tracecontext", "baggage"],
  OTEL_RESOURCE_ATTRIBUTES: "",
  OTEL_SERVICE_NAME: "",
  OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
  OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
  OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
  OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
  OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
  OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
  OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
  OTEL_SPAN_LINK_COUNT_LIMIT: 128,
  OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
  OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
  OTEL_TRACES_EXPORTER: "",
  OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,
  OTEL_TRACES_SAMPLER_ARG: "",
  OTEL_LOGS_EXPORTER: "",
  OTEL_EXPORTER_OTLP_INSECURE: "",
  OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
  OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
  OTEL_EXPORTER_OTLP_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
  OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
  OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
  OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
  OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
};
function parseBoolean(key, environment2, values) {
  if (typeof values[key] === "undefined") {
    return;
  }
  var value = String(values[key]);
  environment2[key] = value.toLowerCase() === "true";
}
function parseNumber(name2, environment2, values, min2, max2) {
  if (min2 === void 0) {
    min2 = -Infinity;
  }
  if (max2 === void 0) {
    max2 = Infinity;
  }
  if (typeof values[name2] !== "undefined") {
    var value = Number(values[name2]);
    if (!isNaN(value)) {
      if (value < min2) {
        environment2[name2] = min2;
      } else if (value > max2) {
        environment2[name2] = max2;
      } else {
        environment2[name2] = value;
      }
    }
  }
}
function parseStringList(name2, output, input, separator) {
  if (separator === void 0) {
    separator = DEFAULT_LIST_SEPARATOR;
  }
  var givenValue = input[name2];
  if (typeof givenValue === "string") {
    output[name2] = givenValue.split(separator).map(function(v) {
      return v.trim();
    });
  }
}
var logLevelMap = {
  ALL: DiagLogLevel.ALL,
  VERBOSE: DiagLogLevel.VERBOSE,
  DEBUG: DiagLogLevel.DEBUG,
  INFO: DiagLogLevel.INFO,
  WARN: DiagLogLevel.WARN,
  ERROR: DiagLogLevel.ERROR,
  NONE: DiagLogLevel.NONE
};
function setLogLevelFromEnv(key, environment2, values) {
  var value = values[key];
  if (typeof value === "string") {
    var theLevel = logLevelMap[value.toUpperCase()];
    if (theLevel != null) {
      environment2[key] = theLevel;
    }
  }
}
function parseEnvironment(values) {
  var environment2 = {};
  for (var env2 in DEFAULT_ENVIRONMENT) {
    var key = env2;
    switch (key) {
      case "OTEL_LOG_LEVEL":
        setLogLevelFromEnv(key, environment2, values);
        break;
      default:
        if (isEnvVarABoolean(key)) {
          parseBoolean(key, environment2, values);
        } else if (isEnvVarANumber(key)) {
          parseNumber(key, environment2, values);
        } else if (isEnvVarAList(key)) {
          parseStringList(key, environment2, values);
        } else {
          var value = values[key];
          if (typeof value !== "undefined" && value !== null) {
            environment2[key] = String(value);
          }
        }
    }
  }
  return environment2;
}
function getEnvWithoutDefaults() {
  return typeof process !== "undefined" && process && define_process_env_default$1 ? parseEnvironment(define_process_env_default$1) : parseEnvironment(_globalThis);
}
function getEnv() {
  var globalEnv = parseEnvironment(_globalThis);
  return Object.assign({}, DEFAULT_ENVIRONMENT, globalEnv);
}
function hexToBase64(hexStr) {
  var hexStrLen = hexStr.length;
  var hexAsciiCharsStr = "";
  for (var i = 0; i < hexStrLen; i += 2) {
    var hexPair = hexStr.substring(i, i + 2);
    var hexVal = parseInt(hexPair, 16);
    hexAsciiCharsStr += String.fromCharCode(hexVal);
  }
  return btoa(hexAsciiCharsStr);
}
var otperformance = performance;
var VERSION$1 = "1.12.0";
var _a;
var SDK_INFO = (_a = {}, _a[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = "opentelemetry", _a[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = "browser", _a[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = TelemetrySdkLanguageValues.WEBJS, _a[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = VERSION$1, _a);
function unrefTimer(_timer) {
}
var NANOSECOND_DIGITS = 9;
var NANOSECOND_DIGITS_IN_MILLIS = 6;
var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
function millisToHrTime(epochMillis) {
  var epochSeconds = epochMillis / 1e3;
  var seconds = Math.trunc(epochSeconds);
  var nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
  return [seconds, nanos];
}
function getTimeOrigin() {
  var timeOrigin = otperformance.timeOrigin;
  if (typeof timeOrigin !== "number") {
    var perf = otperformance;
    timeOrigin = perf.timing && perf.timing.fetchStart;
  }
  return timeOrigin;
}
function hrTime(performanceNow) {
  var timeOrigin = millisToHrTime(getTimeOrigin());
  var now2 = millisToHrTime(typeof performanceNow === "number" ? performanceNow : otperformance.now());
  return addHrTimes(timeOrigin, now2);
}
function hrTimeDuration(startTime, endTime) {
  var seconds = endTime[0] - startTime[0];
  var nanos = endTime[1] - startTime[1];
  if (nanos < 0) {
    seconds -= 1;
    nanos += SECOND_TO_NANOSECONDS;
  }
  return [seconds, nanos];
}
function hrTimeToNanoseconds(time) {
  return time[0] * SECOND_TO_NANOSECONDS + time[1];
}
function isTimeInputHrTime(value) {
  return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
}
function isTimeInput(value) {
  return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
}
function addHrTimes(time1, time2) {
  var out = [time1[0] + time2[0], time1[1] + time2[1]];
  if (out[1] >= SECOND_TO_NANOSECONDS) {
    out[1] -= SECOND_TO_NANOSECONDS;
    out[0] += 1;
  }
  return out;
}
var ExportResultCode;
(function(ExportResultCode2) {
  ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
  ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
})(ExportResultCode || (ExportResultCode = {}));
var __values$3 = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var CompositePropagator = (
  /** @class */
  function() {
    function CompositePropagator2(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      var _a2;
      this._propagators = (_a2 = config2.propagators) !== null && _a2 !== void 0 ? _a2 : [];
      this._fields = Array.from(new Set(this._propagators.map(function(p2) {
        return typeof p2.fields === "function" ? p2.fields() : [];
      }).reduce(function(x2, y2) {
        return x2.concat(y2);
      }, [])));
    }
    CompositePropagator2.prototype.inject = function(context2, carrier, setter) {
      var e_1, _a2;
      try {
        for (var _b2 = __values$3(this._propagators), _c = _b2.next(); !_c.done; _c = _b2.next()) {
          var propagator = _c.value;
          try {
            propagator.inject(context2, carrier, setter);
          } catch (err) {
            diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b2.return))
            _a2.call(_b2);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    CompositePropagator2.prototype.extract = function(context2, carrier, getter) {
      return this._propagators.reduce(function(ctx, propagator) {
        try {
          return propagator.extract(ctx, carrier, getter);
        } catch (err) {
          diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
        }
        return ctx;
      }, context2);
    };
    CompositePropagator2.prototype.fields = function() {
      return this._fields.slice();
    };
    return CompositePropagator2;
  }()
);
var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
var MAX_TRACE_STATE_ITEMS = 32;
var MAX_TRACE_STATE_LEN = 512;
var LIST_MEMBERS_SEPARATOR = ",";
var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
var TraceState = (
  /** @class */
  function() {
    function TraceState2(rawTraceState) {
      this._internalState = /* @__PURE__ */ new Map();
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    TraceState2.prototype.set = function(key, value) {
      var traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    };
    TraceState2.prototype.unset = function(key) {
      var traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    };
    TraceState2.prototype.get = function(key) {
      return this._internalState.get(key);
    };
    TraceState2.prototype.serialize = function() {
      var _this = this;
      return this._keys().reduce(function(agg, key) {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    };
    TraceState2.prototype._parse = function(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
        var listMember = part.trim();
        var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          var key = listMember.slice(0, i);
          var value = listMember.slice(i + 1, part.length);
          if (validateKey(key) && validateValue(value)) {
            agg.set(key, value);
          }
        }
        return agg;
      }, /* @__PURE__ */ new Map());
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    };
    TraceState2.prototype._keys = function() {
      return Array.from(this._internalState.keys()).reverse();
    };
    TraceState2.prototype._clone = function() {
      var traceState = new TraceState2();
      traceState._internalState = new Map(this._internalState);
      return traceState;
    };
    return TraceState2;
  }()
);
var TRACE_PARENT_HEADER = "traceparent";
var TRACE_STATE_HEADER = "tracestate";
var VERSION = "00";
var VERSION_PART = "(?!ff)[\\da-f]{2}";
var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
var FLAGS_PART = "[\\da-f]{2}";
var TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
function parseTraceParent(traceParent) {
  var match2 = TRACE_PARENT_REGEX.exec(traceParent);
  if (!match2)
    return null;
  if (match2[1] === "00" && match2[5])
    return null;
  return {
    traceId: match2[2],
    spanId: match2[3],
    traceFlags: parseInt(match2[4], 16)
  };
}
var W3CTraceContextPropagator = (
  /** @class */
  function() {
    function W3CTraceContextPropagator2() {
    }
    W3CTraceContextPropagator2.prototype.inject = function(context2, carrier, setter) {
      var spanContext = trace.getSpanContext(context2);
      if (!spanContext || isTracingSuppressed(context2) || !isSpanContextValid(spanContext))
        return;
      var traceParent = VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
      setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
      if (spanContext.traceState) {
        setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
      }
    };
    W3CTraceContextPropagator2.prototype.extract = function(context2, carrier, getter) {
      var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
      if (!traceParentHeader)
        return context2;
      var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
      if (typeof traceParent !== "string")
        return context2;
      var spanContext = parseTraceParent(traceParent);
      if (!spanContext)
        return context2;
      spanContext.isRemote = true;
      var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
      if (traceStateHeader) {
        var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
        spanContext.traceState = new TraceState(typeof state === "string" ? state : void 0);
      }
      return trace.setSpanContext(context2, spanContext);
    };
    W3CTraceContextPropagator2.prototype.fields = function() {
      return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];
    };
    return W3CTraceContextPropagator2;
  }()
);
var objectTag = "[object Object]";
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
var objectCtorString = funcToString.call(Object);
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
var nativeObjectToString = objectProto.toString;
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  var unmasked = false;
  try {
    value[symToStringTag] = void 0;
    unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var MAX_LEVEL = 20;
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var result = args.shift();
  var objects = /* @__PURE__ */ new WeakMap();
  while (args.length > 0) {
    result = mergeTwoObjects(result, args.shift(), 0, objects);
  }
  return result;
}
function takeValue(value) {
  if (isArray(value)) {
    return value.slice();
  }
  return value;
}
function mergeTwoObjects(one, two, level, objects) {
  if (level === void 0) {
    level = 0;
  }
  var result;
  if (level > MAX_LEVEL) {
    return void 0;
  }
  level++;
  if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
    result = takeValue(two);
  } else if (isArray(one)) {
    result = one.slice();
    if (isArray(two)) {
      for (var i = 0, j = two.length; i < j; i++) {
        result.push(takeValue(two[i]));
      }
    } else if (isObject(two)) {
      var keys2 = Object.keys(two);
      for (var i = 0, j = keys2.length; i < j; i++) {
        var key = keys2[i];
        result[key] = takeValue(two[key]);
      }
    }
  } else if (isObject(one)) {
    if (isObject(two)) {
      if (!shouldMerge(one, two)) {
        return two;
      }
      result = Object.assign({}, one);
      var keys2 = Object.keys(two);
      for (var i = 0, j = keys2.length; i < j; i++) {
        var key = keys2[i];
        var twoValue = two[key];
        if (isPrimitive(twoValue)) {
          if (typeof twoValue === "undefined") {
            delete result[key];
          } else {
            result[key] = twoValue;
          }
        } else {
          var obj1 = result[key];
          var obj2 = twoValue;
          if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
            delete result[key];
          } else {
            if (isObject(obj1) && isObject(obj2)) {
              var arr1 = objects.get(obj1) || [];
              var arr2 = objects.get(obj2) || [];
              arr1.push({ obj: one, key });
              arr2.push({ obj: two, key });
              objects.set(obj1, arr1);
              objects.set(obj2, arr2);
            }
            result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
          }
        }
      }
    } else {
      result = two;
    }
  }
  return result;
}
function wasObjectReferenced(obj, key, objects) {
  var arr = objects.get(obj[key]) || [];
  for (var i = 0, j = arr.length; i < j; i++) {
    var info = arr[i];
    if (info.key === key && info.obj === obj) {
      return true;
    }
  }
  return false;
}
function isArray(value) {
  return Array.isArray(value);
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
}
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
}
function shouldMerge(one, two) {
  if (!isPlainObject(one) || !isPlainObject(two)) {
    return false;
  }
  return true;
}
var Deferred = (
  /** @class */
  function() {
    function Deferred2() {
      var _this = this;
      this._promise = new Promise(function(resolve3, reject) {
        _this._resolve = resolve3;
        _this._reject = reject;
      });
    }
    Object.defineProperty(Deferred2.prototype, "promise", {
      get: function() {
        return this._promise;
      },
      enumerable: false,
      configurable: true
    });
    Deferred2.prototype.resolve = function(val) {
      this._resolve(val);
    };
    Deferred2.prototype.reject = function(err) {
      this._reject(err);
    };
    return Deferred2;
  }()
);
var __read$7 = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray$1 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BindOnceFuture = (
  /** @class */
  function() {
    function BindOnceFuture2(_callback, _that) {
      this._callback = _callback;
      this._that = _that;
      this._isCalled = false;
      this._deferred = new Deferred();
    }
    Object.defineProperty(BindOnceFuture2.prototype, "isCalled", {
      get: function() {
        return this._isCalled;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BindOnceFuture2.prototype, "promise", {
      get: function() {
        return this._deferred.promise;
      },
      enumerable: false,
      configurable: true
    });
    BindOnceFuture2.prototype.call = function() {
      var _a2;
      var _this = this;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this._isCalled) {
        this._isCalled = true;
        try {
          Promise.resolve((_a2 = this._callback).call.apply(_a2, __spreadArray$1([this._that], __read$7(args), false))).then(function(val) {
            return _this._deferred.resolve(val);
          }, function(err) {
            return _this._deferred.reject(err);
          });
        } catch (err) {
          this._deferred.reject(err);
        }
      }
      return this._deferred.promise;
    };
    return BindOnceFuture2;
  }()
);
function _export(exporter, arg) {
  return new Promise(function(resolve3) {
    context.with(suppressTracing(context.active()), function() {
      exporter.export(arg, function(result) {
        resolve3(result);
      });
    });
  });
}
var internal = {
  _export
};
function defaultServiceName() {
  return "unknown_service";
}
var __assign$2 = function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve3) {
      resolve3(value);
    });
  }
  return new (P || (P = Promise))(function(resolve3, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$2 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read$6 = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var Resource = (
  /** @class */
  function() {
    function Resource2(attributes, asyncAttributesPromise) {
      var _this = this;
      var _a2;
      this._attributes = attributes;
      this.asyncAttributesPending = asyncAttributesPromise != null;
      this._syncAttributes = (_a2 = this._attributes) !== null && _a2 !== void 0 ? _a2 : {};
      this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then(function(asyncAttributes) {
        _this._attributes = Object.assign({}, _this._attributes, asyncAttributes);
        _this.asyncAttributesPending = false;
        return asyncAttributes;
      }, function(err) {
        diag.debug("a resource's async attributes promise rejected: %s", err);
        _this.asyncAttributesPending = false;
        return {};
      });
    }
    Resource2.empty = function() {
      return Resource2.EMPTY;
    };
    Resource2.default = function() {
      var _a2;
      return new Resource2((_a2 = {}, _a2[SemanticResourceAttributes.SERVICE_NAME] = defaultServiceName(), _a2[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE], _a2[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_NAME], _a2[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_VERSION], _a2));
    };
    Object.defineProperty(Resource2.prototype, "attributes", {
      get: function() {
        var _a2;
        if (this.asyncAttributesPending) {
          diag.error("Accessing resource attributes before async attributes settled");
        }
        return (_a2 = this._attributes) !== null && _a2 !== void 0 ? _a2 : {};
      },
      enumerable: false,
      configurable: true
    });
    Resource2.prototype.waitForAsyncAttributes = function() {
      return __awaiter$2(this, void 0, void 0, function() {
        return __generator$2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!this.asyncAttributesPending)
                return [3, 2];
              return [4, this._asyncAttributesPromise];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Resource2.prototype.merge = function(other) {
      var _this = this;
      var _a2;
      if (!other)
        return this;
      var mergedSyncAttributes = __assign$2(__assign$2({}, this._syncAttributes), (_a2 = other._syncAttributes) !== null && _a2 !== void 0 ? _a2 : other.attributes);
      if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) {
        return new Resource2(mergedSyncAttributes);
      }
      var mergedAttributesPromise = Promise.all([
        this._asyncAttributesPromise,
        other._asyncAttributesPromise
      ]).then(function(_a3) {
        var _b2;
        var _c = __read$6(_a3, 2), thisAsyncAttributes = _c[0], otherAsyncAttributes = _c[1];
        return __assign$2(__assign$2(__assign$2(__assign$2({}, _this._syncAttributes), thisAsyncAttributes), (_b2 = other._syncAttributes) !== null && _b2 !== void 0 ? _b2 : other.attributes), otherAsyncAttributes);
      });
      return new Resource2(mergedSyncAttributes, mergedAttributesPromise);
    };
    Resource2.EMPTY = new Resource2({});
    return Resource2;
  }()
);
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var BrowserDetectorSync = (
  /** @class */
  function() {
    function BrowserDetectorSync2() {
    }
    BrowserDetectorSync2.prototype.detect = function(config2) {
      var _a2;
      var isBrowser2 = typeof navigator !== "undefined";
      if (!isBrowser2) {
        return Resource.empty();
      }
      var browserResource = (_a2 = {}, _a2[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = "browser", _a2[SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = "Web Browser", _a2[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = navigator.userAgent, _a2);
      return this._getResourceAttributes(browserResource, config2);
    };
    BrowserDetectorSync2.prototype._getResourceAttributes = function(browserResource, _config) {
      if (browserResource[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === "") {
        diag.debug("BrowserDetector failed: Unable to find required browser resources. ");
        return Resource.empty();
      } else {
        return new Resource(__assign$1({}, browserResource));
      }
    };
    return BrowserDetectorSync2;
  }()
);
var browserDetectorSync = new BrowserDetectorSync();
var isPromiseLike = function(val) {
  return val !== null && typeof val === "object" && typeof val.then === "function";
};
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve3) {
      resolve3(value);
    });
  }
  return new (P || (P = Promise))(function(resolve3, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var detectResourcesSync = function(config2) {
  var _a2;
  if (config2 === void 0) {
    config2 = {};
  }
  var resources = ((_a2 = config2.detectors) !== null && _a2 !== void 0 ? _a2 : []).map(function(d2) {
    try {
      var resourceOrPromise_1 = d2.detect(config2);
      var resource_1;
      if (isPromiseLike(resourceOrPromise_1)) {
        var createPromise = function() {
          return __awaiter$1(void 0, void 0, void 0, function() {
            var resolvedResource;
            return __generator$1(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [4, resourceOrPromise_1];
                case 1:
                  resolvedResource = _a3.sent();
                  return [2, resolvedResource.attributes];
              }
            });
          });
        };
        resource_1 = new Resource({}, createPromise());
      } else {
        resource_1 = resourceOrPromise_1;
      }
      if (resource_1.waitForAsyncAttributes) {
        void resource_1.waitForAsyncAttributes().then(function() {
          return diag.debug(d2.constructor.name + " found resource.", resource_1);
        });
      } else {
        diag.debug(d2.constructor.name + " found resource.", resource_1);
      }
      return resource_1;
    } catch (e) {
      diag.error(d2.constructor.name + " failed: " + e.message);
      return Resource.empty();
    }
  });
  var mergedResources = resources.reduce(function(acc, resource) {
    return acc.merge(resource);
  }, Resource.empty());
  if (mergedResources.waitForAsyncAttributes) {
    void mergedResources.waitForAsyncAttributes().then(function() {
      logResources(resources);
    });
  }
  return mergedResources;
};
var logResources = function(resources) {
  resources.forEach(function(resource) {
    if (Object.keys(resource.attributes).length > 0) {
      var resourceDebugString = JSON.stringify(resource.attributes, null, 4);
      diag.verbose(resourceDebugString);
    }
  });
};
var ExceptionEventName = "exception";
var __values$2 = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read$5 = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var Span = (
  /** @class */
  function() {
    function Span2(parentTracer, context2, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock) {
      if (links === void 0) {
        links = [];
      }
      this.attributes = {};
      this.links = [];
      this.events = [];
      this._droppedAttributesCount = 0;
      this._droppedEventsCount = 0;
      this._droppedLinksCount = 0;
      this.status = {
        code: SpanStatusCode.UNSET
      };
      this.endTime = [0, 0];
      this._ended = false;
      this._duration = [-1, -1];
      this.name = spanName;
      this._spanContext = spanContext;
      this.parentSpanId = parentSpanId;
      this.kind = kind;
      this.links = links;
      var now2 = Date.now();
      this._performanceStartTime = otperformance.now();
      this._performanceOffset = now2 - (this._performanceStartTime + getTimeOrigin());
      this._startTimeProvided = startTime != null;
      this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now2);
      this.resource = parentTracer.resource;
      this.instrumentationLibrary = parentTracer.instrumentationLibrary;
      this._spanLimits = parentTracer.getSpanLimits();
      this._spanProcessor = parentTracer.getActiveSpanProcessor();
      this._spanProcessor.onStart(this, context2);
      this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
    }
    Span2.prototype.spanContext = function() {
      return this._spanContext;
    };
    Span2.prototype.setAttribute = function(key, value) {
      if (value == null || this._isSpanEnded())
        return this;
      if (key.length === 0) {
        diag.warn("Invalid attribute key: " + key);
        return this;
      }
      if (!isAttributeValue(value)) {
        diag.warn("Invalid attribute value set for key: " + key);
        return this;
      }
      if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
        this._droppedAttributesCount++;
        return this;
      }
      this.attributes[key] = this._truncateToSize(value);
      return this;
    };
    Span2.prototype.setAttributes = function(attributes) {
      var e_1, _a2;
      try {
        for (var _b2 = __values$2(Object.entries(attributes)), _c = _b2.next(); !_c.done; _c = _b2.next()) {
          var _d = __read$5(_c.value, 2), k = _d[0], v = _d[1];
          this.setAttribute(k, v);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b2.return))
            _a2.call(_b2);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return this;
    };
    Span2.prototype.addEvent = function(name2, attributesOrStartTime, timeStamp) {
      if (this._isSpanEnded())
        return this;
      if (this._spanLimits.eventCountLimit === 0) {
        diag.warn("No events allowed.");
        this._droppedEventsCount++;
        return this;
      }
      if (this.events.length >= this._spanLimits.eventCountLimit) {
        diag.warn("Dropping extra events.");
        this.events.shift();
        this._droppedEventsCount++;
      }
      if (isTimeInput(attributesOrStartTime)) {
        if (!isTimeInput(timeStamp)) {
          timeStamp = attributesOrStartTime;
        }
        attributesOrStartTime = void 0;
      }
      var attributes = sanitizeAttributes(attributesOrStartTime);
      this.events.push({
        name: name2,
        attributes,
        time: this._getTime(timeStamp),
        droppedAttributesCount: 0
      });
      return this;
    };
    Span2.prototype.setStatus = function(status) {
      if (this._isSpanEnded())
        return this;
      this.status = status;
      return this;
    };
    Span2.prototype.updateName = function(name2) {
      if (this._isSpanEnded())
        return this;
      this.name = name2;
      return this;
    };
    Span2.prototype.end = function(endTime) {
      if (this._isSpanEnded()) {
        diag.error(this.name + " " + this._spanContext.traceId + "-" + this._spanContext.spanId + " - You can only call end() on a span once.");
        return;
      }
      this._ended = true;
      this.endTime = this._getTime(endTime);
      this._duration = hrTimeDuration(this.startTime, this.endTime);
      if (this._duration[0] < 0) {
        diag.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.", this.startTime, this.endTime);
        this.endTime = this.startTime.slice();
        this._duration = [0, 0];
      }
      this._spanProcessor.onEnd(this);
    };
    Span2.prototype._getTime = function(inp) {
      if (typeof inp === "number" && inp < otperformance.now()) {
        return hrTime(inp + this._performanceOffset);
      }
      if (typeof inp === "number") {
        return millisToHrTime(inp);
      }
      if (inp instanceof Date) {
        return millisToHrTime(inp.getTime());
      }
      if (isTimeInputHrTime(inp)) {
        return inp;
      }
      if (this._startTimeProvided) {
        return millisToHrTime(Date.now());
      }
      var msDuration = otperformance.now() - this._performanceStartTime;
      return addHrTimes(this.startTime, millisToHrTime(msDuration));
    };
    Span2.prototype.isRecording = function() {
      return this._ended === false;
    };
    Span2.prototype.recordException = function(exception, time) {
      var attributes = {};
      if (typeof exception === "string") {
        attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;
      } else if (exception) {
        if (exception.code) {
          attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();
        } else if (exception.name) {
          attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;
        }
        if (exception.message) {
          attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;
        }
        if (exception.stack) {
          attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;
        }
      }
      if (attributes[SemanticAttributes.EXCEPTION_TYPE] || attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {
        this.addEvent(ExceptionEventName, attributes, time);
      } else {
        diag.warn("Failed to record an exception " + exception);
      }
    };
    Object.defineProperty(Span2.prototype, "duration", {
      get: function() {
        return this._duration;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Span2.prototype, "ended", {
      get: function() {
        return this._ended;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Span2.prototype, "droppedAttributesCount", {
      get: function() {
        return this._droppedAttributesCount;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Span2.prototype, "droppedEventsCount", {
      get: function() {
        return this._droppedEventsCount;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Span2.prototype, "droppedLinksCount", {
      get: function() {
        return this._droppedLinksCount;
      },
      enumerable: false,
      configurable: true
    });
    Span2.prototype._isSpanEnded = function() {
      if (this._ended) {
        diag.warn("Can not execute the operation on ended Span {traceId: " + this._spanContext.traceId + ", spanId: " + this._spanContext.spanId + "}");
      }
      return this._ended;
    };
    Span2.prototype._truncateToLimitUtil = function(value, limit) {
      if (value.length <= limit) {
        return value;
      }
      return value.substr(0, limit);
    };
    Span2.prototype._truncateToSize = function(value) {
      var _this = this;
      var limit = this._attributeValueLengthLimit;
      if (limit <= 0) {
        diag.warn("Attribute value limit must be positive, got " + limit);
        return value;
      }
      if (typeof value === "string") {
        return this._truncateToLimitUtil(value, limit);
      }
      if (Array.isArray(value)) {
        return value.map(function(val) {
          return typeof val === "string" ? _this._truncateToLimitUtil(val, limit) : val;
        });
      }
      return value;
    };
    return Span2;
  }()
);
var SamplingDecision;
(function(SamplingDecision2) {
  SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
  SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
  SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision || (SamplingDecision = {}));
var AlwaysOffSampler = (
  /** @class */
  function() {
    function AlwaysOffSampler2() {
    }
    AlwaysOffSampler2.prototype.shouldSample = function() {
      return {
        decision: SamplingDecision.NOT_RECORD
      };
    };
    AlwaysOffSampler2.prototype.toString = function() {
      return "AlwaysOffSampler";
    };
    return AlwaysOffSampler2;
  }()
);
var AlwaysOnSampler = (
  /** @class */
  function() {
    function AlwaysOnSampler2() {
    }
    AlwaysOnSampler2.prototype.shouldSample = function() {
      return {
        decision: SamplingDecision.RECORD_AND_SAMPLED
      };
    };
    AlwaysOnSampler2.prototype.toString = function() {
      return "AlwaysOnSampler";
    };
    return AlwaysOnSampler2;
  }()
);
var ParentBasedSampler = (
  /** @class */
  function() {
    function ParentBasedSampler2(config2) {
      var _a2, _b2, _c, _d;
      this._root = config2.root;
      if (!this._root) {
        globalErrorHandler(new Error("ParentBasedSampler must have a root sampler configured"));
        this._root = new AlwaysOnSampler();
      }
      this._remoteParentSampled = (_a2 = config2.remoteParentSampled) !== null && _a2 !== void 0 ? _a2 : new AlwaysOnSampler();
      this._remoteParentNotSampled = (_b2 = config2.remoteParentNotSampled) !== null && _b2 !== void 0 ? _b2 : new AlwaysOffSampler();
      this._localParentSampled = (_c = config2.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler();
      this._localParentNotSampled = (_d = config2.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler();
    }
    ParentBasedSampler2.prototype.shouldSample = function(context2, traceId, spanName, spanKind, attributes, links) {
      var parentContext = trace.getSpanContext(context2);
      if (!parentContext || !isSpanContextValid(parentContext)) {
        return this._root.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.isRemote) {
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
          return this._remoteParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
        }
        return this._remoteParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      }
      if (parentContext.traceFlags & TraceFlags.SAMPLED) {
        return this._localParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      }
      return this._localParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
    };
    ParentBasedSampler2.prototype.toString = function() {
      return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    };
    return ParentBasedSampler2;
  }()
);
var TraceIdRatioBasedSampler = (
  /** @class */
  function() {
    function TraceIdRatioBasedSampler2(_ratio) {
      if (_ratio === void 0) {
        _ratio = 0;
      }
      this._ratio = _ratio;
      this._ratio = this._normalize(_ratio);
      this._upperBound = Math.floor(this._ratio * 4294967295);
    }
    TraceIdRatioBasedSampler2.prototype.shouldSample = function(context2, traceId) {
      return {
        decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD
      };
    };
    TraceIdRatioBasedSampler2.prototype.toString = function() {
      return "TraceIdRatioBased{" + this._ratio + "}";
    };
    TraceIdRatioBasedSampler2.prototype._normalize = function(ratio) {
      if (typeof ratio !== "number" || isNaN(ratio))
        return 0;
      return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    };
    TraceIdRatioBasedSampler2.prototype._accumulate = function(traceId) {
      var accumulation = 0;
      for (var i = 0; i < traceId.length / 8; i++) {
        var pos = i * 8;
        var part = parseInt(traceId.slice(pos, pos + 8), 16);
        accumulation = (accumulation ^ part) >>> 0;
      }
      return accumulation;
    };
    return TraceIdRatioBasedSampler2;
  }()
);
var env = getEnv();
var FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;
var DEFAULT_RATIO = 1;
function loadDefaultConfig() {
  return {
    sampler: buildSamplerFromEnv(env),
    forceFlushTimeoutMillis: 3e4,
    generalLimits: {
      attributeValueLengthLimit: getEnv().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      attributeCountLimit: getEnv().OTEL_ATTRIBUTE_COUNT_LIMIT
    },
    spanLimits: {
      attributeValueLengthLimit: getEnv().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      attributeCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
      linkCountLimit: getEnv().OTEL_SPAN_LINK_COUNT_LIMIT,
      eventCountLimit: getEnv().OTEL_SPAN_EVENT_COUNT_LIMIT,
      attributePerEventCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      attributePerLinkCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
    }
  };
}
function buildSamplerFromEnv(environment2) {
  if (environment2 === void 0) {
    environment2 = getEnv();
  }
  switch (environment2.OTEL_TRACES_SAMPLER) {
    case TracesSamplerValues.AlwaysOn:
      return new AlwaysOnSampler();
    case TracesSamplerValues.AlwaysOff:
      return new AlwaysOffSampler();
    case TracesSamplerValues.ParentBasedAlwaysOn:
      return new ParentBasedSampler({
        root: new AlwaysOnSampler()
      });
    case TracesSamplerValues.ParentBasedAlwaysOff:
      return new ParentBasedSampler({
        root: new AlwaysOffSampler()
      });
    case TracesSamplerValues.TraceIdRatio:
      return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment2));
    case TracesSamplerValues.ParentBasedTraceIdRatio:
      return new ParentBasedSampler({
        root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment2))
      });
    default:
      diag.error('OTEL_TRACES_SAMPLER value "' + environment2.OTEL_TRACES_SAMPLER + " invalid, defaulting to " + FALLBACK_OTEL_TRACES_SAMPLER + '".');
      return new AlwaysOnSampler();
  }
}
function getSamplerProbabilityFromEnv(environment2) {
  if (environment2.OTEL_TRACES_SAMPLER_ARG === void 0 || environment2.OTEL_TRACES_SAMPLER_ARG === "") {
    diag.error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + DEFAULT_RATIO + ".");
    return DEFAULT_RATIO;
  }
  var probability = Number(environment2.OTEL_TRACES_SAMPLER_ARG);
  if (isNaN(probability)) {
    diag.error("OTEL_TRACES_SAMPLER_ARG=" + environment2.OTEL_TRACES_SAMPLER_ARG + " was given, but it is invalid, defaulting to " + DEFAULT_RATIO + ".");
    return DEFAULT_RATIO;
  }
  if (probability < 0 || probability > 1) {
    diag.error("OTEL_TRACES_SAMPLER_ARG=" + environment2.OTEL_TRACES_SAMPLER_ARG + " was given, but it is out of range ([0..1]), defaulting to " + DEFAULT_RATIO + ".");
    return DEFAULT_RATIO;
  }
  return probability;
}
function mergeConfig(userConfig) {
  var perInstanceDefaults = {
    sampler: buildSamplerFromEnv()
  };
  var DEFAULT_CONFIG = loadDefaultConfig();
  var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
  target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
  target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
  return target;
}
function reconfigureLimits(userConfig) {
  var _a2, _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  var spanLimits = Object.assign({}, userConfig.spanLimits);
  var parsedEnvConfig = getEnvWithoutDefaults();
  spanLimits.attributeCountLimit = (_f = (_e = (_d = (_b2 = (_a2 = userConfig.spanLimits) === null || _a2 === void 0 ? void 0 : _a2.attributeCountLimit) !== null && _b2 !== void 0 ? _b2 : (_c = userConfig.generalLimits) === null || _c === void 0 ? void 0 : _c.attributeCountLimit) !== null && _d !== void 0 ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== void 0 ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : DEFAULT_ATTRIBUTE_COUNT_LIMIT;
  spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
  return Object.assign({}, userConfig, { spanLimits });
}
var BatchSpanProcessorBase = (
  /** @class */
  function() {
    function BatchSpanProcessorBase2(_exporter, config2) {
      this._exporter = _exporter;
      this._finishedSpans = [];
      this._droppedSpansCount = 0;
      var env2 = getEnv();
      this._maxExportBatchSize = typeof (config2 === null || config2 === void 0 ? void 0 : config2.maxExportBatchSize) === "number" ? config2.maxExportBatchSize : env2.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
      this._maxQueueSize = typeof (config2 === null || config2 === void 0 ? void 0 : config2.maxQueueSize) === "number" ? config2.maxQueueSize : env2.OTEL_BSP_MAX_QUEUE_SIZE;
      this._scheduledDelayMillis = typeof (config2 === null || config2 === void 0 ? void 0 : config2.scheduledDelayMillis) === "number" ? config2.scheduledDelayMillis : env2.OTEL_BSP_SCHEDULE_DELAY;
      this._exportTimeoutMillis = typeof (config2 === null || config2 === void 0 ? void 0 : config2.exportTimeoutMillis) === "number" ? config2.exportTimeoutMillis : env2.OTEL_BSP_EXPORT_TIMEOUT;
      this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
      if (this._maxExportBatchSize > this._maxQueueSize) {
        diag.warn("BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize");
        this._maxExportBatchSize = this._maxQueueSize;
      }
    }
    BatchSpanProcessorBase2.prototype.forceFlush = function() {
      if (this._shutdownOnce.isCalled) {
        return this._shutdownOnce.promise;
      }
      return this._flushAll();
    };
    BatchSpanProcessorBase2.prototype.onStart = function(_span, _parentContext) {
    };
    BatchSpanProcessorBase2.prototype.onEnd = function(span) {
      if (this._shutdownOnce.isCalled) {
        return;
      }
      if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {
        return;
      }
      this._addToBuffer(span);
    };
    BatchSpanProcessorBase2.prototype.shutdown = function() {
      return this._shutdownOnce.call();
    };
    BatchSpanProcessorBase2.prototype._shutdown = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.onShutdown();
      }).then(function() {
        return _this._flushAll();
      }).then(function() {
        return _this._exporter.shutdown();
      });
    };
    BatchSpanProcessorBase2.prototype._addToBuffer = function(span) {
      if (this._finishedSpans.length >= this._maxQueueSize) {
        if (this._droppedSpansCount === 0) {
          diag.debug("maxQueueSize reached, dropping spans");
        }
        this._droppedSpansCount++;
        return;
      }
      if (this._droppedSpansCount > 0) {
        diag.warn("Dropped " + this._droppedSpansCount + " spans because maxQueueSize reached");
        this._droppedSpansCount = 0;
      }
      this._finishedSpans.push(span);
      this._maybeStartTimer();
    };
    BatchSpanProcessorBase2.prototype._flushAll = function() {
      var _this = this;
      return new Promise(function(resolve3, reject) {
        var promises = [];
        var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);
        for (var i = 0, j = count; i < j; i++) {
          promises.push(_this._flushOneBatch());
        }
        Promise.all(promises).then(function() {
          resolve3();
        }).catch(reject);
      });
    };
    BatchSpanProcessorBase2.prototype._flushOneBatch = function() {
      var _this = this;
      this._clearTimer();
      if (this._finishedSpans.length === 0) {
        return Promise.resolve();
      }
      return new Promise(function(resolve3, reject) {
        var timer = setTimeout(function() {
          reject(new Error("Timeout"));
        }, _this._exportTimeoutMillis);
        context.with(suppressTracing(context.active()), function() {
          var spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize);
          var doExport = function() {
            return _this._exporter.export(spans, function(result) {
              var _a2;
              clearTimeout(timer);
              if (result.code === ExportResultCode.SUCCESS) {
                resolve3();
              } else {
                reject((_a2 = result.error) !== null && _a2 !== void 0 ? _a2 : new Error("BatchSpanProcessor: span export failed"));
              }
            });
          };
          var pendingResources = spans.map(function(span) {
            return span.resource;
          }).filter(function(resource) {
            return resource.asyncAttributesPending;
          });
          if (pendingResources.length === 0) {
            doExport();
          } else {
            Promise.all(pendingResources.map(function(resource) {
              var _a2;
              return (_a2 = resource.waitForAsyncAttributes) === null || _a2 === void 0 ? void 0 : _a2.call(resource);
            })).then(doExport, function(err) {
              globalErrorHandler(err);
              reject(err);
            });
          }
        });
      });
    };
    BatchSpanProcessorBase2.prototype._maybeStartTimer = function() {
      var _this = this;
      if (this._timer !== void 0)
        return;
      this._timer = setTimeout(function() {
        _this._flushOneBatch().then(function() {
          if (_this._finishedSpans.length > 0) {
            _this._clearTimer();
            _this._maybeStartTimer();
          }
        }).catch(function(e) {
          globalErrorHandler(e);
        });
      }, this._scheduledDelayMillis);
      unrefTimer(this._timer);
    };
    BatchSpanProcessorBase2.prototype._clearTimer = function() {
      if (this._timer !== void 0) {
        clearTimeout(this._timer);
        this._timer = void 0;
      }
    };
    return BatchSpanProcessorBase2;
  }()
);
var __extends$4 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var BatchSpanProcessor = (
  /** @class */
  function(_super) {
    __extends$4(BatchSpanProcessor2, _super);
    function BatchSpanProcessor2(_exporter, config2) {
      var _this = _super.call(this, _exporter, config2) || this;
      _this.onInit(config2);
      return _this;
    }
    BatchSpanProcessor2.prototype.onInit = function(config2) {
      var _this = this;
      if ((config2 === null || config2 === void 0 ? void 0 : config2.disableAutoFlushOnDocumentHide) !== true && typeof document !== "undefined") {
        this._visibilityChangeListener = function() {
          if (document.visibilityState === "hidden") {
            void _this.forceFlush();
          }
        };
        this._pageHideListener = function() {
          void _this.forceFlush();
        };
        document.addEventListener("visibilitychange", this._visibilityChangeListener);
        document.addEventListener("pagehide", this._pageHideListener);
      }
    };
    BatchSpanProcessor2.prototype.onShutdown = function() {
      if (typeof document !== "undefined") {
        if (this._visibilityChangeListener) {
          document.removeEventListener("visibilitychange", this._visibilityChangeListener);
        }
        if (this._pageHideListener) {
          document.removeEventListener("pagehide", this._pageHideListener);
        }
      }
    };
    return BatchSpanProcessor2;
  }(BatchSpanProcessorBase)
);
var SPAN_ID_BYTES = 8;
var TRACE_ID_BYTES = 16;
var RandomIdGenerator = (
  /** @class */
  /* @__PURE__ */ function() {
    function RandomIdGenerator2() {
      this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
      this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
    }
    return RandomIdGenerator2;
  }()
);
var SHARED_CHAR_CODES_ARRAY = Array(32);
function getIdGenerator(bytes) {
  return function generateId2() {
    for (var i = 0; i < bytes * 2; i++) {
      SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
      if (SHARED_CHAR_CODES_ARRAY[i] >= 58) {
        SHARED_CHAR_CODES_ARRAY[i] += 39;
      }
    }
    return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
  };
}
var Tracer = (
  /** @class */
  function() {
    function Tracer2(instrumentationLibrary, config2, _tracerProvider) {
      this._tracerProvider = _tracerProvider;
      var localConfig = mergeConfig(config2);
      this._sampler = localConfig.sampler;
      this._generalLimits = localConfig.generalLimits;
      this._spanLimits = localConfig.spanLimits;
      this._idGenerator = config2.idGenerator || new RandomIdGenerator();
      this.resource = _tracerProvider.resource;
      this.instrumentationLibrary = instrumentationLibrary;
    }
    Tracer2.prototype.startSpan = function(name2, options2, context$1) {
      var _a2, _b2, _c;
      if (options2 === void 0) {
        options2 = {};
      }
      if (context$1 === void 0) {
        context$1 = context.active();
      }
      if (options2.root) {
        context$1 = trace.deleteSpan(context$1);
      }
      var parentSpan = trace.getSpan(context$1);
      if (isTracingSuppressed(context$1)) {
        diag.debug("Instrumentation suppressed, returning Noop Span");
        var nonRecordingSpan = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);
        return nonRecordingSpan;
      }
      var parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
      var spanId = this._idGenerator.generateSpanId();
      var traceId;
      var traceState;
      var parentSpanId;
      if (!parentSpanContext || !trace.isSpanContextValid(parentSpanContext)) {
        traceId = this._idGenerator.generateTraceId();
      } else {
        traceId = parentSpanContext.traceId;
        traceState = parentSpanContext.traceState;
        parentSpanId = parentSpanContext.spanId;
      }
      var spanKind = (_a2 = options2.kind) !== null && _a2 !== void 0 ? _a2 : SpanKind.INTERNAL;
      var links = ((_b2 = options2.links) !== null && _b2 !== void 0 ? _b2 : []).map(function(link2) {
        return {
          context: link2.context,
          attributes: sanitizeAttributes(link2.attributes)
        };
      });
      var attributes = sanitizeAttributes(options2.attributes);
      var samplingResult = this._sampler.shouldSample(context$1, traceId, name2, spanKind, attributes, links);
      traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;
      var traceFlags = samplingResult.decision === SamplingDecision$1.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE;
      var spanContext = { traceId, spanId, traceFlags, traceState };
      if (samplingResult.decision === SamplingDecision$1.NOT_RECORD) {
        diag.debug("Recording is off, propagating context in a non-recording span");
        var nonRecordingSpan = trace.wrapSpanContext(spanContext);
        return nonRecordingSpan;
      }
      var span = new Span(this, context$1, name2, spanContext, spanKind, parentSpanId, links, options2.startTime);
      var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));
      span.setAttributes(initAttributes);
      return span;
    };
    Tracer2.prototype.startActiveSpan = function(name2, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn2;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn2 = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn2 = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn2 = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : context.active();
      var span = this.startSpan(name2, opts, parentContext);
      var contextWithSpanSet = trace.setSpan(parentContext, span);
      return context.with(contextWithSpanSet, fn2, void 0, span);
    };
    Tracer2.prototype.getGeneralLimits = function() {
      return this._generalLimits;
    };
    Tracer2.prototype.getSpanLimits = function() {
      return this._spanLimits;
    };
    Tracer2.prototype.getActiveSpanProcessor = function() {
      return this._tracerProvider.getActiveSpanProcessor();
    };
    return Tracer2;
  }()
);
var __values$1 = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var MultiSpanProcessor = (
  /** @class */
  function() {
    function MultiSpanProcessor2(_spanProcessors) {
      this._spanProcessors = _spanProcessors;
    }
    MultiSpanProcessor2.prototype.forceFlush = function() {
      var e_1, _a2;
      var promises = [];
      try {
        for (var _b2 = __values$1(this._spanProcessors), _c = _b2.next(); !_c.done; _c = _b2.next()) {
          var spanProcessor = _c.value;
          promises.push(spanProcessor.forceFlush());
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b2.return))
            _a2.call(_b2);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return new Promise(function(resolve3) {
        Promise.all(promises).then(function() {
          resolve3();
        }).catch(function(error) {
          globalErrorHandler(error || new Error("MultiSpanProcessor: forceFlush failed"));
          resolve3();
        });
      });
    };
    MultiSpanProcessor2.prototype.onStart = function(span, context2) {
      var e_2, _a2;
      try {
        for (var _b2 = __values$1(this._spanProcessors), _c = _b2.next(); !_c.done; _c = _b2.next()) {
          var spanProcessor = _c.value;
          spanProcessor.onStart(span, context2);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b2.return))
            _a2.call(_b2);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    };
    MultiSpanProcessor2.prototype.onEnd = function(span) {
      var e_3, _a2;
      try {
        for (var _b2 = __values$1(this._spanProcessors), _c = _b2.next(); !_c.done; _c = _b2.next()) {
          var spanProcessor = _c.value;
          spanProcessor.onEnd(span);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b2.return))
            _a2.call(_b2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
    };
    MultiSpanProcessor2.prototype.shutdown = function() {
      var e_4, _a2;
      var promises = [];
      try {
        for (var _b2 = __values$1(this._spanProcessors), _c = _b2.next(); !_c.done; _c = _b2.next()) {
          var spanProcessor = _c.value;
          promises.push(spanProcessor.shutdown());
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b2.return))
            _a2.call(_b2);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      return new Promise(function(resolve3, reject) {
        Promise.all(promises).then(function() {
          resolve3();
        }, reject);
      });
    };
    return MultiSpanProcessor2;
  }()
);
var NoopSpanProcessor = (
  /** @class */
  function() {
    function NoopSpanProcessor2() {
    }
    NoopSpanProcessor2.prototype.onStart = function(_span, _context) {
    };
    NoopSpanProcessor2.prototype.onEnd = function(_span) {
    };
    NoopSpanProcessor2.prototype.shutdown = function() {
      return Promise.resolve();
    };
    NoopSpanProcessor2.prototype.forceFlush = function() {
      return Promise.resolve();
    };
    return NoopSpanProcessor2;
  }()
);
var ForceFlushState;
(function(ForceFlushState2) {
  ForceFlushState2[ForceFlushState2["resolved"] = 0] = "resolved";
  ForceFlushState2[ForceFlushState2["timeout"] = 1] = "timeout";
  ForceFlushState2[ForceFlushState2["error"] = 2] = "error";
  ForceFlushState2[ForceFlushState2["unresolved"] = 3] = "unresolved";
})(ForceFlushState || (ForceFlushState = {}));
var BasicTracerProvider = (
  /** @class */
  function() {
    function BasicTracerProvider2(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      var _a2;
      this._registeredSpanProcessors = [];
      this._tracers = /* @__PURE__ */ new Map();
      var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config2));
      this.resource = (_a2 = mergedConfig.resource) !== null && _a2 !== void 0 ? _a2 : Resource.empty();
      this.resource = Resource.default().merge(this.resource);
      this._config = Object.assign({}, mergedConfig, {
        resource: this.resource
      });
      var defaultExporter = this._buildExporterFromEnv();
      if (defaultExporter !== void 0) {
        var batchProcessor = new BatchSpanProcessor(defaultExporter);
        this.activeSpanProcessor = batchProcessor;
      } else {
        this.activeSpanProcessor = new NoopSpanProcessor();
      }
    }
    BasicTracerProvider2.prototype.getTracer = function(name2, version2, options2) {
      var key = name2 + "@" + (version2 || "") + ":" + ((options2 === null || options2 === void 0 ? void 0 : options2.schemaUrl) || "");
      if (!this._tracers.has(key)) {
        this._tracers.set(key, new Tracer({ name: name2, version: version2, schemaUrl: options2 === null || options2 === void 0 ? void 0 : options2.schemaUrl }, this._config, this));
      }
      return this._tracers.get(key);
    };
    BasicTracerProvider2.prototype.addSpanProcessor = function(spanProcessor) {
      if (this._registeredSpanProcessors.length === 0) {
        this.activeSpanProcessor.shutdown().catch(function(err) {
          return diag.error("Error while trying to shutdown current span processor", err);
        });
      }
      this._registeredSpanProcessors.push(spanProcessor);
      this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
    };
    BasicTracerProvider2.prototype.getActiveSpanProcessor = function() {
      return this.activeSpanProcessor;
    };
    BasicTracerProvider2.prototype.register = function(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      trace.setGlobalTracerProvider(this);
      if (config2.propagator === void 0) {
        config2.propagator = this._buildPropagatorFromEnv();
      }
      if (config2.contextManager) {
        context.setGlobalContextManager(config2.contextManager);
      }
      if (config2.propagator) {
        propagation.setGlobalPropagator(config2.propagator);
      }
    };
    BasicTracerProvider2.prototype.forceFlush = function() {
      var timeout = this._config.forceFlushTimeoutMillis;
      var promises = this._registeredSpanProcessors.map(function(spanProcessor) {
        return new Promise(function(resolve3) {
          var state;
          var timeoutInterval = setTimeout(function() {
            resolve3(new Error("Span processor did not completed within timeout period of " + timeout + " ms"));
            state = ForceFlushState.timeout;
          }, timeout);
          spanProcessor.forceFlush().then(function() {
            clearTimeout(timeoutInterval);
            if (state !== ForceFlushState.timeout) {
              state = ForceFlushState.resolved;
              resolve3(state);
            }
          }).catch(function(error) {
            clearTimeout(timeoutInterval);
            state = ForceFlushState.error;
            resolve3(error);
          });
        });
      });
      return new Promise(function(resolve3, reject) {
        Promise.all(promises).then(function(results) {
          var errors = results.filter(function(result) {
            return result !== ForceFlushState.resolved;
          });
          if (errors.length > 0) {
            reject(errors);
          } else {
            resolve3();
          }
        }).catch(function(error) {
          return reject([error]);
        });
      });
    };
    BasicTracerProvider2.prototype.shutdown = function() {
      return this.activeSpanProcessor.shutdown();
    };
    BasicTracerProvider2.prototype._getPropagator = function(name2) {
      var _a2;
      return (_a2 = this.constructor._registeredPropagators.get(name2)) === null || _a2 === void 0 ? void 0 : _a2();
    };
    BasicTracerProvider2.prototype._getSpanExporter = function(name2) {
      var _a2;
      return (_a2 = this.constructor._registeredExporters.get(name2)) === null || _a2 === void 0 ? void 0 : _a2();
    };
    BasicTracerProvider2.prototype._buildPropagatorFromEnv = function() {
      var _this = this;
      var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));
      var propagators = uniquePropagatorNames.map(function(name2) {
        var propagator = _this._getPropagator(name2);
        if (!propagator) {
          diag.warn('Propagator "' + name2 + '" requested through environment variable is unavailable.');
        }
        return propagator;
      });
      var validPropagators = propagators.reduce(function(list, item) {
        if (item) {
          list.push(item);
        }
        return list;
      }, []);
      if (validPropagators.length === 0) {
        return;
      } else if (uniquePropagatorNames.length === 1) {
        return validPropagators[0];
      } else {
        return new CompositePropagator({
          propagators: validPropagators
        });
      }
    };
    BasicTracerProvider2.prototype._buildExporterFromEnv = function() {
      var exporterName = getEnv().OTEL_TRACES_EXPORTER;
      if (exporterName === "none" || exporterName === "")
        return;
      var exporter = this._getSpanExporter(exporterName);
      if (!exporter) {
        diag.error('Exporter "' + exporterName + '" requested through environment variable is unavailable.');
      }
      return exporter;
    };
    BasicTracerProvider2._registeredPropagators = /* @__PURE__ */ new Map([
      ["tracecontext", function() {
        return new W3CTraceContextPropagator();
      }],
      ["baggage", function() {
        return new W3CBaggagePropagator();
      }]
    ]);
    BasicTracerProvider2._registeredExporters = /* @__PURE__ */ new Map();
    return BasicTracerProvider2;
  }()
);
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve3) {
      resolve3(value);
    });
  }
  return new (P || (P = Promise))(function(resolve3, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var SimpleSpanProcessor = (
  /** @class */
  function() {
    function SimpleSpanProcessor2(_exporter) {
      this._exporter = _exporter;
      this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
      this._unresolvedExports = /* @__PURE__ */ new Set();
    }
    SimpleSpanProcessor2.prototype.forceFlush = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, Promise.all(Array.from(this._unresolvedExports))];
            case 1:
              _a2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    SimpleSpanProcessor2.prototype.onStart = function(_span, _parentContext) {
    };
    SimpleSpanProcessor2.prototype.onEnd = function(span) {
      var _this = this;
      var _a2, _b2;
      if (this._shutdownOnce.isCalled) {
        return;
      }
      if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {
        return;
      }
      var doExport = function() {
        return internal._export(_this._exporter, [span]).then(function(result) {
          var _a3;
          if (result.code !== ExportResultCode.SUCCESS) {
            globalErrorHandler((_a3 = result.error) !== null && _a3 !== void 0 ? _a3 : new Error("SimpleSpanProcessor: span export failed (status " + result + ")"));
          }
        }).catch(function(error) {
          globalErrorHandler(error);
        });
      };
      if (span.resource.asyncAttributesPending) {
        var exportPromise_1 = (_b2 = (_a2 = span.resource).waitForAsyncAttributes) === null || _b2 === void 0 ? void 0 : _b2.call(_a2).then(function() {
          if (exportPromise_1 != null) {
            _this._unresolvedExports.delete(exportPromise_1);
          }
          return doExport();
        }, function(err) {
          return globalErrorHandler(err);
        });
        if (exportPromise_1 != null) {
          this._unresolvedExports.add(exportPromise_1);
        }
      } else {
        void doExport();
      }
    };
    SimpleSpanProcessor2.prototype.shutdown = function() {
      return this._shutdownOnce.call();
    };
    SimpleSpanProcessor2.prototype._shutdown = function() {
      return this._exporter.shutdown();
    };
    return SimpleSpanProcessor2;
  }()
);
class OnStartSpanProcessor extends SimpleSpanProcessor {
  onStart(span, _parentContext) {
    return this.onEnd(span);
  }
}
class ConsoleTraceLinkExporter {
  constructor({
    serviceName,
    team,
    environment: environment2
  }) {
    this._traceUrl = "";
    this._uniqueTraces = {};
    this._log = console.log;
    this._traceUrl = buildTraceUrl(serviceName, team, environment2);
  }
  export(spans, resultCallback) {
    if (this._traceUrl) {
      spans.forEach((span) => {
        const { traceId, spanId } = span.spanContext();
        if (!span.ended) {
          if (!Object.keys(this._uniqueTraces).includes(traceId)) {
            this._uniqueTraces[traceId] = spanId;
            this._log(
              `Trace start: [${span.name}] - ${this._traceUrl}=${span.spanContext().traceId}`
            );
          }
        } else if (this._uniqueTraces[traceId] === spanId) {
          this._log(
            `Trace end: [${span.name}] - ${this._traceUrl}=${span.spanContext().traceId}`
          );
        }
      });
    }
    resultCallback({ code: ExportResultCode.SUCCESS });
  }
  shutdown() {
    return Promise.resolve();
  }
}
function buildTraceUrl(serviceName, team, environment2) {
  return `https://ui.honeycomb.io/${team}/environments/${environment2}/datasets/${serviceName}/trace?trace_id`;
}
var define_process_env_default = { CYPRESS_INTERNAL_ENV: "development", NODE_ENV: "production" };
const environment = define_process_env_default.CYPRESS_CONFIG_ENV || define_process_env_default.CYPRESS_INTERNAL_ENV || "development";
const SERVICE_NAME = "cypress-app";
class Telemetry {
  constructor({
    namespace,
    Provider,
    detectors,
    rootContextObject,
    version: version2,
    SpanProcessor,
    exporter,
    resources = {},
    isVerbose = false
  }) {
    this.isVerbose = isVerbose;
    const resource = Resource.default().merge(
      new Resource({
        ...resources,
        [SemanticResourceAttributes.SERVICE_NAME]: SERVICE_NAME,
        [SemanticResourceAttributes.SERVICE_NAMESPACE]: namespace,
        [SemanticResourceAttributes.SERVICE_VERSION]: version2
      })
    );
    this.provider = new Provider({
      resource: resource.merge(detectResourcesSync({ detectors }))
    });
    if (SpanProcessor.name === "BatchSpanProcessor") {
      this.provider.addSpanProcessor(new SpanProcessor(exporter, {
        // Double the max queue size, We were seeing telemetry bursts that would result in loosing the top span.
        maxQueueSize: 4056
      }));
    } else {
      this.provider.addSpanProcessor(new SpanProcessor(exporter));
    }
    const honeyCombConsoleLinkExporter = new ConsoleTraceLinkExporter({
      serviceName: SERVICE_NAME,
      team: "cypress",
      environment: environment === "production" ? "cypress-app" : "cypress-app-staging"
    });
    this.provider.addSpanProcessor(new OnStartSpanProcessor(honeyCombConsoleLinkExporter));
    this.provider.register();
    this.tracer = openTelemetry.trace.getTracer("cypress", version2);
    this.setRootContext(rootContextObject);
    this.spans = {};
    this.activeSpanQueue = [];
    this.exporter = exporter;
  }
  /**
   * Starts a span with the given name. Stores off the span with the name as a key for later retrieval.
   * @param name - the span name
   * @param key - they key associated with the span, to be used to retrieve the span, if not specified, the name is used.
   * @param attachType - Should this span be attached as a new root span or a child of the previous root span.
   * @param name - Set true if this span should have child spans of it's own.
   * @param opts - pass through for otel span opts
   * @returns Span | undefined
   */
  startSpan({
    name: name2,
    attachType = "child",
    active = false,
    parentSpan,
    opts = {},
    key,
    isVerbose = false
  }) {
    if (isVerbose && !this.isVerbose) {
      return void 0;
    }
    let span;
    let parent;
    if (attachType === "root" || this.activeSpanQueue.length < 1 && !parentSpan) {
      if (this.rootContext) {
        span = this.tracer.startSpan(name2, opts, this.rootContext);
        if (this.rootAttributes) {
          span.setAttributes(this.rootAttributes);
        }
      } else {
        span = this.tracer.startSpan(name2, opts);
      }
    } else {
      parent = parentSpan || this.activeSpanQueue[this.activeSpanQueue.length - 1];
      const ctx = openTelemetry.trace.setSpan(openTelemetry.context.active(), parent);
      span = this.tracer.startSpan(name2, opts, ctx);
    }
    if (environment === "development" && key && key in this.spans) {
      throw new Error(`Span key ${key} rejected. Span key already exists in spans map.`);
    }
    const spanKey = key || name2;
    this.spans[spanKey] = span;
    span.getAllAttributes = () => {
      const parentAttributes = parent && parent.getAllAttributes ? parent.getAllAttributes() : {};
      const allAttributes = {
        // @ts-expect-error
        ...span.attributes,
        ...parentAttributes
      };
      delete allAttributes["name"];
      return allAttributes;
    };
    const _end = span.end;
    span.end = (endTime) => {
      if (active) {
        const index = this.activeSpanQueue.findIndex((element) => {
          return element.spanContext().spanId === span.spanContext().spanId;
        });
        if (index > -1) {
          this.activeSpanQueue.splice(index, 1);
        }
      }
      if (parent && parent.getAllAttributes) {
        span.setAttributes(parent.getAllAttributes());
      }
      _end.call(span, endTime);
    };
    if (active) {
      this.activeSpanQueue.push(span);
    }
    return span;
  }
  /**
   * Return requested span
   * @param name - span name to retrieve
   * @returns Span | undefined
   */
  getSpan(name2) {
    return this.spans[name2];
  }
  /**
   * Search the span queue for the active span that meets the criteria
   * @param fn - function to search the active spans
   * @returns Span | undefined
   */
  findActiveSpan(fn2) {
    return this.activeSpanQueue.find(fn2);
  }
  /**
   * Ends specified active span and any active child spans
   * @param span - span to end
   */
  endActiveSpanAndChildren(span) {
    if (!span) {
      return;
    }
    const startIndex = this.activeSpanQueue.findIndex((element) => {
      return element.spanContext().spanId === span.spanContext().spanId;
    });
    this.activeSpanQueue.slice(startIndex).forEach((spanToEnd) => {
      span.setAttribute("spanEndedPrematurely", true);
      spanToEnd == null ? void 0 : spanToEnd.end();
    });
  }
  /**
   * Returns the context object for the active span.
   * @returns the context
   */
  getActiveContextObject() {
    const rootSpan = this.activeSpanQueue[this.activeSpanQueue.length - 1];
    if (!rootSpan) {
      return {};
    }
    const ctx = openTelemetry.trace.setSpan(openTelemetry.context.active(), rootSpan);
    let myCtx = {};
    openTelemetry.propagation.inject(ctx, myCtx);
    return { context: myCtx, attributes: rootSpan.getAllAttributes() };
  }
  /**
   * Gets a list of the resources currently set on the provider.
   * @returns Attributes of resources
   */
  getResources() {
    return this.provider.resource.attributes;
  }
  /**
   * Shuts down telemetry and flushes any batched spans.
   * @returns promise
   */
  shutdown() {
    return this.provider.shutdown();
  }
  /**
   * Returns the assigned exporter
   * @returns SpanExporter
   */
  getExporter() {
    return this.exporter;
  }
  /**
   * Sets or resets the root context for spans
   * @param rootContextObject
   */
  setRootContext(rootContextObject) {
    if (rootContextObject && rootContextObject.context && rootContextObject.context.traceparent) {
      this.rootContext = openTelemetry.propagation.extract(openTelemetry.context.active(), rootContextObject.context);
      this.rootAttributes = rootContextObject.attributes;
    }
  }
}
class TelemetryNoop {
  startSpan() {
    return void 0;
  }
  getSpan() {
    return void 0;
  }
  findActiveSpan() {
    return void 0;
  }
  endActiveSpanAndChildren() {
    return void 0;
  }
  getActiveContextObject() {
    return {};
  }
  getResources() {
    return {};
  }
  shutdown() {
    return Promise.resolve();
  }
  getExporter() {
    return void 0;
  }
  setRootContext() {
  }
}
var __read$4 = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var StackContextManager = (
  /** @class */
  function() {
    function StackContextManager2() {
      this._enabled = false;
      this._currentContext = ROOT_CONTEXT;
    }
    StackContextManager2.prototype._bindFunction = function(context2, target) {
      if (context2 === void 0) {
        context2 = ROOT_CONTEXT;
      }
      var manager2 = this;
      var contextWrapper = function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return manager2.with(context2, function() {
          return target.apply(_this, args);
        });
      };
      Object.defineProperty(contextWrapper, "length", {
        enumerable: false,
        configurable: true,
        writable: false,
        value: target.length
      });
      return contextWrapper;
    };
    StackContextManager2.prototype.active = function() {
      return this._currentContext;
    };
    StackContextManager2.prototype.bind = function(context2, target) {
      if (context2 === void 0) {
        context2 = this.active();
      }
      if (typeof target === "function") {
        return this._bindFunction(context2, target);
      }
      return target;
    };
    StackContextManager2.prototype.disable = function() {
      this._currentContext = ROOT_CONTEXT;
      this._enabled = false;
      return this;
    };
    StackContextManager2.prototype.enable = function() {
      if (this._enabled) {
        return this;
      }
      this._enabled = true;
      this._currentContext = ROOT_CONTEXT;
      return this;
    };
    StackContextManager2.prototype.with = function(context2, fn2, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      var previousContext = this._currentContext;
      this._currentContext = context2 || ROOT_CONTEXT;
      try {
        return fn2.call.apply(fn2, __spreadArray([thisArg], __read$4(args), false));
      } finally {
        this._currentContext = previousContext;
      }
    };
    return StackContextManager2;
  }()
);
var __extends$3 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var WebTracerProvider = (
  /** @class */
  function(_super) {
    __extends$3(WebTracerProvider2, _super);
    function WebTracerProvider2(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      var _this = _super.call(this, config2) || this;
      if (config2.contextManager) {
        throw "contextManager should be defined in register method not in constructor";
      }
      if (config2.propagator) {
        throw "propagator should be defined in register method not in constructor";
      }
      return _this;
    }
    WebTracerProvider2.prototype.register = function(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      if (config2.contextManager === void 0) {
        config2.contextManager = new StackContextManager();
      }
      if (config2.contextManager) {
        config2.contextManager.enable();
      }
      _super.prototype.register.call(this, config2);
    };
    return WebTracerProvider2;
  }(BasicTracerProvider)
);
var __read$3 = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var DEFAULT_TRACE_TIMEOUT = 1e4;
var DEFAULT_EXPORT_MAX_ATTEMPTS = 5;
var DEFAULT_EXPORT_INITIAL_BACKOFF = 1e3;
var DEFAULT_EXPORT_MAX_BACKOFF = 5e3;
var DEFAULT_EXPORT_BACKOFF_MULTIPLIER = 1.5;
function parseHeaders(partialHeaders) {
  if (partialHeaders === void 0) {
    partialHeaders = {};
  }
  var headers = {};
  Object.entries(partialHeaders).forEach(function(_a2) {
    var _b2 = __read$3(_a2, 2), key = _b2[0], value = _b2[1];
    if (typeof value !== "undefined") {
      headers[key] = String(value);
    } else {
      diag.warn('Header "' + key + '" has wrong value and will be ignored');
    }
  });
  return headers;
}
function appendResourcePathToUrl(url2, path) {
  if (!url2.endsWith("/")) {
    url2 = url2 + "/";
  }
  return url2 + path;
}
function appendRootPathToUrlIfNeeded(url2) {
  try {
    var parsedUrl = new URL(url2);
    if (parsedUrl.pathname === "") {
      parsedUrl.pathname = parsedUrl.pathname + "/";
    }
    return parsedUrl.toString();
  } catch (_a2) {
    diag.warn("Could not parse export URL: '" + url2 + "'");
    return url2;
  }
}
function configureExporterTimeout(timeoutMillis) {
  if (typeof timeoutMillis === "number") {
    if (timeoutMillis <= 0) {
      return invalidTimeout(timeoutMillis, DEFAULT_TRACE_TIMEOUT);
    }
    return timeoutMillis;
  } else {
    return getExporterTimeoutFromEnv();
  }
}
function getExporterTimeoutFromEnv() {
  var _a2;
  var definedTimeout = Number((_a2 = getEnv().OTEL_EXPORTER_OTLP_TRACES_TIMEOUT) !== null && _a2 !== void 0 ? _a2 : getEnv().OTEL_EXPORTER_OTLP_TIMEOUT);
  if (definedTimeout <= 0) {
    return invalidTimeout(definedTimeout, DEFAULT_TRACE_TIMEOUT);
  } else {
    return definedTimeout;
  }
}
function invalidTimeout(timeout, defaultTimeout) {
  diag.warn("Timeout must be greater than 0", timeout);
  return defaultTimeout;
}
function isExportRetryable(statusCode) {
  var retryCodes = [429, 502, 503, 504];
  return retryCodes.includes(statusCode);
}
function parseRetryAfterToMills(retryAfter) {
  if (retryAfter == null) {
    return -1;
  }
  var seconds = Number.parseInt(retryAfter, 10);
  if (Number.isInteger(seconds)) {
    return seconds > 0 ? seconds * 1e3 : -1;
  }
  var delay = new Date(retryAfter).getTime() - Date.now();
  if (delay >= 0) {
    return delay;
  }
  return 0;
}
var OTLPExporterBase = (
  /** @class */
  function() {
    function OTLPExporterBase2(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      this._sendingPromises = [];
      this.url = this.getDefaultUrl(config2);
      if (typeof config2.hostname === "string") {
        this.hostname = config2.hostname;
      }
      this.shutdown = this.shutdown.bind(this);
      this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
      this._concurrencyLimit = typeof config2.concurrencyLimit === "number" ? config2.concurrencyLimit : Infinity;
      this.timeoutMillis = configureExporterTimeout(config2.timeoutMillis);
      this.onInit(config2);
    }
    OTLPExporterBase2.prototype.export = function(items, resultCallback) {
      if (this._shutdownOnce.isCalled) {
        resultCallback({
          code: ExportResultCode.FAILED,
          error: new Error("Exporter has been shutdown")
        });
        return;
      }
      if (this._sendingPromises.length >= this._concurrencyLimit) {
        resultCallback({
          code: ExportResultCode.FAILED,
          error: new Error("Concurrent export limit reached")
        });
        return;
      }
      this._export(items).then(function() {
        resultCallback({ code: ExportResultCode.SUCCESS });
      }).catch(function(error) {
        resultCallback({ code: ExportResultCode.FAILED, error });
      });
    };
    OTLPExporterBase2.prototype._export = function(items) {
      var _this = this;
      return new Promise(function(resolve3, reject) {
        try {
          diag.debug("items to be sent", items);
          _this.send(items, resolve3, reject);
        } catch (e) {
          reject(e);
        }
      });
    };
    OTLPExporterBase2.prototype.shutdown = function() {
      return this._shutdownOnce.call();
    };
    OTLPExporterBase2.prototype._shutdown = function() {
      diag.debug("shutdown started");
      this.onShutdown();
      return Promise.all(this._sendingPromises).then(function() {
      });
    };
    return OTLPExporterBase2;
  }()
);
var __extends$2 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var OTLPExporterError = (
  /** @class */
  function(_super) {
    __extends$2(OTLPExporterError2, _super);
    function OTLPExporterError2(message, code2, data) {
      var _this = _super.call(this, message) || this;
      _this.name = "OTLPExporterError";
      _this.data = data;
      _this.code = code2;
      return _this;
    }
    return OTLPExporterError2;
  }(Error)
);
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __read$2 = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function sendWithBeacon(body, url2, blobPropertyBag, onSuccess, onError) {
  if (navigator.sendBeacon(url2, new Blob([body], blobPropertyBag))) {
    diag.debug("sendBeacon - can send", body);
    onSuccess();
  } else {
    var error = new OTLPExporterError("sendBeacon - cannot send " + body);
    onError(error);
  }
}
function sendWithXhr(body, url2, headers, exporterTimeout, onSuccess, onError) {
  var retryTimer;
  var xhr;
  var reqIsDestroyed = false;
  var exporterTimer = setTimeout(function() {
    clearTimeout(retryTimer);
    reqIsDestroyed = true;
    if (xhr.readyState === XMLHttpRequest.DONE) {
      var err = new OTLPExporterError("Request Timeout");
      onError(err);
    } else {
      xhr.abort();
    }
  }, exporterTimeout);
  var sendWithRetry = function(retries, minDelay) {
    if (retries === void 0) {
      retries = DEFAULT_EXPORT_MAX_ATTEMPTS;
    }
    if (minDelay === void 0) {
      minDelay = DEFAULT_EXPORT_INITIAL_BACKOFF;
    }
    xhr = new XMLHttpRequest();
    xhr.open("POST", url2);
    var defaultHeaders = {
      Accept: "application/json",
      "Content-Type": "application/json"
    };
    Object.entries(__assign(__assign({}, defaultHeaders), headers)).forEach(function(_a2) {
      var _b2 = __read$2(_a2, 2), k = _b2[0], v = _b2[1];
      xhr.setRequestHeader(k, v);
    });
    xhr.send(body);
    xhr.onreadystatechange = function() {
      if (xhr.readyState === XMLHttpRequest.DONE && reqIsDestroyed === false) {
        if (xhr.status >= 200 && xhr.status <= 299) {
          diag.debug("xhr success", body);
          onSuccess();
          clearTimeout(exporterTimer);
          clearTimeout(retryTimer);
        } else if (xhr.status && isExportRetryable(xhr.status) && retries > 0) {
          var retryTime = void 0;
          minDelay = DEFAULT_EXPORT_BACKOFF_MULTIPLIER * minDelay;
          if (xhr.getResponseHeader("Retry-After")) {
            retryTime = parseRetryAfterToMills(xhr.getResponseHeader("Retry-After"));
          } else {
            retryTime = Math.round(Math.random() * (DEFAULT_EXPORT_MAX_BACKOFF - minDelay) + minDelay);
          }
          retryTimer = setTimeout(function() {
            sendWithRetry(retries - 1, minDelay);
          }, retryTime);
        } else {
          var error = new OTLPExporterError("Failed to export with XHR (status: " + xhr.status + ")", xhr.status);
          onError(error);
          clearTimeout(exporterTimer);
          clearTimeout(retryTimer);
        }
      }
    };
    xhr.onabort = function() {
      if (reqIsDestroyed) {
        var err = new OTLPExporterError("Request Timeout");
        onError(err);
      }
      clearTimeout(exporterTimer);
      clearTimeout(retryTimer);
    };
    xhr.onerror = function() {
      if (reqIsDestroyed) {
        var err = new OTLPExporterError("Request Timeout");
        onError(err);
      }
      clearTimeout(exporterTimer);
      clearTimeout(retryTimer);
    };
  };
  sendWithRetry();
}
var __extends$1 = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var OTLPExporterBrowserBase = (
  /** @class */
  function(_super) {
    __extends$1(OTLPExporterBrowserBase2, _super);
    function OTLPExporterBrowserBase2(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      var _this = _super.call(this, config2) || this;
      _this._useXHR = false;
      _this._useXHR = !!config2.headers || typeof navigator.sendBeacon !== "function";
      if (_this._useXHR) {
        _this._headers = Object.assign({}, parseHeaders(config2.headers), parseKeyPairsIntoRecord(getEnv().OTEL_EXPORTER_OTLP_HEADERS));
      } else {
        _this._headers = {};
      }
      return _this;
    }
    OTLPExporterBrowserBase2.prototype.onInit = function() {
      window.addEventListener("unload", this.shutdown);
    };
    OTLPExporterBrowserBase2.prototype.onShutdown = function() {
      window.removeEventListener("unload", this.shutdown);
    };
    OTLPExporterBrowserBase2.prototype.send = function(items, onSuccess, onError) {
      var _this = this;
      if (this._shutdownOnce.isCalled) {
        diag.debug("Shutdown already started. Cannot send objects");
        return;
      }
      var serviceRequest = this.convert(items);
      var body = JSON.stringify(serviceRequest);
      var promise = new Promise(function(resolve3, reject) {
        if (_this._useXHR) {
          sendWithXhr(body, _this.url, _this._headers, _this.timeoutMillis, resolve3, reject);
        } else {
          sendWithBeacon(body, _this.url, { type: "application/json" }, resolve3, reject);
        }
      }).then(onSuccess, onError);
      this._sendingPromises.push(promise);
      var popPromise = function() {
        var index = _this._sendingPromises.indexOf(promise);
        _this._sendingPromises.splice(index, 1);
      };
      promise.then(popPromise, popPromise);
    };
    return OTLPExporterBrowserBase2;
  }(OTLPExporterBase)
);
var __read$1 = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function toAttributes(attributes) {
  return Object.keys(attributes).map(function(key) {
    return toKeyValue(key, attributes[key]);
  });
}
function toKeyValue(key, value) {
  return {
    key,
    value: toAnyValue(value)
  };
}
function toAnyValue(value) {
  var t2 = typeof value;
  if (t2 === "string")
    return { stringValue: value };
  if (t2 === "number") {
    if (!Number.isInteger(value))
      return { doubleValue: value };
    return { intValue: value };
  }
  if (t2 === "boolean")
    return { boolValue: value };
  if (value instanceof Uint8Array)
    return { bytesValue: value };
  if (Array.isArray(value))
    return { arrayValue: { values: value.map(toAnyValue) } };
  if (t2 === "object" && value != null)
    return {
      kvlistValue: {
        values: Object.entries(value).map(function(_a2) {
          var _b2 = __read$1(_a2, 2), k = _b2[0], v = _b2[1];
          return toKeyValue(k, v);
        })
      }
    };
  return {};
}
function sdkSpanToOtlpSpan(span, useHex) {
  var _a2;
  var ctx = span.spanContext();
  var status = span.status;
  var parentSpanId = useHex ? span.parentSpanId : span.parentSpanId != null ? hexToBase64(span.parentSpanId) : void 0;
  return {
    traceId: useHex ? ctx.traceId : hexToBase64(ctx.traceId),
    spanId: useHex ? ctx.spanId : hexToBase64(ctx.spanId),
    parentSpanId,
    traceState: (_a2 = ctx.traceState) === null || _a2 === void 0 ? void 0 : _a2.serialize(),
    name: span.name,
    // Span kind is offset by 1 because the API does not define a value for unset
    kind: span.kind == null ? 0 : span.kind + 1,
    startTimeUnixNano: hrTimeToNanoseconds(span.startTime),
    endTimeUnixNano: hrTimeToNanoseconds(span.endTime),
    attributes: toAttributes(span.attributes),
    droppedAttributesCount: span.droppedAttributesCount,
    events: span.events.map(toOtlpSpanEvent),
    droppedEventsCount: span.droppedEventsCount,
    status: {
      // API and proto enums share the same values
      code: status.code,
      message: status.message
    },
    links: span.links.map(function(link2) {
      return toOtlpLink(link2, useHex);
    }),
    droppedLinksCount: span.droppedLinksCount
  };
}
function toOtlpLink(link2, useHex) {
  var _a2;
  return {
    attributes: link2.attributes ? toAttributes(link2.attributes) : [],
    spanId: useHex ? link2.context.spanId : hexToBase64(link2.context.spanId),
    traceId: useHex ? link2.context.traceId : hexToBase64(link2.context.traceId),
    traceState: (_a2 = link2.context.traceState) === null || _a2 === void 0 ? void 0 : _a2.serialize(),
    droppedAttributesCount: link2.droppedAttributesCount || 0
  };
}
function toOtlpSpanEvent(timedEvent) {
  return {
    attributes: timedEvent.attributes ? toAttributes(timedEvent.attributes) : [],
    name: timedEvent.name,
    timeUnixNano: hrTimeToNanoseconds(timedEvent.time),
    droppedAttributesCount: timedEvent.droppedAttributesCount || 0
  };
}
var __values = function(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = function(o2, n) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function createExportTraceServiceRequest(spans, useHex) {
  return {
    resourceSpans: spanRecordsToResourceSpans(spans, useHex)
  };
}
function createResourceMap(readableSpans) {
  var e_1, _a2;
  var resourceMap = /* @__PURE__ */ new Map();
  try {
    for (var readableSpans_1 = __values(readableSpans), readableSpans_1_1 = readableSpans_1.next(); !readableSpans_1_1.done; readableSpans_1_1 = readableSpans_1.next()) {
      var record = readableSpans_1_1.value;
      var ilmMap = resourceMap.get(record.resource);
      if (!ilmMap) {
        ilmMap = /* @__PURE__ */ new Map();
        resourceMap.set(record.resource, ilmMap);
      }
      var instrumentationLibraryKey = record.instrumentationLibrary.name + "@" + (record.instrumentationLibrary.version || "") + ":" + (record.instrumentationLibrary.schemaUrl || "");
      var records = ilmMap.get(instrumentationLibraryKey);
      if (!records) {
        records = [];
        ilmMap.set(instrumentationLibraryKey, records);
      }
      records.push(record);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (readableSpans_1_1 && !readableSpans_1_1.done && (_a2 = readableSpans_1.return))
        _a2.call(readableSpans_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return resourceMap;
}
function spanRecordsToResourceSpans(readableSpans, useHex) {
  var resourceMap = createResourceMap(readableSpans);
  var out = [];
  var entryIterator = resourceMap.entries();
  var entry = entryIterator.next();
  while (!entry.done) {
    var _a2 = __read(entry.value, 2), resource = _a2[0], ilmMap = _a2[1];
    var scopeResourceSpans = [];
    var ilmIterator = ilmMap.values();
    var ilmEntry = ilmIterator.next();
    while (!ilmEntry.done) {
      var scopeSpans = ilmEntry.value;
      if (scopeSpans.length > 0) {
        var _b2 = scopeSpans[0].instrumentationLibrary, name_1 = _b2.name, version2 = _b2.version, schemaUrl = _b2.schemaUrl;
        var spans = scopeSpans.map(function(readableSpan) {
          return sdkSpanToOtlpSpan(readableSpan, useHex);
        });
        scopeResourceSpans.push({
          scope: { name: name_1, version: version2 },
          spans,
          schemaUrl
        });
      }
      ilmEntry = ilmIterator.next();
    }
    var transformedSpans = {
      resource: {
        attributes: toAttributes(resource.attributes),
        droppedAttributesCount: 0
      },
      scopeSpans: scopeResourceSpans,
      schemaUrl: void 0
    };
    out.push(transformedSpans);
    entry = entryIterator.next();
  }
  return out;
}
var __extends = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var DEFAULT_COLLECTOR_RESOURCE_PATH = "v1/traces";
var DEFAULT_COLLECTOR_URL = "http://localhost:4318/" + DEFAULT_COLLECTOR_RESOURCE_PATH;
var OTLPTraceExporter$1 = (
  /** @class */
  function(_super) {
    __extends(OTLPTraceExporter2, _super);
    function OTLPTraceExporter2(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      var _this = _super.call(this, config2) || this;
      _this._headers = Object.assign(_this._headers, parseKeyPairsIntoRecord(getEnv().OTEL_EXPORTER_OTLP_TRACES_HEADERS));
      return _this;
    }
    OTLPTraceExporter2.prototype.convert = function(spans) {
      return createExportTraceServiceRequest(spans, true);
    };
    OTLPTraceExporter2.prototype.getDefaultUrl = function(config2) {
      return typeof config2.url === "string" ? config2.url : getEnv().OTEL_EXPORTER_OTLP_TRACES_ENDPOINT.length > 0 ? appendRootPathToUrlIfNeeded(getEnv().OTEL_EXPORTER_OTLP_TRACES_ENDPOINT) : getEnv().OTEL_EXPORTER_OTLP_ENDPOINT.length > 0 ? appendResourcePathToUrl(getEnv().OTEL_EXPORTER_OTLP_ENDPOINT, DEFAULT_COLLECTOR_RESOURCE_PATH) : DEFAULT_COLLECTOR_URL;
    };
    return OTLPTraceExporter2;
  }(OTLPExporterBrowserBase)
);
class OTLPTraceExporter extends OTLPTraceExporter$1 {
  constructor() {
    super({});
    this.delayedExport = [];
  }
  /**
   * attaches the websocket and replays any exports called without it
   * @param ws - the web socket.
   */
  attachWebSocket(ws2) {
    this.ws = ws2;
    this.delayedExport.forEach(({ items, resultCallback }) => {
      this.export(items, resultCallback);
    });
  }
  /**
   * Overrides export to delay sending spans if encryption is needed and there is no attached projectId
   * @param items
   * @param resultCallback
   */
  export(items, resultCallback) {
    if (!this.ws) {
      this.delayedExport.push({ items, resultCallback });
    } else {
      super.export(items, resultCallback);
    }
  }
  /**
   * Overrides the send method to use a websocket instead of http
   * @param objects
   * @param onSuccess
   * @param onError
   * @returns
   */
  send(objects, onSuccess, onError) {
    if (this._shutdownOnce.isCalled) {
      diag.debug("Shutdown already started. Cannot send objects");
      return;
    }
    const serviceRequest = JSON.stringify(this.convert(objects));
    const promise = Promise.resolve().then(() => {
      return new Promise((resolve3, reject) => {
        this.ws.emit("backend:request", "telemetry", serviceRequest, (res) => {
          if (res && res.error) {
            reject(res.error);
          }
          resolve3();
        });
      });
    }).then(onSuccess, onError);
    this._sendingPromises.push(promise);
    const popPromise = () => {
      const index = this._sendingPromises.indexOf(promise);
      this._sendingPromises.splice(index, 1);
    };
    promise.then(popPromise, popPromise);
  }
}
let telemetryInstance = new TelemetryNoop();
const init = ({ namespace, config: config2 }) => {
  if (!window.__CYPRESS_TELEMETRY__) {
    return;
  }
  if (telemetryInstance instanceof Telemetry) {
    throw "Telemetry instance has already be initialized";
  }
  const { context: context2, resources, isVerbose } = window.__CYPRESS_TELEMETRY__;
  const exporter = new OTLPTraceExporter();
  telemetryInstance = new Telemetry({
    namespace,
    Provider: WebTracerProvider,
    detectors: [
      browserDetectorSync
    ],
    rootContextObject: context2,
    version: config2 == null ? void 0 : config2.version,
    exporter,
    // Because otel is lame we need to use the simple span processor instead of the batch processor
    // or we risk losing spans when the browser navigates.
    // TODO: create a browser batch span processor to account for navigation.
    // See https://github.com/open-telemetry/opentelemetry-js/issues/2613
    SpanProcessor: SimpleSpanProcessor,
    resources,
    isVerbose
  });
  window.cypressTelemetrySingleton = telemetryInstance;
  return;
};
const attach = () => {
  if (window.cypressTelemetrySingleton) {
    telemetryInstance = window.cypressTelemetrySingleton;
    return;
  }
};
const telemetry = {
  init,
  attach,
  startSpan: (arg) => telemetryInstance.startSpan(arg),
  getSpan: (arg) => telemetryInstance.getSpan(arg),
  findActiveSpan: (arg) => telemetryInstance.findActiveSpan(arg),
  endActiveSpanAndChildren: (arg) => telemetryInstance.endActiveSpanAndChildren(arg),
  getActiveContextObject: () => telemetryInstance.getActiveContextObject(),
  shutdown: () => telemetryInstance.shutdown(),
  attachWebSocket: (ws2) => {
    var _a2;
    return (_a2 = telemetryInstance.getExporter()) == null ? void 0 : _a2.attachWebSocket(ws2);
  },
  setRootContext: (context2) => telemetryInstance.setRootContext(context2)
};
const addTelemetryListeners = (Cypress2) => {
  Cypress2.on("test:before:run", (attributes, test) => {
    try {
      const previousTestSpan = telemetry.findActiveSpan((span2) => {
        return span2.name.startsWith("test:");
      });
      if (previousTestSpan) {
        telemetry.endActiveSpanAndChildren(previousTestSpan);
      }
      const span = telemetry.startSpan({ name: `test:${test.fullTitle()}`, active: true });
      span == null ? void 0 : span.setAttributes({
        currentRetry: attributes.currentRetry
      });
    } catch (error) {
    }
  });
  Cypress2.on("test:after:run", (attributes, test) => {
    try {
      const span = telemetry.getSpan(`test:${test.fullTitle()}`);
      span == null ? void 0 : span.setAttributes({
        timings: JSON.stringify(attributes.timings)
      });
      span == null ? void 0 : span.end();
    } catch (error) {
    }
  });
  const commandSpanInfo = (command) => {
    const runnable = Cypress2.state("runnable");
    const runnableType = runnable.type === "hook" ? runnable.hookName : runnable.type;
    return {
      name: `${runnableType}: ${command.attributes.name}(${command.attributes.args.join(",")})`,
      runnable,
      runnableType
    };
  };
  Cypress2.on("command:start", (command) => {
    try {
      const test = Cypress2.state("test");
      const { name: name2, runnable, runnableType } = commandSpanInfo(command);
      const span = telemetry.startSpan({
        name: name2,
        opts: {
          attributes: {
            spec: runnable.invocationDetails.relativeFile,
            test: `test:${test.fullTitle()}`,
            "runnable-type": runnableType
          }
        },
        isVerbose: true
      });
      span == null ? void 0 : span.setAttribute("command-name", command.attributes.name);
    } catch (error) {
    }
  });
  const onCommandEnd = (command) => {
    var _a2;
    try {
      const span = telemetry.getSpan(commandSpanInfo(command).name);
      span == null ? void 0 : span.setAttribute("state", command.state);
      span == null ? void 0 : span.setAttribute("numLogs", ((_a2 = command.logs) == null ? void 0 : _a2.length) || 0);
      span == null ? void 0 : span.end();
    } catch (error) {
    }
  };
  Cypress2.on("command:end", onCommandEnd);
  Cypress2.on("skipped:command:end", onCommandEnd);
  Cypress2.on("command:failed", (command, error) => {
    var _a2;
    try {
      const span = telemetry.getSpan(commandSpanInfo(command).name);
      span == null ? void 0 : span.setAttribute("state", command.state);
      span == null ? void 0 : span.setAttribute("numLogs", ((_a2 = command.logs) == null ? void 0 : _a2.length) || 0);
      span == null ? void 0 : span.setAttribute("error.name", error.name);
      span == null ? void 0 : span.setAttribute("error.message", error.message);
      span == null ? void 0 : span.end();
    } catch (error2) {
    }
  });
};
const attachCypressProtocolInfo = (info) => {
  let cypressProtocolElement = document.getElementById("__cypress-protocol");
  if (!cypressProtocolElement) {
    cypressProtocolElement = document.createElement("div");
    cypressProtocolElement.id = "__cypress-protocol";
    cypressProtocolElement.style.display = "none";
    document.body.appendChild(cypressProtocolElement);
  }
  cypressProtocolElement.dataset.cypressProtocolInfo = JSON.stringify(info);
};
const addCaptureProtocolListeners = (Cypress2) => {
  Cypress2.on("cy:protocol-snapshot", () => {
    attachCypressProtocolInfo({
      type: "cy:protocol-snapshot",
      timestamp: performance.now() + performance.timeOrigin
    });
  });
  Cypress2.on("log:added", (attributes) => {
    if (!Cypress2.runner) {
      return;
    }
    const protocolProps = Cypress2.runner.getProtocolPropsForLog(attributes);
    attachCypressProtocolInfo({
      type: "log:added",
      timestamp: performance.now() + performance.timeOrigin
    });
    Cypress2.backend("protocol:command:log:added", protocolProps);
  });
  Cypress2.on("log:changed", (attributes) => {
    if (!Cypress2.runner) {
      return;
    }
    const protocolProps = Cypress2.runner.getProtocolPropsForLog(attributes);
    attachCypressProtocolInfo({
      type: "log:changed",
      timestamp: performance.now() + performance.timeOrigin
    });
    Cypress2.backend("protocol:command:log:changed", protocolProps);
  });
  const viewportChangedHandler = (viewport2) => {
    const timestamp = performance.timeOrigin + performance.now();
    attachCypressProtocolInfo({
      type: "viewport:changed",
      timestamp
    });
    Cypress2.backend("protocol:viewport:changed", {
      viewport: {
        width: viewport2.viewportWidth,
        height: viewport2.viewportHeight
      },
      timestamp
    });
  };
  Cypress2.on("viewport:changed", viewportChangedHandler);
  Cypress2.primaryOriginCommunicator.on("viewport:changed", viewportChangedHandler);
  Cypress2.on("test:before:run:async", async (attributes) => {
    const timestamp = performance.now() + performance.timeOrigin;
    attachCypressProtocolInfo({
      type: "test:before:run:async",
      timestamp
    });
    await Cypress2.backend("protocol:test:before:run:async", {
      ...attributes,
      timestamp
    });
  });
  Cypress2.on("url:changed", (url2) => {
    const timestamp = performance.timeOrigin + performance.now();
    attachCypressProtocolInfo({
      type: "url:changed",
      timestamp
    });
    Cypress2.backend("protocol:url:changed", { url: url2, timestamp });
  });
  Cypress2.on("page:loading", (loading) => {
    const timestamp = performance.timeOrigin + performance.now();
    attachCypressProtocolInfo({
      type: "page:loading",
      timestamp
    });
    Cypress2.backend("protocol:page:loading", { loading, timestamp });
  });
  Cypress2.on("test:before:after:run:async", async (attributes, _test, options2) => {
    attachCypressProtocolInfo({
      type: "test:before:after:run:async",
      timestamp: performance.timeOrigin + performance.now()
    });
    await Cypress2.backend("protocol:test:before:after:run:async", attributes, options2);
  });
  Cypress2.on("test:after:run:async", async (attributes) => {
    attachCypressProtocolInfo({
      type: "test:after:run:async",
      timestamp: performance.timeOrigin + performance.now()
    });
    await Cypress2.backend("protocol:test:after:run:async", attributes);
  });
};
const noop = () => {
};
let crossOriginOnMessageRef = ({ data, source }) => {
  return void 0;
};
let crossOriginLogs = {};
let hasMochaRunEnded = false;
const driverToLocalAndReporterEvents = "run:start run:end".split(" ");
const driverToSocketEvents = "backend:request automation:request mocha recorder:frame dev-server:on-spec-update".split(" ");
const driverToLocalEvents = "viewport:changed config stop url:changed page:loading visit:failed visit:blank cypress:in:cypress:runner:event".split(" ");
const socketRerunEvents = "runner:restart watched:file:changed".split(" ");
const socketToDriverEvents = "net:stubbing:event request:event script:error cross:origin:cookies dev-server:on-spec-updated".split(" ");
const localToReporterEvents = "reporter:log:add reporter:log:state:changed reporter:log:remove".split(" ");
let Cypress$1;
class EventManager {
  constructor($CypressDriver, Mobx, selectorPlaygroundModel, ws2) {
    this.$CypressDriver = $CypressDriver;
    this.Mobx = Mobx;
    this.reporterBus = new eventsExports.EventEmitter();
    this.localBus = new eventsExports.EventEmitter();
    this.cypressInCypressMochaEvents = [];
    this.selectorPlaygroundModel = selectorPlaygroundModel;
    this.ws = ws2;
    this.specStore = useSpecStore();
    this.studioStore = useStudioStore();
  }
  getCypress() {
    return Cypress$1;
  }
  addGlobalListeners(state, options2) {
    if (!this.ws.hasListeners("connect")) {
      this.ws.on("connect", () => {
        this.ws.emit("runner:connected");
      });
    }
    const rerun = () => {
      if (!this) {
        return;
      }
      return this.rerunSpec();
    };
    const connectionInfo = {
      element: options2.element,
      randomString: options2.randomString
    };
    const runnerUiStore = useRunnerUiStore();
    this.ws.emit("is:automation:client:connected", connectionInfo, (isConnected) => {
      const connected = isConnected ? automation.CONNECTED : automation.MISSING;
      this.Mobx.runInAction(() => {
        state.automation = connected;
      });
      this.ws.on("automation:disconnected", () => {
        this.Mobx.runInAction(() => {
          state.automation = automation.DISCONNECTED;
        });
      });
      this.ws.on("automation:disconnected", () => {
        runnerUiStore.setAutomationStatus("DISCONNECTED");
      });
      runnerUiStore.setAutomationStatus(connected);
    });
    this.ws.on("update:telemetry:context", (contextString) => {
      const context2 = JSON.parse(contextString);
      telemetry.setRootContext(context2);
    });
    this.ws.on("automation:push:message", (msg, data = {}) => {
      if (!Cypress$1)
        return;
      switch (msg) {
        case "change:cookie":
          Cypress$1.Cookies.log(data.message, data.cookie, data.removed);
          break;
        case "create:download":
          Cypress$1.downloads.start(data);
          break;
        case "complete:download":
          Cypress$1.downloads.end(data);
          break;
        case "canceled:download":
          Cypress$1.downloads.end(data, true);
          break;
      }
    });
    this.ws.on("watched:file:changed", () => {
      this.studioStore.cancel();
      rerun();
    });
    this.ws.on("dev-server:compile:success", ({ specFile }) => {
      var _a2;
      if (!specFile || specFile === ((_a2 = state == null ? void 0 : state.spec) == null ? void 0 : _a2.absolute)) {
        rerun();
      }
    });
    socketRerunEvents.forEach((event) => {
      this.ws.on(event, rerun);
    });
    socketToDriverEvents.forEach((event) => {
      this.ws.on(event, (...args) => {
        if (!Cypress$1)
          return;
        Cypress$1.emit(event, ...args);
      });
    });
    localToReporterEvents.forEach((event) => {
      this.localBus.on(event, (...args) => {
        this.reporterBus.emit(event, ...args);
      });
    });
    const logCommand = (testId, logId) => {
      const consoleProps = Cypress$1.runner.getConsolePropsForLog(testId, logId);
      logger.logFormatted(consoleProps);
    };
    this.reporterBus.on("runner:console:error", ({ err, testId, logId }) => {
      if (!Cypress$1)
        return;
      if (logId || err)
        logger.clearLog();
      if (logId)
        logCommand(testId, logId);
      if (err)
        logger.logError(err.stack);
    });
    this.reporterBus.on("runner:console:log", (testId, logId) => {
      if (!Cypress$1)
        return;
      logger.clearLog();
      logCommand(testId, logId);
    });
    this.reporterBus.on("set:user:editor", (editor) => {
      this.ws.emit("set:user:editor", editor);
    });
    this.reporterBus.on("runner:restart", rerun);
    const sendEventIfSnapshotProps = (testId, logId, event) => {
      if (!Cypress$1)
        return;
      const snapshotProps = Cypress$1.runner.getSnapshotPropsForLog(testId, logId);
      if (snapshotProps) {
        this.localBus.emit(event, snapshotProps);
      }
    };
    this.reporterBus.on("runner:show:snapshot", (testId, logId) => {
      sendEventIfSnapshotProps(testId, logId, "show:snapshot");
    });
    this.reporterBus.on("runner:hide:snapshot", this._hideSnapshot.bind(this));
    this.reporterBus.on("runner:pin:snapshot", (testId, logId) => {
      sendEventIfSnapshotProps(testId, logId, "pin:snapshot");
    });
    this.reporterBus.on("runner:unpin:snapshot", this._unpinSnapshot.bind(this));
    this.reporterBus.on("runner:stop", () => {
      if (!Cypress$1)
        return;
      Cypress$1.stop();
    });
    this.reporterBus.on("save:state", (state2) => {
      this.saveState(state2);
    });
    this.reporterBus.on("testFilter:cloudDebug:dismiss", () => {
      this.emit("testFilter:cloudDebug:dismiss", void 0);
    });
    this.reporterBus.on("clear:all:sessions", () => {
      if (!Cypress$1)
        return;
      Cypress$1.backend("clear:sessions", true).then(rerun);
    });
    this.reporterBus.on("external:open", (url2) => {
      this.ws.emit("external:open", url2);
    });
    this.reporterBus.on("get:user:editor", (cb) => {
      this.ws.emit("get:user:editor", cb);
    });
    this.reporterBus.on("open:file:unified", (file) => {
      this.emit("open:file", file);
    });
    this.reporterBus.on("open:file", (url2) => {
      this.ws.emit("open:file", url2);
    });
    const studioInit = () => {
      rerun();
    };
    this.reporterBus.on("studio:init:test", (testId) => {
      this.studioStore.setTestId(testId);
      studioInit();
    });
    this.reporterBus.on("studio:init:suite", (suiteId) => {
      this.studioStore.setSuiteId(suiteId);
      studioInit();
    });
    this.reporterBus.on("studio:cancel", () => {
      this.studioStore.cancel();
      rerun();
    });
    this.reporterBus.on("studio:remove:command", (commandId) => {
      this.studioStore.removeLog(commandId);
    });
    this.reporterBus.on("studio:save", () => {
      this.studioStore.startSave();
    });
    this.reporterBus.on("studio:copy:to:clipboard", (cb) => {
      this._studioCopyToClipboard(cb);
    });
    this.localBus.on("studio:start", () => {
      rerun();
    });
    this.localBus.on("studio:copy:to:clipboard", (cb) => {
      this._studioCopyToClipboard(cb);
    });
    this.localBus.on("studio:save", (saveInfo) => {
      this.ws.emit("studio:save", saveInfo, (err) => {
        if (err) {
          this.reporterBus.emit("test:set:state", this.studioStore.saveError(err), noop);
        }
      });
    });
    this.localBus.on("studio:cancel", () => {
      this.studioStore.cancel();
      rerun();
    });
    this.ws.on("aut:destroy:init", () => {
      const autIframe = getAutIframeModel();
      autIframe.destroy();
      this.ws.emit("aut:destroy:complete");
    });
    const $window = this.$CypressDriver.$(window);
    $window.on("test:trigger:rerun", rerun);
    const unloadEvent = this.isBrowserFamily("chromium") ? "pagehide" : "unload";
    $window.on(unloadEvent, (e) => {
      this._clearAllCookies();
    });
    $window.on("beforeunload", () => {
      var _a2;
      (_a2 = telemetry.getSpan("cypress:app")) == null ? void 0 : _a2.end();
      this.reporterBus.emit("reporter:restart:test:run");
      this._clearAllCookies();
      this._setUnload();
    });
  }
  start(config2) {
    if (config2.socketId) {
      this.ws.emit("app:connect", config2.socketId);
    }
  }
  async setup(config2) {
    this.ws.emit("watch:test:file", config2.spec);
    if (config2.isTextTerminal || config2.experimentalInteractiveRunEvents) {
      await new Promise((resolve3, reject) => {
        this.ws.emit("plugins:before:spec", config2.spec, (res) => {
          if (res && res.error) {
            reject(res.error);
          }
          resolve3(null);
        });
      });
    }
    Cypress$1 = this.Cypress = this.$CypressDriver.create(config2);
    window.Cypress = Cypress$1;
    this._addListeners();
  }
  isBrowserFamily(family) {
    var _a2, _b2;
    return ((_b2 = (_a2 = getRunnerConfigFromWindow()) == null ? void 0 : _a2.browser) == null ? void 0 : _b2.family) === family;
  }
  initialize($autIframe, config2) {
    performance.mark("initialize-start");
    const testFilter = this.specStore.testFilter;
    return Cypress$1.initialize({
      $autIframe,
      onSpecReady: () => {
        this.ws.emit("get:cached:test:state", (runState = {}, testState) => {
          if (!Cypress$1.runner) {
            return;
          }
          const hideCommandLog = Cypress$1.config("hideCommandLog");
          this.studioStore.initialize(config2, runState);
          const runnables = Cypress$1.runner.normalizeAll(runState.tests, hideCommandLog, testFilter);
          const run2 = () => {
            performance.mark("initialize-end");
            performance.measure("initialize", "initialize-start", "initialize-end");
            this._runDriver(runState, testState);
          };
          if (!hideCommandLog) {
            this.reporterBus.emit("runnables:ready", runnables);
          }
          if (runState == null ? void 0 : runState.numLogs) {
            Cypress$1.runner.setNumLogs(runState.numLogs);
          }
          if (runState.startTime) {
            Cypress$1.runner.setStartTime(runState.startTime);
          }
          if (config2.isTextTerminal && !runState.currentId) {
            return this.ws.emit("set:runnables:and:maybe:record:tests", runnables, run2);
          }
          if (runState.currentId) {
            Cypress$1.runner.resumeAtTest(runState.currentId, runState.emissions);
          }
          return run2();
        });
      }
    });
  }
  _addListeners() {
    var _a2;
    addTelemetryListeners(Cypress$1);
    if (Cypress$1.config("protocolEnabled")) {
      addCaptureProtocolListeners(Cypress$1);
    }
    Cypress$1.on("message", (msg, data, cb) => {
      this.ws.emit("client:request", msg, data, cb);
    });
    driverToSocketEvents.forEach((event) => {
      Cypress$1.on(event, (...args) => {
        return this.ws.emit(event, ...args);
      });
    });
    Cypress$1.on("collect:run:state", () => {
      if (Cypress$1.config("hideCommandLog")) {
        return Bluebird.resolve();
      }
      return new Bluebird((resolve3) => {
        this.reporterBus.emit("reporter:collect:run:state", (reporterState) => {
          resolve3({
            ...reporterState,
            studio: {
              testId: this.studioStore.testId,
              suiteId: this.studioStore.suiteId,
              url: this.studioStore.url
            }
          });
        });
      });
    });
    Cypress$1.on("log:added", (log) => {
      if (!Cypress$1.runner) {
        return;
      }
      const displayProps = Cypress$1.runner.getDisplayPropsForLog(log);
      this._interceptStudio(displayProps);
      this.reporterBus.emit("reporter:log:add", displayProps);
    });
    Cypress$1.on("log:changed", (log) => {
      if (!Cypress$1.runner) {
        return;
      }
      const displayProps = Cypress$1.runner.getDisplayPropsForLog(log);
      this._interceptStudio(displayProps);
      this.reporterBus.emit("reporter:log:state:changed", displayProps);
    });
    const screenshotStore = useScreenshotStore();
    const handleBeforeScreenshot = (config2, cb) => {
      if (config2.appOnly || Cypress$1.config("hideRunnerUi")) {
        screenshotStore.setScreenshotting(true);
      }
      const beforeThenCb = () => {
        this.localBus.emit("before:screenshot", config2);
        cb();
      };
      if (Cypress$1.config("hideCommandLog")) {
        return beforeThenCb();
      }
      const wait = !config2.appOnly && config2.waitForCommandSynchronization;
      if (!config2.appOnly) {
        const { id: id2, isOpen } = config2;
        this.reporterBus.emit("test:set:state", { id: id2, isOpen }, wait ? beforeThenCb : void 0);
      }
      if (!wait)
        beforeThenCb();
    };
    Cypress$1.on("before:screenshot", handleBeforeScreenshot);
    const handleAfterScreenshot = (config2) => {
      screenshotStore.setScreenshotting(false);
      this.localBus.emit("after:screenshot", config2);
    };
    Cypress$1.on("after:screenshot", handleAfterScreenshot);
    driverToLocalAndReporterEvents.forEach((event) => {
      Cypress$1.on(event, (...args) => {
        this.localBus.emit(event, ...args);
        this.reporterBus.emit(event, ...args);
      });
    });
    Cypress$1.on("run:start", async () => {
      hasMochaRunEnded = false;
      if (Cypress$1.config("experimentalMemoryManagement") && Cypress$1.isBrowser({ family: "chromium" })) {
        await Cypress$1.backend("start:memory:profiling", Cypress$1.config("spec"));
      }
    });
    Cypress$1.on("run:end", async () => {
      hasMochaRunEnded = true;
      if (Cypress$1.config("experimentalMemoryManagement") && Cypress$1.isBrowser({ family: "chromium" })) {
        await Cypress$1.backend("end:memory:profiling");
      }
    });
    driverToLocalEvents.forEach((event) => {
      Cypress$1.on(event, (...args) => {
        if (event === "cypress:in:cypress:runner:event") {
          if (args[0] === "mocha" && args[1] === "start") {
            this.cypressInCypressMochaEvents = [];
          }
          this.cypressInCypressMochaEvents.push(args);
          if (args[0] === "mocha" && args[1] === "end") {
            this.emit("cypress:in:cypress:run:complete", this.cypressInCypressMochaEvents);
            this.cypressInCypressMochaEvents = [];
          }
          return;
        }
        return this.emit(event, ...args);
      });
    });
    Cypress$1.on("script:error", (err) => {
      Cypress$1.stop();
      this.localBus.emit("script:error", err);
    });
    Cypress$1.on("test:before:run:async", async (...args) => {
      crossOriginLogs = {};
      const [attributes, test] = args;
      this.reporterBus.emit("test:before:run:async", attributes);
      this.studioStore.interceptTest(test);
      if (Cypress$1.config("experimentalMemoryManagement") && Cypress$1.isBrowser({ family: "chromium" })) {
        await Cypress$1.backend("check:memory:pressure", {
          test: { title: attributes.title, order: attributes.order, currentRetry: attributes.currentRetry }
        });
      }
      Cypress$1.primaryOriginCommunicator.toAllSpecBridges("test:before:run:async", ...args);
    });
    Cypress$1.on("test:before:after:run:async", (...args) => {
      Cypress$1.primaryOriginCommunicator.toAllSpecBridges("test:before:after:run:async", ...args);
    });
    Cypress$1.on("test:after:run", (attributes) => {
      this.reporterBus.emit("test:after:run", attributes, Cypress$1.config("isInteractive"));
      if (this.studioStore.isOpen && attributes.state !== "passed") {
        this.studioStore.testFailed();
      }
    });
    handlePausing(this.getCypress, this.reporterBus);
    Cypress$1.on("test:before:run", (...args) => {
      Cypress$1.primaryOriginCommunicator.toAllSpecBridges("test:before:run", ...args);
    });
    Cypress$1.on("window:before:unload", () => {
      Cypress$1.primaryOriginCommunicator.toAllSpecBridges("before:unload", window.origin);
    });
    Cypress$1.primaryOriginCommunicator.on("sync:during:user:test:execution", (_data, { origin, responseEvent }) => {
      Cypress$1.primaryOriginCommunicator.toSpecBridge(origin, responseEvent, cy.state("duringUserTestExecution"));
    });
    Cypress$1.primaryOriginCommunicator.on("before:unload", (origin) => {
      var _a3;
      if (((_a3 = Cypress$1.state("autLocation")) == null ? void 0 : _a3.origin) === origin) {
        cy.state("isStable", false);
      }
      Cypress$1.primaryOriginCommunicator.toAllSpecBridges("before:unload", origin);
    });
    Cypress$1.primaryOriginCommunicator.on("expect:origin", (origin) => {
      this.localBus.emit("expect:origin", origin);
    });
    Cypress$1.primaryOriginCommunicator.on("viewport:changed", (viewport2, { origin }) => {
      const callback = () => {
        Cypress$1.primaryOriginCommunicator.toSpecBridge(origin, "viewport:changed:end");
      };
      Cypress$1.primaryOriginCommunicator.emit("sync:viewport", viewport2);
      this.localBus.emit("viewport:changed", viewport2, callback);
    });
    Cypress$1.primaryOriginCommunicator.on("before:screenshot", (config2, { origin }) => {
      const callback = () => {
        Cypress$1.primaryOriginCommunicator.toSpecBridge(origin, "before:screenshot:end");
      };
      handleBeforeScreenshot(config2, callback);
    });
    Cypress$1.primaryOriginCommunicator.on("url:changed", ({ url: url2 }) => {
      this.localBus.emit("url:changed", url2);
    });
    Cypress$1.primaryOriginCommunicator.on("after:screenshot", handleAfterScreenshot);
    Cypress$1.primaryOriginCommunicator.on("log:added", (attrs) => {
      if (hasMochaRunEnded)
        return;
      crossOriginLogs[attrs.id] = Cypress$1.log(attrs);
    });
    Cypress$1.primaryOriginCommunicator.on("log:changed", (attrs) => {
      const log = crossOriginLogs[attrs.id];
      log == null ? void 0 : log.set(attrs);
    });
    Cypress$1.primaryOriginCommunicator.on(
      "aut:set:cookie",
      (options2) => {
        Cypress$1.automation("set:cookie", options2.cookie).catch(() => {
        });
        Cypress$1.backend("cross:origin:set:cookie", options2).catch(() => {
        });
      }
    );
    Cypress$1.primaryOriginCommunicator.on("backend:request", async ({ args }, { source, responseEvent }) => {
      let response;
      try {
        response = await Cypress$1.backend(...args);
      } catch (error) {
        response = { error };
      }
      Cypress$1.primaryOriginCommunicator.toSource(source, responseEvent, response);
    });
    Cypress$1.primaryOriginCommunicator.on("automation:request", async ({ args }, { source, responseEvent }) => {
      const response = await Cypress$1.automation(...args);
      Cypress$1.primaryOriginCommunicator.toSource(source, responseEvent, response);
    });
    if (!window.top)
      throw new Error("missing window.top in event-manager");
    (_a2 = window == null ? void 0 : window.top) == null ? void 0 : _a2.removeEventListener("message", crossOriginOnMessageRef, false);
    crossOriginOnMessageRef = ({ data, source }) => {
      Cypress$1 == null ? void 0 : Cypress$1.primaryOriginCommunicator.onMessage({ data, source });
      return void 0;
    };
    window.top.addEventListener("message", crossOriginOnMessageRef, false);
  }
  _runDriver(runState, testState) {
    performance.mark("run-s");
    Cypress$1.run(testState, () => {
      performance.mark("run-e");
      performance.measure("run", "run-s", "run-e");
    });
    const hasRunnableId = !!this.studioStore.testId || !!this.studioStore.suiteId;
    this.reporterBus.emit("reporter:start", {
      startTime: Cypress$1.runner.getStartTime(),
      numPassed: runState.passed,
      numFailed: runState.failed,
      numPending: runState.pending,
      autoScrollingEnabled: runState.autoScrollingEnabled,
      isSpecsListOpen: runState.isSpecsListOpen,
      scrollTop: runState.scrollTop,
      studioActive: hasRunnableId
    });
  }
  stop() {
    this.localBus.removeAllListeners();
    const urlChangeListeners = this.ws.listeners("change:to:url");
    this.ws.off();
    urlChangeListeners.forEach((listener) => this.ws.on("change:to:url", listener));
  }
  async teardown(state, isRerun = false) {
    if (!Cypress$1) {
      return;
    }
    state.setIsLoading(true);
    if (!isRerun) {
      Cypress$1.backend("reset:cached:test:state");
    }
    Cypress$1.stop();
    Cypress$1.primaryOriginCommunicator.removeAllListeners();
    crossOriginLogs = {};
    this.studioStore.setInactive();
  }
  resetReporter() {
    return new Bluebird((resolve3) => {
      this.reporterBus.once("reporter:restarted", resolve3);
      this.reporterBus.emit("reporter:restart:test:run");
    });
  }
  async rerunSpec() {
    if (!this || !Cypress$1) {
      return;
    }
    await this.resetReporter();
    Cypress$1.removeAllListeners();
    this.localBus.emit("restart");
  }
  _interceptStudio(displayProps) {
    if (this.studioStore.isActive) {
      displayProps.hookId = this.studioStore.hookId;
      if (displayProps.name === "visit" && displayProps.state === "failed") {
        this.studioStore.testFailed();
        this.reporterBus.emit("test:set:state", this.studioStore.testError, noop);
      }
    }
    return displayProps;
  }
  _studioCopyToClipboard(cb) {
    this.ws.emit("studio:get:commands:text", this.studioStore.logs, (commandsText) => {
      this.studioStore.copyToClipboard(commandsText).then(cb);
    });
  }
  emit(event, ...args) {
    this.localBus.emit(event, ...args);
  }
  on(event, listener) {
    this.localBus.on(event, listener);
  }
  off(event, listener) {
    this.localBus.off(event, listener);
  }
  notifyRunningSpec(specFile) {
    this.ws.emit("spec:changed", specFile);
  }
  notifyCrossOriginBridgeReady(origin) {
    Cypress$1.primaryOriginCommunicator.emit("bridge:ready", void 0, { origin });
  }
  snapshotUnpinned() {
    this._unpinSnapshot();
    this._hideSnapshot();
    this.reporterBus.emit("reporter:snapshot:unpinned");
  }
  _unpinSnapshot() {
    this.localBus.emit("unpin:snapshot");
  }
  _hideSnapshot() {
    this.localBus.emit("hide:snapshot");
  }
  launchBrowser(browser2) {
    this.ws.emit("reload:browser", window.location.toString(), browser2 && browser2.name);
  }
  // clear all the cypress specific cookies
  // whenever our app starts
  // and additional when we stop running our tests
  _clearAllCookies() {
    if (!Cypress$1)
      return;
    Cypress$1.Cookies.clearCypressCookies();
  }
  _setUnload() {
    if (!Cypress$1)
      return;
    Cypress$1.Cookies.setCy("unload", true);
  }
  saveState(state) {
    this.localBus.emit("save:app:state", state);
  }
  // useful for testing
  _testingOnlySetCypress(cypress) {
    Cypress$1 = cypress;
  }
}
let _eventManager;
function createWebsocket(config2) {
  const ws2 = createWebsocket$1({ path: config2.socketIoRoute, browserFamily: config2.browser.family });
  ws2.on("connect", () => {
    ws2.emit("runner:connected");
  });
  ws2.on("change:to:url", (url2) => {
    window.location.href = url2;
  });
  return ws2;
}
function initializeEventManager(UnifiedRunner) {
  if (!window.ws) {
    throw Error("Need window.ws to exist before initializing event manager");
  }
  _eventManager = new EventManager(
    UnifiedRunner.CypressDriver,
    UnifiedRunner.MobX,
    UnifiedRunner.selectorPlaygroundModel,
    window.ws
  );
}
function getEventManager() {
  if (!_eventManager) {
    throw Error(`eventManager is undefined. Make sure you call initializeEventManager before attempting to access it.`);
  }
  return _eventManager;
}
window.getEventManager = getEventManager;
let _autIframeModel;
function getAutIframeModel() {
  if (!_autIframeModel) {
    throw Error("Must create a new instance of AutIframe before accessing");
  }
  return _autIframeModel;
}
function createIframeModel() {
  const autIframe = getAutIframeModel();
  const iframeModel = new IframeModel(
    autIframe.detachDom,
    autIframe.restoreDom,
    autIframe.highlightEl,
    autIframe.doesAUTMatchTopSuperDomainOrigin,
    getEventManager(),
    {
      selectorPlaygroundModel: getEventManager().selectorPlaygroundModel
    }
  );
  iframeModel.listen();
}
function setupRunner() {
  const mobxRunnerStore2 = getMobxRunnerStore();
  const runnerUiStore = useRunnerUiStore();
  const config2 = getRunnerConfigFromWindow();
  getEventManager().addGlobalListeners(mobxRunnerStore2, {
    randomString: runnerUiStore.randomString,
    element: getAutomationElementId()
  });
  getEventManager().start(config2);
  const autStore = useAutStore();
  const studioStore = useStudioStore();
  watchEffect(() => {
    var _a2;
    (_a2 = autStore.viewportUpdateCallback) == null ? void 0 : _a2.call(autStore);
  }, { flush: "post" });
  watchEffect(() => {
    window.UnifiedRunner.MobX.runInAction(() => {
      mobxRunnerStore2.setCanSaveStudioLogs(studioStore.logs.length > 0);
    });
  });
  _autIframeModel = new AutIframe(
    "Test Project",
    getEventManager(),
    window.UnifiedRunner.CypressJQuery
  );
  createIframeModel();
}
function getSpecUrl({ browserFamily, namespace, specSrc }) {
  let url2 = `/${namespace}/iframes/${specSrc}`;
  if (browserFamily) {
    url2 += `?browserFamily=${browserFamily}`;
  }
  return url2;
}
function teardownSpec(isRerun = false) {
  useSnapshotStore().$reset();
  return getEventManager().teardown(getMobxRunnerStore(), isRerun);
}
let isTorndown = false;
async function teardown() {
  UnifiedReporterAPI.setInitializedReporter(false);
  _eventManager == null ? void 0 : _eventManager.stop();
  _eventManager == null ? void 0 : _eventManager.teardown(getMobxRunnerStore());
  await (_eventManager == null ? void 0 : _eventManager.resetReporter());
  _eventManager = void 0;
  isTorndown = true;
}
function addCrossOriginIframe(location2) {
  const id2 = `Spec Bridge: ${location2.origin}`;
  if (document.getElementById(id2)) {
    getEventManager().notifyCrossOriginBridgeReady(location2.origin);
    return;
  }
  const config2 = getRunnerConfigFromWindow();
  addIframe({
    id: id2,
    // the cross origin iframe is added to the document body instead of the
    // container since it needs to match the size of the top window for screenshots
    $container: document.body,
    className: "spec-bridge-iframe",
    src: `${location2.origin}/${config2.namespace}/spec-bridge-iframes?browserFamily=${config2.browser.family}`
  });
}
function runSpecCT(config2, spec) {
  const $runnerRoot = getRunnerElement();
  empty($runnerRoot);
  const $container = document.createElement("div");
  $container.classList.add("screenshot-height-container");
  $runnerRoot.append($container);
  const autIframe = getAutIframeModel();
  const $autIframe = autIframe.create().appendTo($container);
  const specIndexUrl = `index.html?specPath=${encodeURI(spec.absolute)}`;
  const specSrc = getSpecUrl({
    namespace: config2.namespace,
    specSrc: specIndexUrl
  });
  autIframe._showInitialBlankPage();
  $autIframe.prop("src", specSrc);
  getEventManager().initialize($autIframe, config2);
}
function addIframe({ $container, id: id2, src, className }) {
  const $addedIframe = document.createElement("iframe");
  $addedIframe.id = id2, $addedIframe.className = className;
  $container.appendChild($addedIframe);
  $addedIframe.setAttribute("src", src);
}
function setSpecForDriver(spec) {
  return { ...spec, name: spec.baseName };
}
function runSpecE2E(config2, spec) {
  const $runnerRoot = getRunnerElement();
  empty($runnerRoot);
  const $container = document.createElement("div");
  $container.classList.add("screenshot-height-container");
  $runnerRoot.append($container);
  const autIframe = getAutIframeModel();
  const $autIframe = autIframe.create().appendTo($container);
  document.querySelectorAll("iframe.spec-bridge-iframe").forEach((el) => {
    el.remove();
  });
  autIframe.visitBlankPage();
  const specSrc = getSpecUrl({
    browserFamily: config2.browser.family,
    namespace: config2.namespace,
    specSrc: encodeURIComponent(spec.relative)
  });
  addIframe({
    $container,
    src: specSrc,
    id: `Your Spec: '${specSrc}'`,
    className: "spec-iframe"
  });
  getEventManager().initialize($autIframe, config2);
}
async function initialize() {
  await dfd.promise;
  isTorndown = false;
  const config2 = getRunnerConfigFromWindow();
  if (isTorndown) {
    return;
  }
  const autStore = useAutStore();
  autStore.$reset();
  const studioStore = useStudioStore();
  studioStore.cancel();
  autStore.updateDimensions(config2.viewportWidth, config2.viewportHeight);
  initializeEventManager(window.UnifiedRunner);
  window.UnifiedRunner.MobX.runInAction(() => {
    const store = initializeMobxStore(window.__CYPRESS_TESTING_TYPE__);
    store.updateDimensions(config2.viewportWidth, config2.viewportHeight);
  });
  window.UnifiedRunner.MobX.runInAction(() => setupRunner());
}
async function updateDevServerWithSpec(spec) {
  return new Promise((resolve3, _reject) => {
    Cypress.once("dev-server:on-spec-updated", () => {
      resolve3();
    });
    Cypress.emit("dev-server:on-spec-update", spec);
  });
}
async function executeSpec(spec, isRerun = false) {
  await teardownSpec(isRerun);
  const mobxRunnerStore2 = getMobxRunnerStore();
  mobxRunnerStore2.setSpec(spec);
  await UnifiedReporterAPI.resetReporter();
  UnifiedReporterAPI.setupReporter();
  const config2 = getRunnerConfigFromWindow();
  config2.spec = setSpecForDriver(spec);
  await getEventManager().setup(config2);
  if (window.__CYPRESS_TESTING_TYPE__ === "e2e") {
    return runSpecE2E(config2, spec);
  }
  if (window.__CYPRESS_TESTING_TYPE__ === "component") {
    if (config2.experimentalJustInTimeCompile && !config2.isTextTerminal) {
      await updateDevServerWithSpec(spec);
    }
    return runSpecCT(config2, spec);
  }
  throw Error("Unknown or undefined testingType on window.__CYPRESS_TESTING_TYPE__");
}
function getAutomationElementId() {
  return `${window.__CYPRESS_CONFIG__.namespace}-string`;
}
const UnifiedRunnerAPI = {
  initialize,
  executeSpec,
  teardown,
  getAutomationElementId
};
const now = performance.now();
const config = getRunnerConfigFromWindow();
telemetry.init({ namespace: "cypress:app", config });
telemetry.startSpan({ name: "cypress:app", attachType: "root", opts: { startTime: now } });
const app = createApp(_sfc_main$5);
const ws = createWebsocket(config);
window.ws = ws;
telemetry.attachWebSocket(ws);
injectBundle(config.namespace);
app.use(VueToastificationPlugin, {
  position: POSITION.BOTTOM_RIGHT,
  draggable: false,
  closeOnClick: false
});
makeUrqlClient({ target: "app", namespace: config.namespace, socketIoRoute: config.socketIoRoute }).then((client2) => {
  app.use(install, client2);
  app.use(createRouter());
  app.use(createI18n());
  app.use(createPinia());
  app.mount("#app");
});
export {
  pushScopeId as $,
  watch as A,
  renderList as B,
  normalizeStyle as C,
  withKeys as D,
  resolveDynamicComponent as E,
  Fragment as F,
  mergeProps as G,
  useStudioStore as H,
  IconMagnifyingGlass as I,
  gql as J,
  isRef as K,
  useSnapshotStore as L,
  useAutStore as M,
  useElementSize as N,
  useSelectorPlaygroundStore as O,
  useClipboard as P,
  MenuButton as Q,
  RouterLink as R,
  MenuItems as S,
  MenuItem as T,
  Menu$1 as U,
  createTextVNode as V,
  withDirectives as W,
  vModelText as X,
  _sfc_main$y as Y,
  __unplugin_components_2$1 as Z,
  _export_sfc$1 as _,
  createBaseVNode as a,
  getRunnerConfigFromWindow as a$,
  popScopeId as a0,
  getEventManager as a1,
  RefreshIcon as a2,
  PopoverButton as a3,
  TransitionQuickFade as a4,
  PopoverPanel as a5,
  Popover as a6,
  __unplugin_components_0$2 as a7,
  useRoute as a8,
  watchEffect as a9,
  RUN_ALL_SPECS_KEY as aA,
  RUN_ALL_SPECS as aB,
  lodashExports as aC,
  useQuery as aD,
  useUserProjectStatusStore as aE,
  ConnectIcon as aF,
  BannerIds as aG,
  getUrlWithParams as aH,
  OrganizationIcon as aI,
  _sfc_main$a as aJ,
  createStaticVNode as aK,
  UseCohorts_DetermineCohortDocument as aL,
  usePromptManager as aM,
  reactive as aN,
  WarningIcon as aO,
  __unplugin_components_0$3 as aP,
  useTimeout as aQ,
  StandardModalFooter as aR,
  useDebounce as aS,
  nextTick as aT,
  h$1 as aU,
  nanoid as aV,
  useOnline as aW,
  useResizeObserver as aX,
  toRef as aY,
  __unplugin_components_1 as aZ,
  useSubscription as a_,
  useExternalLink as aa,
  _sfc_main$z as ab,
  _sfc_main$i as ac,
  togglePlayground as ad,
  useScreenshotStore as ae,
  useAttrs as af,
  isRunMode as ag,
  runnerConstants as ah,
  useRunnerUiStore as ai,
  useMutation as aj,
  getDefaultExportFromCjs as ak,
  vShow as al,
  UnifiedRunnerAPI as am,
  useWindowSize as an,
  getAutIframeModel as ao,
  addCrossOriginIframe as ap,
  empty as aq,
  getRunnerElement as ar,
  getReporterElement as as,
  _sfc_main$o as at,
  Input as au,
  onBeforeUnmount as av,
  setBlockTracking as aw,
  REPORTER_ID as ax,
  RUNNER_ID as ay,
  readonly as az,
  unref as b,
  useToggle as b0,
  defineStore as b1,
  commonjsGlobal as b2,
  _$1 as b3,
  shallowRef as b4,
  ShikiHighlight as b5,
  _sfc_main$j as b6,
  useVModels as b7,
  whenever as b8,
  __unplugin_components_1$2 as b9,
  _sfc_main$x as bA,
  HeaderBar_HeaderBarQueryDocument as bB,
  promiseTimeout as bC,
  useDebounceFn as bD,
  Transition as bE,
  VerticalBrowserListItems_SetBrowserDocument as bF,
  getAugmentedNamespace as bG,
  useEventListener as bH,
  _sfc_main$n as bI,
  ChooseExternalEditorModal_SetPreferredEditorBinaryDocument as bJ,
  OpenFileInIdeDocument as bK,
  OpenFileInIde_MutationDocument as bL,
  onBeforeMount as bM,
  options as bN,
  Menu as bO,
  Tooltip as bP,
  __unplugin_components_2 as ba,
  _sfc_main$q as bb,
  debouncedWatch as bc,
  createSlots as bd,
  __unplugin_components_0$6 as be,
  not as bf,
  DialogOverlay as bg,
  useSlots as bh,
  IconTerminal as bi,
  _sfc_main$u as bj,
  useModelWrapper as bk,
  vModelCheckbox as bl,
  getUtmSource as bm,
  _sfc_main$w as bn,
  onUnmounted as bo,
  useIntervalFn as bp,
  TransitionGroup as bq,
  decodeBase64Unicode as br,
  Debug as bs,
  _sfc_main$c as bt,
  TopNav_SetPromptShownDocument as bu,
  useTimeAgo as bv,
  onClickOutside as bw,
  HeaderBarContent_AuthChangeDocument as bx,
  GlobalPageHeader_ClearCurrentProjectDocument as by,
  interval as bz,
  createBlock as c,
  defineComponent as d,
  withModifiers as e,
  createVNode as f,
  useI18n as g,
  ref as h,
  createElementBlock as i,
  createCommentVNode as j,
  __unplugin_components_0$1 as k,
  computed as l,
  renderSlot as m,
  normalizeClass as n,
  openBlock as o,
  __unplugin_components_0 as p,
  onBeforeUpdate as q,
  resolveComponent as r,
  onUpdated as s,
  toDisplayString$1 as t,
  useI18n$1 as u,
  onKeyStroke as v,
  withCtx as w,
  useRouter as x,
  useSpecStore as y,
  onMounted as z
};
